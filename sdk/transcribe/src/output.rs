// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVocabularyFilterOutput {
    /// <p>The name of the updated vocabulary filter.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The language code of the words in the vocabulary filter.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary filter was updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for UpdateVocabularyFilterOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVocabularyFilterOutput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`UpdateVocabularyFilterOutput`](crate::output::UpdateVocabularyFilterOutput)
pub mod update_vocabulary_filter_output {
    /// A builder for [`UpdateVocabularyFilterOutput`](crate::output::UpdateVocabularyFilterOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the updated vocabulary filter.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the updated vocabulary filter.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary filter was updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary filter was updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVocabularyFilterOutput`](crate::output::UpdateVocabularyFilterOutput)
        pub fn build(self) -> crate::output::UpdateVocabularyFilterOutput {
            crate::output::UpdateVocabularyFilterOutput {
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl UpdateVocabularyFilterOutput {
    /// Creates a new builder-style object to manufacture [`UpdateVocabularyFilterOutput`](crate::output::UpdateVocabularyFilterOutput)
    pub fn builder() -> crate::output::update_vocabulary_filter_output::Builder {
        crate::output::update_vocabulary_filter_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVocabularyOutput {
    /// <p>The name of the vocabulary that was updated.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary was updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The processing state of the vocabulary. When the <code>VocabularyState</code> field contains
    /// <code>READY</code> the vocabulary is ready to be used in a <code>StartTranscriptionJob</code>
    /// request.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
}
impl std::fmt::Debug for UpdateVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVocabularyOutput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.finish()
    }
}
/// See [`UpdateVocabularyOutput`](crate::output::UpdateVocabularyOutput)
pub mod update_vocabulary_output {
    /// A builder for [`UpdateVocabularyOutput`](crate::output::UpdateVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    }
    impl Builder {
        /// <p>The name of the vocabulary that was updated.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary that was updated.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary was updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The processing state of the vocabulary. When the <code>VocabularyState</code> field contains
        /// <code>READY</code> the vocabulary is ready to be used in a <code>StartTranscriptionJob</code>
        /// request.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of the vocabulary. When the <code>VocabularyState</code> field contains
        /// <code>READY</code> the vocabulary is ready to be used in a <code>StartTranscriptionJob</code>
        /// request.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVocabularyOutput`](crate::output::UpdateVocabularyOutput)
        pub fn build(self) -> crate::output::UpdateVocabularyOutput {
            crate::output::UpdateVocabularyOutput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
                vocabulary_state: self.vocabulary_state,
            }
        }
    }
}
impl UpdateVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`UpdateVocabularyOutput`](crate::output::UpdateVocabularyOutput)
    pub fn builder() -> crate::output::update_vocabulary_output::Builder {
        crate::output::update_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateMedicalVocabularyOutput {
    /// <p>The name of the updated vocabulary.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code for the language of the text file used to update the custom vocabulary. US English (en-US)
    /// is the only language supported in Amazon Transcribe Medical.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary was updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The processing state of the update to the vocabulary. When the <code>VocabularyState</code> field is
    /// <code>READY</code>, the vocabulary is ready to be used in a <code>StartMedicalTranscriptionJob</code>
    /// request.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
}
impl std::fmt::Debug for UpdateMedicalVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateMedicalVocabularyOutput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.finish()
    }
}
/// See [`UpdateMedicalVocabularyOutput`](crate::output::UpdateMedicalVocabularyOutput)
pub mod update_medical_vocabulary_output {
    /// A builder for [`UpdateMedicalVocabularyOutput`](crate::output::UpdateMedicalVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    }
    impl Builder {
        /// <p>The name of the updated vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the updated vocabulary.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code for the language of the text file used to update the custom vocabulary. US English (en-US)
        /// is the only language supported in Amazon Transcribe Medical.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the language of the text file used to update the custom vocabulary. US English (en-US)
        /// is the only language supported in Amazon Transcribe Medical.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary was updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The processing state of the update to the vocabulary. When the <code>VocabularyState</code> field is
        /// <code>READY</code>, the vocabulary is ready to be used in a <code>StartMedicalTranscriptionJob</code>
        /// request.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of the update to the vocabulary. When the <code>VocabularyState</code> field is
        /// <code>READY</code>, the vocabulary is ready to be used in a <code>StartMedicalTranscriptionJob</code>
        /// request.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateMedicalVocabularyOutput`](crate::output::UpdateMedicalVocabularyOutput)
        pub fn build(self) -> crate::output::UpdateMedicalVocabularyOutput {
            crate::output::UpdateMedicalVocabularyOutput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
                vocabulary_state: self.vocabulary_state,
            }
        }
    }
}
impl UpdateMedicalVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`UpdateMedicalVocabularyOutput`](crate::output::UpdateMedicalVocabularyOutput)
    pub fn builder() -> crate::output::update_medical_vocabulary_output::Builder {
        crate::output::update_medical_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCallAnalyticsCategoryOutput {
    /// <p>The attributes describing the analytics category. You can see information such as the rules that you've used
    /// to update the category and when the category was originally created. </p>
    pub category_properties: std::option::Option<crate::model::CategoryProperties>,
}
impl std::fmt::Debug for UpdateCallAnalyticsCategoryOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCallAnalyticsCategoryOutput");
        formatter.field("category_properties", &self.category_properties);
        formatter.finish()
    }
}
/// See [`UpdateCallAnalyticsCategoryOutput`](crate::output::UpdateCallAnalyticsCategoryOutput)
pub mod update_call_analytics_category_output {
    /// A builder for [`UpdateCallAnalyticsCategoryOutput`](crate::output::UpdateCallAnalyticsCategoryOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_properties: std::option::Option<crate::model::CategoryProperties>,
    }
    impl Builder {
        /// <p>The attributes describing the analytics category. You can see information such as the rules that you've used
        /// to update the category and when the category was originally created. </p>
        pub fn category_properties(mut self, input: crate::model::CategoryProperties) -> Self {
            self.category_properties = Some(input);
            self
        }
        /// <p>The attributes describing the analytics category. You can see information such as the rules that you've used
        /// to update the category and when the category was originally created. </p>
        pub fn set_category_properties(
            mut self,
            input: std::option::Option<crate::model::CategoryProperties>,
        ) -> Self {
            self.category_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCallAnalyticsCategoryOutput`](crate::output::UpdateCallAnalyticsCategoryOutput)
        pub fn build(self) -> crate::output::UpdateCallAnalyticsCategoryOutput {
            crate::output::UpdateCallAnalyticsCategoryOutput {
                category_properties: self.category_properties,
            }
        }
    }
}
impl UpdateCallAnalyticsCategoryOutput {
    /// Creates a new builder-style object to manufacture [`UpdateCallAnalyticsCategoryOutput`](crate::output::UpdateCallAnalyticsCategoryOutput)
    pub fn builder() -> crate::output::update_call_analytics_category_output::Builder {
        crate::output::update_call_analytics_category_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceOutput {}
impl std::fmt::Debug for UntagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceOutput");
        formatter.finish()
    }
}
/// See [`UntagResourceOutput`](crate::output::UntagResourceOutput)
pub mod untag_resource_output {
    /// A builder for [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`UntagResourceOutput`](crate::output::UntagResourceOutput)
        pub fn build(self) -> crate::output::UntagResourceOutput {
            crate::output::UntagResourceOutput {}
        }
    }
}
impl UntagResourceOutput {
    /// Creates a new builder-style object to manufacture [`UntagResourceOutput`](crate::output::UntagResourceOutput)
    pub fn builder() -> crate::output::untag_resource_output::Builder {
        crate::output::untag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceOutput {}
impl std::fmt::Debug for TagResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceOutput");
        formatter.finish()
    }
}
/// See [`TagResourceOutput`](crate::output::TagResourceOutput)
pub mod tag_resource_output {
    /// A builder for [`TagResourceOutput`](crate::output::TagResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`TagResourceOutput`](crate::output::TagResourceOutput)
        pub fn build(self) -> crate::output::TagResourceOutput {
            crate::output::TagResourceOutput {}
        }
    }
}
impl TagResourceOutput {
    /// Creates a new builder-style object to manufacture [`TagResourceOutput`](crate::output::TagResourceOutput)
    pub fn builder() -> crate::output::tag_resource_output::Builder {
        crate::output::tag_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartTranscriptionJobOutput {
    /// <p>An object containing details of the asynchronous transcription job.</p>
    pub transcription_job: std::option::Option<crate::model::TranscriptionJob>,
}
impl std::fmt::Debug for StartTranscriptionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartTranscriptionJobOutput");
        formatter.field("transcription_job", &self.transcription_job);
        formatter.finish()
    }
}
/// See [`StartTranscriptionJobOutput`](crate::output::StartTranscriptionJobOutput)
pub mod start_transcription_job_output {
    /// A builder for [`StartTranscriptionJobOutput`](crate::output::StartTranscriptionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job: std::option::Option<crate::model::TranscriptionJob>,
    }
    impl Builder {
        /// <p>An object containing details of the asynchronous transcription job.</p>
        pub fn transcription_job(mut self, input: crate::model::TranscriptionJob) -> Self {
            self.transcription_job = Some(input);
            self
        }
        /// <p>An object containing details of the asynchronous transcription job.</p>
        pub fn set_transcription_job(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJob>,
        ) -> Self {
            self.transcription_job = input;
            self
        }
        /// Consumes the builder and constructs a [`StartTranscriptionJobOutput`](crate::output::StartTranscriptionJobOutput)
        pub fn build(self) -> crate::output::StartTranscriptionJobOutput {
            crate::output::StartTranscriptionJobOutput {
                transcription_job: self.transcription_job,
            }
        }
    }
}
impl StartTranscriptionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartTranscriptionJobOutput`](crate::output::StartTranscriptionJobOutput)
    pub fn builder() -> crate::output::start_transcription_job_output::Builder {
        crate::output::start_transcription_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartMedicalTranscriptionJobOutput {
    /// <p>A batch job submitted to transcribe medical speech to text.</p>
    pub medical_transcription_job: std::option::Option<crate::model::MedicalTranscriptionJob>,
}
impl std::fmt::Debug for StartMedicalTranscriptionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartMedicalTranscriptionJobOutput");
        formatter.field("medical_transcription_job", &self.medical_transcription_job);
        formatter.finish()
    }
}
/// See [`StartMedicalTranscriptionJobOutput`](crate::output::StartMedicalTranscriptionJobOutput)
pub mod start_medical_transcription_job_output {
    /// A builder for [`StartMedicalTranscriptionJobOutput`](crate::output::StartMedicalTranscriptionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job:
            std::option::Option<crate::model::MedicalTranscriptionJob>,
    }
    impl Builder {
        /// <p>A batch job submitted to transcribe medical speech to text.</p>
        pub fn medical_transcription_job(
            mut self,
            input: crate::model::MedicalTranscriptionJob,
        ) -> Self {
            self.medical_transcription_job = Some(input);
            self
        }
        /// <p>A batch job submitted to transcribe medical speech to text.</p>
        pub fn set_medical_transcription_job(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscriptionJob>,
        ) -> Self {
            self.medical_transcription_job = input;
            self
        }
        /// Consumes the builder and constructs a [`StartMedicalTranscriptionJobOutput`](crate::output::StartMedicalTranscriptionJobOutput)
        pub fn build(self) -> crate::output::StartMedicalTranscriptionJobOutput {
            crate::output::StartMedicalTranscriptionJobOutput {
                medical_transcription_job: self.medical_transcription_job,
            }
        }
    }
}
impl StartMedicalTranscriptionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartMedicalTranscriptionJobOutput`](crate::output::StartMedicalTranscriptionJobOutput)
    pub fn builder() -> crate::output::start_medical_transcription_job_output::Builder {
        crate::output::start_medical_transcription_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartCallAnalyticsJobOutput {
    /// <p>An object containing the details of the asynchronous call analytics job.</p>
    pub call_analytics_job: std::option::Option<crate::model::CallAnalyticsJob>,
}
impl std::fmt::Debug for StartCallAnalyticsJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartCallAnalyticsJobOutput");
        formatter.field("call_analytics_job", &self.call_analytics_job);
        formatter.finish()
    }
}
/// See [`StartCallAnalyticsJobOutput`](crate::output::StartCallAnalyticsJobOutput)
pub mod start_call_analytics_job_output {
    /// A builder for [`StartCallAnalyticsJobOutput`](crate::output::StartCallAnalyticsJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job: std::option::Option<crate::model::CallAnalyticsJob>,
    }
    impl Builder {
        /// <p>An object containing the details of the asynchronous call analytics job.</p>
        pub fn call_analytics_job(mut self, input: crate::model::CallAnalyticsJob) -> Self {
            self.call_analytics_job = Some(input);
            self
        }
        /// <p>An object containing the details of the asynchronous call analytics job.</p>
        pub fn set_call_analytics_job(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJob>,
        ) -> Self {
            self.call_analytics_job = input;
            self
        }
        /// Consumes the builder and constructs a [`StartCallAnalyticsJobOutput`](crate::output::StartCallAnalyticsJobOutput)
        pub fn build(self) -> crate::output::StartCallAnalyticsJobOutput {
            crate::output::StartCallAnalyticsJobOutput {
                call_analytics_job: self.call_analytics_job,
            }
        }
    }
}
impl StartCallAnalyticsJobOutput {
    /// Creates a new builder-style object to manufacture [`StartCallAnalyticsJobOutput`](crate::output::StartCallAnalyticsJobOutput)
    pub fn builder() -> crate::output::start_call_analytics_job_output::Builder {
        crate::output::start_call_analytics_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVocabularyFiltersOutput {
    /// <p>The <code>ListVocabularyFilters</code> operation returns a page of collections at a time. The maximum size
    /// of the page is set by the <code>MaxResults</code> parameter. If there are more jobs in the list than the page size,
    /// Amazon Transcribe returns the <code>NextPage</code> token. Include the token in the next request to the
    /// <code>ListVocabularyFilters</code> operation to return in the next page of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The list of vocabulary filters. It contains at most <code>MaxResults</code> number of filters. If there are more
    /// filters, call the <code>ListVocabularyFilters</code> operation again with the <code>NextToken</code> parameter
    /// in the request set to the value of the <code>NextToken</code> field in the response.</p>
    pub vocabulary_filters: std::option::Option<std::vec::Vec<crate::model::VocabularyFilterInfo>>,
}
impl std::fmt::Debug for ListVocabularyFiltersOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVocabularyFiltersOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("vocabulary_filters", &self.vocabulary_filters);
        formatter.finish()
    }
}
/// See [`ListVocabularyFiltersOutput`](crate::output::ListVocabularyFiltersOutput)
pub mod list_vocabulary_filters_output {
    /// A builder for [`ListVocabularyFiltersOutput`](crate::output::ListVocabularyFiltersOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) vocabulary_filters:
            std::option::Option<std::vec::Vec<crate::model::VocabularyFilterInfo>>,
    }
    impl Builder {
        /// <p>The <code>ListVocabularyFilters</code> operation returns a page of collections at a time. The maximum size
        /// of the page is set by the <code>MaxResults</code> parameter. If there are more jobs in the list than the page size,
        /// Amazon Transcribe returns the <code>NextPage</code> token. Include the token in the next request to the
        /// <code>ListVocabularyFilters</code> operation to return in the next page of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The <code>ListVocabularyFilters</code> operation returns a page of collections at a time. The maximum size
        /// of the page is set by the <code>MaxResults</code> parameter. If there are more jobs in the list than the page size,
        /// Amazon Transcribe returns the <code>NextPage</code> token. Include the token in the next request to the
        /// <code>ListVocabularyFilters</code> operation to return in the next page of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `vocabulary_filters`.
        ///
        /// To override the contents of this collection use [`set_vocabulary_filters`](Self::set_vocabulary_filters).
        ///
        /// <p>The list of vocabulary filters. It contains at most <code>MaxResults</code> number of filters. If there are more
        /// filters, call the <code>ListVocabularyFilters</code> operation again with the <code>NextToken</code> parameter
        /// in the request set to the value of the <code>NextToken</code> field in the response.</p>
        pub fn vocabulary_filters(
            mut self,
            input: impl Into<crate::model::VocabularyFilterInfo>,
        ) -> Self {
            let mut v = self.vocabulary_filters.unwrap_or_default();
            v.push(input.into());
            self.vocabulary_filters = Some(v);
            self
        }
        /// <p>The list of vocabulary filters. It contains at most <code>MaxResults</code> number of filters. If there are more
        /// filters, call the <code>ListVocabularyFilters</code> operation again with the <code>NextToken</code> parameter
        /// in the request set to the value of the <code>NextToken</code> field in the response.</p>
        pub fn set_vocabulary_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VocabularyFilterInfo>>,
        ) -> Self {
            self.vocabulary_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVocabularyFiltersOutput`](crate::output::ListVocabularyFiltersOutput)
        pub fn build(self) -> crate::output::ListVocabularyFiltersOutput {
            crate::output::ListVocabularyFiltersOutput {
                next_token: self.next_token,
                vocabulary_filters: self.vocabulary_filters,
            }
        }
    }
}
impl ListVocabularyFiltersOutput {
    /// Creates a new builder-style object to manufacture [`ListVocabularyFiltersOutput`](crate::output::ListVocabularyFiltersOutput)
    pub fn builder() -> crate::output::list_vocabulary_filters_output::Builder {
        crate::output::list_vocabulary_filters_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListVocabulariesOutput {
    /// <p>The requested vocabulary state.</p>
    pub status: std::option::Option<crate::model::VocabularyState>,
    /// <p>The <code>ListVocabularies</code> operation returns a page of vocabularies at a time. The maximum size of
    /// the page is set in the <code>MaxResults</code> parameter. If there are more jobs in the list than will fit on the
    /// page, Amazon Transcribe returns the <code>NextPage</code> token. To return in the next page of jobs, include the token in the
    /// next request to the <code>ListVocabularies</code> operation.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects that describe the vocabularies that match the search criteria in the request.</p>
    pub vocabularies: std::option::Option<std::vec::Vec<crate::model::VocabularyInfo>>,
}
impl std::fmt::Debug for ListVocabulariesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListVocabulariesOutput");
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.field("vocabularies", &self.vocabularies);
        formatter.finish()
    }
}
/// See [`ListVocabulariesOutput`](crate::output::ListVocabulariesOutput)
pub mod list_vocabularies_output {
    /// A builder for [`ListVocabulariesOutput`](crate::output::ListVocabulariesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::VocabularyState>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) vocabularies: std::option::Option<std::vec::Vec<crate::model::VocabularyInfo>>,
    }
    impl Builder {
        /// <p>The requested vocabulary state.</p>
        pub fn status(mut self, input: crate::model::VocabularyState) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The requested vocabulary state.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The <code>ListVocabularies</code> operation returns a page of vocabularies at a time. The maximum size of
        /// the page is set in the <code>MaxResults</code> parameter. If there are more jobs in the list than will fit on the
        /// page, Amazon Transcribe returns the <code>NextPage</code> token. To return in the next page of jobs, include the token in the
        /// next request to the <code>ListVocabularies</code> operation.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The <code>ListVocabularies</code> operation returns a page of vocabularies at a time. The maximum size of
        /// the page is set in the <code>MaxResults</code> parameter. If there are more jobs in the list than will fit on the
        /// page, Amazon Transcribe returns the <code>NextPage</code> token. To return in the next page of jobs, include the token in the
        /// next request to the <code>ListVocabularies</code> operation.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `vocabularies`.
        ///
        /// To override the contents of this collection use [`set_vocabularies`](Self::set_vocabularies).
        ///
        /// <p>A list of objects that describe the vocabularies that match the search criteria in the request.</p>
        pub fn vocabularies(mut self, input: impl Into<crate::model::VocabularyInfo>) -> Self {
            let mut v = self.vocabularies.unwrap_or_default();
            v.push(input.into());
            self.vocabularies = Some(v);
            self
        }
        /// <p>A list of objects that describe the vocabularies that match the search criteria in the request.</p>
        pub fn set_vocabularies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VocabularyInfo>>,
        ) -> Self {
            self.vocabularies = input;
            self
        }
        /// Consumes the builder and constructs a [`ListVocabulariesOutput`](crate::output::ListVocabulariesOutput)
        pub fn build(self) -> crate::output::ListVocabulariesOutput {
            crate::output::ListVocabulariesOutput {
                status: self.status,
                next_token: self.next_token,
                vocabularies: self.vocabularies,
            }
        }
    }
}
impl ListVocabulariesOutput {
    /// Creates a new builder-style object to manufacture [`ListVocabulariesOutput`](crate::output::ListVocabulariesOutput)
    pub fn builder() -> crate::output::list_vocabularies_output::Builder {
        crate::output::list_vocabularies_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTranscriptionJobsOutput {
    /// <p>The requested status of the jobs returned.</p>
    pub status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>The <code>ListTranscriptionJobs</code> operation returns a page of jobs at a time. The maximum size of the
    /// page is set by the <code>MaxResults</code> parameter. If there are more jobs in the list than the page size, Amazon Transcribe
    /// returns the <code>NextPage</code> token. Include the token in the next request to the
    /// <code>ListTranscriptionJobs</code> operation to return in the next page of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects containing summary information for a transcription job.</p>
    pub transcription_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::TranscriptionJobSummary>>,
}
impl std::fmt::Debug for ListTranscriptionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTranscriptionJobsOutput");
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.field(
            "transcription_job_summaries",
            &self.transcription_job_summaries,
        );
        formatter.finish()
    }
}
/// See [`ListTranscriptionJobsOutput`](crate::output::ListTranscriptionJobsOutput)
pub mod list_transcription_jobs_output {
    /// A builder for [`ListTranscriptionJobsOutput`](crate::output::ListTranscriptionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) transcription_job_summaries:
            std::option::Option<std::vec::Vec<crate::model::TranscriptionJobSummary>>,
    }
    impl Builder {
        /// <p>The requested status of the jobs returned.</p>
        pub fn status(mut self, input: crate::model::TranscriptionJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The requested status of the jobs returned.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The <code>ListTranscriptionJobs</code> operation returns a page of jobs at a time. The maximum size of the
        /// page is set by the <code>MaxResults</code> parameter. If there are more jobs in the list than the page size, Amazon Transcribe
        /// returns the <code>NextPage</code> token. Include the token in the next request to the
        /// <code>ListTranscriptionJobs</code> operation to return in the next page of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The <code>ListTranscriptionJobs</code> operation returns a page of jobs at a time. The maximum size of the
        /// page is set by the <code>MaxResults</code> parameter. If there are more jobs in the list than the page size, Amazon Transcribe
        /// returns the <code>NextPage</code> token. Include the token in the next request to the
        /// <code>ListTranscriptionJobs</code> operation to return in the next page of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `transcription_job_summaries`.
        ///
        /// To override the contents of this collection use [`set_transcription_job_summaries`](Self::set_transcription_job_summaries).
        ///
        /// <p>A list of objects containing summary information for a transcription job.</p>
        pub fn transcription_job_summaries(
            mut self,
            input: impl Into<crate::model::TranscriptionJobSummary>,
        ) -> Self {
            let mut v = self.transcription_job_summaries.unwrap_or_default();
            v.push(input.into());
            self.transcription_job_summaries = Some(v);
            self
        }
        /// <p>A list of objects containing summary information for a transcription job.</p>
        pub fn set_transcription_job_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TranscriptionJobSummary>>,
        ) -> Self {
            self.transcription_job_summaries = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTranscriptionJobsOutput`](crate::output::ListTranscriptionJobsOutput)
        pub fn build(self) -> crate::output::ListTranscriptionJobsOutput {
            crate::output::ListTranscriptionJobsOutput {
                status: self.status,
                next_token: self.next_token,
                transcription_job_summaries: self.transcription_job_summaries,
            }
        }
    }
}
impl ListTranscriptionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListTranscriptionJobsOutput`](crate::output::ListTranscriptionJobsOutput)
    pub fn builder() -> crate::output::list_transcription_jobs_output::Builder {
        crate::output::list_transcription_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutput {
    /// <p>Lists all tags associated with the given Amazon Resource Name (ARN).</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Lists all tags associated with the given transcription job, vocabulary, or resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ListTagsForResourceOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
pub mod list_tags_for_resource_output {
    /// A builder for [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>Lists all tags associated with the given Amazon Resource Name (ARN).</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>Lists all tags associated with the given Amazon Resource Name (ARN).</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Lists all tags associated with the given transcription job, vocabulary, or resource.</p>
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        /// <p>Lists all tags associated with the given transcription job, vocabulary, or resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
        pub fn build(self) -> crate::output::ListTagsForResourceOutput {
            crate::output::ListTagsForResourceOutput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            }
        }
    }
}
impl ListTagsForResourceOutput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceOutput`](crate::output::ListTagsForResourceOutput)
    pub fn builder() -> crate::output::list_tags_for_resource_output::Builder {
        crate::output::list_tags_for_resource_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMedicalVocabulariesOutput {
    /// <p>The requested vocabulary state.</p>
    pub status: std::option::Option<crate::model::VocabularyState>,
    /// <p>The <code>ListMedicalVocabularies</code> operation returns a page of vocabularies at a time. You set the
    /// maximum number of vocabularies to return on a page with the <code>MaxResults</code> parameter. If there
    /// are more jobs in the list will fit on a page, Amazon Transcribe Medical returns the <code>NextPage</code> token. To return the next
    /// page of vocabularies, include the token in the next request to the <code>ListMedicalVocabularies</code>
    /// operation .</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects that describe the vocabularies that match your search criteria.</p>
    pub vocabularies: std::option::Option<std::vec::Vec<crate::model::VocabularyInfo>>,
}
impl std::fmt::Debug for ListMedicalVocabulariesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMedicalVocabulariesOutput");
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.field("vocabularies", &self.vocabularies);
        formatter.finish()
    }
}
/// See [`ListMedicalVocabulariesOutput`](crate::output::ListMedicalVocabulariesOutput)
pub mod list_medical_vocabularies_output {
    /// A builder for [`ListMedicalVocabulariesOutput`](crate::output::ListMedicalVocabulariesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::VocabularyState>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) vocabularies: std::option::Option<std::vec::Vec<crate::model::VocabularyInfo>>,
    }
    impl Builder {
        /// <p>The requested vocabulary state.</p>
        pub fn status(mut self, input: crate::model::VocabularyState) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The requested vocabulary state.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The <code>ListMedicalVocabularies</code> operation returns a page of vocabularies at a time. You set the
        /// maximum number of vocabularies to return on a page with the <code>MaxResults</code> parameter. If there
        /// are more jobs in the list will fit on a page, Amazon Transcribe Medical returns the <code>NextPage</code> token. To return the next
        /// page of vocabularies, include the token in the next request to the <code>ListMedicalVocabularies</code>
        /// operation .</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The <code>ListMedicalVocabularies</code> operation returns a page of vocabularies at a time. You set the
        /// maximum number of vocabularies to return on a page with the <code>MaxResults</code> parameter. If there
        /// are more jobs in the list will fit on a page, Amazon Transcribe Medical returns the <code>NextPage</code> token. To return the next
        /// page of vocabularies, include the token in the next request to the <code>ListMedicalVocabularies</code>
        /// operation .</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `vocabularies`.
        ///
        /// To override the contents of this collection use [`set_vocabularies`](Self::set_vocabularies).
        ///
        /// <p>A list of objects that describe the vocabularies that match your search criteria.</p>
        pub fn vocabularies(mut self, input: impl Into<crate::model::VocabularyInfo>) -> Self {
            let mut v = self.vocabularies.unwrap_or_default();
            v.push(input.into());
            self.vocabularies = Some(v);
            self
        }
        /// <p>A list of objects that describe the vocabularies that match your search criteria.</p>
        pub fn set_vocabularies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VocabularyInfo>>,
        ) -> Self {
            self.vocabularies = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMedicalVocabulariesOutput`](crate::output::ListMedicalVocabulariesOutput)
        pub fn build(self) -> crate::output::ListMedicalVocabulariesOutput {
            crate::output::ListMedicalVocabulariesOutput {
                status: self.status,
                next_token: self.next_token,
                vocabularies: self.vocabularies,
            }
        }
    }
}
impl ListMedicalVocabulariesOutput {
    /// Creates a new builder-style object to manufacture [`ListMedicalVocabulariesOutput`](crate::output::ListMedicalVocabulariesOutput)
    pub fn builder() -> crate::output::list_medical_vocabularies_output::Builder {
        crate::output::list_medical_vocabularies_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListMedicalTranscriptionJobsOutput {
    /// <p>The requested status of the medical transcription jobs returned.</p>
    pub status: std::option::Option<crate::model::TranscriptionJobStatus>,
    /// <p>The <code>ListMedicalTranscriptionJobs</code> operation returns a page of jobs at a time. The maximum
    /// size of the page is set by the <code>MaxResults</code> parameter. If the number of jobs exceeds what can fit on
    /// a page, Amazon Transcribe Medical returns the <code>NextPage</code> token. Include the token in the next request to the
    /// <code>ListMedicalTranscriptionJobs</code> operation to return in the next page of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects containing summary information for a transcription job.</p>
    pub medical_transcription_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::MedicalTranscriptionJobSummary>>,
}
impl std::fmt::Debug for ListMedicalTranscriptionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListMedicalTranscriptionJobsOutput");
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.field(
            "medical_transcription_job_summaries",
            &self.medical_transcription_job_summaries,
        );
        formatter.finish()
    }
}
/// See [`ListMedicalTranscriptionJobsOutput`](crate::output::ListMedicalTranscriptionJobsOutput)
pub mod list_medical_transcription_jobs_output {
    /// A builder for [`ListMedicalTranscriptionJobsOutput`](crate::output::ListMedicalTranscriptionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::TranscriptionJobStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) medical_transcription_job_summaries:
            std::option::Option<std::vec::Vec<crate::model::MedicalTranscriptionJobSummary>>,
    }
    impl Builder {
        /// <p>The requested status of the medical transcription jobs returned.</p>
        pub fn status(mut self, input: crate::model::TranscriptionJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The requested status of the medical transcription jobs returned.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The <code>ListMedicalTranscriptionJobs</code> operation returns a page of jobs at a time. The maximum
        /// size of the page is set by the <code>MaxResults</code> parameter. If the number of jobs exceeds what can fit on
        /// a page, Amazon Transcribe Medical returns the <code>NextPage</code> token. Include the token in the next request to the
        /// <code>ListMedicalTranscriptionJobs</code> operation to return in the next page of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The <code>ListMedicalTranscriptionJobs</code> operation returns a page of jobs at a time. The maximum
        /// size of the page is set by the <code>MaxResults</code> parameter. If the number of jobs exceeds what can fit on
        /// a page, Amazon Transcribe Medical returns the <code>NextPage</code> token. Include the token in the next request to the
        /// <code>ListMedicalTranscriptionJobs</code> operation to return in the next page of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `medical_transcription_job_summaries`.
        ///
        /// To override the contents of this collection use [`set_medical_transcription_job_summaries`](Self::set_medical_transcription_job_summaries).
        ///
        /// <p>A list of objects containing summary information for a transcription job.</p>
        pub fn medical_transcription_job_summaries(
            mut self,
            input: impl Into<crate::model::MedicalTranscriptionJobSummary>,
        ) -> Self {
            let mut v = self.medical_transcription_job_summaries.unwrap_or_default();
            v.push(input.into());
            self.medical_transcription_job_summaries = Some(v);
            self
        }
        /// <p>A list of objects containing summary information for a transcription job.</p>
        pub fn set_medical_transcription_job_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MedicalTranscriptionJobSummary>>,
        ) -> Self {
            self.medical_transcription_job_summaries = input;
            self
        }
        /// Consumes the builder and constructs a [`ListMedicalTranscriptionJobsOutput`](crate::output::ListMedicalTranscriptionJobsOutput)
        pub fn build(self) -> crate::output::ListMedicalTranscriptionJobsOutput {
            crate::output::ListMedicalTranscriptionJobsOutput {
                status: self.status,
                next_token: self.next_token,
                medical_transcription_job_summaries: self.medical_transcription_job_summaries,
            }
        }
    }
}
impl ListMedicalTranscriptionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListMedicalTranscriptionJobsOutput`](crate::output::ListMedicalTranscriptionJobsOutput)
    pub fn builder() -> crate::output::list_medical_transcription_jobs_output::Builder {
        crate::output::list_medical_transcription_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListLanguageModelsOutput {
    /// <p>The  operation returns a page of jobs at a time. The maximum size
    /// of the list is set by the MaxResults parameter. If there are more language models in the list than the page size, Amazon Transcribe
    /// returns the <code>NextPage</code> token. Include the token in the next request to the  operation to return the next page of language models.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects containing information about custom language models.</p>
    pub models: std::option::Option<std::vec::Vec<crate::model::LanguageModel>>,
}
impl std::fmt::Debug for ListLanguageModelsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListLanguageModelsOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("models", &self.models);
        formatter.finish()
    }
}
/// See [`ListLanguageModelsOutput`](crate::output::ListLanguageModelsOutput)
pub mod list_language_models_output {
    /// A builder for [`ListLanguageModelsOutput`](crate::output::ListLanguageModelsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) models: std::option::Option<std::vec::Vec<crate::model::LanguageModel>>,
    }
    impl Builder {
        /// <p>The  operation returns a page of jobs at a time. The maximum size
        /// of the list is set by the MaxResults parameter. If there are more language models in the list than the page size, Amazon Transcribe
        /// returns the <code>NextPage</code> token. Include the token in the next request to the  operation to return the next page of language models.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The  operation returns a page of jobs at a time. The maximum size
        /// of the list is set by the MaxResults parameter. If there are more language models in the list than the page size, Amazon Transcribe
        /// returns the <code>NextPage</code> token. Include the token in the next request to the  operation to return the next page of language models.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `models`.
        ///
        /// To override the contents of this collection use [`set_models`](Self::set_models).
        ///
        /// <p>A list of objects containing information about custom language models.</p>
        pub fn models(mut self, input: impl Into<crate::model::LanguageModel>) -> Self {
            let mut v = self.models.unwrap_or_default();
            v.push(input.into());
            self.models = Some(v);
            self
        }
        /// <p>A list of objects containing information about custom language models.</p>
        pub fn set_models(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LanguageModel>>,
        ) -> Self {
            self.models = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLanguageModelsOutput`](crate::output::ListLanguageModelsOutput)
        pub fn build(self) -> crate::output::ListLanguageModelsOutput {
            crate::output::ListLanguageModelsOutput {
                next_token: self.next_token,
                models: self.models,
            }
        }
    }
}
impl ListLanguageModelsOutput {
    /// Creates a new builder-style object to manufacture [`ListLanguageModelsOutput`](crate::output::ListLanguageModelsOutput)
    pub fn builder() -> crate::output::list_language_models_output::Builder {
        crate::output::list_language_models_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCallAnalyticsJobsOutput {
    /// <p>When specified, returns only call analytics jobs with that status. Jobs are ordered
    /// by creation date, with the most recent jobs returned first. If you don't specify a status, Amazon Transcribe
    /// returns all transcription jobs ordered by creation date.</p>
    pub status: std::option::Option<crate::model::CallAnalyticsJobStatus>,
    /// <p>The  operation returns a page of jobs at a time. The
    /// maximum size of the page is set by the <code>MaxResults</code> parameter. If there are more
    /// jobs in the list than the page size, Amazon Transcribe returns the <code>NextPage</code> token. Include the
    /// token in your next request to the  operation to return next page of jobs.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects containing summary information for a transcription job.</p>
    pub call_analytics_job_summaries:
        std::option::Option<std::vec::Vec<crate::model::CallAnalyticsJobSummary>>,
}
impl std::fmt::Debug for ListCallAnalyticsJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCallAnalyticsJobsOutput");
        formatter.field("status", &self.status);
        formatter.field("next_token", &self.next_token);
        formatter.field(
            "call_analytics_job_summaries",
            &self.call_analytics_job_summaries,
        );
        formatter.finish()
    }
}
/// See [`ListCallAnalyticsJobsOutput`](crate::output::ListCallAnalyticsJobsOutput)
pub mod list_call_analytics_jobs_output {
    /// A builder for [`ListCallAnalyticsJobsOutput`](crate::output::ListCallAnalyticsJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::CallAnalyticsJobStatus>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) call_analytics_job_summaries:
            std::option::Option<std::vec::Vec<crate::model::CallAnalyticsJobSummary>>,
    }
    impl Builder {
        /// <p>When specified, returns only call analytics jobs with that status. Jobs are ordered
        /// by creation date, with the most recent jobs returned first. If you don't specify a status, Amazon Transcribe
        /// returns all transcription jobs ordered by creation date.</p>
        pub fn status(mut self, input: crate::model::CallAnalyticsJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>When specified, returns only call analytics jobs with that status. Jobs are ordered
        /// by creation date, with the most recent jobs returned first. If you don't specify a status, Amazon Transcribe
        /// returns all transcription jobs ordered by creation date.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The  operation returns a page of jobs at a time. The
        /// maximum size of the page is set by the <code>MaxResults</code> parameter. If there are more
        /// jobs in the list than the page size, Amazon Transcribe returns the <code>NextPage</code> token. Include the
        /// token in your next request to the  operation to return next page of jobs.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The  operation returns a page of jobs at a time. The
        /// maximum size of the page is set by the <code>MaxResults</code> parameter. If there are more
        /// jobs in the list than the page size, Amazon Transcribe returns the <code>NextPage</code> token. Include the
        /// token in your next request to the  operation to return next page of jobs.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `call_analytics_job_summaries`.
        ///
        /// To override the contents of this collection use [`set_call_analytics_job_summaries`](Self::set_call_analytics_job_summaries).
        ///
        /// <p>A list of objects containing summary information for a transcription job.</p>
        pub fn call_analytics_job_summaries(
            mut self,
            input: impl Into<crate::model::CallAnalyticsJobSummary>,
        ) -> Self {
            let mut v = self.call_analytics_job_summaries.unwrap_or_default();
            v.push(input.into());
            self.call_analytics_job_summaries = Some(v);
            self
        }
        /// <p>A list of objects containing summary information for a transcription job.</p>
        pub fn set_call_analytics_job_summaries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CallAnalyticsJobSummary>>,
        ) -> Self {
            self.call_analytics_job_summaries = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCallAnalyticsJobsOutput`](crate::output::ListCallAnalyticsJobsOutput)
        pub fn build(self) -> crate::output::ListCallAnalyticsJobsOutput {
            crate::output::ListCallAnalyticsJobsOutput {
                status: self.status,
                next_token: self.next_token,
                call_analytics_job_summaries: self.call_analytics_job_summaries,
            }
        }
    }
}
impl ListCallAnalyticsJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListCallAnalyticsJobsOutput`](crate::output::ListCallAnalyticsJobsOutput)
    pub fn builder() -> crate::output::list_call_analytics_jobs_output::Builder {
        crate::output::list_call_analytics_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCallAnalyticsCategoriesOutput {
    /// <p>The  operation returns a page of jobs at a time. The
    /// maximum size of the list is set by the <code>MaxResults</code> parameter. If there are
    /// more categories in the list than the page size, Amazon Transcribe returns the <code>NextPage</code>
    /// token. Include the token in the next request to the
    /// operation to return the next page of analytics categories.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of objects containing information about analytics categories.</p>
    pub categories: std::option::Option<std::vec::Vec<crate::model::CategoryProperties>>,
}
impl std::fmt::Debug for ListCallAnalyticsCategoriesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCallAnalyticsCategoriesOutput");
        formatter.field("next_token", &self.next_token);
        formatter.field("categories", &self.categories);
        formatter.finish()
    }
}
/// See [`ListCallAnalyticsCategoriesOutput`](crate::output::ListCallAnalyticsCategoriesOutput)
pub mod list_call_analytics_categories_output {
    /// A builder for [`ListCallAnalyticsCategoriesOutput`](crate::output::ListCallAnalyticsCategoriesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) categories: std::option::Option<std::vec::Vec<crate::model::CategoryProperties>>,
    }
    impl Builder {
        /// <p>The  operation returns a page of jobs at a time. The
        /// maximum size of the list is set by the <code>MaxResults</code> parameter. If there are
        /// more categories in the list than the page size, Amazon Transcribe returns the <code>NextPage</code>
        /// token. Include the token in the next request to the
        /// operation to return the next page of analytics categories.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The  operation returns a page of jobs at a time. The
        /// maximum size of the list is set by the <code>MaxResults</code> parameter. If there are
        /// more categories in the list than the page size, Amazon Transcribe returns the <code>NextPage</code>
        /// token. Include the token in the next request to the
        /// operation to return the next page of analytics categories.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `categories`.
        ///
        /// To override the contents of this collection use [`set_categories`](Self::set_categories).
        ///
        /// <p>A list of objects containing information about analytics categories.</p>
        pub fn categories(mut self, input: impl Into<crate::model::CategoryProperties>) -> Self {
            let mut v = self.categories.unwrap_or_default();
            v.push(input.into());
            self.categories = Some(v);
            self
        }
        /// <p>A list of objects containing information about analytics categories.</p>
        pub fn set_categories(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CategoryProperties>>,
        ) -> Self {
            self.categories = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCallAnalyticsCategoriesOutput`](crate::output::ListCallAnalyticsCategoriesOutput)
        pub fn build(self) -> crate::output::ListCallAnalyticsCategoriesOutput {
            crate::output::ListCallAnalyticsCategoriesOutput {
                next_token: self.next_token,
                categories: self.categories,
            }
        }
    }
}
impl ListCallAnalyticsCategoriesOutput {
    /// Creates a new builder-style object to manufacture [`ListCallAnalyticsCategoriesOutput`](crate::output::ListCallAnalyticsCategoriesOutput)
    pub fn builder() -> crate::output::list_call_analytics_categories_output::Builder {
        crate::output::list_call_analytics_categories_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVocabularyFilterOutput {
    /// <p>The name of the vocabulary filter.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The language code of the words in the vocabulary filter.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the contents of the vocabulary filter were updated.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The URI of the list of words in the vocabulary filter. You can use this URI to get the list of words.</p>
    pub download_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetVocabularyFilterOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVocabularyFilterOutput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("download_uri", &self.download_uri);
        formatter.finish()
    }
}
/// See [`GetVocabularyFilterOutput`](crate::output::GetVocabularyFilterOutput)
pub mod get_vocabulary_filter_output {
    /// A builder for [`GetVocabularyFilterOutput`](crate::output::GetVocabularyFilterOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) download_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the words in the vocabulary filter.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the contents of the vocabulary filter were updated.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the contents of the vocabulary filter were updated.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>The URI of the list of words in the vocabulary filter. You can use this URI to get the list of words.</p>
        pub fn download_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.download_uri = Some(input.into());
            self
        }
        /// <p>The URI of the list of words in the vocabulary filter. You can use this URI to get the list of words.</p>
        pub fn set_download_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.download_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVocabularyFilterOutput`](crate::output::GetVocabularyFilterOutput)
        pub fn build(self) -> crate::output::GetVocabularyFilterOutput {
            crate::output::GetVocabularyFilterOutput {
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
                download_uri: self.download_uri,
            }
        }
    }
}
impl GetVocabularyFilterOutput {
    /// Creates a new builder-style object to manufacture [`GetVocabularyFilterOutput`](crate::output::GetVocabularyFilterOutput)
    pub fn builder() -> crate::output::get_vocabulary_filter_output::Builder {
        crate::output::get_vocabulary_filter_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVocabularyOutput {
    /// <p>The name of the vocabulary to return.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The processing state of the vocabulary.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The date and time that the vocabulary was last modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains
    /// information about why the job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The S3 location where the vocabulary is stored. Use this URI to get the contents of
    /// the vocabulary. The URI is available for a limited time.</p>
    pub download_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVocabularyOutput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("download_uri", &self.download_uri);
        formatter.finish()
    }
}
/// See [`GetVocabularyOutput`](crate::output::GetVocabularyOutput)
pub mod get_vocabulary_output {
    /// A builder for [`GetVocabularyOutput`](crate::output::GetVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) download_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary to return.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary to return.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The processing state of the vocabulary.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of the vocabulary.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// <p>The date and time that the vocabulary was last modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was last modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains
        /// information about why the job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains
        /// information about why the job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The S3 location where the vocabulary is stored. Use this URI to get the contents of
        /// the vocabulary. The URI is available for a limited time.</p>
        pub fn download_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.download_uri = Some(input.into());
            self
        }
        /// <p>The S3 location where the vocabulary is stored. Use this URI to get the contents of
        /// the vocabulary. The URI is available for a limited time.</p>
        pub fn set_download_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.download_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVocabularyOutput`](crate::output::GetVocabularyOutput)
        pub fn build(self) -> crate::output::GetVocabularyOutput {
            crate::output::GetVocabularyOutput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                vocabulary_state: self.vocabulary_state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                download_uri: self.download_uri,
            }
        }
    }
}
impl GetVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`GetVocabularyOutput`](crate::output::GetVocabularyOutput)
    pub fn builder() -> crate::output::get_vocabulary_output::Builder {
        crate::output::get_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTranscriptionJobOutput {
    /// <p>An object that contains the results of the transcription job.</p>
    pub transcription_job: std::option::Option<crate::model::TranscriptionJob>,
}
impl std::fmt::Debug for GetTranscriptionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTranscriptionJobOutput");
        formatter.field("transcription_job", &self.transcription_job);
        formatter.finish()
    }
}
/// See [`GetTranscriptionJobOutput`](crate::output::GetTranscriptionJobOutput)
pub mod get_transcription_job_output {
    /// A builder for [`GetTranscriptionJobOutput`](crate::output::GetTranscriptionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transcription_job: std::option::Option<crate::model::TranscriptionJob>,
    }
    impl Builder {
        /// <p>An object that contains the results of the transcription job.</p>
        pub fn transcription_job(mut self, input: crate::model::TranscriptionJob) -> Self {
            self.transcription_job = Some(input);
            self
        }
        /// <p>An object that contains the results of the transcription job.</p>
        pub fn set_transcription_job(
            mut self,
            input: std::option::Option<crate::model::TranscriptionJob>,
        ) -> Self {
            self.transcription_job = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTranscriptionJobOutput`](crate::output::GetTranscriptionJobOutput)
        pub fn build(self) -> crate::output::GetTranscriptionJobOutput {
            crate::output::GetTranscriptionJobOutput {
                transcription_job: self.transcription_job,
            }
        }
    }
}
impl GetTranscriptionJobOutput {
    /// Creates a new builder-style object to manufacture [`GetTranscriptionJobOutput`](crate::output::GetTranscriptionJobOutput)
    pub fn builder() -> crate::output::get_transcription_job_output::Builder {
        crate::output::get_transcription_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMedicalVocabularyOutput {
    /// <p>The name of the vocabulary returned by Amazon Transcribe Medical.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The valid language code for your vocabulary entries.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The processing state of the vocabulary. If the <code>VocabularyState</code> is <code>READY</code>
    /// then you can use it in the <code>StartMedicalTranscriptionJob</code> operation.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The date and time that the vocabulary was last modified with a text file different from the one that was
    /// previously used.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>VocabularyState</code> is <code>FAILED</code>, this field contains information about why
    /// the job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>The location in Amazon S3 where the vocabulary is stored. Use this URI to get the contents of the vocabulary. You
    /// can download your vocabulary from the URI for a limited time.</p>
    pub download_uri: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetMedicalVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMedicalVocabularyOutput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.field("download_uri", &self.download_uri);
        formatter.finish()
    }
}
/// See [`GetMedicalVocabularyOutput`](crate::output::GetMedicalVocabularyOutput)
pub mod get_medical_vocabulary_output {
    /// A builder for [`GetMedicalVocabularyOutput`](crate::output::GetMedicalVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) download_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary returned by Amazon Transcribe Medical.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary returned by Amazon Transcribe Medical.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The valid language code for your vocabulary entries.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The valid language code for your vocabulary entries.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The processing state of the vocabulary. If the <code>VocabularyState</code> is <code>READY</code>
        /// then you can use it in the <code>StartMedicalTranscriptionJob</code> operation.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of the vocabulary. If the <code>VocabularyState</code> is <code>READY</code>
        /// then you can use it in the <code>StartMedicalTranscriptionJob</code> operation.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// <p>The date and time that the vocabulary was last modified with a text file different from the one that was
        /// previously used.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was last modified with a text file different from the one that was
        /// previously used.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>If the <code>VocabularyState</code> is <code>FAILED</code>, this field contains information about why
        /// the job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>VocabularyState</code> is <code>FAILED</code>, this field contains information about why
        /// the job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>The location in Amazon S3 where the vocabulary is stored. Use this URI to get the contents of the vocabulary. You
        /// can download your vocabulary from the URI for a limited time.</p>
        pub fn download_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.download_uri = Some(input.into());
            self
        }
        /// <p>The location in Amazon S3 where the vocabulary is stored. Use this URI to get the contents of the vocabulary. You
        /// can download your vocabulary from the URI for a limited time.</p>
        pub fn set_download_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.download_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMedicalVocabularyOutput`](crate::output::GetMedicalVocabularyOutput)
        pub fn build(self) -> crate::output::GetMedicalVocabularyOutput {
            crate::output::GetMedicalVocabularyOutput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                vocabulary_state: self.vocabulary_state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
                download_uri: self.download_uri,
            }
        }
    }
}
impl GetMedicalVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`GetMedicalVocabularyOutput`](crate::output::GetMedicalVocabularyOutput)
    pub fn builder() -> crate::output::get_medical_vocabulary_output::Builder {
        crate::output::get_medical_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetMedicalTranscriptionJobOutput {
    /// <p>An object that contains the results of the medical transcription job.</p>
    pub medical_transcription_job: std::option::Option<crate::model::MedicalTranscriptionJob>,
}
impl std::fmt::Debug for GetMedicalTranscriptionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetMedicalTranscriptionJobOutput");
        formatter.field("medical_transcription_job", &self.medical_transcription_job);
        formatter.finish()
    }
}
/// See [`GetMedicalTranscriptionJobOutput`](crate::output::GetMedicalTranscriptionJobOutput)
pub mod get_medical_transcription_job_output {
    /// A builder for [`GetMedicalTranscriptionJobOutput`](crate::output::GetMedicalTranscriptionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) medical_transcription_job:
            std::option::Option<crate::model::MedicalTranscriptionJob>,
    }
    impl Builder {
        /// <p>An object that contains the results of the medical transcription job.</p>
        pub fn medical_transcription_job(
            mut self,
            input: crate::model::MedicalTranscriptionJob,
        ) -> Self {
            self.medical_transcription_job = Some(input);
            self
        }
        /// <p>An object that contains the results of the medical transcription job.</p>
        pub fn set_medical_transcription_job(
            mut self,
            input: std::option::Option<crate::model::MedicalTranscriptionJob>,
        ) -> Self {
            self.medical_transcription_job = input;
            self
        }
        /// Consumes the builder and constructs a [`GetMedicalTranscriptionJobOutput`](crate::output::GetMedicalTranscriptionJobOutput)
        pub fn build(self) -> crate::output::GetMedicalTranscriptionJobOutput {
            crate::output::GetMedicalTranscriptionJobOutput {
                medical_transcription_job: self.medical_transcription_job,
            }
        }
    }
}
impl GetMedicalTranscriptionJobOutput {
    /// Creates a new builder-style object to manufacture [`GetMedicalTranscriptionJobOutput`](crate::output::GetMedicalTranscriptionJobOutput)
    pub fn builder() -> crate::output::get_medical_transcription_job_output::Builder {
        crate::output::get_medical_transcription_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCallAnalyticsJobOutput {
    /// <p>An object that contains the results of your call analytics job.</p>
    pub call_analytics_job: std::option::Option<crate::model::CallAnalyticsJob>,
}
impl std::fmt::Debug for GetCallAnalyticsJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCallAnalyticsJobOutput");
        formatter.field("call_analytics_job", &self.call_analytics_job);
        formatter.finish()
    }
}
/// See [`GetCallAnalyticsJobOutput`](crate::output::GetCallAnalyticsJobOutput)
pub mod get_call_analytics_job_output {
    /// A builder for [`GetCallAnalyticsJobOutput`](crate::output::GetCallAnalyticsJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) call_analytics_job: std::option::Option<crate::model::CallAnalyticsJob>,
    }
    impl Builder {
        /// <p>An object that contains the results of your call analytics job.</p>
        pub fn call_analytics_job(mut self, input: crate::model::CallAnalyticsJob) -> Self {
            self.call_analytics_job = Some(input);
            self
        }
        /// <p>An object that contains the results of your call analytics job.</p>
        pub fn set_call_analytics_job(
            mut self,
            input: std::option::Option<crate::model::CallAnalyticsJob>,
        ) -> Self {
            self.call_analytics_job = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCallAnalyticsJobOutput`](crate::output::GetCallAnalyticsJobOutput)
        pub fn build(self) -> crate::output::GetCallAnalyticsJobOutput {
            crate::output::GetCallAnalyticsJobOutput {
                call_analytics_job: self.call_analytics_job,
            }
        }
    }
}
impl GetCallAnalyticsJobOutput {
    /// Creates a new builder-style object to manufacture [`GetCallAnalyticsJobOutput`](crate::output::GetCallAnalyticsJobOutput)
    pub fn builder() -> crate::output::get_call_analytics_job_output::Builder {
        crate::output::get_call_analytics_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCallAnalyticsCategoryOutput {
    /// <p>The rules you've defined for a category.</p>
    pub category_properties: std::option::Option<crate::model::CategoryProperties>,
}
impl std::fmt::Debug for GetCallAnalyticsCategoryOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCallAnalyticsCategoryOutput");
        formatter.field("category_properties", &self.category_properties);
        formatter.finish()
    }
}
/// See [`GetCallAnalyticsCategoryOutput`](crate::output::GetCallAnalyticsCategoryOutput)
pub mod get_call_analytics_category_output {
    /// A builder for [`GetCallAnalyticsCategoryOutput`](crate::output::GetCallAnalyticsCategoryOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_properties: std::option::Option<crate::model::CategoryProperties>,
    }
    impl Builder {
        /// <p>The rules you've defined for a category.</p>
        pub fn category_properties(mut self, input: crate::model::CategoryProperties) -> Self {
            self.category_properties = Some(input);
            self
        }
        /// <p>The rules you've defined for a category.</p>
        pub fn set_category_properties(
            mut self,
            input: std::option::Option<crate::model::CategoryProperties>,
        ) -> Self {
            self.category_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCallAnalyticsCategoryOutput`](crate::output::GetCallAnalyticsCategoryOutput)
        pub fn build(self) -> crate::output::GetCallAnalyticsCategoryOutput {
            crate::output::GetCallAnalyticsCategoryOutput {
                category_properties: self.category_properties,
            }
        }
    }
}
impl GetCallAnalyticsCategoryOutput {
    /// Creates a new builder-style object to manufacture [`GetCallAnalyticsCategoryOutput`](crate::output::GetCallAnalyticsCategoryOutput)
    pub fn builder() -> crate::output::get_call_analytics_category_output::Builder {
        crate::output::get_call_analytics_category_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeLanguageModelOutput {
    /// <p>The name of the custom language model you requested more information about.</p>
    pub language_model: std::option::Option<crate::model::LanguageModel>,
}
impl std::fmt::Debug for DescribeLanguageModelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeLanguageModelOutput");
        formatter.field("language_model", &self.language_model);
        formatter.finish()
    }
}
/// See [`DescribeLanguageModelOutput`](crate::output::DescribeLanguageModelOutput)
pub mod describe_language_model_output {
    /// A builder for [`DescribeLanguageModelOutput`](crate::output::DescribeLanguageModelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_model: std::option::Option<crate::model::LanguageModel>,
    }
    impl Builder {
        /// <p>The name of the custom language model you requested more information about.</p>
        pub fn language_model(mut self, input: crate::model::LanguageModel) -> Self {
            self.language_model = Some(input);
            self
        }
        /// <p>The name of the custom language model you requested more information about.</p>
        pub fn set_language_model(
            mut self,
            input: std::option::Option<crate::model::LanguageModel>,
        ) -> Self {
            self.language_model = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeLanguageModelOutput`](crate::output::DescribeLanguageModelOutput)
        pub fn build(self) -> crate::output::DescribeLanguageModelOutput {
            crate::output::DescribeLanguageModelOutput {
                language_model: self.language_model,
            }
        }
    }
}
impl DescribeLanguageModelOutput {
    /// Creates a new builder-style object to manufacture [`DescribeLanguageModelOutput`](crate::output::DescribeLanguageModelOutput)
    pub fn builder() -> crate::output::describe_language_model_output::Builder {
        crate::output::describe_language_model_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVocabularyFilterOutput {}
impl std::fmt::Debug for DeleteVocabularyFilterOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVocabularyFilterOutput");
        formatter.finish()
    }
}
/// See [`DeleteVocabularyFilterOutput`](crate::output::DeleteVocabularyFilterOutput)
pub mod delete_vocabulary_filter_output {
    /// A builder for [`DeleteVocabularyFilterOutput`](crate::output::DeleteVocabularyFilterOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteVocabularyFilterOutput`](crate::output::DeleteVocabularyFilterOutput)
        pub fn build(self) -> crate::output::DeleteVocabularyFilterOutput {
            crate::output::DeleteVocabularyFilterOutput {}
        }
    }
}
impl DeleteVocabularyFilterOutput {
    /// Creates a new builder-style object to manufacture [`DeleteVocabularyFilterOutput`](crate::output::DeleteVocabularyFilterOutput)
    pub fn builder() -> crate::output::delete_vocabulary_filter_output::Builder {
        crate::output::delete_vocabulary_filter_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteVocabularyOutput {}
impl std::fmt::Debug for DeleteVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteVocabularyOutput");
        formatter.finish()
    }
}
/// See [`DeleteVocabularyOutput`](crate::output::DeleteVocabularyOutput)
pub mod delete_vocabulary_output {
    /// A builder for [`DeleteVocabularyOutput`](crate::output::DeleteVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteVocabularyOutput`](crate::output::DeleteVocabularyOutput)
        pub fn build(self) -> crate::output::DeleteVocabularyOutput {
            crate::output::DeleteVocabularyOutput {}
        }
    }
}
impl DeleteVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`DeleteVocabularyOutput`](crate::output::DeleteVocabularyOutput)
    pub fn builder() -> crate::output::delete_vocabulary_output::Builder {
        crate::output::delete_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteTranscriptionJobOutput {}
impl std::fmt::Debug for DeleteTranscriptionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteTranscriptionJobOutput");
        formatter.finish()
    }
}
/// See [`DeleteTranscriptionJobOutput`](crate::output::DeleteTranscriptionJobOutput)
pub mod delete_transcription_job_output {
    /// A builder for [`DeleteTranscriptionJobOutput`](crate::output::DeleteTranscriptionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteTranscriptionJobOutput`](crate::output::DeleteTranscriptionJobOutput)
        pub fn build(self) -> crate::output::DeleteTranscriptionJobOutput {
            crate::output::DeleteTranscriptionJobOutput {}
        }
    }
}
impl DeleteTranscriptionJobOutput {
    /// Creates a new builder-style object to manufacture [`DeleteTranscriptionJobOutput`](crate::output::DeleteTranscriptionJobOutput)
    pub fn builder() -> crate::output::delete_transcription_job_output::Builder {
        crate::output::delete_transcription_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMedicalVocabularyOutput {}
impl std::fmt::Debug for DeleteMedicalVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMedicalVocabularyOutput");
        formatter.finish()
    }
}
/// See [`DeleteMedicalVocabularyOutput`](crate::output::DeleteMedicalVocabularyOutput)
pub mod delete_medical_vocabulary_output {
    /// A builder for [`DeleteMedicalVocabularyOutput`](crate::output::DeleteMedicalVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteMedicalVocabularyOutput`](crate::output::DeleteMedicalVocabularyOutput)
        pub fn build(self) -> crate::output::DeleteMedicalVocabularyOutput {
            crate::output::DeleteMedicalVocabularyOutput {}
        }
    }
}
impl DeleteMedicalVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`DeleteMedicalVocabularyOutput`](crate::output::DeleteMedicalVocabularyOutput)
    pub fn builder() -> crate::output::delete_medical_vocabulary_output::Builder {
        crate::output::delete_medical_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteMedicalTranscriptionJobOutput {}
impl std::fmt::Debug for DeleteMedicalTranscriptionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteMedicalTranscriptionJobOutput");
        formatter.finish()
    }
}
/// See [`DeleteMedicalTranscriptionJobOutput`](crate::output::DeleteMedicalTranscriptionJobOutput)
pub mod delete_medical_transcription_job_output {
    /// A builder for [`DeleteMedicalTranscriptionJobOutput`](crate::output::DeleteMedicalTranscriptionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteMedicalTranscriptionJobOutput`](crate::output::DeleteMedicalTranscriptionJobOutput)
        pub fn build(self) -> crate::output::DeleteMedicalTranscriptionJobOutput {
            crate::output::DeleteMedicalTranscriptionJobOutput {}
        }
    }
}
impl DeleteMedicalTranscriptionJobOutput {
    /// Creates a new builder-style object to manufacture [`DeleteMedicalTranscriptionJobOutput`](crate::output::DeleteMedicalTranscriptionJobOutput)
    pub fn builder() -> crate::output::delete_medical_transcription_job_output::Builder {
        crate::output::delete_medical_transcription_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLanguageModelOutput {}
impl std::fmt::Debug for DeleteLanguageModelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLanguageModelOutput");
        formatter.finish()
    }
}
/// See [`DeleteLanguageModelOutput`](crate::output::DeleteLanguageModelOutput)
pub mod delete_language_model_output {
    /// A builder for [`DeleteLanguageModelOutput`](crate::output::DeleteLanguageModelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteLanguageModelOutput`](crate::output::DeleteLanguageModelOutput)
        pub fn build(self) -> crate::output::DeleteLanguageModelOutput {
            crate::output::DeleteLanguageModelOutput {}
        }
    }
}
impl DeleteLanguageModelOutput {
    /// Creates a new builder-style object to manufacture [`DeleteLanguageModelOutput`](crate::output::DeleteLanguageModelOutput)
    pub fn builder() -> crate::output::delete_language_model_output::Builder {
        crate::output::delete_language_model_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCallAnalyticsJobOutput {}
impl std::fmt::Debug for DeleteCallAnalyticsJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCallAnalyticsJobOutput");
        formatter.finish()
    }
}
/// See [`DeleteCallAnalyticsJobOutput`](crate::output::DeleteCallAnalyticsJobOutput)
pub mod delete_call_analytics_job_output {
    /// A builder for [`DeleteCallAnalyticsJobOutput`](crate::output::DeleteCallAnalyticsJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteCallAnalyticsJobOutput`](crate::output::DeleteCallAnalyticsJobOutput)
        pub fn build(self) -> crate::output::DeleteCallAnalyticsJobOutput {
            crate::output::DeleteCallAnalyticsJobOutput {}
        }
    }
}
impl DeleteCallAnalyticsJobOutput {
    /// Creates a new builder-style object to manufacture [`DeleteCallAnalyticsJobOutput`](crate::output::DeleteCallAnalyticsJobOutput)
    pub fn builder() -> crate::output::delete_call_analytics_job_output::Builder {
        crate::output::delete_call_analytics_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCallAnalyticsCategoryOutput {}
impl std::fmt::Debug for DeleteCallAnalyticsCategoryOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCallAnalyticsCategoryOutput");
        formatter.finish()
    }
}
/// See [`DeleteCallAnalyticsCategoryOutput`](crate::output::DeleteCallAnalyticsCategoryOutput)
pub mod delete_call_analytics_category_output {
    /// A builder for [`DeleteCallAnalyticsCategoryOutput`](crate::output::DeleteCallAnalyticsCategoryOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`DeleteCallAnalyticsCategoryOutput`](crate::output::DeleteCallAnalyticsCategoryOutput)
        pub fn build(self) -> crate::output::DeleteCallAnalyticsCategoryOutput {
            crate::output::DeleteCallAnalyticsCategoryOutput {}
        }
    }
}
impl DeleteCallAnalyticsCategoryOutput {
    /// Creates a new builder-style object to manufacture [`DeleteCallAnalyticsCategoryOutput`](crate::output::DeleteCallAnalyticsCategoryOutput)
    pub fn builder() -> crate::output::delete_call_analytics_category_output::Builder {
        crate::output::delete_call_analytics_category_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVocabularyFilterOutput {
    /// <p>The name of the vocabulary filter.</p>
    pub vocabulary_filter_name: std::option::Option<std::string::String>,
    /// <p>The language code of the words in the collection.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The date and time that the vocabulary filter was modified.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for CreateVocabularyFilterOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVocabularyFilterOutput");
        formatter.field("vocabulary_filter_name", &self.vocabulary_filter_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.finish()
    }
}
/// See [`CreateVocabularyFilterOutput`](crate::output::CreateVocabularyFilterOutput)
pub mod create_vocabulary_filter_output {
    /// A builder for [`CreateVocabularyFilterOutput`](crate::output::CreateVocabularyFilterOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_filter_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The name of the vocabulary filter.</p>
        pub fn vocabulary_filter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_filter_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary filter.</p>
        pub fn set_vocabulary_filter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_filter_name = input;
            self
        }
        /// <p>The language code of the words in the collection.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the words in the collection.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date and time that the vocabulary filter was modified.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary filter was modified.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVocabularyFilterOutput`](crate::output::CreateVocabularyFilterOutput)
        pub fn build(self) -> crate::output::CreateVocabularyFilterOutput {
            crate::output::CreateVocabularyFilterOutput {
                vocabulary_filter_name: self.vocabulary_filter_name,
                language_code: self.language_code,
                last_modified_time: self.last_modified_time,
            }
        }
    }
}
impl CreateVocabularyFilterOutput {
    /// Creates a new builder-style object to manufacture [`CreateVocabularyFilterOutput`](crate::output::CreateVocabularyFilterOutput)
    pub fn builder() -> crate::output::create_vocabulary_filter_output::Builder {
        crate::output::create_vocabulary_filter_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVocabularyOutput {
    /// <p>The name of the vocabulary.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code of the vocabulary entries.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The processing state of the vocabulary. When the <code>VocabularyState</code> field contains
    /// <code>READY</code> the vocabulary is ready to be used in a <code>StartTranscriptionJob</code>
    /// request.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The date and time that the vocabulary was created.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains information about
    /// why the job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVocabularyOutput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`CreateVocabularyOutput`](crate::output::CreateVocabularyOutput)
pub mod create_vocabulary_output {
    /// A builder for [`CreateVocabularyOutput`](crate::output::CreateVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the vocabulary entries.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The processing state of the vocabulary. When the <code>VocabularyState</code> field contains
        /// <code>READY</code> the vocabulary is ready to be used in a <code>StartTranscriptionJob</code>
        /// request.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of the vocabulary. When the <code>VocabularyState</code> field contains
        /// <code>READY</code> the vocabulary is ready to be used in a <code>StartTranscriptionJob</code>
        /// request.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// <p>The date and time that the vocabulary was created.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that the vocabulary was created.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains information about
        /// why the job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains information about
        /// why the job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVocabularyOutput`](crate::output::CreateVocabularyOutput)
        pub fn build(self) -> crate::output::CreateVocabularyOutput {
            crate::output::CreateVocabularyOutput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                vocabulary_state: self.vocabulary_state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl CreateVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`CreateVocabularyOutput`](crate::output::CreateVocabularyOutput)
    pub fn builder() -> crate::output::create_vocabulary_output::Builder {
        crate::output::create_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateMedicalVocabularyOutput {
    /// <p>The name of the vocabulary. The name must be unique within an Amazon Web Services account and is case
    /// sensitive.</p>
    pub vocabulary_name: std::option::Option<std::string::String>,
    /// <p>The language code for the entries in your custom vocabulary. US English (en-US) is the only valid language
    /// code for Amazon Transcribe Medical.</p>
    pub language_code: std::option::Option<crate::model::LanguageCode>,
    /// <p>The processing state of your custom vocabulary in Amazon Transcribe Medical. If the state is <code>READY</code>, you can
    /// use the vocabulary in a <code>StartMedicalTranscriptionJob</code> request.</p>
    pub vocabulary_state: std::option::Option<crate::model::VocabularyState>,
    /// <p>The date and time that you created the vocabulary.</p>
    pub last_modified_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains information about
    /// why the job failed.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateMedicalVocabularyOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateMedicalVocabularyOutput");
        formatter.field("vocabulary_name", &self.vocabulary_name);
        formatter.field("language_code", &self.language_code);
        formatter.field("vocabulary_state", &self.vocabulary_state);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`CreateMedicalVocabularyOutput`](crate::output::CreateMedicalVocabularyOutput)
pub mod create_medical_vocabulary_output {
    /// A builder for [`CreateMedicalVocabularyOutput`](crate::output::CreateMedicalVocabularyOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) vocabulary_name: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<crate::model::LanguageCode>,
        pub(crate) vocabulary_state: std::option::Option<crate::model::VocabularyState>,
        pub(crate) last_modified_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the vocabulary. The name must be unique within an Amazon Web Services account and is case
        /// sensitive.</p>
        pub fn vocabulary_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.vocabulary_name = Some(input.into());
            self
        }
        /// <p>The name of the vocabulary. The name must be unique within an Amazon Web Services account and is case
        /// sensitive.</p>
        pub fn set_vocabulary_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vocabulary_name = input;
            self
        }
        /// <p>The language code for the entries in your custom vocabulary. US English (en-US) is the only valid language
        /// code for Amazon Transcribe Medical.</p>
        pub fn language_code(mut self, input: crate::model::LanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code for the entries in your custom vocabulary. US English (en-US) is the only valid language
        /// code for Amazon Transcribe Medical.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::LanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The processing state of your custom vocabulary in Amazon Transcribe Medical. If the state is <code>READY</code>, you can
        /// use the vocabulary in a <code>StartMedicalTranscriptionJob</code> request.</p>
        pub fn vocabulary_state(mut self, input: crate::model::VocabularyState) -> Self {
            self.vocabulary_state = Some(input);
            self
        }
        /// <p>The processing state of your custom vocabulary in Amazon Transcribe Medical. If the state is <code>READY</code>, you can
        /// use the vocabulary in a <code>StartMedicalTranscriptionJob</code> request.</p>
        pub fn set_vocabulary_state(
            mut self,
            input: std::option::Option<crate::model::VocabularyState>,
        ) -> Self {
            self.vocabulary_state = input;
            self
        }
        /// <p>The date and time that you created the vocabulary.</p>
        pub fn last_modified_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The date and time that you created the vocabulary.</p>
        pub fn set_last_modified_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains information about
        /// why the job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>If the <code>VocabularyState</code> field is <code>FAILED</code>, this field contains information about
        /// why the job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateMedicalVocabularyOutput`](crate::output::CreateMedicalVocabularyOutput)
        pub fn build(self) -> crate::output::CreateMedicalVocabularyOutput {
            crate::output::CreateMedicalVocabularyOutput {
                vocabulary_name: self.vocabulary_name,
                language_code: self.language_code,
                vocabulary_state: self.vocabulary_state,
                last_modified_time: self.last_modified_time,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl CreateMedicalVocabularyOutput {
    /// Creates a new builder-style object to manufacture [`CreateMedicalVocabularyOutput`](crate::output::CreateMedicalVocabularyOutput)
    pub fn builder() -> crate::output::create_medical_vocabulary_output::Builder {
        crate::output::create_medical_vocabulary_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLanguageModelOutput {
    /// <p>The language code of the text you've used to create a custom language model.</p>
    pub language_code: std::option::Option<crate::model::ClmLanguageCode>,
    /// <p>The Amazon Transcribe standard language model, or base model you've used to create a custom language model.</p>
    pub base_model_name: std::option::Option<crate::model::BaseModelName>,
    /// <p>The name you've chosen for your custom language model.</p>
    pub model_name: std::option::Option<std::string::String>,
    /// <p>The data access role and Amazon S3 prefixes you've chosen to create your custom language model.</p>
    pub input_data_config: std::option::Option<crate::model::InputDataConfig>,
    /// <p>The status of the custom language model. When the status is <code>COMPLETED</code> the model is ready
    /// to use.</p>
    pub model_status: std::option::Option<crate::model::ModelStatus>,
}
impl std::fmt::Debug for CreateLanguageModelOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLanguageModelOutput");
        formatter.field("language_code", &self.language_code);
        formatter.field("base_model_name", &self.base_model_name);
        formatter.field("model_name", &self.model_name);
        formatter.field("input_data_config", &self.input_data_config);
        formatter.field("model_status", &self.model_status);
        formatter.finish()
    }
}
/// See [`CreateLanguageModelOutput`](crate::output::CreateLanguageModelOutput)
pub mod create_language_model_output {
    /// A builder for [`CreateLanguageModelOutput`](crate::output::CreateLanguageModelOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) language_code: std::option::Option<crate::model::ClmLanguageCode>,
        pub(crate) base_model_name: std::option::Option<crate::model::BaseModelName>,
        pub(crate) model_name: std::option::Option<std::string::String>,
        pub(crate) input_data_config: std::option::Option<crate::model::InputDataConfig>,
        pub(crate) model_status: std::option::Option<crate::model::ModelStatus>,
    }
    impl Builder {
        /// <p>The language code of the text you've used to create a custom language model.</p>
        pub fn language_code(mut self, input: crate::model::ClmLanguageCode) -> Self {
            self.language_code = Some(input);
            self
        }
        /// <p>The language code of the text you've used to create a custom language model.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<crate::model::ClmLanguageCode>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model you've used to create a custom language model.</p>
        pub fn base_model_name(mut self, input: crate::model::BaseModelName) -> Self {
            self.base_model_name = Some(input);
            self
        }
        /// <p>The Amazon Transcribe standard language model, or base model you've used to create a custom language model.</p>
        pub fn set_base_model_name(
            mut self,
            input: std::option::Option<crate::model::BaseModelName>,
        ) -> Self {
            self.base_model_name = input;
            self
        }
        /// <p>The name you've chosen for your custom language model.</p>
        pub fn model_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_name = Some(input.into());
            self
        }
        /// <p>The name you've chosen for your custom language model.</p>
        pub fn set_model_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_name = input;
            self
        }
        /// <p>The data access role and Amazon S3 prefixes you've chosen to create your custom language model.</p>
        pub fn input_data_config(mut self, input: crate::model::InputDataConfig) -> Self {
            self.input_data_config = Some(input);
            self
        }
        /// <p>The data access role and Amazon S3 prefixes you've chosen to create your custom language model.</p>
        pub fn set_input_data_config(
            mut self,
            input: std::option::Option<crate::model::InputDataConfig>,
        ) -> Self {
            self.input_data_config = input;
            self
        }
        /// <p>The status of the custom language model. When the status is <code>COMPLETED</code> the model is ready
        /// to use.</p>
        pub fn model_status(mut self, input: crate::model::ModelStatus) -> Self {
            self.model_status = Some(input);
            self
        }
        /// <p>The status of the custom language model. When the status is <code>COMPLETED</code> the model is ready
        /// to use.</p>
        pub fn set_model_status(
            mut self,
            input: std::option::Option<crate::model::ModelStatus>,
        ) -> Self {
            self.model_status = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLanguageModelOutput`](crate::output::CreateLanguageModelOutput)
        pub fn build(self) -> crate::output::CreateLanguageModelOutput {
            crate::output::CreateLanguageModelOutput {
                language_code: self.language_code,
                base_model_name: self.base_model_name,
                model_name: self.model_name,
                input_data_config: self.input_data_config,
                model_status: self.model_status,
            }
        }
    }
}
impl CreateLanguageModelOutput {
    /// Creates a new builder-style object to manufacture [`CreateLanguageModelOutput`](crate::output::CreateLanguageModelOutput)
    pub fn builder() -> crate::output::create_language_model_output::Builder {
        crate::output::create_language_model_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCallAnalyticsCategoryOutput {
    /// <p>The rules and associated metadata used to create a category.</p>
    pub category_properties: std::option::Option<crate::model::CategoryProperties>,
}
impl std::fmt::Debug for CreateCallAnalyticsCategoryOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCallAnalyticsCategoryOutput");
        formatter.field("category_properties", &self.category_properties);
        formatter.finish()
    }
}
/// See [`CreateCallAnalyticsCategoryOutput`](crate::output::CreateCallAnalyticsCategoryOutput)
pub mod create_call_analytics_category_output {
    /// A builder for [`CreateCallAnalyticsCategoryOutput`](crate::output::CreateCallAnalyticsCategoryOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) category_properties: std::option::Option<crate::model::CategoryProperties>,
    }
    impl Builder {
        /// <p>The rules and associated metadata used to create a category.</p>
        pub fn category_properties(mut self, input: crate::model::CategoryProperties) -> Self {
            self.category_properties = Some(input);
            self
        }
        /// <p>The rules and associated metadata used to create a category.</p>
        pub fn set_category_properties(
            mut self,
            input: std::option::Option<crate::model::CategoryProperties>,
        ) -> Self {
            self.category_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCallAnalyticsCategoryOutput`](crate::output::CreateCallAnalyticsCategoryOutput)
        pub fn build(self) -> crate::output::CreateCallAnalyticsCategoryOutput {
            crate::output::CreateCallAnalyticsCategoryOutput {
                category_properties: self.category_properties,
            }
        }
    }
}
impl CreateCallAnalyticsCategoryOutput {
    /// Creates a new builder-style object to manufacture [`CreateCallAnalyticsCategoryOutput`](crate::output::CreateCallAnalyticsCategoryOutput)
    pub fn builder() -> crate::output::create_call_analytics_category_output::Builder {
        crate::output::create_call_analytics_category_output::Builder::default()
    }
}
