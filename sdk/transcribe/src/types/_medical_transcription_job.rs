// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides detailed information about a medical transcription job.</p>
/// <p>To view the status of the specified medical transcription job, check the <code>TranscriptionJobStatus</code> field. If the status is <code>COMPLETED</code>, the job is finished and you can find the results at the location specified in <code>TranscriptFileUri</code>. If the status is <code>FAILED</code>, <code>FailureReason</code> provides details on why your transcription job failed.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MedicalTranscriptionJob {
    /// <p>The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.</p>
    pub medical_transcription_job_name: ::std::option::Option<::std::string::String>,
    /// <p>Provides the status of the specified medical transcription job.</p>
    /// <p>If the status is <code>COMPLETED</code>, the job is finished and you can find the results at the location specified in <code>TranscriptFileUri</code>. If the status is <code>FAILED</code>, <code>FailureReason</code> provides details on why your transcription job failed.</p>
    pub transcription_job_status: ::std::option::Option<crate::types::TranscriptionJobStatus>,
    /// <p>The language code used to create your medical transcription job. US English (<code>en-US</code>) is the only supported language for medical transcriptions.</p>
    pub language_code: ::std::option::Option<crate::types::LanguageCode>,
    /// <p>The sample rate, in hertz, of the audio track in your input media file.</p>
    pub media_sample_rate_hertz: ::std::option::Option<i32>,
    /// <p>The format of the input media file.</p>
    pub media_format: ::std::option::Option<crate::types::MediaFormat>,
    /// <p>Describes the Amazon S3 location of the media file you want to use in your request.</p>
    /// <p>For information on supported media formats, refer to the <code>MediaFormat</code> parameter or the <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio">Media formats</a> section in the Amazon S3 Developer Guide.</p>
    pub media: ::std::option::Option<crate::types::Media>,
    /// <p>Provides you with the Amazon S3 URI you can use to access your transcript.</p>
    pub transcript: ::std::option::Option<crate::types::MedicalTranscript>,
    /// <p>The date and time the specified medical transcription job began processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.789000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date and time the specified medical transcription job request was made.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.761000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date and time the specified medical transcription job finished processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:33:13.922000-07:00</code> represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.</p>
    pub completion_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>If <code>TranscriptionJobStatus</code> is <code>FAILED</code>, <code>FailureReason</code> contains information about why the transcription job request failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p><code>Unsupported media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> isn't valid. Refer to refer to the <code>MediaFormat</code> parameter for a list of supported formats.</p></li>
    /// <li>
    /// <p><code>The media format provided does not match the detected media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> doesn't match the format of the input file. Check the media format of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid sample rate for audio file</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> isn't valid. The sample rate must be between 16,000 and 48,000 hertz.</p></li>
    /// <li>
    /// <p><code>The sample rate provided does not match the detected sample rate</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid file size: file size too large</code>.</p>
    /// <p>The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// <li>
    /// <p><code>Invalid number of channels: number of channels too large</code>.</p>
    /// <p>Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// </ul>
    pub failure_reason: ::std::option::Option<::std::string::String>,
    /// <p>Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.</p>
    pub settings: ::std::option::Option<crate::types::MedicalTranscriptionSetting>,
    /// <p>Indicates whether content identification was enabled for your transcription request.</p>
    pub content_identification_type: ::std::option::Option<crate::types::MedicalContentIdentificationType>,
    /// <p>Describes the medical specialty represented in your media.</p>
    pub specialty: ::std::option::Option<crate::types::Specialty>,
    /// <p>Indicates whether the input media is a dictation or a conversation, as specified in the <code>StartMedicalTranscriptionJob</code> request.</p>
    pub r#type: ::std::option::Option<crate::types::Type>,
    /// <p>The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl MedicalTranscriptionJob {
    /// <p>The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.</p>
    pub fn medical_transcription_job_name(&self) -> ::std::option::Option<&str> {
        self.medical_transcription_job_name.as_deref()
    }
    /// <p>Provides the status of the specified medical transcription job.</p>
    /// <p>If the status is <code>COMPLETED</code>, the job is finished and you can find the results at the location specified in <code>TranscriptFileUri</code>. If the status is <code>FAILED</code>, <code>FailureReason</code> provides details on why your transcription job failed.</p>
    pub fn transcription_job_status(&self) -> ::std::option::Option<&crate::types::TranscriptionJobStatus> {
        self.transcription_job_status.as_ref()
    }
    /// <p>The language code used to create your medical transcription job. US English (<code>en-US</code>) is the only supported language for medical transcriptions.</p>
    pub fn language_code(&self) -> ::std::option::Option<&crate::types::LanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>The sample rate, in hertz, of the audio track in your input media file.</p>
    pub fn media_sample_rate_hertz(&self) -> ::std::option::Option<i32> {
        self.media_sample_rate_hertz
    }
    /// <p>The format of the input media file.</p>
    pub fn media_format(&self) -> ::std::option::Option<&crate::types::MediaFormat> {
        self.media_format.as_ref()
    }
    /// <p>Describes the Amazon S3 location of the media file you want to use in your request.</p>
    /// <p>For information on supported media formats, refer to the <code>MediaFormat</code> parameter or the <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio">Media formats</a> section in the Amazon S3 Developer Guide.</p>
    pub fn media(&self) -> ::std::option::Option<&crate::types::Media> {
        self.media.as_ref()
    }
    /// <p>Provides you with the Amazon S3 URI you can use to access your transcript.</p>
    pub fn transcript(&self) -> ::std::option::Option<&crate::types::MedicalTranscript> {
        self.transcript.as_ref()
    }
    /// <p>The date and time the specified medical transcription job began processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.789000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn start_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The date and time the specified medical transcription job request was made.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.761000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn creation_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The date and time the specified medical transcription job finished processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:33:13.922000-07:00</code> represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.</p>
    pub fn completion_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.completion_time.as_ref()
    }
    /// <p>If <code>TranscriptionJobStatus</code> is <code>FAILED</code>, <code>FailureReason</code> contains information about why the transcription job request failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p><code>Unsupported media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> isn't valid. Refer to refer to the <code>MediaFormat</code> parameter for a list of supported formats.</p></li>
    /// <li>
    /// <p><code>The media format provided does not match the detected media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> doesn't match the format of the input file. Check the media format of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid sample rate for audio file</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> isn't valid. The sample rate must be between 16,000 and 48,000 hertz.</p></li>
    /// <li>
    /// <p><code>The sample rate provided does not match the detected sample rate</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid file size: file size too large</code>.</p>
    /// <p>The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// <li>
    /// <p><code>Invalid number of channels: number of channels too large</code>.</p>
    /// <p>Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// </ul>
    pub fn failure_reason(&self) -> ::std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.</p>
    pub fn settings(&self) -> ::std::option::Option<&crate::types::MedicalTranscriptionSetting> {
        self.settings.as_ref()
    }
    /// <p>Indicates whether content identification was enabled for your transcription request.</p>
    pub fn content_identification_type(&self) -> ::std::option::Option<&crate::types::MedicalContentIdentificationType> {
        self.content_identification_type.as_ref()
    }
    /// <p>Describes the medical specialty represented in your media.</p>
    pub fn specialty(&self) -> ::std::option::Option<&crate::types::Specialty> {
        self.specialty.as_ref()
    }
    /// <p>Indicates whether the input media is a dictation or a conversation, as specified in the <code>StartMedicalTranscriptionJob</code> request.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::Type> {
        self.r#type.as_ref()
    }
    /// <p>The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
}
impl MedicalTranscriptionJob {
    /// Creates a new builder-style object to manufacture [`MedicalTranscriptionJob`](crate::types::MedicalTranscriptionJob).
    pub fn builder() -> crate::types::builders::MedicalTranscriptionJobBuilder {
        crate::types::builders::MedicalTranscriptionJobBuilder::default()
    }
}

/// A builder for [`MedicalTranscriptionJob`](crate::types::MedicalTranscriptionJob).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct MedicalTranscriptionJobBuilder {
    pub(crate) medical_transcription_job_name: ::std::option::Option<::std::string::String>,
    pub(crate) transcription_job_status: ::std::option::Option<crate::types::TranscriptionJobStatus>,
    pub(crate) language_code: ::std::option::Option<crate::types::LanguageCode>,
    pub(crate) media_sample_rate_hertz: ::std::option::Option<i32>,
    pub(crate) media_format: ::std::option::Option<crate::types::MediaFormat>,
    pub(crate) media: ::std::option::Option<crate::types::Media>,
    pub(crate) transcript: ::std::option::Option<crate::types::MedicalTranscript>,
    pub(crate) start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) creation_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) completion_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) failure_reason: ::std::option::Option<::std::string::String>,
    pub(crate) settings: ::std::option::Option<crate::types::MedicalTranscriptionSetting>,
    pub(crate) content_identification_type: ::std::option::Option<crate::types::MedicalContentIdentificationType>,
    pub(crate) specialty: ::std::option::Option<crate::types::Specialty>,
    pub(crate) r#type: ::std::option::Option<crate::types::Type>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
}
impl MedicalTranscriptionJobBuilder {
    /// <p>The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.</p>
    pub fn medical_transcription_job_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.medical_transcription_job_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.</p>
    pub fn set_medical_transcription_job_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.medical_transcription_job_name = input;
        self
    }
    /// <p>The name of the medical transcription job. Job names are case sensitive and must be unique within an Amazon Web Services account.</p>
    pub fn get_medical_transcription_job_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.medical_transcription_job_name
    }
    /// <p>Provides the status of the specified medical transcription job.</p>
    /// <p>If the status is <code>COMPLETED</code>, the job is finished and you can find the results at the location specified in <code>TranscriptFileUri</code>. If the status is <code>FAILED</code>, <code>FailureReason</code> provides details on why your transcription job failed.</p>
    pub fn transcription_job_status(mut self, input: crate::types::TranscriptionJobStatus) -> Self {
        self.transcription_job_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides the status of the specified medical transcription job.</p>
    /// <p>If the status is <code>COMPLETED</code>, the job is finished and you can find the results at the location specified in <code>TranscriptFileUri</code>. If the status is <code>FAILED</code>, <code>FailureReason</code> provides details on why your transcription job failed.</p>
    pub fn set_transcription_job_status(mut self, input: ::std::option::Option<crate::types::TranscriptionJobStatus>) -> Self {
        self.transcription_job_status = input;
        self
    }
    /// <p>Provides the status of the specified medical transcription job.</p>
    /// <p>If the status is <code>COMPLETED</code>, the job is finished and you can find the results at the location specified in <code>TranscriptFileUri</code>. If the status is <code>FAILED</code>, <code>FailureReason</code> provides details on why your transcription job failed.</p>
    pub fn get_transcription_job_status(&self) -> &::std::option::Option<crate::types::TranscriptionJobStatus> {
        &self.transcription_job_status
    }
    /// <p>The language code used to create your medical transcription job. US English (<code>en-US</code>) is the only supported language for medical transcriptions.</p>
    pub fn language_code(mut self, input: crate::types::LanguageCode) -> Self {
        self.language_code = ::std::option::Option::Some(input);
        self
    }
    /// <p>The language code used to create your medical transcription job. US English (<code>en-US</code>) is the only supported language for medical transcriptions.</p>
    pub fn set_language_code(mut self, input: ::std::option::Option<crate::types::LanguageCode>) -> Self {
        self.language_code = input;
        self
    }
    /// <p>The language code used to create your medical transcription job. US English (<code>en-US</code>) is the only supported language for medical transcriptions.</p>
    pub fn get_language_code(&self) -> &::std::option::Option<crate::types::LanguageCode> {
        &self.language_code
    }
    /// <p>The sample rate, in hertz, of the audio track in your input media file.</p>
    pub fn media_sample_rate_hertz(mut self, input: i32) -> Self {
        self.media_sample_rate_hertz = ::std::option::Option::Some(input);
        self
    }
    /// <p>The sample rate, in hertz, of the audio track in your input media file.</p>
    pub fn set_media_sample_rate_hertz(mut self, input: ::std::option::Option<i32>) -> Self {
        self.media_sample_rate_hertz = input;
        self
    }
    /// <p>The sample rate, in hertz, of the audio track in your input media file.</p>
    pub fn get_media_sample_rate_hertz(&self) -> &::std::option::Option<i32> {
        &self.media_sample_rate_hertz
    }
    /// <p>The format of the input media file.</p>
    pub fn media_format(mut self, input: crate::types::MediaFormat) -> Self {
        self.media_format = ::std::option::Option::Some(input);
        self
    }
    /// <p>The format of the input media file.</p>
    pub fn set_media_format(mut self, input: ::std::option::Option<crate::types::MediaFormat>) -> Self {
        self.media_format = input;
        self
    }
    /// <p>The format of the input media file.</p>
    pub fn get_media_format(&self) -> &::std::option::Option<crate::types::MediaFormat> {
        &self.media_format
    }
    /// <p>Describes the Amazon S3 location of the media file you want to use in your request.</p>
    /// <p>For information on supported media formats, refer to the <code>MediaFormat</code> parameter or the <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio">Media formats</a> section in the Amazon S3 Developer Guide.</p>
    pub fn media(mut self, input: crate::types::Media) -> Self {
        self.media = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the Amazon S3 location of the media file you want to use in your request.</p>
    /// <p>For information on supported media formats, refer to the <code>MediaFormat</code> parameter or the <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio">Media formats</a> section in the Amazon S3 Developer Guide.</p>
    pub fn set_media(mut self, input: ::std::option::Option<crate::types::Media>) -> Self {
        self.media = input;
        self
    }
    /// <p>Describes the Amazon S3 location of the media file you want to use in your request.</p>
    /// <p>For information on supported media formats, refer to the <code>MediaFormat</code> parameter or the <a href="https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio">Media formats</a> section in the Amazon S3 Developer Guide.</p>
    pub fn get_media(&self) -> &::std::option::Option<crate::types::Media> {
        &self.media
    }
    /// <p>Provides you with the Amazon S3 URI you can use to access your transcript.</p>
    pub fn transcript(mut self, input: crate::types::MedicalTranscript) -> Self {
        self.transcript = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides you with the Amazon S3 URI you can use to access your transcript.</p>
    pub fn set_transcript(mut self, input: ::std::option::Option<crate::types::MedicalTranscript>) -> Self {
        self.transcript = input;
        self
    }
    /// <p>Provides you with the Amazon S3 URI you can use to access your transcript.</p>
    pub fn get_transcript(&self) -> &::std::option::Option<crate::types::MedicalTranscript> {
        &self.transcript
    }
    /// <p>The date and time the specified medical transcription job began processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.789000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn start_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the specified medical transcription job began processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.789000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn set_start_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The date and time the specified medical transcription job began processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.789000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn get_start_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.start_time
    }
    /// <p>The date and time the specified medical transcription job request was made.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.761000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn creation_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.creation_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the specified medical transcription job request was made.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.761000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn set_creation_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.creation_time = input;
        self
    }
    /// <p>The date and time the specified medical transcription job request was made.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:32:58.761000-07:00</code> represents a transcription job that started processing at 12:32 PM UTC-7 on May 4, 2022.</p>
    pub fn get_creation_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.creation_time
    }
    /// <p>The date and time the specified medical transcription job finished processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:33:13.922000-07:00</code> represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.</p>
    pub fn completion_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.completion_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time the specified medical transcription job finished processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:33:13.922000-07:00</code> represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.</p>
    pub fn set_completion_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.completion_time = input;
        self
    }
    /// <p>The date and time the specified medical transcription job finished processing.</p>
    /// <p>Timestamps are in the format <code>YYYY-MM-DD'T'HH:MM:SS.SSSSSS-UTC</code>. For example, <code>2022-05-04T12:33:13.922000-07:00</code> represents a transcription job that started processing at 12:33 PM UTC-7 on May 4, 2022.</p>
    pub fn get_completion_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.completion_time
    }
    /// <p>If <code>TranscriptionJobStatus</code> is <code>FAILED</code>, <code>FailureReason</code> contains information about why the transcription job request failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p><code>Unsupported media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> isn't valid. Refer to refer to the <code>MediaFormat</code> parameter for a list of supported formats.</p></li>
    /// <li>
    /// <p><code>The media format provided does not match the detected media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> doesn't match the format of the input file. Check the media format of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid sample rate for audio file</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> isn't valid. The sample rate must be between 16,000 and 48,000 hertz.</p></li>
    /// <li>
    /// <p><code>The sample rate provided does not match the detected sample rate</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid file size: file size too large</code>.</p>
    /// <p>The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// <li>
    /// <p><code>Invalid number of channels: number of channels too large</code>.</p>
    /// <p>Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// </ul>
    pub fn failure_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.failure_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If <code>TranscriptionJobStatus</code> is <code>FAILED</code>, <code>FailureReason</code> contains information about why the transcription job request failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p><code>Unsupported media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> isn't valid. Refer to refer to the <code>MediaFormat</code> parameter for a list of supported formats.</p></li>
    /// <li>
    /// <p><code>The media format provided does not match the detected media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> doesn't match the format of the input file. Check the media format of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid sample rate for audio file</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> isn't valid. The sample rate must be between 16,000 and 48,000 hertz.</p></li>
    /// <li>
    /// <p><code>The sample rate provided does not match the detected sample rate</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid file size: file size too large</code>.</p>
    /// <p>The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// <li>
    /// <p><code>Invalid number of channels: number of channels too large</code>.</p>
    /// <p>Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// </ul>
    pub fn set_failure_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.failure_reason = input;
        self
    }
    /// <p>If <code>TranscriptionJobStatus</code> is <code>FAILED</code>, <code>FailureReason</code> contains information about why the transcription job request failed.</p>
    /// <p>The <code>FailureReason</code> field contains one of the following values:</p>
    /// <ul>
    /// <li>
    /// <p><code>Unsupported media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> isn't valid. Refer to refer to the <code>MediaFormat</code> parameter for a list of supported formats.</p></li>
    /// <li>
    /// <p><code>The media format provided does not match the detected media format</code>.</p>
    /// <p>The media format specified in <code>MediaFormat</code> doesn't match the format of the input file. Check the media format of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid sample rate for audio file</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> isn't valid. The sample rate must be between 16,000 and 48,000 hertz.</p></li>
    /// <li>
    /// <p><code>The sample rate provided does not match the detected sample rate</code>.</p>
    /// <p>The sample rate specified in <code>MediaSampleRateHertz</code> doesn't match the sample rate detected in your input media file. Check the sample rate of your media file and correct the specified value.</p></li>
    /// <li>
    /// <p><code>Invalid file size: file size too large</code>.</p>
    /// <p>The size of your media file is larger than what Amazon Transcribe can process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// <li>
    /// <p><code>Invalid number of channels: number of channels too large</code>.</p>
    /// <p>Your audio contains more channels than Amazon Transcribe is able to process. For more information, refer to <a href="https://docs.aws.amazon.com/general/latest/gr/transcribe.html#limits-amazon-transcribe">Service quotas</a>.</p></li>
    /// </ul>
    pub fn get_failure_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.failure_reason
    }
    /// <p>Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.</p>
    pub fn settings(mut self, input: crate::types::MedicalTranscriptionSetting) -> Self {
        self.settings = ::std::option::Option::Some(input);
        self
    }
    /// <p>Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.</p>
    pub fn set_settings(mut self, input: ::std::option::Option<crate::types::MedicalTranscriptionSetting>) -> Self {
        self.settings = input;
        self
    }
    /// <p>Provides information on any additional settings that were included in your request. Additional settings include channel identification, alternative transcriptions, speaker partitioning, custom vocabularies, and custom vocabulary filters.</p>
    pub fn get_settings(&self) -> &::std::option::Option<crate::types::MedicalTranscriptionSetting> {
        &self.settings
    }
    /// <p>Indicates whether content identification was enabled for your transcription request.</p>
    pub fn content_identification_type(mut self, input: crate::types::MedicalContentIdentificationType) -> Self {
        self.content_identification_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether content identification was enabled for your transcription request.</p>
    pub fn set_content_identification_type(mut self, input: ::std::option::Option<crate::types::MedicalContentIdentificationType>) -> Self {
        self.content_identification_type = input;
        self
    }
    /// <p>Indicates whether content identification was enabled for your transcription request.</p>
    pub fn get_content_identification_type(&self) -> &::std::option::Option<crate::types::MedicalContentIdentificationType> {
        &self.content_identification_type
    }
    /// <p>Describes the medical specialty represented in your media.</p>
    pub fn specialty(mut self, input: crate::types::Specialty) -> Self {
        self.specialty = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the medical specialty represented in your media.</p>
    pub fn set_specialty(mut self, input: ::std::option::Option<crate::types::Specialty>) -> Self {
        self.specialty = input;
        self
    }
    /// <p>Describes the medical specialty represented in your media.</p>
    pub fn get_specialty(&self) -> &::std::option::Option<crate::types::Specialty> {
        &self.specialty
    }
    /// <p>Indicates whether the input media is a dictation or a conversation, as specified in the <code>StartMedicalTranscriptionJob</code> request.</p>
    pub fn r#type(mut self, input: crate::types::Type) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the input media is a dictation or a conversation, as specified in the <code>StartMedicalTranscriptionJob</code> request.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::Type>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>Indicates whether the input media is a dictation or a conversation, as specified in the <code>StartMedicalTranscriptionJob</code> request.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::Type> {
        &self.r#type
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The tags, each in the form of a key:value pair, assigned to the specified medical transcription job.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`MedicalTranscriptionJob`](crate::types::MedicalTranscriptionJob).
    pub fn build(self) -> crate::types::MedicalTranscriptionJob {
        crate::types::MedicalTranscriptionJob {
            medical_transcription_job_name: self.medical_transcription_job_name,
            transcription_job_status: self.transcription_job_status,
            language_code: self.language_code,
            media_sample_rate_hertz: self.media_sample_rate_hertz,
            media_format: self.media_format,
            media: self.media,
            transcript: self.transcript,
            start_time: self.start_time,
            creation_time: self.creation_time,
            completion_time: self.completion_time,
            failure_reason: self.failure_reason,
            settings: self.settings,
            content_identification_type: self.content_identification_type,
            specialty: self.specialty,
            r#type: self.r#type,
            tags: self.tags,
        }
    }
}
