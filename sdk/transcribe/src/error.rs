// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLanguageModelError {
    pub kind: CreateLanguageModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLanguageModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLanguageModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLanguageModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateLanguageModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLanguageModelError {
    fn code(&self) -> Option<&str> {
        CreateLanguageModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLanguageModelError {
    pub fn new(kind: CreateLanguageModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLanguageModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLanguageModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLanguageModelErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateLanguageModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLanguageModelErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::ConflictException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateLanguageModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateMedicalVocabularyError {
    pub kind: CreateMedicalVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMedicalVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        CreateMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMedicalVocabularyError {
    pub fn new(kind: CreateMedicalVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVocabularyError {
    pub kind: CreateVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVocabularyError {
    fn code(&self) -> Option<&str> {
        CreateVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVocabularyError {
    pub fn new(kind: CreateVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateVocabularyErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVocabularyFilterError {
    pub kind: CreateVocabularyFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVocabularyFilterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        CreateVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVocabularyFilterError {
    pub fn new(kind: CreateVocabularyFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for CreateVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::ConflictException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLanguageModelError {
    pub kind: DeleteLanguageModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLanguageModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLanguageModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLanguageModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteLanguageModelErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteLanguageModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteLanguageModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLanguageModelError {
    fn code(&self) -> Option<&str> {
        DeleteLanguageModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLanguageModelError {
    pub fn new(kind: DeleteLanguageModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLanguageModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLanguageModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLanguageModelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLanguageModelErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLanguageModelErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteLanguageModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLanguageModelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteLanguageModelErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteLanguageModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteLanguageModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMedicalTranscriptionJobError {
    pub kind: DeleteMedicalTranscriptionJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMedicalTranscriptionJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMedicalTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            DeleteMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteMedicalTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMedicalTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        DeleteMedicalTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMedicalTranscriptionJobError {
    pub fn new(kind: DeleteMedicalTranscriptionJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteMedicalTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => {
                Some(_inner)
            }
            DeleteMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteMedicalTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteMedicalVocabularyError {
    pub kind: DeleteMedicalVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteMedicalVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        DeleteMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteMedicalVocabularyError {
    pub fn new(kind: DeleteMedicalVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteMedicalVocabularyErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTranscriptionJobError {
    pub kind: DeleteTranscriptionJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTranscriptionJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        DeleteTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTranscriptionJobError {
    pub fn new(kind: DeleteTranscriptionJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for DeleteTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVocabularyError {
    pub kind: DeleteVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVocabularyError {
    fn code(&self) -> Option<&str> {
        DeleteVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVocabularyError {
    pub fn new(kind: DeleteVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteVocabularyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for DeleteVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVocabularyFilterError {
    pub kind: DeleteVocabularyFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVocabularyFilterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        DeleteVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVocabularyFilterError {
    pub fn new(kind: DeleteVocabularyFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVocabularyFilterErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLanguageModelError {
    pub kind: DescribeLanguageModelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLanguageModelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLanguageModelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLanguageModelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DescribeLanguageModelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLanguageModelError {
    fn code(&self) -> Option<&str> {
        DescribeLanguageModelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLanguageModelError {
    pub fn new(kind: DescribeLanguageModelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLanguageModelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLanguageModelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLanguageModelErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeLanguageModelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLanguageModelErrorKind::BadRequestException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::InternalFailureException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::LimitExceededException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::NotFoundException(_inner) => Some(_inner),
            DescribeLanguageModelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMedicalTranscriptionJobError {
    pub kind: GetMedicalTranscriptionJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMedicalTranscriptionJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMedicalTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMedicalTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMedicalTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        GetMedicalTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMedicalTranscriptionJobError {
    pub fn new(kind: GetMedicalTranscriptionJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalTranscriptionJobErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetMedicalTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMedicalTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMedicalVocabularyError {
    pub kind: GetMedicalVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMedicalVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        GetMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMedicalVocabularyError {
    pub fn new(kind: GetMedicalVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMedicalVocabularyErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTranscriptionJobError {
    pub kind: GetTranscriptionJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTranscriptionJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        GetTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetTranscriptionJobError {
    pub fn new(kind: GetTranscriptionJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetTranscriptionJobErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVocabularyError {
    pub kind: GetVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVocabularyError {
    fn code(&self) -> Option<&str> {
        GetVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVocabularyError {
    pub fn new(kind: GetVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVocabularyErrorKind::BadRequestException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVocabularyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for GetVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVocabularyFilterError {
    pub kind: GetVocabularyFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVocabularyFilterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        GetVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVocabularyFilterError {
    pub fn new(kind: GetVocabularyFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVocabularyFilterErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for GetVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLanguageModelsError {
    pub kind: ListLanguageModelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLanguageModelsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLanguageModelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLanguageModelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListLanguageModelsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListLanguageModelsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListLanguageModelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLanguageModelsError {
    fn code(&self) -> Option<&str> {
        ListLanguageModelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLanguageModelsError {
    pub fn new(kind: ListLanguageModelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLanguageModelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLanguageModelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLanguageModelsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLanguageModelsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLanguageModelsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListLanguageModelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLanguageModelsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListLanguageModelsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListLanguageModelsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListLanguageModelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMedicalTranscriptionJobsError {
    pub kind: ListMedicalTranscriptionJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMedicalTranscriptionJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMedicalTranscriptionJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMedicalTranscriptionJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMedicalTranscriptionJobsErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            ListMedicalTranscriptionJobsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListMedicalTranscriptionJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMedicalTranscriptionJobsError {
    fn code(&self) -> Option<&str> {
        ListMedicalTranscriptionJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMedicalTranscriptionJobsError {
    pub fn new(kind: ListMedicalTranscriptionJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMedicalTranscriptionJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMedicalTranscriptionJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalTranscriptionJobsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalTranscriptionJobsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalTranscriptionJobsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListMedicalTranscriptionJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMedicalTranscriptionJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMedicalTranscriptionJobsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListMedicalTranscriptionJobsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListMedicalTranscriptionJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListMedicalVocabulariesError {
    pub kind: ListMedicalVocabulariesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListMedicalVocabulariesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListMedicalVocabulariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListMedicalVocabulariesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListMedicalVocabulariesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListMedicalVocabulariesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListMedicalVocabulariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListMedicalVocabulariesError {
    fn code(&self) -> Option<&str> {
        ListMedicalVocabulariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListMedicalVocabulariesError {
    pub fn new(kind: ListMedicalVocabulariesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListMedicalVocabulariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListMedicalVocabulariesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalVocabulariesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalVocabulariesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListMedicalVocabulariesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListMedicalVocabulariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListMedicalVocabulariesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListMedicalVocabulariesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListMedicalVocabulariesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListMedicalVocabulariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTranscriptionJobsError {
    pub kind: ListTranscriptionJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTranscriptionJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTranscriptionJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTranscriptionJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTranscriptionJobsErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListTranscriptionJobsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListTranscriptionJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTranscriptionJobsError {
    fn code(&self) -> Option<&str> {
        ListTranscriptionJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTranscriptionJobsError {
    pub fn new(kind: ListTranscriptionJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTranscriptionJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTranscriptionJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTranscriptionJobsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTranscriptionJobsErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTranscriptionJobsErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListTranscriptionJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTranscriptionJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTranscriptionJobsErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListTranscriptionJobsErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListTranscriptionJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVocabulariesError {
    pub kind: ListVocabulariesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVocabulariesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVocabulariesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVocabulariesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVocabulariesErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListVocabulariesErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListVocabulariesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVocabulariesError {
    fn code(&self) -> Option<&str> {
        ListVocabulariesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVocabulariesError {
    pub fn new(kind: ListVocabulariesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVocabulariesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVocabulariesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabulariesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabulariesErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabulariesErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListVocabulariesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVocabulariesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVocabulariesErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListVocabulariesErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListVocabulariesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVocabularyFiltersError {
    pub kind: ListVocabularyFiltersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVocabularyFiltersErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVocabularyFiltersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVocabularyFiltersErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListVocabularyFiltersErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            ListVocabularyFiltersErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ListVocabularyFiltersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVocabularyFiltersError {
    fn code(&self) -> Option<&str> {
        ListVocabularyFiltersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVocabularyFiltersError {
    pub fn new(kind: ListVocabularyFiltersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVocabularyFiltersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVocabularyFiltersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabularyFiltersErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabularyFiltersErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVocabularyFiltersErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for ListVocabularyFiltersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVocabularyFiltersErrorKind::BadRequestException(_inner) => Some(_inner),
            ListVocabularyFiltersErrorKind::InternalFailureException(_inner) => Some(_inner),
            ListVocabularyFiltersErrorKind::LimitExceededException(_inner) => Some(_inner),
            ListVocabularyFiltersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMedicalTranscriptionJobError {
    pub kind: StartMedicalTranscriptionJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMedicalTranscriptionJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMedicalTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartMedicalTranscriptionJobErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => {
                _inner.fmt(f)
            }
            StartMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartMedicalTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMedicalTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        StartMedicalTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMedicalTranscriptionJobError {
    pub fn new(kind: StartMedicalTranscriptionJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMedicalTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMedicalTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for StartMedicalTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMedicalTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::ConflictException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartMedicalTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartTranscriptionJobError {
    pub kind: StartTranscriptionJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartTranscriptionJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartTranscriptionJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartTranscriptionJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::ConflictException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartTranscriptionJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartTranscriptionJobError {
    fn code(&self) -> Option<&str> {
        StartTranscriptionJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartTranscriptionJobError {
    pub fn new(kind: StartTranscriptionJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartTranscriptionJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartTranscriptionJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartTranscriptionJobErrorKind::LimitExceededException(_)
        )
    }
}
impl std::error::Error for StartTranscriptionJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartTranscriptionJobErrorKind::BadRequestException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::ConflictException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::InternalFailureException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartTranscriptionJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateMedicalVocabularyError {
    pub kind: UpdateMedicalVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateMedicalVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateMedicalVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateMedicalVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateMedicalVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateMedicalVocabularyError {
    fn code(&self) -> Option<&str> {
        UpdateMedicalVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateMedicalVocabularyError {
    pub fn new(kind: UpdateMedicalVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateMedicalVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateMedicalVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateMedicalVocabularyErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateMedicalVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateMedicalVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateMedicalVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVocabularyError {
    pub kind: UpdateVocabularyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVocabularyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVocabularyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVocabularyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVocabularyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVocabularyError {
    fn code(&self) -> Option<&str> {
        UpdateVocabularyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVocabularyError {
    pub fn new(kind: UpdateVocabularyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVocabularyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVocabularyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateVocabularyErrorKind::ConflictException(_))
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateVocabularyErrorKind::NotFoundException(_))
    }
}
impl std::error::Error for UpdateVocabularyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVocabularyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVocabularyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVocabularyFilterError {
    pub kind: UpdateVocabularyFilterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVocabularyFilterErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InternalFailureException(crate::error::InternalFailureException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVocabularyFilterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVocabularyFilterErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::InternalFailureException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVocabularyFilterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVocabularyFilterError {
    fn code(&self) -> Option<&str> {
        UpdateVocabularyFilterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVocabularyFilterError {
    pub fn new(kind: UpdateVocabularyFilterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVocabularyFilterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVocabularyFilterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::BadRequestException(_)
        )
    }
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::InternalFailureException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVocabularyFilterErrorKind::NotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateVocabularyFilterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVocabularyFilterErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::InternalFailureException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVocabularyFilterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>We can't find the requested resource. Check the name and try your request
/// again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>Either you have sent too many requests or your input file is too long. Wait before you
/// resend your request, or use a smaller file and resend the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>There was an internal error. Check the error message and try your request
/// again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// <p>Your request didn't pass one or more validation tests. For example, if the entity that
/// you're trying to delete doesn't exist or if it is in a non-terminal state (for example,
/// it's "in progress"). See the exception <code>Message</code> field for more
/// information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>There is already a resource with that name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
