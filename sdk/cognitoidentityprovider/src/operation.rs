// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds additional user attributes to the user pool schema.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddCustomAttributes {
    _private: (),
}
impl AddCustomAttributes {
    /// Creates a new builder-style object to manufacture [`AddCustomAttributesInput`](crate::input::AddCustomAttributesInput)
    pub fn builder() -> crate::input::add_custom_attributes_input::Builder {
        crate::input::add_custom_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddCustomAttributes {
    type Output = std::result::Result<
        crate::output::AddCustomAttributesOutput,
        crate::error::AddCustomAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_add_custom_attributes_error(response)
        } else {
            crate::operation_ser::parse_add_custom_attributes_response(response)
        }
    }
}

/// <p>Adds the specified user to the specified group.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminAddUserToGroup {
    _private: (),
}
impl AdminAddUserToGroup {
    /// Creates a new builder-style object to manufacture [`AdminAddUserToGroupInput`](crate::input::AdminAddUserToGroupInput)
    pub fn builder() -> crate::input::admin_add_user_to_group_input::Builder {
        crate::input::admin_add_user_to_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminAddUserToGroup {
    type Output = std::result::Result<
        crate::output::AdminAddUserToGroupOutput,
        crate::error::AdminAddUserToGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_add_user_to_group_error(response)
        } else {
            crate::operation_ser::parse_admin_add_user_to_group_response(response)
        }
    }
}

/// <p>Confirms user registration as an admin without using a confirmation code. Works on any
/// user.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminConfirmSignUp {
    _private: (),
}
impl AdminConfirmSignUp {
    /// Creates a new builder-style object to manufacture [`AdminConfirmSignUpInput`](crate::input::AdminConfirmSignUpInput)
    pub fn builder() -> crate::input::admin_confirm_sign_up_input::Builder {
        crate::input::admin_confirm_sign_up_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminConfirmSignUp {
    type Output = std::result::Result<
        crate::output::AdminConfirmSignUpOutput,
        crate::error::AdminConfirmSignUpError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_confirm_sign_up_error(response)
        } else {
            crate::operation_ser::parse_admin_confirm_sign_up_response(response)
        }
    }
}

/// <p>Creates a new user in the specified user pool.</p>
/// <p>If <code>MessageAction</code> is not set, the default is to send a welcome message via
/// email or phone (SMS).</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
/// <p>This message is based on a template that you configured in your call to create or
/// update a user pool. This template includes your custom sign-up instructions and
/// placeholders for user name and temporary password.</p>
/// <p>Alternatively, you can call <code>AdminCreateUser</code> with “SUPPRESS” for the
/// <code>MessageAction</code> parameter, and Amazon Cognito will not send any email. </p>
/// <p>In either case, the user will be in the <code>FORCE_CHANGE_PASSWORD</code> state until
/// they sign in and change their password.</p>
/// <p>
/// <code>AdminCreateUser</code> requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminCreateUser {
    _private: (),
}
impl AdminCreateUser {
    /// Creates a new builder-style object to manufacture [`AdminCreateUserInput`](crate::input::AdminCreateUserInput)
    pub fn builder() -> crate::input::admin_create_user_input::Builder {
        crate::input::admin_create_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminCreateUser {
    type Output = std::result::Result<
        crate::output::AdminCreateUserOutput,
        crate::error::AdminCreateUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_create_user_error(response)
        } else {
            crate::operation_ser::parse_admin_create_user_response(response)
        }
    }
}

/// <p>Deletes a user as an administrator. Works on any user.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminDeleteUser {
    _private: (),
}
impl AdminDeleteUser {
    /// Creates a new builder-style object to manufacture [`AdminDeleteUserInput`](crate::input::AdminDeleteUserInput)
    pub fn builder() -> crate::input::admin_delete_user_input::Builder {
        crate::input::admin_delete_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminDeleteUser {
    type Output = std::result::Result<
        crate::output::AdminDeleteUserOutput,
        crate::error::AdminDeleteUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_delete_user_error(response)
        } else {
            crate::operation_ser::parse_admin_delete_user_response(response)
        }
    }
}

/// <p>Deletes the user attributes in a user pool as an administrator. Works on any
/// user.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminDeleteUserAttributes {
    _private: (),
}
impl AdminDeleteUserAttributes {
    /// Creates a new builder-style object to manufacture [`AdminDeleteUserAttributesInput`](crate::input::AdminDeleteUserAttributesInput)
    pub fn builder() -> crate::input::admin_delete_user_attributes_input::Builder {
        crate::input::admin_delete_user_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminDeleteUserAttributes {
    type Output = std::result::Result<
        crate::output::AdminDeleteUserAttributesOutput,
        crate::error::AdminDeleteUserAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_delete_user_attributes_error(response)
        } else {
            crate::operation_ser::parse_admin_delete_user_attributes_response(response)
        }
    }
}

/// <p>Disables the user from signing in with the specified external (SAML or social)
/// identity provider. If the user to disable is a Cognito User Pools native username +
/// password user, they are not permitted to use their password to sign-in. If the user to
/// disable is a linked external IdP user, any link between that user and an existing user
/// is removed. The next time the external user (no longer attached to the previously linked
/// <code>DestinationUser</code>) signs in, they must create a new user account. See
/// <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminLinkProviderForUser.html">AdminLinkProviderForUser</a>.</p>
/// <p>This action is enabled only for admin access and requires developer
/// credentials.</p>
/// <p>The <code>ProviderName</code> must match the value specified when creating an IdP for
/// the pool. </p>
/// <p>To disable a native username + password user, the <code>ProviderName</code> value must
/// be <code>Cognito</code> and the <code>ProviderAttributeName</code> must be
/// <code>Cognito_Subject</code>, with the <code>ProviderAttributeValue</code> being the
/// name that is used in the user pool for the user.</p>
/// <p>The <code>ProviderAttributeName</code> must always be <code>Cognito_Subject</code> for
/// social identity providers. The <code>ProviderAttributeValue</code> must always be the
/// exact subject that was used when the user was originally linked as a source user.</p>
/// <p>For de-linking a SAML identity, there are two scenarios. If the linked identity has
/// not yet been used to sign-in, the <code>ProviderAttributeName</code> and
/// <code>ProviderAttributeValue</code> must be the same values that were used for the
/// <code>SourceUser</code> when the identities were originally linked using <code>
/// AdminLinkProviderForUser</code> call. (If the linking was done with
/// <code>ProviderAttributeName</code> set to <code>Cognito_Subject</code>, the same
/// applies here). However, if the user has already signed in, the
/// <code>ProviderAttributeName</code> must be <code>Cognito_Subject</code> and
/// <code>ProviderAttributeValue</code> must be the subject of the SAML
/// assertion.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminDisableProviderForUser {
    _private: (),
}
impl AdminDisableProviderForUser {
    /// Creates a new builder-style object to manufacture [`AdminDisableProviderForUserInput`](crate::input::AdminDisableProviderForUserInput)
    pub fn builder() -> crate::input::admin_disable_provider_for_user_input::Builder {
        crate::input::admin_disable_provider_for_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminDisableProviderForUser {
    type Output = std::result::Result<
        crate::output::AdminDisableProviderForUserOutput,
        crate::error::AdminDisableProviderForUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_disable_provider_for_user_error(response)
        } else {
            crate::operation_ser::parse_admin_disable_provider_for_user_response(response)
        }
    }
}

/// <p>Disables the specified user.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminDisableUser {
    _private: (),
}
impl AdminDisableUser {
    /// Creates a new builder-style object to manufacture [`AdminDisableUserInput`](crate::input::AdminDisableUserInput)
    pub fn builder() -> crate::input::admin_disable_user_input::Builder {
        crate::input::admin_disable_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminDisableUser {
    type Output = std::result::Result<
        crate::output::AdminDisableUserOutput,
        crate::error::AdminDisableUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_disable_user_error(response)
        } else {
            crate::operation_ser::parse_admin_disable_user_response(response)
        }
    }
}

/// <p>Enables the specified user as an administrator. Works on any user.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminEnableUser {
    _private: (),
}
impl AdminEnableUser {
    /// Creates a new builder-style object to manufacture [`AdminEnableUserInput`](crate::input::AdminEnableUserInput)
    pub fn builder() -> crate::input::admin_enable_user_input::Builder {
        crate::input::admin_enable_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminEnableUser {
    type Output = std::result::Result<
        crate::output::AdminEnableUserOutput,
        crate::error::AdminEnableUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_enable_user_error(response)
        } else {
            crate::operation_ser::parse_admin_enable_user_response(response)
        }
    }
}

/// <p>Forgets the device, as an administrator.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminForgetDevice {
    _private: (),
}
impl AdminForgetDevice {
    /// Creates a new builder-style object to manufacture [`AdminForgetDeviceInput`](crate::input::AdminForgetDeviceInput)
    pub fn builder() -> crate::input::admin_forget_device_input::Builder {
        crate::input::admin_forget_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminForgetDevice {
    type Output = std::result::Result<
        crate::output::AdminForgetDeviceOutput,
        crate::error::AdminForgetDeviceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_forget_device_error(response)
        } else {
            crate::operation_ser::parse_admin_forget_device_response(response)
        }
    }
}

/// <p>Gets the device, as an administrator.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminGetDevice {
    _private: (),
}
impl AdminGetDevice {
    /// Creates a new builder-style object to manufacture [`AdminGetDeviceInput`](crate::input::AdminGetDeviceInput)
    pub fn builder() -> crate::input::admin_get_device_input::Builder {
        crate::input::admin_get_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminGetDevice {
    type Output =
        std::result::Result<crate::output::AdminGetDeviceOutput, crate::error::AdminGetDeviceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_get_device_error(response)
        } else {
            crate::operation_ser::parse_admin_get_device_response(response)
        }
    }
}

/// <p>Gets the specified user by user name in a user pool as an administrator. Works on any
/// user.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminGetUser {
    _private: (),
}
impl AdminGetUser {
    /// Creates a new builder-style object to manufacture [`AdminGetUserInput`](crate::input::AdminGetUserInput)
    pub fn builder() -> crate::input::admin_get_user_input::Builder {
        crate::input::admin_get_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminGetUser {
    type Output =
        std::result::Result<crate::output::AdminGetUserOutput, crate::error::AdminGetUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_get_user_error(response)
        } else {
            crate::operation_ser::parse_admin_get_user_response(response)
        }
    }
}

/// <p>Initiates the authentication flow, as an administrator.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminInitiateAuth {
    _private: (),
}
impl AdminInitiateAuth {
    /// Creates a new builder-style object to manufacture [`AdminInitiateAuthInput`](crate::input::AdminInitiateAuthInput)
    pub fn builder() -> crate::input::admin_initiate_auth_input::Builder {
        crate::input::admin_initiate_auth_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminInitiateAuth {
    type Output = std::result::Result<
        crate::output::AdminInitiateAuthOutput,
        crate::error::AdminInitiateAuthError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_initiate_auth_error(response)
        } else {
            crate::operation_ser::parse_admin_initiate_auth_response(response)
        }
    }
}

/// <p>Links an existing user account in a user pool (<code>DestinationUser</code>) to an
/// identity from an external identity provider (<code>SourceUser</code>) based on a
/// specified attribute name and value from the external identity provider. This allows you
/// to create a link from the existing user account to an external federated user identity
/// that has not yet been used to sign in, so that the federated user identity can be used
/// to sign in as the existing user account. </p>
/// <p> For example, if there is an existing user with a username and password, this API
/// links that user to a federated user identity, so that when the federated user identity
/// is used, the user signs in as the existing user account. </p>
/// <note>
/// <p>The maximum number of federated identities linked to a user is 5.</p>
/// </note>
/// <important>
/// <p>Because this API allows a user with an external federated identity to sign in as
/// an existing user in the user pool, it is critical that it only be used with external
/// identity providers and provider attributes that have been trusted by the application
/// owner.</p>
/// </important>
/// <p>This action is enabled only for admin access and requires developer
/// credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminLinkProviderForUser {
    _private: (),
}
impl AdminLinkProviderForUser {
    /// Creates a new builder-style object to manufacture [`AdminLinkProviderForUserInput`](crate::input::AdminLinkProviderForUserInput)
    pub fn builder() -> crate::input::admin_link_provider_for_user_input::Builder {
        crate::input::admin_link_provider_for_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminLinkProviderForUser {
    type Output = std::result::Result<
        crate::output::AdminLinkProviderForUserOutput,
        crate::error::AdminLinkProviderForUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_link_provider_for_user_error(response)
        } else {
            crate::operation_ser::parse_admin_link_provider_for_user_response(response)
        }
    }
}

/// <p>Lists devices, as an administrator.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminListDevices {
    _private: (),
}
impl AdminListDevices {
    /// Creates a new builder-style object to manufacture [`AdminListDevicesInput`](crate::input::AdminListDevicesInput)
    pub fn builder() -> crate::input::admin_list_devices_input::Builder {
        crate::input::admin_list_devices_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminListDevices {
    type Output = std::result::Result<
        crate::output::AdminListDevicesOutput,
        crate::error::AdminListDevicesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_list_devices_error(response)
        } else {
            crate::operation_ser::parse_admin_list_devices_response(response)
        }
    }
}

/// <p>Lists the groups that the user belongs to.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminListGroupsForUser {
    _private: (),
}
impl AdminListGroupsForUser {
    /// Creates a new builder-style object to manufacture [`AdminListGroupsForUserInput`](crate::input::AdminListGroupsForUserInput)
    pub fn builder() -> crate::input::admin_list_groups_for_user_input::Builder {
        crate::input::admin_list_groups_for_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminListGroupsForUser {
    type Output = std::result::Result<
        crate::output::AdminListGroupsForUserOutput,
        crate::error::AdminListGroupsForUserError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_list_groups_for_user_error(response)
        } else {
            crate::operation_ser::parse_admin_list_groups_for_user_response(response)
        }
    }
}

/// <p>Lists a history of user activity and any risks detected as part of Amazon Cognito
/// advanced security.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminListUserAuthEvents {
    _private: (),
}
impl AdminListUserAuthEvents {
    /// Creates a new builder-style object to manufacture [`AdminListUserAuthEventsInput`](crate::input::AdminListUserAuthEventsInput)
    pub fn builder() -> crate::input::admin_list_user_auth_events_input::Builder {
        crate::input::admin_list_user_auth_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminListUserAuthEvents {
    type Output = std::result::Result<
        crate::output::AdminListUserAuthEventsOutput,
        crate::error::AdminListUserAuthEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_list_user_auth_events_error(response)
        } else {
            crate::operation_ser::parse_admin_list_user_auth_events_response(response)
        }
    }
}

/// <p>Removes the specified user from the specified group.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminRemoveUserFromGroup {
    _private: (),
}
impl AdminRemoveUserFromGroup {
    /// Creates a new builder-style object to manufacture [`AdminRemoveUserFromGroupInput`](crate::input::AdminRemoveUserFromGroupInput)
    pub fn builder() -> crate::input::admin_remove_user_from_group_input::Builder {
        crate::input::admin_remove_user_from_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminRemoveUserFromGroup {
    type Output = std::result::Result<
        crate::output::AdminRemoveUserFromGroupOutput,
        crate::error::AdminRemoveUserFromGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_remove_user_from_group_error(response)
        } else {
            crate::operation_ser::parse_admin_remove_user_from_group_response(response)
        }
    }
}

/// <p>Resets the specified user's password in a user pool as an administrator. Works on any
/// user.</p>
/// <p>When a developer calls this API, the current password is invalidated, so it must be
/// changed. If a user tries to sign in after the API is called, the app will get a
/// PasswordResetRequiredException exception back and should direct the user down the flow
/// to reset the password, which is the same as the forgot password flow. In addition, if
/// the user pool has phone verification selected and a verified phone number exists for the
/// user, or if email verification is selected and a verified email exists for the user,
/// calling this API will also result in sending a message to the end user with the code to
/// change their password.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminResetUserPassword {
    _private: (),
}
impl AdminResetUserPassword {
    /// Creates a new builder-style object to manufacture [`AdminResetUserPasswordInput`](crate::input::AdminResetUserPasswordInput)
    pub fn builder() -> crate::input::admin_reset_user_password_input::Builder {
        crate::input::admin_reset_user_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminResetUserPassword {
    type Output = std::result::Result<
        crate::output::AdminResetUserPasswordOutput,
        crate::error::AdminResetUserPasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_reset_user_password_error(response)
        } else {
            crate::operation_ser::parse_admin_reset_user_password_response(response)
        }
    }
}

/// <p>Responds to an authentication challenge, as an administrator.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminRespondToAuthChallenge {
    _private: (),
}
impl AdminRespondToAuthChallenge {
    /// Creates a new builder-style object to manufacture [`AdminRespondToAuthChallengeInput`](crate::input::AdminRespondToAuthChallengeInput)
    pub fn builder() -> crate::input::admin_respond_to_auth_challenge_input::Builder {
        crate::input::admin_respond_to_auth_challenge_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminRespondToAuthChallenge {
    type Output = std::result::Result<
        crate::output::AdminRespondToAuthChallengeOutput,
        crate::error::AdminRespondToAuthChallengeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_respond_to_auth_challenge_error(response)
        } else {
            crate::operation_ser::parse_admin_respond_to_auth_challenge_response(response)
        }
    }
}

/// <p>Sets the user's multi-factor authentication (MFA) preference, including which MFA
/// options are enabled and if any are preferred. Only one factor can be set as preferred.
/// The preferred MFA factor will be used to authenticate a user if multiple factors are
/// enabled. If multiple options are enabled and no preference is set, a challenge to choose
/// an MFA option will be returned during sign in.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminSetUserMFAPreference {
    _private: (),
}
impl AdminSetUserMFAPreference {
    /// Creates a new builder-style object to manufacture [`AdminSetUserMfaPreferenceInput`](crate::input::AdminSetUserMfaPreferenceInput)
    pub fn builder() -> crate::input::admin_set_user_mfa_preference_input::Builder {
        crate::input::admin_set_user_mfa_preference_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminSetUserMFAPreference {
    type Output = std::result::Result<
        crate::output::AdminSetUserMfaPreferenceOutput,
        crate::error::AdminSetUserMFAPreferenceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_set_user_mfa_preference_error(response)
        } else {
            crate::operation_ser::parse_admin_set_user_mfa_preference_response(response)
        }
    }
}

/// <p>Sets the specified user's password in a user pool as an administrator. Works on any
/// user. </p>
/// <p>The password can be temporary or permanent. If it is temporary, the user status will
/// be placed into the <code>FORCE_CHANGE_PASSWORD</code> state. When the user next tries to
/// sign in, the InitiateAuth/AdminInitiateAuth response will contain the
/// <code>NEW_PASSWORD_REQUIRED</code> challenge. If the user does not sign in before it
/// expires, the user will not be able to sign in and their password will need to be reset
/// by an administrator. </p>
/// <p>Once the user has set a new password, or the password is permanent, the user status
/// will be set to <code>Confirmed</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminSetUserPassword {
    _private: (),
}
impl AdminSetUserPassword {
    /// Creates a new builder-style object to manufacture [`AdminSetUserPasswordInput`](crate::input::AdminSetUserPasswordInput)
    pub fn builder() -> crate::input::admin_set_user_password_input::Builder {
        crate::input::admin_set_user_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminSetUserPassword {
    type Output = std::result::Result<
        crate::output::AdminSetUserPasswordOutput,
        crate::error::AdminSetUserPasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_set_user_password_error(response)
        } else {
            crate::operation_ser::parse_admin_set_user_password_response(response)
        }
    }
}

/// <p>
/// <i>This action is no longer supported.</i> You can use it to configure
/// only SMS MFA. You can't use it to configure TOTP software token MFA. To configure either
/// type of MFA, use <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminSetUserMFAPreference.html">AdminSetUserMFAPreference</a> instead.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminSetUserSettings {
    _private: (),
}
impl AdminSetUserSettings {
    /// Creates a new builder-style object to manufacture [`AdminSetUserSettingsInput`](crate::input::AdminSetUserSettingsInput)
    pub fn builder() -> crate::input::admin_set_user_settings_input::Builder {
        crate::input::admin_set_user_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminSetUserSettings {
    type Output = std::result::Result<
        crate::output::AdminSetUserSettingsOutput,
        crate::error::AdminSetUserSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_set_user_settings_error(response)
        } else {
            crate::operation_ser::parse_admin_set_user_settings_response(response)
        }
    }
}

/// <p>Provides feedback for an authentication event as to whether it was from a valid user.
/// This feedback is used for improving the risk evaluation decision for the user pool as
/// part of Amazon Cognito advanced security.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminUpdateAuthEventFeedback {
    _private: (),
}
impl AdminUpdateAuthEventFeedback {
    /// Creates a new builder-style object to manufacture [`AdminUpdateAuthEventFeedbackInput`](crate::input::AdminUpdateAuthEventFeedbackInput)
    pub fn builder() -> crate::input::admin_update_auth_event_feedback_input::Builder {
        crate::input::admin_update_auth_event_feedback_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminUpdateAuthEventFeedback {
    type Output = std::result::Result<
        crate::output::AdminUpdateAuthEventFeedbackOutput,
        crate::error::AdminUpdateAuthEventFeedbackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_update_auth_event_feedback_error(response)
        } else {
            crate::operation_ser::parse_admin_update_auth_event_feedback_response(response)
        }
    }
}

/// <p>Updates the device status as an administrator.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminUpdateDeviceStatus {
    _private: (),
}
impl AdminUpdateDeviceStatus {
    /// Creates a new builder-style object to manufacture [`AdminUpdateDeviceStatusInput`](crate::input::AdminUpdateDeviceStatusInput)
    pub fn builder() -> crate::input::admin_update_device_status_input::Builder {
        crate::input::admin_update_device_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminUpdateDeviceStatus {
    type Output = std::result::Result<
        crate::output::AdminUpdateDeviceStatusOutput,
        crate::error::AdminUpdateDeviceStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_update_device_status_error(response)
        } else {
            crate::operation_ser::parse_admin_update_device_status_response(response)
        }
    }
}

/// <p>Updates the specified user's attributes, including developer attributes, as an
/// administrator. Works on any user.</p>
/// <p>For custom attributes, you must prepend the <code>custom:</code> prefix to the
/// attribute name.</p>
/// <p>In addition to updating user attributes, this API can also be used to mark phone and
/// email as verified.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminUpdateUserAttributes {
    _private: (),
}
impl AdminUpdateUserAttributes {
    /// Creates a new builder-style object to manufacture [`AdminUpdateUserAttributesInput`](crate::input::AdminUpdateUserAttributesInput)
    pub fn builder() -> crate::input::admin_update_user_attributes_input::Builder {
        crate::input::admin_update_user_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminUpdateUserAttributes {
    type Output = std::result::Result<
        crate::output::AdminUpdateUserAttributesOutput,
        crate::error::AdminUpdateUserAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_update_user_attributes_error(response)
        } else {
            crate::operation_ser::parse_admin_update_user_attributes_response(response)
        }
    }
}

/// <p>Signs out users from all devices, as an administrator. It also invalidates all refresh
/// tokens issued to a user. The user's current access and Id tokens remain valid until
/// their expiry. Access and Id tokens expire one hour after they are issued.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AdminUserGlobalSignOut {
    _private: (),
}
impl AdminUserGlobalSignOut {
    /// Creates a new builder-style object to manufacture [`AdminUserGlobalSignOutInput`](crate::input::AdminUserGlobalSignOutInput)
    pub fn builder() -> crate::input::admin_user_global_sign_out_input::Builder {
        crate::input::admin_user_global_sign_out_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AdminUserGlobalSignOut {
    type Output = std::result::Result<
        crate::output::AdminUserGlobalSignOutOutput,
        crate::error::AdminUserGlobalSignOutError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_admin_user_global_sign_out_error(response)
        } else {
            crate::operation_ser::parse_admin_user_global_sign_out_response(response)
        }
    }
}

/// <p>Returns a unique generated shared secret key code for the user account. The request
/// takes an access token or a session string, but not both.</p>
/// <note>
/// <p>Calling AssociateSoftwareToken immediately disassociates the existing software
/// token from the user account. If the user doesn't subsequently verify the software
/// token, their account is essentially set up to authenticate without MFA. If MFA
/// config is set to Optional at the user pool level, the user can then login without
/// MFA. However, if MFA is set to Required for the user pool, the user will be asked to
/// setup a new software token MFA during sign in.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateSoftwareToken {
    _private: (),
}
impl AssociateSoftwareToken {
    /// Creates a new builder-style object to manufacture [`AssociateSoftwareTokenInput`](crate::input::AssociateSoftwareTokenInput)
    pub fn builder() -> crate::input::associate_software_token_input::Builder {
        crate::input::associate_software_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateSoftwareToken {
    type Output = std::result::Result<
        crate::output::AssociateSoftwareTokenOutput,
        crate::error::AssociateSoftwareTokenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_associate_software_token_error(response)
        } else {
            crate::operation_ser::parse_associate_software_token_response(response)
        }
    }
}

/// <p>Changes the password for a specified user in a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ChangePassword {
    _private: (),
}
impl ChangePassword {
    /// Creates a new builder-style object to manufacture [`ChangePasswordInput`](crate::input::ChangePasswordInput)
    pub fn builder() -> crate::input::change_password_input::Builder {
        crate::input::change_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ChangePassword {
    type Output =
        std::result::Result<crate::output::ChangePasswordOutput, crate::error::ChangePasswordError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_change_password_error(response)
        } else {
            crate::operation_ser::parse_change_password_response(response)
        }
    }
}

/// <p>Confirms tracking of the device. This API call is the call that begins device
/// tracking.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ConfirmDevice {
    _private: (),
}
impl ConfirmDevice {
    /// Creates a new builder-style object to manufacture [`ConfirmDeviceInput`](crate::input::ConfirmDeviceInput)
    pub fn builder() -> crate::input::confirm_device_input::Builder {
        crate::input::confirm_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ConfirmDevice {
    type Output =
        std::result::Result<crate::output::ConfirmDeviceOutput, crate::error::ConfirmDeviceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_confirm_device_error(response)
        } else {
            crate::operation_ser::parse_confirm_device_response(response)
        }
    }
}

/// <p>Allows a user to enter a confirmation code to reset a forgotten password.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ConfirmForgotPassword {
    _private: (),
}
impl ConfirmForgotPassword {
    /// Creates a new builder-style object to manufacture [`ConfirmForgotPasswordInput`](crate::input::ConfirmForgotPasswordInput)
    pub fn builder() -> crate::input::confirm_forgot_password_input::Builder {
        crate::input::confirm_forgot_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ConfirmForgotPassword {
    type Output = std::result::Result<
        crate::output::ConfirmForgotPasswordOutput,
        crate::error::ConfirmForgotPasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_confirm_forgot_password_error(response)
        } else {
            crate::operation_ser::parse_confirm_forgot_password_response(response)
        }
    }
}

/// <p>Confirms registration of a user and handles the existing alias from a previous
/// user.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ConfirmSignUp {
    _private: (),
}
impl ConfirmSignUp {
    /// Creates a new builder-style object to manufacture [`ConfirmSignUpInput`](crate::input::ConfirmSignUpInput)
    pub fn builder() -> crate::input::confirm_sign_up_input::Builder {
        crate::input::confirm_sign_up_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ConfirmSignUp {
    type Output =
        std::result::Result<crate::output::ConfirmSignUpOutput, crate::error::ConfirmSignUpError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_confirm_sign_up_error(response)
        } else {
            crate::operation_ser::parse_confirm_sign_up_response(response)
        }
    }
}

/// <p>Creates a new group in the specified user pool.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateGroup {
    _private: (),
}
impl CreateGroup {
    /// Creates a new builder-style object to manufacture [`CreateGroupInput`](crate::input::CreateGroupInput)
    pub fn builder() -> crate::input::create_group_input::Builder {
        crate::input::create_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateGroup {
    type Output =
        std::result::Result<crate::output::CreateGroupOutput, crate::error::CreateGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_group_error(response)
        } else {
            crate::operation_ser::parse_create_group_response(response)
        }
    }
}

/// <p>Creates an identity provider for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIdentityProvider {
    _private: (),
}
impl CreateIdentityProvider {
    /// Creates a new builder-style object to manufacture [`CreateIdentityProviderInput`](crate::input::CreateIdentityProviderInput)
    pub fn builder() -> crate::input::create_identity_provider_input::Builder {
        crate::input::create_identity_provider_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIdentityProvider {
    type Output = std::result::Result<
        crate::output::CreateIdentityProviderOutput,
        crate::error::CreateIdentityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_identity_provider_error(response)
        } else {
            crate::operation_ser::parse_create_identity_provider_response(response)
        }
    }
}

/// <p>Creates a new OAuth2.0 resource server and defines custom scopes in it.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateResourceServer {
    _private: (),
}
impl CreateResourceServer {
    /// Creates a new builder-style object to manufacture [`CreateResourceServerInput`](crate::input::CreateResourceServerInput)
    pub fn builder() -> crate::input::create_resource_server_input::Builder {
        crate::input::create_resource_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateResourceServer {
    type Output = std::result::Result<
        crate::output::CreateResourceServerOutput,
        crate::error::CreateResourceServerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_resource_server_error(response)
        } else {
            crate::operation_ser::parse_create_resource_server_response(response)
        }
    }
}

/// <p>Creates the user import job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUserImportJob {
    _private: (),
}
impl CreateUserImportJob {
    /// Creates a new builder-style object to manufacture [`CreateUserImportJobInput`](crate::input::CreateUserImportJobInput)
    pub fn builder() -> crate::input::create_user_import_job_input::Builder {
        crate::input::create_user_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUserImportJob {
    type Output = std::result::Result<
        crate::output::CreateUserImportJobOutput,
        crate::error::CreateUserImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_user_import_job_error(response)
        } else {
            crate::operation_ser::parse_create_user_import_job_response(response)
        }
    }
}

/// <p>Creates a new Amazon Cognito user pool and sets the password policy for the
/// pool.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUserPool {
    _private: (),
}
impl CreateUserPool {
    /// Creates a new builder-style object to manufacture [`CreateUserPoolInput`](crate::input::CreateUserPoolInput)
    pub fn builder() -> crate::input::create_user_pool_input::Builder {
        crate::input::create_user_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUserPool {
    type Output =
        std::result::Result<crate::output::CreateUserPoolOutput, crate::error::CreateUserPoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_user_pool_error(response)
        } else {
            crate::operation_ser::parse_create_user_pool_response(response)
        }
    }
}

/// <p>Creates the user pool client.</p>
/// <p>When you create a new user pool client, token revocation is automatically enabled. For more information
/// about revoking tokens, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_RevokeToken.html">RevokeToken</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUserPoolClient {
    _private: (),
}
impl CreateUserPoolClient {
    /// Creates a new builder-style object to manufacture [`CreateUserPoolClientInput`](crate::input::CreateUserPoolClientInput)
    pub fn builder() -> crate::input::create_user_pool_client_input::Builder {
        crate::input::create_user_pool_client_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUserPoolClient {
    type Output = std::result::Result<
        crate::output::CreateUserPoolClientOutput,
        crate::error::CreateUserPoolClientError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_user_pool_client_error(response)
        } else {
            crate::operation_ser::parse_create_user_pool_client_response(response)
        }
    }
}

/// <p>Creates a new domain for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUserPoolDomain {
    _private: (),
}
impl CreateUserPoolDomain {
    /// Creates a new builder-style object to manufacture [`CreateUserPoolDomainInput`](crate::input::CreateUserPoolDomainInput)
    pub fn builder() -> crate::input::create_user_pool_domain_input::Builder {
        crate::input::create_user_pool_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUserPoolDomain {
    type Output = std::result::Result<
        crate::output::CreateUserPoolDomainOutput,
        crate::error::CreateUserPoolDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_user_pool_domain_error(response)
        } else {
            crate::operation_ser::parse_create_user_pool_domain_response(response)
        }
    }
}

/// <p>Deletes a group.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteGroup {
    _private: (),
}
impl DeleteGroup {
    /// Creates a new builder-style object to manufacture [`DeleteGroupInput`](crate::input::DeleteGroupInput)
    pub fn builder() -> crate::input::delete_group_input::Builder {
        crate::input::delete_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteGroup {
    type Output =
        std::result::Result<crate::output::DeleteGroupOutput, crate::error::DeleteGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_group_error(response)
        } else {
            crate::operation_ser::parse_delete_group_response(response)
        }
    }
}

/// <p>Deletes an identity provider for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIdentityProvider {
    _private: (),
}
impl DeleteIdentityProvider {
    /// Creates a new builder-style object to manufacture [`DeleteIdentityProviderInput`](crate::input::DeleteIdentityProviderInput)
    pub fn builder() -> crate::input::delete_identity_provider_input::Builder {
        crate::input::delete_identity_provider_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIdentityProvider {
    type Output = std::result::Result<
        crate::output::DeleteIdentityProviderOutput,
        crate::error::DeleteIdentityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_identity_provider_error(response)
        } else {
            crate::operation_ser::parse_delete_identity_provider_response(response)
        }
    }
}

/// <p>Deletes a resource server.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourceServer {
    _private: (),
}
impl DeleteResourceServer {
    /// Creates a new builder-style object to manufacture [`DeleteResourceServerInput`](crate::input::DeleteResourceServerInput)
    pub fn builder() -> crate::input::delete_resource_server_input::Builder {
        crate::input::delete_resource_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourceServer {
    type Output = std::result::Result<
        crate::output::DeleteResourceServerOutput,
        crate::error::DeleteResourceServerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_resource_server_error(response)
        } else {
            crate::operation_ser::parse_delete_resource_server_response(response)
        }
    }
}

/// <p>Allows a user to delete himself or herself.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUser {
    _private: (),
}
impl DeleteUser {
    /// Creates a new builder-style object to manufacture [`DeleteUserInput`](crate::input::DeleteUserInput)
    pub fn builder() -> crate::input::delete_user_input::Builder {
        crate::input::delete_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUser {
    type Output =
        std::result::Result<crate::output::DeleteUserOutput, crate::error::DeleteUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_user_error(response)
        } else {
            crate::operation_ser::parse_delete_user_response(response)
        }
    }
}

/// <p>Deletes the attributes for a user.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUserAttributes {
    _private: (),
}
impl DeleteUserAttributes {
    /// Creates a new builder-style object to manufacture [`DeleteUserAttributesInput`](crate::input::DeleteUserAttributesInput)
    pub fn builder() -> crate::input::delete_user_attributes_input::Builder {
        crate::input::delete_user_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUserAttributes {
    type Output = std::result::Result<
        crate::output::DeleteUserAttributesOutput,
        crate::error::DeleteUserAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_user_attributes_error(response)
        } else {
            crate::operation_ser::parse_delete_user_attributes_response(response)
        }
    }
}

/// <p>Deletes the specified Amazon Cognito user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUserPool {
    _private: (),
}
impl DeleteUserPool {
    /// Creates a new builder-style object to manufacture [`DeleteUserPoolInput`](crate::input::DeleteUserPoolInput)
    pub fn builder() -> crate::input::delete_user_pool_input::Builder {
        crate::input::delete_user_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUserPool {
    type Output =
        std::result::Result<crate::output::DeleteUserPoolOutput, crate::error::DeleteUserPoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_user_pool_error(response)
        } else {
            crate::operation_ser::parse_delete_user_pool_response(response)
        }
    }
}

/// <p>Allows the developer to delete the user pool client.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUserPoolClient {
    _private: (),
}
impl DeleteUserPoolClient {
    /// Creates a new builder-style object to manufacture [`DeleteUserPoolClientInput`](crate::input::DeleteUserPoolClientInput)
    pub fn builder() -> crate::input::delete_user_pool_client_input::Builder {
        crate::input::delete_user_pool_client_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUserPoolClient {
    type Output = std::result::Result<
        crate::output::DeleteUserPoolClientOutput,
        crate::error::DeleteUserPoolClientError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_user_pool_client_error(response)
        } else {
            crate::operation_ser::parse_delete_user_pool_client_response(response)
        }
    }
}

/// <p>Deletes a domain for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteUserPoolDomain {
    _private: (),
}
impl DeleteUserPoolDomain {
    /// Creates a new builder-style object to manufacture [`DeleteUserPoolDomainInput`](crate::input::DeleteUserPoolDomainInput)
    pub fn builder() -> crate::input::delete_user_pool_domain_input::Builder {
        crate::input::delete_user_pool_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteUserPoolDomain {
    type Output = std::result::Result<
        crate::output::DeleteUserPoolDomainOutput,
        crate::error::DeleteUserPoolDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_user_pool_domain_error(response)
        } else {
            crate::operation_ser::parse_delete_user_pool_domain_response(response)
        }
    }
}

/// <p>Gets information about a specific identity provider.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIdentityProvider {
    _private: (),
}
impl DescribeIdentityProvider {
    /// Creates a new builder-style object to manufacture [`DescribeIdentityProviderInput`](crate::input::DescribeIdentityProviderInput)
    pub fn builder() -> crate::input::describe_identity_provider_input::Builder {
        crate::input::describe_identity_provider_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIdentityProvider {
    type Output = std::result::Result<
        crate::output::DescribeIdentityProviderOutput,
        crate::error::DescribeIdentityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_identity_provider_error(response)
        } else {
            crate::operation_ser::parse_describe_identity_provider_response(response)
        }
    }
}

/// <p>Describes a resource server.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeResourceServer {
    _private: (),
}
impl DescribeResourceServer {
    /// Creates a new builder-style object to manufacture [`DescribeResourceServerInput`](crate::input::DescribeResourceServerInput)
    pub fn builder() -> crate::input::describe_resource_server_input::Builder {
        crate::input::describe_resource_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeResourceServer {
    type Output = std::result::Result<
        crate::output::DescribeResourceServerOutput,
        crate::error::DescribeResourceServerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_resource_server_error(response)
        } else {
            crate::operation_ser::parse_describe_resource_server_response(response)
        }
    }
}

/// <p>Describes the risk configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRiskConfiguration {
    _private: (),
}
impl DescribeRiskConfiguration {
    /// Creates a new builder-style object to manufacture [`DescribeRiskConfigurationInput`](crate::input::DescribeRiskConfigurationInput)
    pub fn builder() -> crate::input::describe_risk_configuration_input::Builder {
        crate::input::describe_risk_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRiskConfiguration {
    type Output = std::result::Result<
        crate::output::DescribeRiskConfigurationOutput,
        crate::error::DescribeRiskConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_risk_configuration_error(response)
        } else {
            crate::operation_ser::parse_describe_risk_configuration_response(response)
        }
    }
}

/// <p>Describes the user import job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUserImportJob {
    _private: (),
}
impl DescribeUserImportJob {
    /// Creates a new builder-style object to manufacture [`DescribeUserImportJobInput`](crate::input::DescribeUserImportJobInput)
    pub fn builder() -> crate::input::describe_user_import_job_input::Builder {
        crate::input::describe_user_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUserImportJob {
    type Output = std::result::Result<
        crate::output::DescribeUserImportJobOutput,
        crate::error::DescribeUserImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_user_import_job_error(response)
        } else {
            crate::operation_ser::parse_describe_user_import_job_response(response)
        }
    }
}

/// <p>Returns the configuration information and metadata of the specified user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUserPool {
    _private: (),
}
impl DescribeUserPool {
    /// Creates a new builder-style object to manufacture [`DescribeUserPoolInput`](crate::input::DescribeUserPoolInput)
    pub fn builder() -> crate::input::describe_user_pool_input::Builder {
        crate::input::describe_user_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUserPool {
    type Output = std::result::Result<
        crate::output::DescribeUserPoolOutput,
        crate::error::DescribeUserPoolError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_user_pool_error(response)
        } else {
            crate::operation_ser::parse_describe_user_pool_response(response)
        }
    }
}

/// <p>Client method for returning the configuration information and metadata of the
/// specified user pool app client.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUserPoolClient {
    _private: (),
}
impl DescribeUserPoolClient {
    /// Creates a new builder-style object to manufacture [`DescribeUserPoolClientInput`](crate::input::DescribeUserPoolClientInput)
    pub fn builder() -> crate::input::describe_user_pool_client_input::Builder {
        crate::input::describe_user_pool_client_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUserPoolClient {
    type Output = std::result::Result<
        crate::output::DescribeUserPoolClientOutput,
        crate::error::DescribeUserPoolClientError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_user_pool_client_error(response)
        } else {
            crate::operation_ser::parse_describe_user_pool_client_response(response)
        }
    }
}

/// <p>Gets information about a domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeUserPoolDomain {
    _private: (),
}
impl DescribeUserPoolDomain {
    /// Creates a new builder-style object to manufacture [`DescribeUserPoolDomainInput`](crate::input::DescribeUserPoolDomainInput)
    pub fn builder() -> crate::input::describe_user_pool_domain_input::Builder {
        crate::input::describe_user_pool_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeUserPoolDomain {
    type Output = std::result::Result<
        crate::output::DescribeUserPoolDomainOutput,
        crate::error::DescribeUserPoolDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_user_pool_domain_error(response)
        } else {
            crate::operation_ser::parse_describe_user_pool_domain_response(response)
        }
    }
}

/// <p>Forgets the specified device.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ForgetDevice {
    _private: (),
}
impl ForgetDevice {
    /// Creates a new builder-style object to manufacture [`ForgetDeviceInput`](crate::input::ForgetDeviceInput)
    pub fn builder() -> crate::input::forget_device_input::Builder {
        crate::input::forget_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ForgetDevice {
    type Output =
        std::result::Result<crate::output::ForgetDeviceOutput, crate::error::ForgetDeviceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_forget_device_error(response)
        } else {
            crate::operation_ser::parse_forget_device_response(response)
        }
    }
}

/// <p>Calling this API causes a message to be sent to the end user with a confirmation code
/// that is required to change the user's password. For the <code>Username</code> parameter,
/// you can use the username or user alias. The method used to send the confirmation code is
/// sent according to the specified AccountRecoverySetting. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/how-to-recover-a-user-account.html">Recovering
/// User Accounts</a> in the <i>Amazon Cognito Developer Guide</i>. If
/// neither a verified phone number nor a verified email exists, an
/// <code>InvalidParameterException</code> is thrown. To use the confirmation code for
/// resetting the password, call <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ConfirmForgotPassword.html">ConfirmForgotPassword</a>.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ForgotPassword {
    _private: (),
}
impl ForgotPassword {
    /// Creates a new builder-style object to manufacture [`ForgotPasswordInput`](crate::input::ForgotPasswordInput)
    pub fn builder() -> crate::input::forgot_password_input::Builder {
        crate::input::forgot_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ForgotPassword {
    type Output =
        std::result::Result<crate::output::ForgotPasswordOutput, crate::error::ForgotPasswordError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_forgot_password_error(response)
        } else {
            crate::operation_ser::parse_forgot_password_response(response)
        }
    }
}

/// <p>Gets the header information for the .csv file to be used as input for the user import
/// job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCSVHeader {
    _private: (),
}
impl GetCSVHeader {
    /// Creates a new builder-style object to manufacture [`GetCsvHeaderInput`](crate::input::GetCsvHeaderInput)
    pub fn builder() -> crate::input::get_csv_header_input::Builder {
        crate::input::get_csv_header_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCSVHeader {
    type Output =
        std::result::Result<crate::output::GetCsvHeaderOutput, crate::error::GetCSVHeaderError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_csv_header_error(response)
        } else {
            crate::operation_ser::parse_get_csv_header_response(response)
        }
    }
}

/// <p>Gets the device.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDevice {
    _private: (),
}
impl GetDevice {
    /// Creates a new builder-style object to manufacture [`GetDeviceInput`](crate::input::GetDeviceInput)
    pub fn builder() -> crate::input::get_device_input::Builder {
        crate::input::get_device_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDevice {
    type Output = std::result::Result<crate::output::GetDeviceOutput, crate::error::GetDeviceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_device_error(response)
        } else {
            crate::operation_ser::parse_get_device_response(response)
        }
    }
}

/// <p>Gets a group.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetGroup {
    _private: (),
}
impl GetGroup {
    /// Creates a new builder-style object to manufacture [`GetGroupInput`](crate::input::GetGroupInput)
    pub fn builder() -> crate::input::get_group_input::Builder {
        crate::input::get_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetGroup {
    type Output = std::result::Result<crate::output::GetGroupOutput, crate::error::GetGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_group_error(response)
        } else {
            crate::operation_ser::parse_get_group_response(response)
        }
    }
}

/// <p>Gets the specified identity provider.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetIdentityProviderByIdentifier {
    _private: (),
}
impl GetIdentityProviderByIdentifier {
    /// Creates a new builder-style object to manufacture [`GetIdentityProviderByIdentifierInput`](crate::input::GetIdentityProviderByIdentifierInput)
    pub fn builder() -> crate::input::get_identity_provider_by_identifier_input::Builder {
        crate::input::get_identity_provider_by_identifier_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetIdentityProviderByIdentifier {
    type Output = std::result::Result<
        crate::output::GetIdentityProviderByIdentifierOutput,
        crate::error::GetIdentityProviderByIdentifierError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_identity_provider_by_identifier_error(response)
        } else {
            crate::operation_ser::parse_get_identity_provider_by_identifier_response(response)
        }
    }
}

/// <p>This method takes a user pool ID, and returns the signing certificate.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSigningCertificate {
    _private: (),
}
impl GetSigningCertificate {
    /// Creates a new builder-style object to manufacture [`GetSigningCertificateInput`](crate::input::GetSigningCertificateInput)
    pub fn builder() -> crate::input::get_signing_certificate_input::Builder {
        crate::input::get_signing_certificate_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSigningCertificate {
    type Output = std::result::Result<
        crate::output::GetSigningCertificateOutput,
        crate::error::GetSigningCertificateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_signing_certificate_error(response)
        } else {
            crate::operation_ser::parse_get_signing_certificate_response(response)
        }
    }
}

/// <p>Gets the UI Customization information for a particular app client's app UI, if there
/// is something set. If nothing is set for the particular client, but there is an existing
/// pool level customization (app <code>clientId</code> will be <code>ALL</code>), then that
/// is returned. If nothing is present, then an empty shape is returned.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUICustomization {
    _private: (),
}
impl GetUICustomization {
    /// Creates a new builder-style object to manufacture [`GetUiCustomizationInput`](crate::input::GetUiCustomizationInput)
    pub fn builder() -> crate::input::get_ui_customization_input::Builder {
        crate::input::get_ui_customization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUICustomization {
    type Output = std::result::Result<
        crate::output::GetUiCustomizationOutput,
        crate::error::GetUICustomizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_ui_customization_error(response)
        } else {
            crate::operation_ser::parse_get_ui_customization_response(response)
        }
    }
}

/// <p>Gets the user attributes and metadata for a user.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUser {
    _private: (),
}
impl GetUser {
    /// Creates a new builder-style object to manufacture [`GetUserInput`](crate::input::GetUserInput)
    pub fn builder() -> crate::input::get_user_input::Builder {
        crate::input::get_user_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUser {
    type Output = std::result::Result<crate::output::GetUserOutput, crate::error::GetUserError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_user_error(response)
        } else {
            crate::operation_ser::parse_get_user_response(response)
        }
    }
}

/// <p>Gets the user attribute verification code for the specified attribute name.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUserAttributeVerificationCode {
    _private: (),
}
impl GetUserAttributeVerificationCode {
    /// Creates a new builder-style object to manufacture [`GetUserAttributeVerificationCodeInput`](crate::input::GetUserAttributeVerificationCodeInput)
    pub fn builder() -> crate::input::get_user_attribute_verification_code_input::Builder {
        crate::input::get_user_attribute_verification_code_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUserAttributeVerificationCode {
    type Output = std::result::Result<
        crate::output::GetUserAttributeVerificationCodeOutput,
        crate::error::GetUserAttributeVerificationCodeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_user_attribute_verification_code_error(response)
        } else {
            crate::operation_ser::parse_get_user_attribute_verification_code_response(response)
        }
    }
}

/// <p>Gets the user pool multi-factor authentication (MFA) configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetUserPoolMfaConfig {
    _private: (),
}
impl GetUserPoolMfaConfig {
    /// Creates a new builder-style object to manufacture [`GetUserPoolMfaConfigInput`](crate::input::GetUserPoolMfaConfigInput)
    pub fn builder() -> crate::input::get_user_pool_mfa_config_input::Builder {
        crate::input::get_user_pool_mfa_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetUserPoolMfaConfig {
    type Output = std::result::Result<
        crate::output::GetUserPoolMfaConfigOutput,
        crate::error::GetUserPoolMfaConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_user_pool_mfa_config_error(response)
        } else {
            crate::operation_ser::parse_get_user_pool_mfa_config_response(response)
        }
    }
}

/// <p>Signs out users from all devices. It also invalidates all refresh tokens issued to a
/// user. The user's current access and Id tokens remain valid until their expiry. Access
/// and Id tokens expire one hour after they are issued.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GlobalSignOut {
    _private: (),
}
impl GlobalSignOut {
    /// Creates a new builder-style object to manufacture [`GlobalSignOutInput`](crate::input::GlobalSignOutInput)
    pub fn builder() -> crate::input::global_sign_out_input::Builder {
        crate::input::global_sign_out_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GlobalSignOut {
    type Output =
        std::result::Result<crate::output::GlobalSignOutOutput, crate::error::GlobalSignOutError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_global_sign_out_error(response)
        } else {
            crate::operation_ser::parse_global_sign_out_response(response)
        }
    }
}

/// <p>Initiates the authentication flow.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct InitiateAuth {
    _private: (),
}
impl InitiateAuth {
    /// Creates a new builder-style object to manufacture [`InitiateAuthInput`](crate::input::InitiateAuthInput)
    pub fn builder() -> crate::input::initiate_auth_input::Builder {
        crate::input::initiate_auth_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for InitiateAuth {
    type Output =
        std::result::Result<crate::output::InitiateAuthOutput, crate::error::InitiateAuthError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_initiate_auth_error(response)
        } else {
            crate::operation_ser::parse_initiate_auth_response(response)
        }
    }
}

/// <p>Lists the devices.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDevices {
    _private: (),
}
impl ListDevices {
    /// Creates a new builder-style object to manufacture [`ListDevicesInput`](crate::input::ListDevicesInput)
    pub fn builder() -> crate::input::list_devices_input::Builder {
        crate::input::list_devices_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDevices {
    type Output =
        std::result::Result<crate::output::ListDevicesOutput, crate::error::ListDevicesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_devices_error(response)
        } else {
            crate::operation_ser::parse_list_devices_response(response)
        }
    }
}

/// <p>Lists the groups associated with a user pool.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGroups {
    _private: (),
}
impl ListGroups {
    /// Creates a new builder-style object to manufacture [`ListGroupsInput`](crate::input::ListGroupsInput)
    pub fn builder() -> crate::input::list_groups_input::Builder {
        crate::input::list_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGroups {
    type Output =
        std::result::Result<crate::output::ListGroupsOutput, crate::error::ListGroupsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_groups_error(response)
        } else {
            crate::operation_ser::parse_list_groups_response(response)
        }
    }
}

/// <p>Lists information about all identity providers for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListIdentityProviders {
    _private: (),
}
impl ListIdentityProviders {
    /// Creates a new builder-style object to manufacture [`ListIdentityProvidersInput`](crate::input::ListIdentityProvidersInput)
    pub fn builder() -> crate::input::list_identity_providers_input::Builder {
        crate::input::list_identity_providers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListIdentityProviders {
    type Output = std::result::Result<
        crate::output::ListIdentityProvidersOutput,
        crate::error::ListIdentityProvidersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_identity_providers_error(response)
        } else {
            crate::operation_ser::parse_list_identity_providers_response(response)
        }
    }
}

/// <p>Lists the resource servers for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListResourceServers {
    _private: (),
}
impl ListResourceServers {
    /// Creates a new builder-style object to manufacture [`ListResourceServersInput`](crate::input::ListResourceServersInput)
    pub fn builder() -> crate::input::list_resource_servers_input::Builder {
        crate::input::list_resource_servers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListResourceServers {
    type Output = std::result::Result<
        crate::output::ListResourceServersOutput,
        crate::error::ListResourceServersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_resource_servers_error(response)
        } else {
            crate::operation_ser::parse_list_resource_servers_response(response)
        }
    }
}

/// <p>Lists the tags that are assigned to an Amazon Cognito user pool.</p>
/// <p>A tag is a label that you can apply to user pools to categorize and manage them in
/// different ways, such as by purpose, owner, environment, or other criteria.</p>
/// <p>You can use this action up to 10 times per second, per account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_ser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Lists the user import jobs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUserImportJobs {
    _private: (),
}
impl ListUserImportJobs {
    /// Creates a new builder-style object to manufacture [`ListUserImportJobsInput`](crate::input::ListUserImportJobsInput)
    pub fn builder() -> crate::input::list_user_import_jobs_input::Builder {
        crate::input::list_user_import_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUserImportJobs {
    type Output = std::result::Result<
        crate::output::ListUserImportJobsOutput,
        crate::error::ListUserImportJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_user_import_jobs_error(response)
        } else {
            crate::operation_ser::parse_list_user_import_jobs_response(response)
        }
    }
}

/// <p>Lists the clients that have been created for the specified user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUserPoolClients {
    _private: (),
}
impl ListUserPoolClients {
    /// Creates a new builder-style object to manufacture [`ListUserPoolClientsInput`](crate::input::ListUserPoolClientsInput)
    pub fn builder() -> crate::input::list_user_pool_clients_input::Builder {
        crate::input::list_user_pool_clients_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUserPoolClients {
    type Output = std::result::Result<
        crate::output::ListUserPoolClientsOutput,
        crate::error::ListUserPoolClientsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_user_pool_clients_error(response)
        } else {
            crate::operation_ser::parse_list_user_pool_clients_response(response)
        }
    }
}

/// <p>Lists the user pools associated with an account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUserPools {
    _private: (),
}
impl ListUserPools {
    /// Creates a new builder-style object to manufacture [`ListUserPoolsInput`](crate::input::ListUserPoolsInput)
    pub fn builder() -> crate::input::list_user_pools_input::Builder {
        crate::input::list_user_pools_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUserPools {
    type Output =
        std::result::Result<crate::output::ListUserPoolsOutput, crate::error::ListUserPoolsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_user_pools_error(response)
        } else {
            crate::operation_ser::parse_list_user_pools_response(response)
        }
    }
}

/// <p>Lists the users in the Amazon Cognito user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUsers {
    _private: (),
}
impl ListUsers {
    /// Creates a new builder-style object to manufacture [`ListUsersInput`](crate::input::ListUsersInput)
    pub fn builder() -> crate::input::list_users_input::Builder {
        crate::input::list_users_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUsers {
    type Output = std::result::Result<crate::output::ListUsersOutput, crate::error::ListUsersError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_users_error(response)
        } else {
            crate::operation_ser::parse_list_users_response(response)
        }
    }
}

/// <p>Lists the users in the specified group.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListUsersInGroup {
    _private: (),
}
impl ListUsersInGroup {
    /// Creates a new builder-style object to manufacture [`ListUsersInGroupInput`](crate::input::ListUsersInGroupInput)
    pub fn builder() -> crate::input::list_users_in_group_input::Builder {
        crate::input::list_users_in_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListUsersInGroup {
    type Output = std::result::Result<
        crate::output::ListUsersInGroupOutput,
        crate::error::ListUsersInGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_users_in_group_error(response)
        } else {
            crate::operation_ser::parse_list_users_in_group_response(response)
        }
    }
}

/// <p>Resends the confirmation (for confirmation of registration) to a specific user in the
/// user pool.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResendConfirmationCode {
    _private: (),
}
impl ResendConfirmationCode {
    /// Creates a new builder-style object to manufacture [`ResendConfirmationCodeInput`](crate::input::ResendConfirmationCodeInput)
    pub fn builder() -> crate::input::resend_confirmation_code_input::Builder {
        crate::input::resend_confirmation_code_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResendConfirmationCode {
    type Output = std::result::Result<
        crate::output::ResendConfirmationCodeOutput,
        crate::error::ResendConfirmationCodeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_resend_confirmation_code_error(response)
        } else {
            crate::operation_ser::parse_resend_confirmation_code_response(response)
        }
    }
}

/// <p>Responds to the authentication challenge.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RespondToAuthChallenge {
    _private: (),
}
impl RespondToAuthChallenge {
    /// Creates a new builder-style object to manufacture [`RespondToAuthChallengeInput`](crate::input::RespondToAuthChallengeInput)
    pub fn builder() -> crate::input::respond_to_auth_challenge_input::Builder {
        crate::input::respond_to_auth_challenge_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RespondToAuthChallenge {
    type Output = std::result::Result<
        crate::output::RespondToAuthChallengeOutput,
        crate::error::RespondToAuthChallengeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_respond_to_auth_challenge_error(response)
        } else {
            crate::operation_ser::parse_respond_to_auth_challenge_response(response)
        }
    }
}

/// <p>Revokes all of the access tokens generated by the specified refresh token. After the token is revoked, you can not
/// use the revoked token to access Cognito authenticated APIs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RevokeToken {
    _private: (),
}
impl RevokeToken {
    /// Creates a new builder-style object to manufacture [`RevokeTokenInput`](crate::input::RevokeTokenInput)
    pub fn builder() -> crate::input::revoke_token_input::Builder {
        crate::input::revoke_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RevokeToken {
    type Output =
        std::result::Result<crate::output::RevokeTokenOutput, crate::error::RevokeTokenError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_revoke_token_error(response)
        } else {
            crate::operation_ser::parse_revoke_token_response(response)
        }
    }
}

/// <p>Configures actions on detected risks. To delete the risk configuration for
/// <code>UserPoolId</code> or <code>ClientId</code>, pass null values for all four
/// configuration types.</p>
/// <p>To enable Amazon Cognito advanced security features, update the user pool to include
/// the <code>UserPoolAddOns</code> key<code>AdvancedSecurityMode</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetRiskConfiguration {
    _private: (),
}
impl SetRiskConfiguration {
    /// Creates a new builder-style object to manufacture [`SetRiskConfigurationInput`](crate::input::SetRiskConfigurationInput)
    pub fn builder() -> crate::input::set_risk_configuration_input::Builder {
        crate::input::set_risk_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetRiskConfiguration {
    type Output = std::result::Result<
        crate::output::SetRiskConfigurationOutput,
        crate::error::SetRiskConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_risk_configuration_error(response)
        } else {
            crate::operation_ser::parse_set_risk_configuration_response(response)
        }
    }
}

/// <p>Sets the UI customization information for a user pool's built-in app UI.</p>
/// <p>You can specify app UI customization settings for a single client (with a specific
/// <code>clientId</code>) or for all clients (by setting the <code>clientId</code> to
/// <code>ALL</code>). If you specify <code>ALL</code>, the default configuration will
/// be used for every client that has no UI customization set previously. If you specify UI
/// customization settings for a particular client, it will no longer fall back to the
/// <code>ALL</code> configuration. </p>
/// <note>
/// <p>To use this API, your user pool must have a domain associated with it. Otherwise,
/// there is no place to host the app's pages, and the service will throw an
/// error.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetUICustomization {
    _private: (),
}
impl SetUICustomization {
    /// Creates a new builder-style object to manufacture [`SetUiCustomizationInput`](crate::input::SetUiCustomizationInput)
    pub fn builder() -> crate::input::set_ui_customization_input::Builder {
        crate::input::set_ui_customization_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetUICustomization {
    type Output = std::result::Result<
        crate::output::SetUiCustomizationOutput,
        crate::error::SetUICustomizationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_ui_customization_error(response)
        } else {
            crate::operation_ser::parse_set_ui_customization_response(response)
        }
    }
}

/// <p>Set the user's multi-factor authentication (MFA) method preference, including which
/// MFA factors are enabled and if any are preferred. Only one factor can be set as
/// preferred. The preferred MFA factor will be used to authenticate a user if multiple
/// factors are enabled. If multiple options are enabled and no preference is set, a
/// challenge to choose an MFA option will be returned during sign in. If an MFA type is
/// enabled for a user, the user will be prompted for MFA during all sign in attempts,
/// unless device tracking is turned on and the device has been trusted. If you would like
/// MFA to be applied selectively based on the assessed risk level of sign in attempts,
/// disable MFA for users and turn on Adaptive Authentication for the user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetUserMFAPreference {
    _private: (),
}
impl SetUserMFAPreference {
    /// Creates a new builder-style object to manufacture [`SetUserMfaPreferenceInput`](crate::input::SetUserMfaPreferenceInput)
    pub fn builder() -> crate::input::set_user_mfa_preference_input::Builder {
        crate::input::set_user_mfa_preference_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetUserMFAPreference {
    type Output = std::result::Result<
        crate::output::SetUserMfaPreferenceOutput,
        crate::error::SetUserMFAPreferenceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_user_mfa_preference_error(response)
        } else {
            crate::operation_ser::parse_set_user_mfa_preference_response(response)
        }
    }
}

/// <p>Set the user pool multi-factor authentication (MFA) configuration.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetUserPoolMfaConfig {
    _private: (),
}
impl SetUserPoolMfaConfig {
    /// Creates a new builder-style object to manufacture [`SetUserPoolMfaConfigInput`](crate::input::SetUserPoolMfaConfigInput)
    pub fn builder() -> crate::input::set_user_pool_mfa_config_input::Builder {
        crate::input::set_user_pool_mfa_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetUserPoolMfaConfig {
    type Output = std::result::Result<
        crate::output::SetUserPoolMfaConfigOutput,
        crate::error::SetUserPoolMfaConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_user_pool_mfa_config_error(response)
        } else {
            crate::operation_ser::parse_set_user_pool_mfa_config_response(response)
        }
    }
}

/// <p>
/// <i>This action is no longer supported.</i> You can use it to configure
/// only SMS MFA. You can't use it to configure TOTP software token MFA. To configure either
/// type of MFA, use <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_SetUserMFAPreference.html">SetUserMFAPreference</a> instead.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetUserSettings {
    _private: (),
}
impl SetUserSettings {
    /// Creates a new builder-style object to manufacture [`SetUserSettingsInput`](crate::input::SetUserSettingsInput)
    pub fn builder() -> crate::input::set_user_settings_input::Builder {
        crate::input::set_user_settings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetUserSettings {
    type Output = std::result::Result<
        crate::output::SetUserSettingsOutput,
        crate::error::SetUserSettingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_set_user_settings_error(response)
        } else {
            crate::operation_ser::parse_set_user_settings_response(response)
        }
    }
}

/// <p>Registers the user in the specified user pool and creates a user name, password, and
/// user attributes.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SignUp {
    _private: (),
}
impl SignUp {
    /// Creates a new builder-style object to manufacture [`SignUpInput`](crate::input::SignUpInput)
    pub fn builder() -> crate::input::sign_up_input::Builder {
        crate::input::sign_up_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SignUp {
    type Output = std::result::Result<crate::output::SignUpOutput, crate::error::SignUpError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_sign_up_error(response)
        } else {
            crate::operation_ser::parse_sign_up_response(response)
        }
    }
}

/// <p>Starts the user import.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartUserImportJob {
    _private: (),
}
impl StartUserImportJob {
    /// Creates a new builder-style object to manufacture [`StartUserImportJobInput`](crate::input::StartUserImportJobInput)
    pub fn builder() -> crate::input::start_user_import_job_input::Builder {
        crate::input::start_user_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartUserImportJob {
    type Output = std::result::Result<
        crate::output::StartUserImportJobOutput,
        crate::error::StartUserImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_start_user_import_job_error(response)
        } else {
            crate::operation_ser::parse_start_user_import_job_response(response)
        }
    }
}

/// <p>Stops the user import job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopUserImportJob {
    _private: (),
}
impl StopUserImportJob {
    /// Creates a new builder-style object to manufacture [`StopUserImportJobInput`](crate::input::StopUserImportJobInput)
    pub fn builder() -> crate::input::stop_user_import_job_input::Builder {
        crate::input::stop_user_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopUserImportJob {
    type Output = std::result::Result<
        crate::output::StopUserImportJobOutput,
        crate::error::StopUserImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_stop_user_import_job_error(response)
        } else {
            crate::operation_ser::parse_stop_user_import_job_response(response)
        }
    }
}

/// <p>Assigns a set of tags to an Amazon Cognito user pool. A tag is a label that you can
/// use to categorize and manage user pools in different ways, such as by purpose, owner,
/// environment, or other criteria.</p>
/// <p>Each tag consists of a key and value, both of which you define. A key is a general
/// category for more specific values. For example, if you have two versions of a user pool,
/// one for testing and another for production, you might assign an <code>Environment</code>
/// tag key to both user pools. The value of this key might be <code>Test</code> for one
/// user pool and <code>Production</code> for the other.</p>
/// <p>Tags are useful for cost tracking and access control. You can activate your tags so
/// that they appear on the Billing and Cost Management console, where you can track the
/// costs associated with your user pools. In an IAM policy, you can constrain permissions
/// for user pools based on specific tags or tag values.</p>
/// <p>You can use this action up to 5 times per second, per account. A user pool can have as
/// many as 50 tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_tag_resource_error(response)
        } else {
            crate::operation_ser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes the specified tags from an Amazon Cognito user pool. You can use this action
/// up to 5 times per second, per account</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_untag_resource_error(response)
        } else {
            crate::operation_ser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Provides the feedback for an authentication event whether it was from a valid user or
/// not. This feedback is used for improving the risk evaluation decision for the user pool
/// as part of Amazon Cognito advanced security.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAuthEventFeedback {
    _private: (),
}
impl UpdateAuthEventFeedback {
    /// Creates a new builder-style object to manufacture [`UpdateAuthEventFeedbackInput`](crate::input::UpdateAuthEventFeedbackInput)
    pub fn builder() -> crate::input::update_auth_event_feedback_input::Builder {
        crate::input::update_auth_event_feedback_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAuthEventFeedback {
    type Output = std::result::Result<
        crate::output::UpdateAuthEventFeedbackOutput,
        crate::error::UpdateAuthEventFeedbackError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_auth_event_feedback_error(response)
        } else {
            crate::operation_ser::parse_update_auth_event_feedback_response(response)
        }
    }
}

/// <p>Updates the device status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDeviceStatus {
    _private: (),
}
impl UpdateDeviceStatus {
    /// Creates a new builder-style object to manufacture [`UpdateDeviceStatusInput`](crate::input::UpdateDeviceStatusInput)
    pub fn builder() -> crate::input::update_device_status_input::Builder {
        crate::input::update_device_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDeviceStatus {
    type Output = std::result::Result<
        crate::output::UpdateDeviceStatusOutput,
        crate::error::UpdateDeviceStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_device_status_error(response)
        } else {
            crate::operation_ser::parse_update_device_status_response(response)
        }
    }
}

/// <p>Updates the specified group with the specified attributes.</p>
/// <p>Calling this action requires developer credentials.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateGroup {
    _private: (),
}
impl UpdateGroup {
    /// Creates a new builder-style object to manufacture [`UpdateGroupInput`](crate::input::UpdateGroupInput)
    pub fn builder() -> crate::input::update_group_input::Builder {
        crate::input::update_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateGroup {
    type Output =
        std::result::Result<crate::output::UpdateGroupOutput, crate::error::UpdateGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_group_error(response)
        } else {
            crate::operation_ser::parse_update_group_response(response)
        }
    }
}

/// <p>Updates identity provider information for a user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateIdentityProvider {
    _private: (),
}
impl UpdateIdentityProvider {
    /// Creates a new builder-style object to manufacture [`UpdateIdentityProviderInput`](crate::input::UpdateIdentityProviderInput)
    pub fn builder() -> crate::input::update_identity_provider_input::Builder {
        crate::input::update_identity_provider_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateIdentityProvider {
    type Output = std::result::Result<
        crate::output::UpdateIdentityProviderOutput,
        crate::error::UpdateIdentityProviderError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_identity_provider_error(response)
        } else {
            crate::operation_ser::parse_update_identity_provider_response(response)
        }
    }
}

/// <p>Updates the name and scopes of resource server. All other fields are read-only.</p>
/// <important>
/// <p>If you don't provide a value for an attribute, it will be set to the default
/// value.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateResourceServer {
    _private: (),
}
impl UpdateResourceServer {
    /// Creates a new builder-style object to manufacture [`UpdateResourceServerInput`](crate::input::UpdateResourceServerInput)
    pub fn builder() -> crate::input::update_resource_server_input::Builder {
        crate::input::update_resource_server_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateResourceServer {
    type Output = std::result::Result<
        crate::output::UpdateResourceServerOutput,
        crate::error::UpdateResourceServerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_resource_server_error(response)
        } else {
            crate::operation_ser::parse_update_resource_server_response(response)
        }
    }
}

/// <p>Allows a user to update a specific attribute (one at a time).</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUserAttributes {
    _private: (),
}
impl UpdateUserAttributes {
    /// Creates a new builder-style object to manufacture [`UpdateUserAttributesInput`](crate::input::UpdateUserAttributesInput)
    pub fn builder() -> crate::input::update_user_attributes_input::Builder {
        crate::input::update_user_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUserAttributes {
    type Output = std::result::Result<
        crate::output::UpdateUserAttributesOutput,
        crate::error::UpdateUserAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_user_attributes_error(response)
        } else {
            crate::operation_ser::parse_update_user_attributes_response(response)
        }
    }
}

/// <p>Updates the specified user pool with the specified attributes. You can get a list of
/// the current user pool settings using <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_DescribeUserPool.html">DescribeUserPool</a>. If you don't provide a value for an attribute, it will be set to the default
/// value.</p>
/// <note>
/// <p>This action might generate an SMS text message. Starting June 1, 2021, U.S.
/// telecom carriers require that you register an origination phone number before you can
/// send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
/// you must register a phone number with <a href="https://console.aws.amazon.com/pinpoint/home/">Amazon Pinpoint</a>.
/// Cognito  will use the the registered number automatically. Otherwise, Cognito users that must
/// receive SMS messages might be unable to sign up, activate their accounts, or sign
/// in.</p>
/// <p>If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon SNS might place your account in SMS sandbox. In <i>
/// <a href="https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html">sandbox
/// mode</a>
/// </i>, you’ll have limitations, such as sending messages
/// to only verified phone numbers. After testing in the sandbox environment, you can
/// move out of the SMS sandbox and into production. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-sms-userpool-settings.html"> SMS message settings for Cognito User Pools</a> in the <i>Amazon
/// Cognito Developer Guide</i>. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUserPool {
    _private: (),
}
impl UpdateUserPool {
    /// Creates a new builder-style object to manufacture [`UpdateUserPoolInput`](crate::input::UpdateUserPoolInput)
    pub fn builder() -> crate::input::update_user_pool_input::Builder {
        crate::input::update_user_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUserPool {
    type Output =
        std::result::Result<crate::output::UpdateUserPoolOutput, crate::error::UpdateUserPoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_user_pool_error(response)
        } else {
            crate::operation_ser::parse_update_user_pool_response(response)
        }
    }
}

/// <p>Updates the specified user pool app client with the specified attributes. You can get
/// a list of the current user pool app client settings using <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_DescribeUserPoolClient.html">DescribeUserPoolClient</a>.</p>
/// <important>
/// <p>If you don't provide a value for an attribute, it will be set to the default
/// value.</p>
/// </important>
/// <p>You can also use this operation to enable token revocation for user pool clients. For more information
/// about revoking tokens, see <a href="https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_RevokeToken.html">RevokeToken</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUserPoolClient {
    _private: (),
}
impl UpdateUserPoolClient {
    /// Creates a new builder-style object to manufacture [`UpdateUserPoolClientInput`](crate::input::UpdateUserPoolClientInput)
    pub fn builder() -> crate::input::update_user_pool_client_input::Builder {
        crate::input::update_user_pool_client_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUserPoolClient {
    type Output = std::result::Result<
        crate::output::UpdateUserPoolClientOutput,
        crate::error::UpdateUserPoolClientError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_user_pool_client_error(response)
        } else {
            crate::operation_ser::parse_update_user_pool_client_response(response)
        }
    }
}

/// <p>Updates the Secure Sockets Layer (SSL) certificate for the custom domain for your user
/// pool.</p>
/// <p>You can use this operation to provide the Amazon Resource Name (ARN) of a new
/// certificate to Amazon Cognito. You cannot use it to change the domain for a user
/// pool.</p>
/// <p>A custom domain is used to host the Amazon Cognito hosted UI, which provides sign-up
/// and sign-in pages for your application. When you set up a custom domain, you provide a
/// certificate that you manage with Certificate Manager (ACM). When necessary, you can
/// use this operation to change the certificate that you applied to your custom
/// domain.</p>
/// <p>Usually, this is unnecessary following routine certificate renewal with ACM. When you
/// renew your existing certificate in ACM, the ARN for your certificate remains the same,
/// and your custom domain uses the new certificate automatically.</p>
/// <p>However, if you replace your existing certificate with a new one, ACM gives the new
/// certificate a new ARN. To apply the new certificate to your custom domain, you must
/// provide this ARN to Amazon Cognito.</p>
/// <p>When you add your new certificate in ACM, you must choose US East (N. Virginia) as the
/// Region.</p>
/// <p>After you submit your request, Amazon Cognito requires up to 1 hour to distribute your
/// new certificate to your custom domain.</p>
/// <p>For more information about adding a custom domain to your user pool, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-add-custom-domain.html">Using Your Own Domain for the Hosted UI</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateUserPoolDomain {
    _private: (),
}
impl UpdateUserPoolDomain {
    /// Creates a new builder-style object to manufacture [`UpdateUserPoolDomainInput`](crate::input::UpdateUserPoolDomainInput)
    pub fn builder() -> crate::input::update_user_pool_domain_input::Builder {
        crate::input::update_user_pool_domain_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateUserPoolDomain {
    type Output = std::result::Result<
        crate::output::UpdateUserPoolDomainOutput,
        crate::error::UpdateUserPoolDomainError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_user_pool_domain_error(response)
        } else {
            crate::operation_ser::parse_update_user_pool_domain_response(response)
        }
    }
}

/// <p>Use this API to register a user's entered TOTP code and mark the user's software token
/// MFA status as "verified" if successful. The request takes an access token or a session
/// string, but not both.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct VerifySoftwareToken {
    _private: (),
}
impl VerifySoftwareToken {
    /// Creates a new builder-style object to manufacture [`VerifySoftwareTokenInput`](crate::input::VerifySoftwareTokenInput)
    pub fn builder() -> crate::input::verify_software_token_input::Builder {
        crate::input::verify_software_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for VerifySoftwareToken {
    type Output = std::result::Result<
        crate::output::VerifySoftwareTokenOutput,
        crate::error::VerifySoftwareTokenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_verify_software_token_error(response)
        } else {
            crate::operation_ser::parse_verify_software_token_response(response)
        }
    }
}

/// <p>Verifies the specified user attributes in the user pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct VerifyUserAttribute {
    _private: (),
}
impl VerifyUserAttribute {
    /// Creates a new builder-style object to manufacture [`VerifyUserAttributeInput`](crate::input::VerifyUserAttributeInput)
    pub fn builder() -> crate::input::verify_user_attribute_input::Builder {
        crate::input::verify_user_attribute_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for VerifyUserAttribute {
    type Output = std::result::Result<
        crate::output::VerifyUserAttributeOutput,
        crate::error::VerifyUserAttributeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_verify_user_attribute_error(response)
        } else {
            crate::operation_ser::parse_verify_user_attribute_response(response)
        }
    }
}
