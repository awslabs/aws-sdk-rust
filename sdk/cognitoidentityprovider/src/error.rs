// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddCustomAttributesError {
    pub kind: AddCustomAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddCustomAttributesErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserImportInProgressException(crate::error::UserImportInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddCustomAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddCustomAttributesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AddCustomAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AddCustomAttributesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AddCustomAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AddCustomAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AddCustomAttributesErrorKind::UserImportInProgressException(_inner) => _inner.fmt(f),
            AddCustomAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddCustomAttributesError {
    fn code(&self) -> Option<&str> {
        AddCustomAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddCustomAttributesError {
    pub fn new(kind: AddCustomAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddCustomAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddCustomAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCustomAttributesErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCustomAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCustomAttributesErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCustomAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCustomAttributesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_import_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            AddCustomAttributesErrorKind::UserImportInProgressException(_)
        )
    }
}
impl std::error::Error for AddCustomAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddCustomAttributesErrorKind::InternalErrorException(_inner) => Some(_inner),
            AddCustomAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AddCustomAttributesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AddCustomAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AddCustomAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AddCustomAttributesErrorKind::UserImportInProgressException(_inner) => Some(_inner),
            AddCustomAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminAddUserToGroupError {
    pub kind: AdminAddUserToGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminAddUserToGroupErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminAddUserToGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminAddUserToGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminAddUserToGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminAddUserToGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminAddUserToGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminAddUserToGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminAddUserToGroupErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminAddUserToGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminAddUserToGroupError {
    fn code(&self) -> Option<&str> {
        AdminAddUserToGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminAddUserToGroupError {
    pub fn new(kind: AdminAddUserToGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminAddUserToGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminAddUserToGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminAddUserToGroupErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminAddUserToGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminAddUserToGroupErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminAddUserToGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminAddUserToGroupErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminAddUserToGroupErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminAddUserToGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminAddUserToGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminAddUserToGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminAddUserToGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminAddUserToGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminAddUserToGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminAddUserToGroupErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminAddUserToGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminConfirmSignUpError {
    pub kind: AdminConfirmSignUpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminConfirmSignUpErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyFailedAttemptsException(crate::error::TooManyFailedAttemptsException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminConfirmSignUpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminConfirmSignUpErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::TooManyFailedAttemptsException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminConfirmSignUpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminConfirmSignUpError {
    fn code(&self) -> Option<&str> {
        AdminConfirmSignUpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminConfirmSignUpError {
    pub fn new(kind: AdminConfirmSignUpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminConfirmSignUpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminConfirmSignUpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_failed_attempts_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::TooManyFailedAttemptsException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminConfirmSignUpErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminConfirmSignUpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminConfirmSignUpErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::LimitExceededException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::TooManyFailedAttemptsException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminConfirmSignUpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminCreateUserError {
    pub kind: AdminCreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminCreateUserErrorKind {
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UnsupportedUserStateException(crate::error::UnsupportedUserStateException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UsernameExistsException(crate::error::UsernameExistsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminCreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminCreateUserErrorKind::CodeDeliveryFailureException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            AdminCreateUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::UnsupportedUserStateException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::UsernameExistsException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminCreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminCreateUserError {
    fn code(&self) -> Option<&str> {
        AdminCreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminCreateUserError {
    pub fn new(kind: AdminCreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminCreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminCreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::CodeDeliveryFailureException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_unsupported_user_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::UnsupportedUserStateException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_username_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::UsernameExistsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminCreateUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminCreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminCreateUserErrorKind::CodeDeliveryFailureException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            AdminCreateUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::UnsupportedUserStateException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::UsernameExistsException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminCreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminDeleteUserError {
    pub kind: AdminDeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminDeleteUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminDeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminDeleteUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminDeleteUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminDeleteUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminDeleteUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminDeleteUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminDeleteUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminDeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminDeleteUserError {
    fn code(&self) -> Option<&str> {
        AdminDeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminDeleteUserError {
    pub fn new(kind: AdminDeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminDeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminDeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminDeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminDeleteUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminDeleteUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminDeleteUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminDeleteUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminDeleteUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminDeleteUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminDeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminDeleteUserAttributesError {
    pub kind: AdminDeleteUserAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminDeleteUserAttributesErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminDeleteUserAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminDeleteUserAttributesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminDeleteUserAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminDeleteUserAttributesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminDeleteUserAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminDeleteUserAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminDeleteUserAttributesErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminDeleteUserAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminDeleteUserAttributesError {
    fn code(&self) -> Option<&str> {
        AdminDeleteUserAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminDeleteUserAttributesError {
    pub fn new(kind: AdminDeleteUserAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminDeleteUserAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminDeleteUserAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserAttributesErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserAttributesErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserAttributesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDeleteUserAttributesErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminDeleteUserAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminDeleteUserAttributesErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminDeleteUserAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminDeleteUserAttributesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminDeleteUserAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminDeleteUserAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminDeleteUserAttributesErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminDeleteUserAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminDisableProviderForUserError {
    pub kind: AdminDisableProviderForUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminDisableProviderForUserErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminDisableProviderForUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminDisableProviderForUserErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            AdminDisableProviderForUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminDisableProviderForUserErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AdminDisableProviderForUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminDisableProviderForUserErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AdminDisableProviderForUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminDisableProviderForUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminDisableProviderForUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminDisableProviderForUserError {
    fn code(&self) -> Option<&str> {
        AdminDisableProviderForUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminDisableProviderForUserError {
    pub fn new(kind: AdminDisableProviderForUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminDisableProviderForUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminDisableProviderForUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::AliasExistsException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableProviderForUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminDisableProviderForUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminDisableProviderForUserErrorKind::AliasExistsException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminDisableProviderForUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminDisableUserError {
    pub kind: AdminDisableUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminDisableUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminDisableUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminDisableUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminDisableUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminDisableUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminDisableUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminDisableUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminDisableUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminDisableUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminDisableUserError {
    fn code(&self) -> Option<&str> {
        AdminDisableUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminDisableUserError {
    pub fn new(kind: AdminDisableUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminDisableUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminDisableUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminDisableUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminDisableUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminDisableUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminDisableUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminDisableUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminDisableUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminDisableUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminDisableUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminDisableUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminEnableUserError {
    pub kind: AdminEnableUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminEnableUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminEnableUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminEnableUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminEnableUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminEnableUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminEnableUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminEnableUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminEnableUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminEnableUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminEnableUserError {
    fn code(&self) -> Option<&str> {
        AdminEnableUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminEnableUserError {
    pub fn new(kind: AdminEnableUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminEnableUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminEnableUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminEnableUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminEnableUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminEnableUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminEnableUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminEnableUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminEnableUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminEnableUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminEnableUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminEnableUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminEnableUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminEnableUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminEnableUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminEnableUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminEnableUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminForgetDeviceError {
    pub kind: AdminForgetDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminForgetDeviceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminForgetDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminForgetDeviceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminForgetDeviceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminForgetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            AdminForgetDeviceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminForgetDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminForgetDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminForgetDeviceErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminForgetDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminForgetDeviceError {
    fn code(&self) -> Option<&str> {
        AdminForgetDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminForgetDeviceError {
    pub fn new(kind: AdminForgetDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminForgetDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminForgetDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminForgetDeviceErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminForgetDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminForgetDeviceErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminForgetDeviceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminForgetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            AdminForgetDeviceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminForgetDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminForgetDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminForgetDeviceErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminForgetDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminGetDeviceError {
    pub kind: AdminGetDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminGetDeviceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminGetDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminGetDeviceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminGetDeviceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminGetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => _inner.fmt(f),
            AdminGetDeviceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminGetDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminGetDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminGetDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminGetDeviceError {
    fn code(&self) -> Option<&str> {
        AdminGetDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminGetDeviceError {
    pub fn new(kind: AdminGetDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminGetDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminGetDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetDeviceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetDeviceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetDeviceErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetDeviceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetDeviceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for AdminGetDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminGetDeviceErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminGetDeviceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminGetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => Some(_inner),
            AdminGetDeviceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminGetDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminGetDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminGetDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminGetUserError {
    pub kind: AdminGetUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminGetUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminGetUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminGetUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminGetUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminGetUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminGetUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminGetUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminGetUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminGetUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminGetUserError {
    fn code(&self) -> Option<&str> {
        AdminGetUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminGetUserError {
    pub fn new(kind: AdminGetUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminGetUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminGetUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, AdminGetUserErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, AdminGetUserErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminGetUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, AdminGetUserErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for AdminGetUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminGetUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminGetUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminGetUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminGetUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminGetUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminGetUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminGetUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminInitiateAuthError {
    pub kind: AdminInitiateAuthErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminInitiateAuthErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    MfaMethodNotFoundException(crate::error::MfaMethodNotFoundException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminInitiateAuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminInitiateAuthErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            AdminInitiateAuthErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            AdminInitiateAuthErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            AdminInitiateAuthErrorKind::MfaMethodNotFoundException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminInitiateAuthErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminInitiateAuthError {
    fn code(&self) -> Option<&str> {
        AdminInitiateAuthError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminInitiateAuthError {
    pub fn new(kind: AdminInitiateAuthErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminInitiateAuthErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminInitiateAuthErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_mfa_method_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::MfaMethodNotFoundException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminInitiateAuthErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminInitiateAuthError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminInitiateAuthErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            AdminInitiateAuthErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            AdminInitiateAuthErrorKind::MfaMethodNotFoundException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminInitiateAuthErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminLinkProviderForUserError {
    pub kind: AdminLinkProviderForUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminLinkProviderForUserErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminLinkProviderForUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminLinkProviderForUserErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminLinkProviderForUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminLinkProviderForUserError {
    fn code(&self) -> Option<&str> {
        AdminLinkProviderForUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminLinkProviderForUserError {
    pub fn new(kind: AdminLinkProviderForUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminLinkProviderForUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminLinkProviderForUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::AliasExistsException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminLinkProviderForUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminLinkProviderForUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminLinkProviderForUserErrorKind::AliasExistsException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::LimitExceededException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminLinkProviderForUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminListDevicesError {
    pub kind: AdminListDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminListDevicesErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminListDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminListDevicesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminListDevicesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminListDevicesErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            AdminListDevicesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminListDevicesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminListDevicesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminListDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminListDevicesError {
    fn code(&self) -> Option<&str> {
        AdminListDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminListDevicesError {
    pub fn new(kind: AdminListDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminListDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminListDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListDevicesErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListDevicesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListDevicesErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListDevicesErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListDevicesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListDevicesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for AdminListDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminListDevicesErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminListDevicesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminListDevicesErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            AdminListDevicesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminListDevicesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminListDevicesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminListDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminListGroupsForUserError {
    pub kind: AdminListGroupsForUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminListGroupsForUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminListGroupsForUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminListGroupsForUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminListGroupsForUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminListGroupsForUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminListGroupsForUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminListGroupsForUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminListGroupsForUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminListGroupsForUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminListGroupsForUserError {
    fn code(&self) -> Option<&str> {
        AdminListGroupsForUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminListGroupsForUserError {
    pub fn new(kind: AdminListGroupsForUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminListGroupsForUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminListGroupsForUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListGroupsForUserErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListGroupsForUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListGroupsForUserErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListGroupsForUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListGroupsForUserErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListGroupsForUserErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminListGroupsForUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminListGroupsForUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminListGroupsForUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminListGroupsForUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminListGroupsForUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminListGroupsForUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminListGroupsForUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminListGroupsForUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminListUserAuthEventsError {
    pub kind: AdminListUserAuthEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminListUserAuthEventsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    UserPoolAddOnNotEnabledException(crate::error::UserPoolAddOnNotEnabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminListUserAuthEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminListUserAuthEventsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminListUserAuthEventsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminListUserAuthEventsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminListUserAuthEventsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminListUserAuthEventsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminListUserAuthEventsErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminListUserAuthEventsErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                _inner.fmt(f)
            }
            AdminListUserAuthEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminListUserAuthEventsError {
    fn code(&self) -> Option<&str> {
        AdminListUserAuthEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminListUserAuthEventsError {
    pub fn new(kind: AdminListUserAuthEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminListUserAuthEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminListUserAuthEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::UserNotFoundException(_)
        )
    }
    pub fn is_user_pool_add_on_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminListUserAuthEventsErrorKind::UserPoolAddOnNotEnabledException(_)
        )
    }
}
impl std::error::Error for AdminListUserAuthEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminListUserAuthEventsErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminListUserAuthEventsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminListUserAuthEventsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminListUserAuthEventsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminListUserAuthEventsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminListUserAuthEventsErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminListUserAuthEventsErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                Some(_inner)
            }
            AdminListUserAuthEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminRemoveUserFromGroupError {
    pub kind: AdminRemoveUserFromGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminRemoveUserFromGroupErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminRemoveUserFromGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminRemoveUserFromGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminRemoveUserFromGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminRemoveUserFromGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminRemoveUserFromGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminRemoveUserFromGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminRemoveUserFromGroupErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminRemoveUserFromGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminRemoveUserFromGroupError {
    fn code(&self) -> Option<&str> {
        AdminRemoveUserFromGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminRemoveUserFromGroupError {
    pub fn new(kind: AdminRemoveUserFromGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminRemoveUserFromGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminRemoveUserFromGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRemoveUserFromGroupErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRemoveUserFromGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRemoveUserFromGroupErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRemoveUserFromGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRemoveUserFromGroupErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRemoveUserFromGroupErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminRemoveUserFromGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminRemoveUserFromGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminRemoveUserFromGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminRemoveUserFromGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminRemoveUserFromGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminRemoveUserFromGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminRemoveUserFromGroupErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminRemoveUserFromGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminResetUserPasswordError {
    pub kind: AdminResetUserPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminResetUserPasswordErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminResetUserPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminResetUserPasswordErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            AdminResetUserPasswordErrorKind::InvalidLambdaResponseException(_inner) => {
                _inner.fmt(f)
            }
            AdminResetUserPasswordErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            AdminResetUserPasswordErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            AdminResetUserPasswordErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminResetUserPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminResetUserPasswordError {
    fn code(&self) -> Option<&str> {
        AdminResetUserPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminResetUserPasswordError {
    pub fn new(kind: AdminResetUserPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminResetUserPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminResetUserPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminResetUserPasswordErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminResetUserPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminResetUserPasswordErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            AdminResetUserPasswordErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            AdminResetUserPasswordErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            AdminResetUserPasswordErrorKind::LimitExceededException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminResetUserPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminRespondToAuthChallengeError {
    pub kind: AdminRespondToAuthChallengeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminRespondToAuthChallengeErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    CodeMismatchException(crate::error::CodeMismatchException),
    ExpiredCodeException(crate::error::ExpiredCodeException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    MfaMethodNotFoundException(crate::error::MfaMethodNotFoundException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SoftwareTokenMfaNotFoundException(crate::error::SoftwareTokenMfaNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminRespondToAuthChallengeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminRespondToAuthChallengeErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::ExpiredCodeException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::InvalidLambdaResponseException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::InvalidSmsRoleTrustRelationshipException(
                _inner,
            ) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::MfaMethodNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::PasswordResetRequiredException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::UnexpectedLambdaException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::UserLambdaValidationException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::UserNotConfirmedException(_inner) => {
                _inner.fmt(f)
            }
            AdminRespondToAuthChallengeErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminRespondToAuthChallengeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminRespondToAuthChallengeError {
    fn code(&self) -> Option<&str> {
        AdminRespondToAuthChallengeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminRespondToAuthChallengeError {
    pub fn new(kind: AdminRespondToAuthChallengeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminRespondToAuthChallengeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminRespondToAuthChallengeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::AliasExistsException(_)
        )
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::CodeMismatchException(_)
        )
    }
    pub fn is_expired_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::ExpiredCodeException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_mfa_method_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::MfaMethodNotFoundException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_software_token_mfa_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::SoftwareTokenMfaNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminRespondToAuthChallengeErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminRespondToAuthChallengeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminRespondToAuthChallengeErrorKind::AliasExistsException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::CodeMismatchException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::ExpiredCodeException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::InvalidLambdaResponseException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::InvalidSmsRoleTrustRelationshipException(
                _inner,
            ) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::MfaMethodNotFoundException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::PasswordResetRequiredException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::UserLambdaValidationException(_inner) => {
                Some(_inner)
            }
            AdminRespondToAuthChallengeErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminRespondToAuthChallengeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminSetUserMFAPreferenceError {
    pub kind: AdminSetUserMFAPreferenceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminSetUserMFAPreferenceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminSetUserMFAPreferenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminSetUserMFAPreferenceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminSetUserMFAPreferenceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminSetUserMFAPreferenceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminSetUserMFAPreferenceErrorKind::PasswordResetRequiredException(_inner) => {
                _inner.fmt(f)
            }
            AdminSetUserMFAPreferenceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminSetUserMFAPreferenceErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            AdminSetUserMFAPreferenceErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminSetUserMFAPreferenceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminSetUserMFAPreferenceError {
    fn code(&self) -> Option<&str> {
        AdminSetUserMFAPreferenceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminSetUserMFAPreferenceError {
    pub fn new(kind: AdminSetUserMFAPreferenceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminSetUserMFAPreferenceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminSetUserMFAPreferenceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserMFAPreferenceErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminSetUserMFAPreferenceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminSetUserMFAPreferenceErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminSetUserMFAPreferenceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminSetUserMFAPreferenceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminSetUserMFAPreferenceErrorKind::PasswordResetRequiredException(_inner) => {
                Some(_inner)
            }
            AdminSetUserMFAPreferenceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminSetUserMFAPreferenceErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            AdminSetUserMFAPreferenceErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminSetUserMFAPreferenceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminSetUserPasswordError {
    pub kind: AdminSetUserPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminSetUserPasswordErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminSetUserPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminSetUserPasswordErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminSetUserPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminSetUserPasswordError {
    fn code(&self) -> Option<&str> {
        AdminSetUserPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminSetUserPasswordError {
    pub fn new(kind: AdminSetUserPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminSetUserPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminSetUserPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserPasswordErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminSetUserPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminSetUserPasswordErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminSetUserPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminSetUserSettingsError {
    pub kind: AdminSetUserSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminSetUserSettingsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminSetUserSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminSetUserSettingsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminSetUserSettingsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminSetUserSettingsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminSetUserSettingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminSetUserSettingsErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminSetUserSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminSetUserSettingsError {
    fn code(&self) -> Option<&str> {
        AdminSetUserSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminSetUserSettingsError {
    pub fn new(kind: AdminSetUserSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminSetUserSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminSetUserSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserSettingsErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserSettingsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserSettingsErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserSettingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminSetUserSettingsErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminSetUserSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminSetUserSettingsErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminSetUserSettingsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminSetUserSettingsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminSetUserSettingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminSetUserSettingsErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminSetUserSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminUpdateAuthEventFeedbackError {
    pub kind: AdminUpdateAuthEventFeedbackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminUpdateAuthEventFeedbackErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    UserPoolAddOnNotEnabledException(crate::error::UserPoolAddOnNotEnabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminUpdateAuthEventFeedbackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminUpdateAuthEventFeedbackErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminUpdateAuthEventFeedbackErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateAuthEventFeedbackErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminUpdateAuthEventFeedbackErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateAuthEventFeedbackErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateAuthEventFeedbackErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminUpdateAuthEventFeedbackErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateAuthEventFeedbackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminUpdateAuthEventFeedbackError {
    fn code(&self) -> Option<&str> {
        AdminUpdateAuthEventFeedbackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminUpdateAuthEventFeedbackError {
    pub fn new(kind: AdminUpdateAuthEventFeedbackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminUpdateAuthEventFeedbackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminUpdateAuthEventFeedbackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::UserNotFoundException(_)
        )
    }
    pub fn is_user_pool_add_on_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateAuthEventFeedbackErrorKind::UserPoolAddOnNotEnabledException(_)
        )
    }
}
impl std::error::Error for AdminUpdateAuthEventFeedbackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminUpdateAuthEventFeedbackErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminUpdateAuthEventFeedbackErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            AdminUpdateAuthEventFeedbackErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminUpdateAuthEventFeedbackErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AdminUpdateAuthEventFeedbackErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminUpdateAuthEventFeedbackErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminUpdateAuthEventFeedbackErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                Some(_inner)
            }
            AdminUpdateAuthEventFeedbackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminUpdateDeviceStatusError {
    pub kind: AdminUpdateDeviceStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminUpdateDeviceStatusErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminUpdateDeviceStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminUpdateDeviceStatusErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminUpdateDeviceStatusErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminUpdateDeviceStatusErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateDeviceStatusErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminUpdateDeviceStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminUpdateDeviceStatusErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminUpdateDeviceStatusErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminUpdateDeviceStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminUpdateDeviceStatusError {
    fn code(&self) -> Option<&str> {
        AdminUpdateDeviceStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminUpdateDeviceStatusError {
    pub fn new(kind: AdminUpdateDeviceStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminUpdateDeviceStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminUpdateDeviceStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateDeviceStatusErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminUpdateDeviceStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminUpdateDeviceStatusErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminUpdateDeviceStatusErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminUpdateDeviceStatusErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            AdminUpdateDeviceStatusErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminUpdateDeviceStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminUpdateDeviceStatusErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminUpdateDeviceStatusErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminUpdateDeviceStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminUpdateUserAttributesError {
    pub kind: AdminUpdateUserAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminUpdateUserAttributesErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminUpdateUserAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminUpdateUserAttributesErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateUserAttributesErrorKind::InvalidLambdaResponseException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateUserAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateUserAttributesErrorKind::InvalidSmsRoleTrustRelationshipException(
                _inner,
            ) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::UserLambdaValidationException(_inner) => {
                _inner.fmt(f)
            }
            AdminUpdateUserAttributesErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminUpdateUserAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminUpdateUserAttributesError {
    fn code(&self) -> Option<&str> {
        AdminUpdateUserAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminUpdateUserAttributesError {
    pub fn new(kind: AdminUpdateUserAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminUpdateUserAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminUpdateUserAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::AliasExistsException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUpdateUserAttributesErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminUpdateUserAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminUpdateUserAttributesErrorKind::AliasExistsException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            AdminUpdateUserAttributesErrorKind::InvalidLambdaResponseException(_inner) => {
                Some(_inner)
            }
            AdminUpdateUserAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            AdminUpdateUserAttributesErrorKind::InvalidSmsRoleTrustRelationshipException(
                _inner,
            ) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::UserLambdaValidationException(_inner) => {
                Some(_inner)
            }
            AdminUpdateUserAttributesErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminUpdateUserAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AdminUserGlobalSignOutError {
    pub kind: AdminUserGlobalSignOutErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AdminUserGlobalSignOutErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AdminUserGlobalSignOutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AdminUserGlobalSignOutErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AdminUserGlobalSignOutErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AdminUserGlobalSignOutErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AdminUserGlobalSignOutErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AdminUserGlobalSignOutErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            AdminUserGlobalSignOutErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            AdminUserGlobalSignOutErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AdminUserGlobalSignOutError {
    fn code(&self) -> Option<&str> {
        AdminUserGlobalSignOutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AdminUserGlobalSignOutError {
    pub fn new(kind: AdminUserGlobalSignOutErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AdminUserGlobalSignOutErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AdminUserGlobalSignOutErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUserGlobalSignOutErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUserGlobalSignOutErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUserGlobalSignOutErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUserGlobalSignOutErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUserGlobalSignOutErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AdminUserGlobalSignOutErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for AdminUserGlobalSignOutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AdminUserGlobalSignOutErrorKind::InternalErrorException(_inner) => Some(_inner),
            AdminUserGlobalSignOutErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AdminUserGlobalSignOutErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AdminUserGlobalSignOutErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AdminUserGlobalSignOutErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            AdminUserGlobalSignOutErrorKind::UserNotFoundException(_inner) => Some(_inner),
            AdminUserGlobalSignOutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateSoftwareTokenError {
    pub kind: AssociateSoftwareTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateSoftwareTokenErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SoftwareTokenMfaNotFoundException(crate::error::SoftwareTokenMfaNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateSoftwareTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateSoftwareTokenErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSoftwareTokenErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            AssociateSoftwareTokenErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            AssociateSoftwareTokenErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            AssociateSoftwareTokenErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            AssociateSoftwareTokenErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateSoftwareTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateSoftwareTokenError {
    fn code(&self) -> Option<&str> {
        AssociateSoftwareTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateSoftwareTokenError {
    pub fn new(kind: AssociateSoftwareTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateSoftwareTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateSoftwareTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSoftwareTokenErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSoftwareTokenErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSoftwareTokenErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSoftwareTokenErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSoftwareTokenErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_software_token_mfa_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateSoftwareTokenErrorKind::SoftwareTokenMfaNotFoundException(_)
        )
    }
}
impl std::error::Error for AssociateSoftwareTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateSoftwareTokenErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            AssociateSoftwareTokenErrorKind::InternalErrorException(_inner) => Some(_inner),
            AssociateSoftwareTokenErrorKind::InvalidParameterException(_inner) => Some(_inner),
            AssociateSoftwareTokenErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            AssociateSoftwareTokenErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            AssociateSoftwareTokenErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateSoftwareTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ChangePasswordError {
    pub kind: ChangePasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ChangePasswordErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ChangePasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ChangePasswordErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ChangePasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ChangePasswordError {
    fn code(&self) -> Option<&str> {
        ChangePasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ChangePasswordError {
    pub fn new(kind: ChangePasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ChangePasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ChangePasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ChangePasswordErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for ChangePasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ChangePasswordErrorKind::InternalErrorException(_inner) => Some(_inner),
            ChangePasswordErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ChangePasswordErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            ChangePasswordErrorKind::LimitExceededException(_inner) => Some(_inner),
            ChangePasswordErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ChangePasswordErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            ChangePasswordErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ChangePasswordErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ChangePasswordErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            ChangePasswordErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ChangePasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmDeviceError {
    pub kind: ConfirmDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmDeviceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UsernameExistsException(crate::error::UsernameExistsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmDeviceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::UsernameExistsException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ConfirmDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmDeviceError {
    fn code(&self) -> Option<&str> {
        ConfirmDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmDeviceError {
    pub fn new(kind: ConfirmDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_username_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::UsernameExistsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmDeviceErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, ConfirmDeviceErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for ConfirmDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmDeviceErrorKind::InternalErrorException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::UsernameExistsException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ConfirmDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmForgotPasswordError {
    pub kind: ConfirmForgotPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmForgotPasswordErrorKind {
    CodeMismatchException(crate::error::CodeMismatchException),
    ExpiredCodeException(crate::error::ExpiredCodeException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyFailedAttemptsException(crate::error::TooManyFailedAttemptsException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmForgotPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmForgotPasswordErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::ExpiredCodeException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::TooManyFailedAttemptsException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ConfirmForgotPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmForgotPasswordError {
    fn code(&self) -> Option<&str> {
        ConfirmForgotPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmForgotPasswordError {
    pub fn new(kind: ConfirmForgotPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmForgotPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmForgotPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::CodeMismatchException(_)
        )
    }
    pub fn is_expired_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::ExpiredCodeException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_failed_attempts_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::TooManyFailedAttemptsException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmForgotPasswordErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for ConfirmForgotPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmForgotPasswordErrorKind::CodeMismatchException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::ExpiredCodeException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::InternalErrorException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::LimitExceededException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::TooManyFailedAttemptsException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ConfirmForgotPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmSignUpError {
    pub kind: ConfirmSignUpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmSignUpErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    CodeMismatchException(crate::error::CodeMismatchException),
    ExpiredCodeException(crate::error::ExpiredCodeException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyFailedAttemptsException(crate::error::TooManyFailedAttemptsException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmSignUpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmSignUpErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::ExpiredCodeException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::TooManyFailedAttemptsException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ConfirmSignUpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmSignUpError {
    fn code(&self) -> Option<&str> {
        ConfirmSignUpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmSignUpError {
    pub fn new(kind: ConfirmSignUpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmSignUpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmSignUpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(&self.kind, ConfirmSignUpErrorKind::AliasExistsException(_))
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(&self.kind, ConfirmSignUpErrorKind::CodeMismatchException(_))
    }
    pub fn is_expired_code_exception(&self) -> bool {
        matches!(&self.kind, ConfirmSignUpErrorKind::ExpiredCodeException(_))
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_failed_attempts_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::TooManyFailedAttemptsException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmSignUpErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, ConfirmSignUpErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for ConfirmSignUpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmSignUpErrorKind::AliasExistsException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::CodeMismatchException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::ExpiredCodeException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::InternalErrorException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::LimitExceededException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::TooManyFailedAttemptsException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ConfirmSignUpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGroupError {
    pub kind: CreateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGroupErrorKind {
    GroupExistsException(crate::error::GroupExistsException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGroupErrorKind::GroupExistsException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGroupError {
    fn code(&self) -> Option<&str> {
        CreateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGroupError {
    pub fn new(kind: CreateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_group_exists_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::GroupExistsException(_))
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::LimitExceededException(_))
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, CreateGroupErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGroupErrorKind::GroupExistsException(_inner) => Some(_inner),
            CreateGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateGroupErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateIdentityProviderError {
    pub kind: CreateIdentityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateIdentityProviderErrorKind {
    DuplicateProviderException(crate::error::DuplicateProviderException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateIdentityProviderErrorKind::DuplicateProviderException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateIdentityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateIdentityProviderError {
    fn code(&self) -> Option<&str> {
        CreateIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateIdentityProviderError {
    pub fn new(kind: CreateIdentityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateIdentityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateIdentityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_provider_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::DuplicateProviderException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateIdentityProviderErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateIdentityProviderErrorKind::DuplicateProviderException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateIdentityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateResourceServerError {
    pub kind: CreateResourceServerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateResourceServerErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateResourceServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateResourceServerErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateResourceServerErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateResourceServerErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateResourceServerErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateResourceServerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateResourceServerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateResourceServerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateResourceServerError {
    fn code(&self) -> Option<&str> {
        CreateResourceServerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateResourceServerError {
    pub fn new(kind: CreateResourceServerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateResourceServerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateResourceServerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceServerErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceServerErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceServerErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceServerErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceServerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateResourceServerErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateResourceServerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateResourceServerErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateResourceServerErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateResourceServerErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateResourceServerErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateResourceServerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateResourceServerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateResourceServerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserImportJobError {
    pub kind: CreateUserImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserImportJobErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserImportJobErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateUserImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserImportJobError {
    fn code(&self) -> Option<&str> {
        CreateUserImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserImportJobError {
    pub fn new(kind: CreateUserImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateUserImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserImportJobErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateUserImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserPoolError {
    pub kind: CreateUserPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserPoolErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserPoolTaggingException(crate::error::UserPoolTaggingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserPoolErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            CreateUserPoolErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::UserPoolTaggingException(_inner) => _inner.fmt(f),
            CreateUserPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserPoolError {
    fn code(&self) -> Option<&str> {
        CreateUserPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserPoolError {
    pub fn new(kind: CreateUserPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_pool_tagging_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolErrorKind::UserPoolTaggingException(_)
        )
    }
}
impl std::error::Error for CreateUserPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserPoolErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            CreateUserPoolErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::UserPoolTaggingException(_inner) => Some(_inner),
            CreateUserPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserPoolClientError {
    pub kind: CreateUserPoolClientErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserPoolClientErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidOAuthFlowException(crate::error::InvalidOAuthFlowException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ScopeDoesNotExistException(crate::error::ScopeDoesNotExistException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserPoolClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserPoolClientErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::InvalidOAuthFlowException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::ScopeDoesNotExistException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateUserPoolClientErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserPoolClientError {
    fn code(&self) -> Option<&str> {
        CreateUserPoolClientError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserPoolClientError {
    pub fn new(kind: CreateUserPoolClientErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserPoolClientErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserPoolClientErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_o_auth_flow_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::InvalidOAuthFlowException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_scope_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::ScopeDoesNotExistException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolClientErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateUserPoolClientError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserPoolClientErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::InvalidOAuthFlowException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::ScopeDoesNotExistException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateUserPoolClientErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserPoolDomainError {
    pub kind: CreateUserPoolDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserPoolDomainErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserPoolDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserPoolDomainErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            CreateUserPoolDomainErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            CreateUserPoolDomainErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateUserPoolDomainErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            CreateUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateUserPoolDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserPoolDomainError {
    fn code(&self) -> Option<&str> {
        CreateUserPoolDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserPoolDomainError {
    pub fn new(kind: CreateUserPoolDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserPoolDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserPoolDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolDomainErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolDomainErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolDomainErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolDomainErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserPoolDomainErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreateUserPoolDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserPoolDomainErrorKind::InternalErrorException(_inner) => Some(_inner),
            CreateUserPoolDomainErrorKind::InvalidParameterException(_inner) => Some(_inner),
            CreateUserPoolDomainErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateUserPoolDomainErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            CreateUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateUserPoolDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGroupError {
    pub kind: DeleteGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGroupErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGroupError {
    fn code(&self) -> Option<&str> {
        DeleteGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGroupError {
    pub fn new(kind: DeleteGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteGroupErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteIdentityProviderError {
    pub kind: DeleteIdentityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteIdentityProviderErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnsupportedIdentityProviderException(crate::error::UnsupportedIdentityProviderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteIdentityProviderErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteIdentityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteIdentityProviderErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteIdentityProviderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteIdentityProviderErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteIdentityProviderErrorKind::UnsupportedIdentityProviderException(_inner) => {
                _inner.fmt(f)
            }
            DeleteIdentityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteIdentityProviderError {
    fn code(&self) -> Option<&str> {
        DeleteIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteIdentityProviderError {
    pub fn new(kind: DeleteIdentityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteIdentityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteIdentityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIdentityProviderErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIdentityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIdentityProviderErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIdentityProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIdentityProviderErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unsupported_identity_provider_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteIdentityProviderErrorKind::UnsupportedIdentityProviderException(_)
        )
    }
}
impl std::error::Error for DeleteIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteIdentityProviderErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteIdentityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteIdentityProviderErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteIdentityProviderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteIdentityProviderErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteIdentityProviderErrorKind::UnsupportedIdentityProviderException(_inner) => {
                Some(_inner)
            }
            DeleteIdentityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourceServerError {
    pub kind: DeleteResourceServerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourceServerErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourceServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourceServerErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteResourceServerErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteResourceServerErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteResourceServerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteResourceServerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteResourceServerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourceServerError {
    fn code(&self) -> Option<&str> {
        DeleteResourceServerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourceServerError {
    pub fn new(kind: DeleteResourceServerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourceServerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourceServerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceServerErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceServerErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceServerErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceServerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourceServerErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteResourceServerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourceServerErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteResourceServerErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteResourceServerErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteResourceServerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteResourceServerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteResourceServerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::NotAuthorizedException(_))
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::TooManyRequestsException(_))
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteUserErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            DeleteUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUserErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            DeleteUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserAttributesError {
    pub kind: DeleteUserAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserAttributesErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserAttributesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserAttributesError {
    fn code(&self) -> Option<&str> {
        DeleteUserAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserAttributesError {
    pub fn new(kind: DeleteUserAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserAttributesErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteUserAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserAttributesErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::UserNotFoundException(_inner) => Some(_inner),
            DeleteUserAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPoolError {
    pub kind: DeleteUserPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPoolErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserImportInProgressException(crate::error::UserImportInProgressException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPoolErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteUserPoolErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserPoolErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteUserPoolErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUserPoolErrorKind::UserImportInProgressException(_inner) => _inner.fmt(f),
            DeleteUserPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPoolError {
    fn code(&self) -> Option<&str> {
        DeleteUserPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPoolError {
    pub fn new(kind: DeleteUserPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_import_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolErrorKind::UserImportInProgressException(_)
        )
    }
}
impl std::error::Error for DeleteUserPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPoolErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteUserPoolErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserPoolErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteUserPoolErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUserPoolErrorKind::UserImportInProgressException(_inner) => Some(_inner),
            DeleteUserPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPoolClientError {
    pub kind: DeleteUserPoolClientErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPoolClientErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPoolClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPoolClientErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteUserPoolClientErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserPoolClientErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteUserPoolClientErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserPoolClientErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUserPoolClientErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPoolClientError {
    fn code(&self) -> Option<&str> {
        DeleteUserPoolClientError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPoolClientError {
    pub fn new(kind: DeleteUserPoolClientErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPoolClientErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPoolClientErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolClientErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolClientErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolClientErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolClientErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolClientErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteUserPoolClientError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPoolClientErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteUserPoolClientErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserPoolClientErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteUserPoolClientErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserPoolClientErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUserPoolClientErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserPoolDomainError {
    pub kind: DeleteUserPoolDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserPoolDomainErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserPoolDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserPoolDomainErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DeleteUserPoolDomainErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DeleteUserPoolDomainErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DeleteUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteUserPoolDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserPoolDomainError {
    fn code(&self) -> Option<&str> {
        DeleteUserPoolDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserPoolDomainError {
    pub fn new(kind: DeleteUserPoolDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserPoolDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserPoolDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolDomainErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolDomainErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolDomainErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserPoolDomainErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteUserPoolDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserPoolDomainErrorKind::InternalErrorException(_inner) => Some(_inner),
            DeleteUserPoolDomainErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DeleteUserPoolDomainErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DeleteUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteUserPoolDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeIdentityProviderError {
    pub kind: DescribeIdentityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeIdentityProviderErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeIdentityProviderErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeIdentityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeIdentityProviderErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeIdentityProviderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeIdentityProviderErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeIdentityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeIdentityProviderError {
    fn code(&self) -> Option<&str> {
        DescribeIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeIdentityProviderError {
    pub fn new(kind: DescribeIdentityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeIdentityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeIdentityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeIdentityProviderErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeIdentityProviderErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeIdentityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeIdentityProviderErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeIdentityProviderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeIdentityProviderErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeIdentityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeResourceServerError {
    pub kind: DescribeResourceServerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeResourceServerErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeResourceServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeResourceServerErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeResourceServerErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeResourceServerErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeResourceServerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeResourceServerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeResourceServerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeResourceServerError {
    fn code(&self) -> Option<&str> {
        DescribeResourceServerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeResourceServerError {
    pub fn new(kind: DescribeResourceServerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeResourceServerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeResourceServerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceServerErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceServerErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceServerErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceServerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeResourceServerErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeResourceServerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeResourceServerErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeResourceServerErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeResourceServerErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeResourceServerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeResourceServerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeResourceServerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRiskConfigurationError {
    pub kind: DescribeRiskConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRiskConfigurationErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserPoolAddOnNotEnabledException(crate::error::UserPoolAddOnNotEnabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRiskConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRiskConfigurationErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeRiskConfigurationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeRiskConfigurationErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeRiskConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRiskConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeRiskConfigurationErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                _inner.fmt(f)
            }
            DescribeRiskConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRiskConfigurationError {
    fn code(&self) -> Option<&str> {
        DescribeRiskConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRiskConfigurationError {
    pub fn new(kind: DescribeRiskConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRiskConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRiskConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRiskConfigurationErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRiskConfigurationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRiskConfigurationErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRiskConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRiskConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_pool_add_on_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRiskConfigurationErrorKind::UserPoolAddOnNotEnabledException(_)
        )
    }
}
impl std::error::Error for DescribeRiskConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRiskConfigurationErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeRiskConfigurationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeRiskConfigurationErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeRiskConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRiskConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeRiskConfigurationErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                Some(_inner)
            }
            DescribeRiskConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserImportJobError {
    pub kind: DescribeUserImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserImportJobErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserImportJobErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeUserImportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeUserImportJobErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeUserImportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeUserImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserImportJobError {
    fn code(&self) -> Option<&str> {
        DescribeUserImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserImportJobError {
    pub fn new(kind: DescribeUserImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserImportJobErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserImportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserImportJobErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserImportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeUserImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserImportJobErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeUserImportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeUserImportJobErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeUserImportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeUserImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserPoolError {
    pub kind: DescribeUserPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserPoolErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserPoolTaggingException(crate::error::UserPoolTaggingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserPoolErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeUserPoolErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeUserPoolErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeUserPoolErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeUserPoolErrorKind::UserPoolTaggingException(_inner) => _inner.fmt(f),
            DescribeUserPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserPoolError {
    fn code(&self) -> Option<&str> {
        DescribeUserPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserPoolError {
    pub fn new(kind: DescribeUserPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_pool_tagging_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolErrorKind::UserPoolTaggingException(_)
        )
    }
}
impl std::error::Error for DescribeUserPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserPoolErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeUserPoolErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeUserPoolErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeUserPoolErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeUserPoolErrorKind::UserPoolTaggingException(_inner) => Some(_inner),
            DescribeUserPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserPoolClientError {
    pub kind: DescribeUserPoolClientErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserPoolClientErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserPoolClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserPoolClientErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeUserPoolClientErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeUserPoolClientErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeUserPoolClientErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserPoolClientErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DescribeUserPoolClientErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserPoolClientError {
    fn code(&self) -> Option<&str> {
        DescribeUserPoolClientError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserPoolClientError {
    pub fn new(kind: DescribeUserPoolClientErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserPoolClientErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserPoolClientErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolClientErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolClientErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolClientErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolClientErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolClientErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DescribeUserPoolClientError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserPoolClientErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeUserPoolClientErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeUserPoolClientErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeUserPoolClientErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserPoolClientErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DescribeUserPoolClientErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserPoolDomainError {
    pub kind: DescribeUserPoolDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserPoolDomainErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserPoolDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserPoolDomainErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            DescribeUserPoolDomainErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            DescribeUserPoolDomainErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            DescribeUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserPoolDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserPoolDomainError {
    fn code(&self) -> Option<&str> {
        DescribeUserPoolDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserPoolDomainError {
    pub fn new(kind: DescribeUserPoolDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserPoolDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserPoolDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolDomainErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolDomainErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolDomainErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserPoolDomainErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeUserPoolDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserPoolDomainErrorKind::InternalErrorException(_inner) => Some(_inner),
            DescribeUserPoolDomainErrorKind::InvalidParameterException(_inner) => Some(_inner),
            DescribeUserPoolDomainErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            DescribeUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeUserPoolDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ForgetDeviceError {
    pub kind: ForgetDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ForgetDeviceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ForgetDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ForgetDeviceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ForgetDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ForgetDeviceError {
    fn code(&self) -> Option<&str> {
        ForgetDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ForgetDeviceError {
    pub fn new(kind: ForgetDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ForgetDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ForgetDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, ForgetDeviceErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgetDeviceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgetDeviceErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, ForgetDeviceErrorKind::NotAuthorizedException(_))
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgetDeviceErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgetDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgetDeviceErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgetDeviceErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, ForgetDeviceErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for ForgetDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ForgetDeviceErrorKind::InternalErrorException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ForgetDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ForgotPasswordError {
    pub kind: ForgotPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ForgotPasswordErrorKind {
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ForgotPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ForgotPasswordErrorKind::CodeDeliveryFailureException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            ForgotPasswordErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ForgotPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ForgotPasswordError {
    fn code(&self) -> Option<&str> {
        ForgotPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ForgotPasswordError {
    pub fn new(kind: ForgotPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ForgotPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ForgotPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::CodeDeliveryFailureException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ForgotPasswordErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for ForgotPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ForgotPasswordErrorKind::CodeDeliveryFailureException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::InternalErrorException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            ForgotPasswordErrorKind::LimitExceededException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ForgotPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCSVHeaderError {
    pub kind: GetCSVHeaderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCSVHeaderErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCSVHeaderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCSVHeaderErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetCSVHeaderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetCSVHeaderErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GetCSVHeaderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetCSVHeaderErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCSVHeaderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCSVHeaderError {
    fn code(&self) -> Option<&str> {
        GetCSVHeaderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCSVHeaderError {
    pub fn new(kind: GetCSVHeaderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCSVHeaderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCSVHeaderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, GetCSVHeaderErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCSVHeaderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, GetCSVHeaderErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCSVHeaderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCSVHeaderErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCSVHeaderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCSVHeaderErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetCSVHeaderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetCSVHeaderErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GetCSVHeaderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetCSVHeaderErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCSVHeaderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeviceError {
    pub kind: GetDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeviceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeviceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            GetDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeviceError {
    fn code(&self) -> Option<&str> {
        GetDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeviceError {
    pub fn new(kind: GetDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::InvalidParameterException(_))
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::NotAuthorizedException(_))
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::TooManyRequestsException(_))
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::UserNotConfirmedException(_))
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDeviceErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for GetDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeviceErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetDeviceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetDeviceErrorKind::InvalidUserPoolConfigurationException(_inner) => Some(_inner),
            GetDeviceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GetDeviceErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            GetDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetDeviceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDeviceErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            GetDeviceErrorKind::UserNotFoundException(_inner) => Some(_inner),
            GetDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGroupError {
    pub kind: GetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGroupErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGroupError {
    fn code(&self) -> Option<&str> {
        GetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGroupError {
    pub fn new(kind: GetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::InvalidParameterException(_))
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetGroupErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GetGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetIdentityProviderByIdentifierError {
    pub kind: GetIdentityProviderByIdentifierErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetIdentityProviderByIdentifierErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetIdentityProviderByIdentifierError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetIdentityProviderByIdentifierErrorKind::InternalErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetIdentityProviderByIdentifierErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            GetIdentityProviderByIdentifierErrorKind::NotAuthorizedException(_inner) => {
                _inner.fmt(f)
            }
            GetIdentityProviderByIdentifierErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetIdentityProviderByIdentifierErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetIdentityProviderByIdentifierErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetIdentityProviderByIdentifierError {
    fn code(&self) -> Option<&str> {
        GetIdentityProviderByIdentifierError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetIdentityProviderByIdentifierError {
    pub fn new(kind: GetIdentityProviderByIdentifierErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetIdentityProviderByIdentifierErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetIdentityProviderByIdentifierErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIdentityProviderByIdentifierErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIdentityProviderByIdentifierErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIdentityProviderByIdentifierErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIdentityProviderByIdentifierErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetIdentityProviderByIdentifierErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetIdentityProviderByIdentifierError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetIdentityProviderByIdentifierErrorKind::InternalErrorException(_inner) => {
                Some(_inner)
            }
            GetIdentityProviderByIdentifierErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            GetIdentityProviderByIdentifierErrorKind::NotAuthorizedException(_inner) => {
                Some(_inner)
            }
            GetIdentityProviderByIdentifierErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetIdentityProviderByIdentifierErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetIdentityProviderByIdentifierErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSigningCertificateError {
    pub kind: GetSigningCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSigningCertificateErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSigningCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSigningCertificateErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetSigningCertificateErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetSigningCertificateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetSigningCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSigningCertificateError {
    fn code(&self) -> Option<&str> {
        GetSigningCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSigningCertificateError {
    pub fn new(kind: GetSigningCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSigningCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSigningCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSigningCertificateErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSigningCertificateErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSigningCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for GetSigningCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSigningCertificateErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetSigningCertificateErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetSigningCertificateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetSigningCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUICustomizationError {
    pub kind: GetUICustomizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUICustomizationErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUICustomizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUICustomizationErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetUICustomizationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetUICustomizationErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GetUICustomizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetUICustomizationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUICustomizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUICustomizationError {
    fn code(&self) -> Option<&str> {
        GetUICustomizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUICustomizationError {
    pub fn new(kind: GetUICustomizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUICustomizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUICustomizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUICustomizationErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUICustomizationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUICustomizationErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUICustomizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUICustomizationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetUICustomizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUICustomizationErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetUICustomizationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetUICustomizationErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GetUICustomizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetUICustomizationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUICustomizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserError {
    pub kind: GetUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetUserErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetUserErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GetUserErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            GetUserErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetUserErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUserErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            GetUserErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            GetUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserError {
    fn code(&self) -> Option<&str> {
        GetUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserError {
    pub fn new(kind: GetUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::InvalidParameterException(_))
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::NotAuthorizedException(_))
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::TooManyRequestsException(_))
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::UserNotConfirmedException(_))
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUserErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for GetUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetUserErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetUserErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GetUserErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            GetUserErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetUserErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUserErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            GetUserErrorKind::UserNotFoundException(_inner) => Some(_inner),
            GetUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserAttributeVerificationCodeError {
    pub kind: GetUserAttributeVerificationCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserAttributeVerificationCodeErrorKind {
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserAttributeVerificationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserAttributeVerificationCodeErrorKind::CodeDeliveryFailureException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::InternalErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::InvalidEmailRoleAccessPolicyException(
                _inner,
            ) => _inner.fmt(f),
            GetUserAttributeVerificationCodeErrorKind::InvalidLambdaResponseException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::InvalidParameterException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::InvalidSmsRoleAccessPolicyException(
                _inner,
            ) => _inner.fmt(f),
            GetUserAttributeVerificationCodeErrorKind::InvalidSmsRoleTrustRelationshipException(
                _inner,
            ) => _inner.fmt(f),
            GetUserAttributeVerificationCodeErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::NotAuthorizedException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::PasswordResetRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::UnexpectedLambdaException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::UserLambdaValidationException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::UserNotConfirmedException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::UserNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetUserAttributeVerificationCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserAttributeVerificationCodeError {
    fn code(&self) -> Option<&str> {
        GetUserAttributeVerificationCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserAttributeVerificationCodeError {
    pub fn new(kind: GetUserAttributeVerificationCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserAttributeVerificationCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserAttributeVerificationCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::CodeDeliveryFailureException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserAttributeVerificationCodeErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for GetUserAttributeVerificationCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserAttributeVerificationCodeErrorKind::CodeDeliveryFailureException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::InternalErrorException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::InvalidEmailRoleAccessPolicyException(
                _inner,
            ) => Some(_inner),
            GetUserAttributeVerificationCodeErrorKind::InvalidLambdaResponseException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::InvalidParameterException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::InvalidSmsRoleAccessPolicyException(
                _inner,
            ) => Some(_inner),
            GetUserAttributeVerificationCodeErrorKind::InvalidSmsRoleTrustRelationshipException(
                _inner,
            ) => Some(_inner),
            GetUserAttributeVerificationCodeErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::NotAuthorizedException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::PasswordResetRequiredException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::UnexpectedLambdaException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::UserLambdaValidationException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::UserNotConfirmedException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::UserNotFoundException(_inner) => {
                Some(_inner)
            }
            GetUserAttributeVerificationCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserPoolMfaConfigError {
    pub kind: GetUserPoolMfaConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserPoolMfaConfigErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserPoolMfaConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserPoolMfaConfigErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GetUserPoolMfaConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GetUserPoolMfaConfigErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GetUserPoolMfaConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetUserPoolMfaConfigErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUserPoolMfaConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserPoolMfaConfigError {
    fn code(&self) -> Option<&str> {
        GetUserPoolMfaConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserPoolMfaConfigError {
    pub fn new(kind: GetUserPoolMfaConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserPoolMfaConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserPoolMfaConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserPoolMfaConfigErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserPoolMfaConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserPoolMfaConfigErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserPoolMfaConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserPoolMfaConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetUserPoolMfaConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserPoolMfaConfigErrorKind::InternalErrorException(_inner) => Some(_inner),
            GetUserPoolMfaConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GetUserPoolMfaConfigErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GetUserPoolMfaConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetUserPoolMfaConfigErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUserPoolMfaConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GlobalSignOutError {
    pub kind: GlobalSignOutErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GlobalSignOutErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GlobalSignOutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GlobalSignOutErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            GlobalSignOutErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GlobalSignOutError {
    fn code(&self) -> Option<&str> {
        GlobalSignOutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GlobalSignOutError {
    pub fn new(kind: GlobalSignOutErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GlobalSignOutErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GlobalSignOutErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GlobalSignOutErrorKind::UserNotConfirmedException(_)
        )
    }
}
impl std::error::Error for GlobalSignOutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GlobalSignOutErrorKind::InternalErrorException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::InvalidParameterException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            GlobalSignOutErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct InitiateAuthError {
    pub kind: InitiateAuthErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum InitiateAuthErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for InitiateAuthError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            InitiateAuthErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            InitiateAuthErrorKind::InvalidUserPoolConfigurationException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            InitiateAuthErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for InitiateAuthError {
    fn code(&self) -> Option<&str> {
        InitiateAuthError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl InitiateAuthError {
    pub fn new(kind: InitiateAuthErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: InitiateAuthErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: InitiateAuthErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, InitiateAuthErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, InitiateAuthErrorKind::NotAuthorizedException(_))
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            InitiateAuthErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, InitiateAuthErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for InitiateAuthError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            InitiateAuthErrorKind::InternalErrorException(_inner) => Some(_inner),
            InitiateAuthErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            InitiateAuthErrorKind::InvalidParameterException(_inner) => Some(_inner),
            InitiateAuthErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            InitiateAuthErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => Some(_inner),
            InitiateAuthErrorKind::InvalidUserPoolConfigurationException(_inner) => Some(_inner),
            InitiateAuthErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            InitiateAuthErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            InitiateAuthErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            InitiateAuthErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            InitiateAuthErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            InitiateAuthErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            InitiateAuthErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            InitiateAuthErrorKind::UserNotFoundException(_inner) => Some(_inner),
            InitiateAuthErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDevicesError {
    pub kind: ListDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDevicesErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDevicesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::InvalidUserPoolConfigurationException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ListDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDevicesError {
    fn code(&self) -> Option<&str> {
        ListDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDevicesError {
    pub fn new(kind: ListDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::NotAuthorizedException(_))
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDevicesErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListDevicesErrorKind::UserNotFoundException(_))
    }
}
impl std::error::Error for ListDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDevicesErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListDevicesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListDevicesErrorKind::InvalidUserPoolConfigurationException(_inner) => Some(_inner),
            ListDevicesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListDevicesErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            ListDevicesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListDevicesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListDevicesErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            ListDevicesErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ListDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListGroupsError {
    pub kind: ListGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGroupsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListGroupsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListGroupsError {
    fn code(&self) -> Option<&str> {
        ListGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGroupsError {
    pub fn new(kind: ListGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListGroupsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListGroupsErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListGroupsErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListGroupsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListGroupsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListGroupsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListGroupsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListIdentityProvidersError {
    pub kind: ListIdentityProvidersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListIdentityProvidersErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListIdentityProvidersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListIdentityProvidersErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListIdentityProvidersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListIdentityProvidersError {
    fn code(&self) -> Option<&str> {
        ListIdentityProvidersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListIdentityProvidersError {
    pub fn new(kind: ListIdentityProvidersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListIdentityProvidersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListIdentityProvidersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListIdentityProvidersErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListIdentityProvidersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListIdentityProvidersErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListIdentityProvidersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourceServersError {
    pub kind: ListResourceServersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourceServersErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourceServersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourceServersErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListResourceServersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListResourceServersErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListResourceServersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListResourceServersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListResourceServersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourceServersError {
    fn code(&self) -> Option<&str> {
        ListResourceServersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourceServersError {
    pub fn new(kind: ListResourceServersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourceServersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourceServersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceServersErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceServersErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceServersErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceServersErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceServersErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListResourceServersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourceServersErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListResourceServersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListResourceServersErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListResourceServersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListResourceServersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListResourceServersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserImportJobsError {
    pub kind: ListUserImportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserImportJobsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserImportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserImportJobsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListUserImportJobsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUserImportJobsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListUserImportJobsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUserImportJobsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListUserImportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserImportJobsError {
    fn code(&self) -> Option<&str> {
        ListUserImportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserImportJobsError {
    pub fn new(kind: ListUserImportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserImportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserImportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserImportJobsErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserImportJobsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserImportJobsErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserImportJobsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserImportJobsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListUserImportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserImportJobsErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListUserImportJobsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUserImportJobsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListUserImportJobsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUserImportJobsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListUserImportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserPoolClientsError {
    pub kind: ListUserPoolClientsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserPoolClientsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserPoolClientsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserPoolClientsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListUserPoolClientsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUserPoolClientsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListUserPoolClientsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUserPoolClientsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListUserPoolClientsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserPoolClientsError {
    fn code(&self) -> Option<&str> {
        ListUserPoolClientsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserPoolClientsError {
    pub fn new(kind: ListUserPoolClientsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserPoolClientsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserPoolClientsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolClientsErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolClientsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolClientsErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolClientsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolClientsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListUserPoolClientsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserPoolClientsErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListUserPoolClientsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUserPoolClientsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListUserPoolClientsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUserPoolClientsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListUserPoolClientsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserPoolsError {
    pub kind: ListUserPoolsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserPoolsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserPoolsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserPoolsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListUserPoolsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUserPoolsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListUserPoolsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListUserPoolsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserPoolsError {
    fn code(&self) -> Option<&str> {
        ListUserPoolsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserPoolsError {
    pub fn new(kind: ListUserPoolsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserPoolsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserPoolsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolsErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolsErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserPoolsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListUserPoolsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserPoolsErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListUserPoolsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUserPoolsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListUserPoolsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListUserPoolsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersError {
    pub kind: ListUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersError {
    fn code(&self) -> Option<&str> {
        ListUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersError {
    pub fn new(kind: ListUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::InvalidParameterException(_))
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, ListUsersErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for ListUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListUsersErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUsersErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListUsersErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUsersErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsersInGroupError {
    pub kind: ListUsersInGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsersInGroupErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsersInGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsersInGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ListUsersInGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ListUsersInGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ListUsersInGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListUsersInGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListUsersInGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsersInGroupError {
    fn code(&self) -> Option<&str> {
        ListUsersInGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsersInGroupError {
    pub fn new(kind: ListUsersInGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsersInGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsersInGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersInGroupErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersInGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersInGroupErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersInGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsersInGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListUsersInGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsersInGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            ListUsersInGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ListUsersInGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ListUsersInGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListUsersInGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListUsersInGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResendConfirmationCodeError {
    pub kind: ResendConfirmationCodeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResendConfirmationCodeErrorKind {
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResendConfirmationCodeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResendConfirmationCodeErrorKind::CodeDeliveryFailureException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            ResendConfirmationCodeErrorKind::InvalidLambdaResponseException(_inner) => {
                _inner.fmt(f)
            }
            ResendConfirmationCodeErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            ResendConfirmationCodeErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            ResendConfirmationCodeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            ResendConfirmationCodeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResendConfirmationCodeError {
    fn code(&self) -> Option<&str> {
        ResendConfirmationCodeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResendConfirmationCodeError {
    pub fn new(kind: ResendConfirmationCodeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResendConfirmationCodeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResendConfirmationCodeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::CodeDeliveryFailureException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResendConfirmationCodeErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for ResendConfirmationCodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResendConfirmationCodeErrorKind::CodeDeliveryFailureException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::InternalErrorException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            ResendConfirmationCodeErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            ResendConfirmationCodeErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            ResendConfirmationCodeErrorKind::LimitExceededException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::UserNotFoundException(_inner) => Some(_inner),
            ResendConfirmationCodeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RespondToAuthChallengeError {
    pub kind: RespondToAuthChallengeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RespondToAuthChallengeErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    CodeMismatchException(crate::error::CodeMismatchException),
    ExpiredCodeException(crate::error::ExpiredCodeException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    MfaMethodNotFoundException(crate::error::MfaMethodNotFoundException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SoftwareTokenMfaNotFoundException(crate::error::SoftwareTokenMfaNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RespondToAuthChallengeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RespondToAuthChallengeErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::ExpiredCodeException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::InvalidLambdaResponseException(_inner) => {
                _inner.fmt(f)
            }
            RespondToAuthChallengeErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            RespondToAuthChallengeErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            RespondToAuthChallengeErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            RespondToAuthChallengeErrorKind::MfaMethodNotFoundException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::PasswordResetRequiredException(_inner) => {
                _inner.fmt(f)
            }
            RespondToAuthChallengeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RespondToAuthChallengeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            RespondToAuthChallengeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RespondToAuthChallengeError {
    fn code(&self) -> Option<&str> {
        RespondToAuthChallengeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RespondToAuthChallengeError {
    pub fn new(kind: RespondToAuthChallengeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RespondToAuthChallengeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RespondToAuthChallengeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::AliasExistsException(_)
        )
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::CodeMismatchException(_)
        )
    }
    pub fn is_expired_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::ExpiredCodeException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InvalidPasswordException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_mfa_method_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::MfaMethodNotFoundException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_software_token_mfa_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::SoftwareTokenMfaNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RespondToAuthChallengeErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for RespondToAuthChallengeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RespondToAuthChallengeErrorKind::AliasExistsException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::CodeMismatchException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::ExpiredCodeException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::InternalErrorException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            RespondToAuthChallengeErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            RespondToAuthChallengeErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            RespondToAuthChallengeErrorKind::MfaMethodNotFoundException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                Some(_inner)
            }
            RespondToAuthChallengeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::UserNotFoundException(_inner) => Some(_inner),
            RespondToAuthChallengeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeTokenError {
    pub kind: RevokeTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeTokenErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnauthorizedException(crate::error::UnauthorizedException),
    UnsupportedOperationException(crate::error::UnsupportedOperationException),
    UnsupportedTokenTypeException(crate::error::UnsupportedTokenTypeException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeTokenErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            RevokeTokenErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            RevokeTokenErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RevokeTokenErrorKind::UnauthorizedException(_inner) => _inner.fmt(f),
            RevokeTokenErrorKind::UnsupportedOperationException(_inner) => _inner.fmt(f),
            RevokeTokenErrorKind::UnsupportedTokenTypeException(_inner) => _inner.fmt(f),
            RevokeTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeTokenError {
    fn code(&self) -> Option<&str> {
        RevokeTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeTokenError {
    pub fn new(kind: RevokeTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, RevokeTokenErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeTokenErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeTokenErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unauthorized_exception(&self) -> bool {
        matches!(&self.kind, RevokeTokenErrorKind::UnauthorizedException(_))
    }
    pub fn is_unsupported_operation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeTokenErrorKind::UnsupportedOperationException(_)
        )
    }
    pub fn is_unsupported_token_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeTokenErrorKind::UnsupportedTokenTypeException(_)
        )
    }
}
impl std::error::Error for RevokeTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeTokenErrorKind::InternalErrorException(_inner) => Some(_inner),
            RevokeTokenErrorKind::InvalidParameterException(_inner) => Some(_inner),
            RevokeTokenErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RevokeTokenErrorKind::UnauthorizedException(_inner) => Some(_inner),
            RevokeTokenErrorKind::UnsupportedOperationException(_inner) => Some(_inner),
            RevokeTokenErrorKind::UnsupportedTokenTypeException(_inner) => Some(_inner),
            RevokeTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetRiskConfigurationError {
    pub kind: SetRiskConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetRiskConfigurationErrorKind {
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserPoolAddOnNotEnabledException(crate::error::UserPoolAddOnNotEnabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetRiskConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetRiskConfigurationErrorKind::CodeDeliveryFailureException(_inner) => _inner.fmt(f),
            SetRiskConfigurationErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            SetRiskConfigurationErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            SetRiskConfigurationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SetRiskConfigurationErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            SetRiskConfigurationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetRiskConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SetRiskConfigurationErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                _inner.fmt(f)
            }
            SetRiskConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetRiskConfigurationError {
    fn code(&self) -> Option<&str> {
        SetRiskConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetRiskConfigurationError {
    pub fn new(kind: SetRiskConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetRiskConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetRiskConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::CodeDeliveryFailureException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_pool_add_on_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetRiskConfigurationErrorKind::UserPoolAddOnNotEnabledException(_)
        )
    }
}
impl std::error::Error for SetRiskConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetRiskConfigurationErrorKind::CodeDeliveryFailureException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::InternalErrorException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            SetRiskConfigurationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::UserPoolAddOnNotEnabledException(_inner) => Some(_inner),
            SetRiskConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetUICustomizationError {
    pub kind: SetUICustomizationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetUICustomizationErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetUICustomizationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetUICustomizationErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            SetUICustomizationErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SetUICustomizationErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            SetUICustomizationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetUICustomizationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SetUICustomizationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetUICustomizationError {
    fn code(&self) -> Option<&str> {
        SetUICustomizationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetUICustomizationError {
    pub fn new(kind: SetUICustomizationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetUICustomizationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetUICustomizationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUICustomizationErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUICustomizationErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUICustomizationErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUICustomizationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUICustomizationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for SetUICustomizationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetUICustomizationErrorKind::InternalErrorException(_inner) => Some(_inner),
            SetUICustomizationErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SetUICustomizationErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            SetUICustomizationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetUICustomizationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SetUICustomizationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetUserMFAPreferenceError {
    pub kind: SetUserMFAPreferenceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetUserMFAPreferenceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetUserMFAPreferenceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetUserMFAPreferenceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            SetUserMFAPreferenceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetUserMFAPreferenceError {
    fn code(&self) -> Option<&str> {
        SetUserMFAPreferenceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetUserMFAPreferenceError {
    pub fn new(kind: SetUserMFAPreferenceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetUserMFAPreferenceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetUserMFAPreferenceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserMFAPreferenceErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for SetUserMFAPreferenceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetUserMFAPreferenceErrorKind::InternalErrorException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::UserNotFoundException(_inner) => Some(_inner),
            SetUserMFAPreferenceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetUserPoolMfaConfigError {
    pub kind: SetUserPoolMfaConfigErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetUserPoolMfaConfigErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetUserPoolMfaConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetUserPoolMfaConfigErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            SetUserPoolMfaConfigErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SetUserPoolMfaConfigErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            SetUserPoolMfaConfigErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            SetUserPoolMfaConfigErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            SetUserPoolMfaConfigErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetUserPoolMfaConfigErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SetUserPoolMfaConfigErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetUserPoolMfaConfigError {
    fn code(&self) -> Option<&str> {
        SetUserPoolMfaConfigError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetUserPoolMfaConfigError {
    pub fn new(kind: SetUserPoolMfaConfigErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetUserPoolMfaConfigErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetUserPoolMfaConfigErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserPoolMfaConfigErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for SetUserPoolMfaConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetUserPoolMfaConfigErrorKind::InternalErrorException(_inner) => Some(_inner),
            SetUserPoolMfaConfigErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SetUserPoolMfaConfigErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            SetUserPoolMfaConfigErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            SetUserPoolMfaConfigErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            SetUserPoolMfaConfigErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetUserPoolMfaConfigErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SetUserPoolMfaConfigErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SetUserSettingsError {
    pub kind: SetUserSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SetUserSettingsErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SetUserSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SetUserSettingsErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            SetUserSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SetUserSettingsError {
    fn code(&self) -> Option<&str> {
        SetUserSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SetUserSettingsError {
    pub fn new(kind: SetUserSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SetUserSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SetUserSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SetUserSettingsErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for SetUserSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SetUserSettingsErrorKind::InternalErrorException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::UserNotFoundException(_inner) => Some(_inner),
            SetUserSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SignUpError {
    pub kind: SignUpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SignUpErrorKind {
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidPasswordException(crate::error::InvalidPasswordException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UsernameExistsException(crate::error::UsernameExistsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SignUpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SignUpErrorKind::CodeDeliveryFailureException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InvalidPasswordException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => _inner.fmt(f),
            SignUpErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => _inner.fmt(f),
            SignUpErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            SignUpErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SignUpErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SignUpErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            SignUpErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            SignUpErrorKind::UsernameExistsException(_inner) => _inner.fmt(f),
            SignUpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SignUpError {
    fn code(&self) -> Option<&str> {
        SignUpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SignUpError {
    pub fn new(kind: SignUpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SignUpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SignUpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::CodeDeliveryFailureException(_))
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignUpErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignUpErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::InvalidParameterException(_))
    }
    pub fn is_invalid_password_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::InvalidPasswordException(_))
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignUpErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignUpErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::ResourceNotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::TooManyRequestsException(_))
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::UnexpectedLambdaException(_))
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            SignUpErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_username_exists_exception(&self) -> bool {
        matches!(&self.kind, SignUpErrorKind::UsernameExistsException(_))
    }
}
impl std::error::Error for SignUpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SignUpErrorKind::CodeDeliveryFailureException(_inner) => Some(_inner),
            SignUpErrorKind::InternalErrorException(_inner) => Some(_inner),
            SignUpErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => Some(_inner),
            SignUpErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            SignUpErrorKind::InvalidParameterException(_inner) => Some(_inner),
            SignUpErrorKind::InvalidPasswordException(_inner) => Some(_inner),
            SignUpErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            SignUpErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => Some(_inner),
            SignUpErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            SignUpErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SignUpErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SignUpErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            SignUpErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            SignUpErrorKind::UsernameExistsException(_inner) => Some(_inner),
            SignUpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartUserImportJobError {
    pub kind: StartUserImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartUserImportJobErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartUserImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartUserImportJobErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            StartUserImportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StartUserImportJobErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            StartUserImportJobErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            StartUserImportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartUserImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            StartUserImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartUserImportJobError {
    fn code(&self) -> Option<&str> {
        StartUserImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartUserImportJobError {
    pub fn new(kind: StartUserImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartUserImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartUserImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartUserImportJobErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartUserImportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartUserImportJobErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartUserImportJobErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartUserImportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartUserImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for StartUserImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartUserImportJobErrorKind::InternalErrorException(_inner) => Some(_inner),
            StartUserImportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StartUserImportJobErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            StartUserImportJobErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            StartUserImportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartUserImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            StartUserImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopUserImportJobError {
    pub kind: StopUserImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopUserImportJobErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PreconditionNotMetException(crate::error::PreconditionNotMetException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopUserImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopUserImportJobErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            StopUserImportJobErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            StopUserImportJobErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            StopUserImportJobErrorKind::PreconditionNotMetException(_inner) => _inner.fmt(f),
            StopUserImportJobErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StopUserImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            StopUserImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopUserImportJobError {
    fn code(&self) -> Option<&str> {
        StopUserImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopUserImportJobError {
    pub fn new(kind: StopUserImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopUserImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopUserImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopUserImportJobErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopUserImportJobErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopUserImportJobErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopUserImportJobErrorKind::PreconditionNotMetException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopUserImportJobErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopUserImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for StopUserImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopUserImportJobErrorKind::InternalErrorException(_inner) => Some(_inner),
            StopUserImportJobErrorKind::InvalidParameterException(_inner) => Some(_inner),
            StopUserImportJobErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            StopUserImportJobErrorKind::PreconditionNotMetException(_inner) => Some(_inner),
            StopUserImportJobErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StopUserImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            StopUserImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalErrorException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            TagResourceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalErrorException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAuthEventFeedbackError {
    pub kind: UpdateAuthEventFeedbackErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAuthEventFeedbackErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotFoundException(crate::error::UserNotFoundException),
    UserPoolAddOnNotEnabledException(crate::error::UserPoolAddOnNotEnabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAuthEventFeedbackError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAuthEventFeedbackErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateAuthEventFeedbackErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateAuthEventFeedbackErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateAuthEventFeedbackErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateAuthEventFeedbackErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateAuthEventFeedbackErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            UpdateAuthEventFeedbackErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                _inner.fmt(f)
            }
            UpdateAuthEventFeedbackErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAuthEventFeedbackError {
    fn code(&self) -> Option<&str> {
        UpdateAuthEventFeedbackError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAuthEventFeedbackError {
    pub fn new(kind: UpdateAuthEventFeedbackErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAuthEventFeedbackErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAuthEventFeedbackErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::UserNotFoundException(_)
        )
    }
    pub fn is_user_pool_add_on_not_enabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAuthEventFeedbackErrorKind::UserPoolAddOnNotEnabledException(_)
        )
    }
}
impl std::error::Error for UpdateAuthEventFeedbackError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAuthEventFeedbackErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateAuthEventFeedbackErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateAuthEventFeedbackErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateAuthEventFeedbackErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateAuthEventFeedbackErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateAuthEventFeedbackErrorKind::UserNotFoundException(_inner) => Some(_inner),
            UpdateAuthEventFeedbackErrorKind::UserPoolAddOnNotEnabledException(_inner) => {
                Some(_inner)
            }
            UpdateAuthEventFeedbackErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDeviceStatusError {
    pub kind: UpdateDeviceStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDeviceStatusErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDeviceStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDeviceStatusErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDeviceStatusErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            UpdateDeviceStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDeviceStatusError {
    fn code(&self) -> Option<&str> {
        UpdateDeviceStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDeviceStatusError {
    pub fn new(kind: UpdateDeviceStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDeviceStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDeviceStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDeviceStatusErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateDeviceStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDeviceStatusErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            UpdateDeviceStatusErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::UserNotFoundException(_inner) => Some(_inner),
            UpdateDeviceStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGroupError {
    pub kind: UpdateGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGroupErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGroupErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGroupError {
    fn code(&self) -> Option<&str> {
        UpdateGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGroupError {
    pub fn new(kind: UpdateGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::InternalErrorException(_))
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(&self.kind, UpdateGroupErrorKind::NotAuthorizedException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGroupErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGroupErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateGroupErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateGroupErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateGroupErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateGroupErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateIdentityProviderError {
    pub kind: UpdateIdentityProviderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateIdentityProviderErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnsupportedIdentityProviderException(crate::error::UnsupportedIdentityProviderException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateIdentityProviderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateIdentityProviderErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateIdentityProviderErrorKind::UnsupportedIdentityProviderException(_inner) => {
                _inner.fmt(f)
            }
            UpdateIdentityProviderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateIdentityProviderError {
    fn code(&self) -> Option<&str> {
        UpdateIdentityProviderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateIdentityProviderError {
    pub fn new(kind: UpdateIdentityProviderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateIdentityProviderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateIdentityProviderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unsupported_identity_provider_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateIdentityProviderErrorKind::UnsupportedIdentityProviderException(_)
        )
    }
}
impl std::error::Error for UpdateIdentityProviderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateIdentityProviderErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateIdentityProviderErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateIdentityProviderErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateIdentityProviderErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateIdentityProviderErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateIdentityProviderErrorKind::UnsupportedIdentityProviderException(_inner) => {
                Some(_inner)
            }
            UpdateIdentityProviderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateResourceServerError {
    pub kind: UpdateResourceServerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateResourceServerErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateResourceServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateResourceServerErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateResourceServerErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateResourceServerErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateResourceServerErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateResourceServerErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateResourceServerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateResourceServerError {
    fn code(&self) -> Option<&str> {
        UpdateResourceServerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateResourceServerError {
    pub fn new(kind: UpdateResourceServerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateResourceServerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateResourceServerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceServerErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceServerErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceServerErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceServerErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateResourceServerErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateResourceServerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateResourceServerErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateResourceServerErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateResourceServerErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateResourceServerErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateResourceServerErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateResourceServerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserAttributesError {
    pub kind: UpdateUserAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserAttributesErrorKind {
    AliasExistsException(crate::error::AliasExistsException),
    CodeDeliveryFailureException(crate::error::CodeDeliveryFailureException),
    CodeMismatchException(crate::error::CodeMismatchException),
    ExpiredCodeException(crate::error::ExpiredCodeException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidLambdaResponseException(crate::error::InvalidLambdaResponseException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UnexpectedLambdaException(crate::error::UnexpectedLambdaException),
    UserLambdaValidationException(crate::error::UserLambdaValidationException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserAttributesErrorKind::AliasExistsException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::CodeDeliveryFailureException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::ExpiredCodeException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserAttributesErrorKind::InvalidLambdaResponseException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserAttributesErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserAttributesErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::UnexpectedLambdaException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::UserLambdaValidationException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserAttributesError {
    fn code(&self) -> Option<&str> {
        UpdateUserAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserAttributesError {
    pub fn new(kind: UpdateUserAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_alias_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::AliasExistsException(_)
        )
    }
    pub fn is_code_delivery_failure_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::CodeDeliveryFailureException(_)
        )
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::CodeMismatchException(_)
        )
    }
    pub fn is_expired_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::ExpiredCodeException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_lambda_response_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::InvalidLambdaResponseException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_unexpected_lambda_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::UnexpectedLambdaException(_)
        )
    }
    pub fn is_user_lambda_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::UserLambdaValidationException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserAttributesErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateUserAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserAttributesErrorKind::AliasExistsException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::CodeDeliveryFailureException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::CodeMismatchException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::ExpiredCodeException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            UpdateUserAttributesErrorKind::InvalidLambdaResponseException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => {
                Some(_inner)
            }
            UpdateUserAttributesErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            UpdateUserAttributesErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::UnexpectedLambdaException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::UserLambdaValidationException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::UserNotFoundException(_inner) => Some(_inner),
            UpdateUserAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserPoolError {
    pub kind: UpdateUserPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserPoolErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidEmailRoleAccessPolicyException(crate::error::InvalidEmailRoleAccessPolicyException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidSmsRoleAccessPolicyException(crate::error::InvalidSmsRoleAccessPolicyException),
    InvalidSmsRoleTrustRelationshipException(
        crate::error::InvalidSmsRoleTrustRelationshipException,
    ),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserImportInProgressException(crate::error::UserImportInProgressException),
    UserPoolTaggingException(crate::error::UserPoolTaggingException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserPoolErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                _inner.fmt(f)
            }
            UpdateUserPoolErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::UserImportInProgressException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::UserPoolTaggingException(_inner) => _inner.fmt(f),
            UpdateUserPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserPoolError {
    fn code(&self) -> Option<&str> {
        UpdateUserPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserPoolError {
    pub fn new(kind: UpdateUserPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_email_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::InvalidEmailRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_sms_role_access_policy_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::InvalidSmsRoleAccessPolicyException(_)
        )
    }
    pub fn is_invalid_sms_role_trust_relationship_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::InvalidSmsRoleTrustRelationshipException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_import_in_progress_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::UserImportInProgressException(_)
        )
    }
    pub fn is_user_pool_tagging_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolErrorKind::UserPoolTaggingException(_)
        )
    }
}
impl std::error::Error for UpdateUserPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserPoolErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::InvalidEmailRoleAccessPolicyException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::InvalidSmsRoleAccessPolicyException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::InvalidSmsRoleTrustRelationshipException(_inner) => {
                Some(_inner)
            }
            UpdateUserPoolErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::UserImportInProgressException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::UserPoolTaggingException(_inner) => Some(_inner),
            UpdateUserPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserPoolClientError {
    pub kind: UpdateUserPoolClientErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserPoolClientErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidOAuthFlowException(crate::error::InvalidOAuthFlowException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ScopeDoesNotExistException(crate::error::ScopeDoesNotExistException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserPoolClientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserPoolClientErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::InvalidOAuthFlowException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::ScopeDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateUserPoolClientErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserPoolClientError {
    fn code(&self) -> Option<&str> {
        UpdateUserPoolClientError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserPoolClientError {
    pub fn new(kind: UpdateUserPoolClientErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserPoolClientErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserPoolClientErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_o_auth_flow_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::InvalidOAuthFlowException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_scope_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::ScopeDoesNotExistException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolClientErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateUserPoolClientError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserPoolClientErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::InvalidOAuthFlowException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::ScopeDoesNotExistException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateUserPoolClientErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserPoolDomainError {
    pub kind: UpdateUserPoolDomainErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserPoolDomainErrorKind {
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserPoolDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserPoolDomainErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            UpdateUserPoolDomainErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            UpdateUserPoolDomainErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            UpdateUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserPoolDomainErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateUserPoolDomainErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserPoolDomainError {
    fn code(&self) -> Option<&str> {
        UpdateUserPoolDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserPoolDomainError {
    pub fn new(kind: UpdateUserPoolDomainErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserPoolDomainErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserPoolDomainErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolDomainErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolDomainErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolDomainErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolDomainErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserPoolDomainErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateUserPoolDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserPoolDomainErrorKind::InternalErrorException(_inner) => Some(_inner),
            UpdateUserPoolDomainErrorKind::InvalidParameterException(_inner) => Some(_inner),
            UpdateUserPoolDomainErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            UpdateUserPoolDomainErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateUserPoolDomainErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateUserPoolDomainErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct VerifySoftwareTokenError {
    pub kind: VerifySoftwareTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum VerifySoftwareTokenErrorKind {
    CodeMismatchException(crate::error::CodeMismatchException),
    EnableSoftwareTokenMfaException(crate::error::EnableSoftwareTokenMfaException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    InvalidUserPoolConfigurationException(crate::error::InvalidUserPoolConfigurationException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    SoftwareTokenMfaNotFoundException(crate::error::SoftwareTokenMfaNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for VerifySoftwareTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            VerifySoftwareTokenErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::EnableSoftwareTokenMfaException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                _inner.fmt(f)
            }
            VerifySoftwareTokenErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::SoftwareTokenMfaNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            VerifySoftwareTokenErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            VerifySoftwareTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for VerifySoftwareTokenError {
    fn code(&self) -> Option<&str> {
        VerifySoftwareTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl VerifySoftwareTokenError {
    pub fn new(kind: VerifySoftwareTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: VerifySoftwareTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: VerifySoftwareTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::CodeMismatchException(_)
        )
    }
    pub fn is_enable_software_token_mfa_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::EnableSoftwareTokenMfaException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_invalid_user_pool_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::InvalidUserPoolConfigurationException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_software_token_mfa_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::SoftwareTokenMfaNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifySoftwareTokenErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for VerifySoftwareTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            VerifySoftwareTokenErrorKind::CodeMismatchException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::EnableSoftwareTokenMfaException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::InternalErrorException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::InvalidParameterException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::InvalidUserPoolConfigurationException(_inner) => {
                Some(_inner)
            }
            VerifySoftwareTokenErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::SoftwareTokenMfaNotFoundException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::UserNotFoundException(_inner) => Some(_inner),
            VerifySoftwareTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct VerifyUserAttributeError {
    pub kind: VerifyUserAttributeErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum VerifyUserAttributeErrorKind {
    CodeMismatchException(crate::error::CodeMismatchException),
    ExpiredCodeException(crate::error::ExpiredCodeException),
    InternalErrorException(crate::error::InternalErrorException),
    InvalidParameterException(crate::error::InvalidParameterException),
    LimitExceededException(crate::error::LimitExceededException),
    NotAuthorizedException(crate::error::NotAuthorizedException),
    PasswordResetRequiredException(crate::error::PasswordResetRequiredException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    UserNotConfirmedException(crate::error::UserNotConfirmedException),
    UserNotFoundException(crate::error::UserNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for VerifyUserAttributeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            VerifyUserAttributeErrorKind::CodeMismatchException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::ExpiredCodeException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::InternalErrorException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::InvalidParameterException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::NotAuthorizedException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::PasswordResetRequiredException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::UserNotConfirmedException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::UserNotFoundException(_inner) => _inner.fmt(f),
            VerifyUserAttributeErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for VerifyUserAttributeError {
    fn code(&self) -> Option<&str> {
        VerifyUserAttributeError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl VerifyUserAttributeError {
    pub fn new(kind: VerifyUserAttributeErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: VerifyUserAttributeErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: VerifyUserAttributeErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_code_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::CodeMismatchException(_)
        )
    }
    pub fn is_expired_code_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::ExpiredCodeException(_)
        )
    }
    pub fn is_internal_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::InternalErrorException(_)
        )
    }
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::InvalidParameterException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_authorized_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::NotAuthorizedException(_)
        )
    }
    pub fn is_password_reset_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::PasswordResetRequiredException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::TooManyRequestsException(_)
        )
    }
    pub fn is_user_not_confirmed_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::UserNotConfirmedException(_)
        )
    }
    pub fn is_user_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            VerifyUserAttributeErrorKind::UserNotFoundException(_)
        )
    }
}
impl std::error::Error for VerifyUserAttributeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            VerifyUserAttributeErrorKind::CodeMismatchException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::ExpiredCodeException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::InternalErrorException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::InvalidParameterException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::LimitExceededException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::NotAuthorizedException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::PasswordResetRequiredException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::UserNotConfirmedException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::UserNotFoundException(_inner) => Some(_inner),
            VerifyUserAttributeErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>This exception is thrown when a user is not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserNotFoundException {
    /// <p>The message returned when a user is not found.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserNotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserNotFoundException {}
/// See [`UserNotFoundException`](crate::error::UserNotFoundException)
pub mod user_not_found_exception {
    /// A builder for [`UserNotFoundException`](crate::error::UserNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when a user is not found.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserNotFoundException`](crate::error::UserNotFoundException)
        pub fn build(self) -> crate::error::UserNotFoundException {
            crate::error::UserNotFoundException {
                message: self.message,
            }
        }
    }
}
impl UserNotFoundException {
    /// Creates a new builder-style object to manufacture [`UserNotFoundException`](crate::error::UserNotFoundException)
    pub fn builder() -> crate::error::user_not_found_exception::Builder {
        crate::error::user_not_found_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a user is not confirmed successfully.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserNotConfirmedException {
    /// <p>The message returned when a user is not confirmed successfully.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserNotConfirmedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserNotConfirmedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserNotConfirmedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserNotConfirmedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserNotConfirmedException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserNotConfirmedException {}
/// See [`UserNotConfirmedException`](crate::error::UserNotConfirmedException)
pub mod user_not_confirmed_exception {
    /// A builder for [`UserNotConfirmedException`](crate::error::UserNotConfirmedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when a user is not confirmed successfully.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserNotConfirmedException`](crate::error::UserNotConfirmedException)
        pub fn build(self) -> crate::error::UserNotConfirmedException {
            crate::error::UserNotConfirmedException {
                message: self.message,
            }
        }
    }
}
impl UserNotConfirmedException {
    /// Creates a new builder-style object to manufacture [`UserNotConfirmedException`](crate::error::UserNotConfirmedException)
    pub fn builder() -> crate::error::user_not_confirmed_exception::Builder {
        crate::error::user_not_confirmed_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the user has made too many requests for a given
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    /// <p>The message returned when the Amazon Cognito service returns a too many requests
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service returns a too many requests
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Cognito service cannot find the requested
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// <p>The message returned when the Amazon Cognito service returns a resource not found
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service returns a resource not found
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a password reset is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PasswordResetRequiredException {
    /// <p>The message returned when a password reset is required.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PasswordResetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PasswordResetRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PasswordResetRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PasswordResetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PasswordResetRequiredException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for PasswordResetRequiredException {}
/// See [`PasswordResetRequiredException`](crate::error::PasswordResetRequiredException)
pub mod password_reset_required_exception {
    /// A builder for [`PasswordResetRequiredException`](crate::error::PasswordResetRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when a password reset is required.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PasswordResetRequiredException`](crate::error::PasswordResetRequiredException)
        pub fn build(self) -> crate::error::PasswordResetRequiredException {
            crate::error::PasswordResetRequiredException {
                message: self.message,
            }
        }
    }
}
impl PasswordResetRequiredException {
    /// Creates a new builder-style object to manufacture [`PasswordResetRequiredException`](crate::error::PasswordResetRequiredException)
    pub fn builder() -> crate::error::password_reset_required_exception::Builder {
        crate::error::password_reset_required_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a user is not authorized.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotAuthorizedException {
    /// <p>The message returned when the Amazon Cognito service returns a not authorized
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotAuthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotAuthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotAuthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotAuthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotAuthorizedException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotAuthorizedException {}
/// See [`NotAuthorizedException`](crate::error::NotAuthorizedException)
pub mod not_authorized_exception {
    /// A builder for [`NotAuthorizedException`](crate::error::NotAuthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service returns a not authorized
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotAuthorizedException`](crate::error::NotAuthorizedException)
        pub fn build(self) -> crate::error::NotAuthorizedException {
            crate::error::NotAuthorizedException {
                message: self.message,
            }
        }
    }
}
impl NotAuthorizedException {
    /// Creates a new builder-style object to manufacture [`NotAuthorizedException`](crate::error::NotAuthorizedException)
    pub fn builder() -> crate::error::not_authorized_exception::Builder {
        crate::error::not_authorized_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a user exceeds the limit for a requested AWS
/// resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    /// <p>The message returned when Amazon Cognito throws a limit exceeded exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when Amazon Cognito throws a limit exceeded exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an invalid
/// parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterException {
    /// <p>The message returned when the Amazon Cognito service throws an invalid parameter
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterException {}
/// See [`InvalidParameterException`](crate::error::InvalidParameterException)
pub mod invalid_parameter_exception {
    /// A builder for [`InvalidParameterException`](crate::error::InvalidParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service throws an invalid parameter
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterException`](crate::error::InvalidParameterException)
        pub fn build(self) -> crate::error::InvalidParameterException {
            crate::error::InvalidParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterException`](crate::error::InvalidParameterException)
    pub fn builder() -> crate::error::invalid_parameter_exception::Builder {
        crate::error::invalid_parameter_exception::Builder::default()
    }
}

/// <p>This exception is thrown when Amazon Cognito encounters an internal error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalErrorException {
    /// <p>The message returned when Amazon Cognito throws an internal error exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalErrorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalErrorException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalErrorException {}
/// See [`InternalErrorException`](crate::error::InternalErrorException)
pub mod internal_error_exception {
    /// A builder for [`InternalErrorException`](crate::error::InternalErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when Amazon Cognito throws an internal error exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalErrorException`](crate::error::InternalErrorException)
        pub fn build(self) -> crate::error::InternalErrorException {
            crate::error::InternalErrorException {
                message: self.message,
            }
        }
    }
}
impl InternalErrorException {
    /// Creates a new builder-style object to manufacture [`InternalErrorException`](crate::error::InternalErrorException)
    pub fn builder() -> crate::error::internal_error_exception::Builder {
        crate::error::internal_error_exception::Builder::default()
    }
}

/// <p>This exception is thrown if a code has expired.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExpiredCodeException {
    /// <p>The message returned when the expired code exception is thrown.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExpiredCodeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredCodeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredCodeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExpiredCodeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredCodeException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExpiredCodeException {}
/// See [`ExpiredCodeException`](crate::error::ExpiredCodeException)
pub mod expired_code_exception {
    /// A builder for [`ExpiredCodeException`](crate::error::ExpiredCodeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the expired code exception is thrown.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExpiredCodeException`](crate::error::ExpiredCodeException)
        pub fn build(self) -> crate::error::ExpiredCodeException {
            crate::error::ExpiredCodeException {
                message: self.message,
            }
        }
    }
}
impl ExpiredCodeException {
    /// Creates a new builder-style object to manufacture [`ExpiredCodeException`](crate::error::ExpiredCodeException)
    pub fn builder() -> crate::error::expired_code_exception::Builder {
        crate::error::expired_code_exception::Builder::default()
    }
}

/// <p>This exception is thrown if the provided code does not match what the server was
/// expecting.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeMismatchException {
    /// <p>The message provided when the code mismatch exception is thrown.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CodeMismatchException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeMismatchException {}
/// See [`CodeMismatchException`](crate::error::CodeMismatchException)
pub mod code_mismatch_exception {
    /// A builder for [`CodeMismatchException`](crate::error::CodeMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message provided when the code mismatch exception is thrown.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeMismatchException`](crate::error::CodeMismatchException)
        pub fn build(self) -> crate::error::CodeMismatchException {
            crate::error::CodeMismatchException {
                message: self.message,
            }
        }
    }
}
impl CodeMismatchException {
    /// Creates a new builder-style object to manufacture [`CodeMismatchException`](crate::error::CodeMismatchException)
    pub fn builder() -> crate::error::code_mismatch_exception::Builder {
        crate::error::code_mismatch_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the software token TOTP multi-factor authentication
/// (MFA) is not enabled for the user pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SoftwareTokenMfaNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SoftwareTokenMfaNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SoftwareTokenMfaNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SoftwareTokenMfaNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SoftwareTokenMfaNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "SoftwareTokenMfaNotFoundException [SoftwareTokenMFANotFoundException]"
        )?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for SoftwareTokenMfaNotFoundException {}
/// See [`SoftwareTokenMfaNotFoundException`](crate::error::SoftwareTokenMfaNotFoundException)
pub mod software_token_mfa_not_found_exception {
    /// A builder for [`SoftwareTokenMfaNotFoundException`](crate::error::SoftwareTokenMfaNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SoftwareTokenMfaNotFoundException`](crate::error::SoftwareTokenMfaNotFoundException)
        pub fn build(self) -> crate::error::SoftwareTokenMfaNotFoundException {
            crate::error::SoftwareTokenMfaNotFoundException {
                message: self.message,
            }
        }
    }
}
impl SoftwareTokenMfaNotFoundException {
    /// Creates a new builder-style object to manufacture [`SoftwareTokenMfaNotFoundException`](crate::error::SoftwareTokenMfaNotFoundException)
    pub fn builder() -> crate::error::software_token_mfa_not_found_exception::Builder {
        crate::error::software_token_mfa_not_found_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the user pool configuration is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidUserPoolConfigurationException {
    /// <p>The message returned when the user pool configuration is invalid.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidUserPoolConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidUserPoolConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidUserPoolConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUserPoolConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUserPoolConfigurationException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUserPoolConfigurationException {}
/// See [`InvalidUserPoolConfigurationException`](crate::error::InvalidUserPoolConfigurationException)
pub mod invalid_user_pool_configuration_exception {
    /// A builder for [`InvalidUserPoolConfigurationException`](crate::error::InvalidUserPoolConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the user pool configuration is invalid.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUserPoolConfigurationException`](crate::error::InvalidUserPoolConfigurationException)
        pub fn build(self) -> crate::error::InvalidUserPoolConfigurationException {
            crate::error::InvalidUserPoolConfigurationException {
                message: self.message,
            }
        }
    }
}
impl InvalidUserPoolConfigurationException {
    /// Creates a new builder-style object to manufacture [`InvalidUserPoolConfigurationException`](crate::error::InvalidUserPoolConfigurationException)
    pub fn builder() -> crate::error::invalid_user_pool_configuration_exception::Builder {
        crate::error::invalid_user_pool_configuration_exception::Builder::default()
    }
}

/// <p>This exception is thrown when there is a code mismatch and the service fails to
/// configure the software token TOTP multi-factor authentication (MFA).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnableSoftwareTokenMfaException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EnableSoftwareTokenMfaException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnableSoftwareTokenMfaException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EnableSoftwareTokenMfaException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EnableSoftwareTokenMfaException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EnableSoftwareTokenMfaException [EnableSoftwareTokenMFAException]"
        )?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for EnableSoftwareTokenMfaException {}
/// See [`EnableSoftwareTokenMfaException`](crate::error::EnableSoftwareTokenMfaException)
pub mod enable_software_token_mfa_exception {
    /// A builder for [`EnableSoftwareTokenMfaException`](crate::error::EnableSoftwareTokenMfaException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EnableSoftwareTokenMfaException`](crate::error::EnableSoftwareTokenMfaException)
        pub fn build(self) -> crate::error::EnableSoftwareTokenMfaException {
            crate::error::EnableSoftwareTokenMfaException {
                message: self.message,
            }
        }
    }
}
impl EnableSoftwareTokenMfaException {
    /// Creates a new builder-style object to manufacture [`EnableSoftwareTokenMfaException`](crate::error::EnableSoftwareTokenMfaException)
    pub fn builder() -> crate::error::enable_software_token_mfa_exception::Builder {
        crate::error::enable_software_token_mfa_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified scope does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScopeDoesNotExistException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScopeDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScopeDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ScopeDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ScopeDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ScopeDoesNotExistException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for ScopeDoesNotExistException {}
/// See [`ScopeDoesNotExistException`](crate::error::ScopeDoesNotExistException)
pub mod scope_does_not_exist_exception {
    /// A builder for [`ScopeDoesNotExistException`](crate::error::ScopeDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ScopeDoesNotExistException`](crate::error::ScopeDoesNotExistException)
        pub fn build(self) -> crate::error::ScopeDoesNotExistException {
            crate::error::ScopeDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ScopeDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ScopeDoesNotExistException`](crate::error::ScopeDoesNotExistException)
    pub fn builder() -> crate::error::scope_does_not_exist_exception::Builder {
        crate::error::scope_does_not_exist_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified OAuth flow is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOAuthFlowException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOAuthFlowException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOAuthFlowException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOAuthFlowException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOAuthFlowException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOAuthFlowException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOAuthFlowException {}
/// See [`InvalidOAuthFlowException`](crate::error::InvalidOAuthFlowException)
pub mod invalid_o_auth_flow_exception {
    /// A builder for [`InvalidOAuthFlowException`](crate::error::InvalidOAuthFlowException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOAuthFlowException`](crate::error::InvalidOAuthFlowException)
        pub fn build(self) -> crate::error::InvalidOAuthFlowException {
            crate::error::InvalidOAuthFlowException {
                message: self.message,
            }
        }
    }
}
impl InvalidOAuthFlowException {
    /// Creates a new builder-style object to manufacture [`InvalidOAuthFlowException`](crate::error::InvalidOAuthFlowException)
    pub fn builder() -> crate::error::invalid_o_auth_flow_exception::Builder {
        crate::error::invalid_o_auth_flow_exception::Builder::default()
    }
}

/// <p>This exception is thrown if two or more modifications are happening
/// concurrently.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    /// <p>The message provided when the concurrent exception is thrown.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message provided when the concurrent exception is thrown.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a user pool tag cannot be set or updated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserPoolTaggingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserPoolTaggingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserPoolTaggingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserPoolTaggingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserPoolTaggingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserPoolTaggingException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserPoolTaggingException {}
/// See [`UserPoolTaggingException`](crate::error::UserPoolTaggingException)
pub mod user_pool_tagging_exception {
    /// A builder for [`UserPoolTaggingException`](crate::error::UserPoolTaggingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserPoolTaggingException`](crate::error::UserPoolTaggingException)
        pub fn build(self) -> crate::error::UserPoolTaggingException {
            crate::error::UserPoolTaggingException {
                message: self.message,
            }
        }
    }
}
impl UserPoolTaggingException {
    /// Creates a new builder-style object to manufacture [`UserPoolTaggingException`](crate::error::UserPoolTaggingException)
    pub fn builder() -> crate::error::user_pool_tagging_exception::Builder {
        crate::error::user_pool_tagging_exception::Builder::default()
    }
}

/// <p>This exception is thrown when you are trying to modify a user pool while a user import
/// job is in progress for that pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserImportInProgressException {
    /// <p>The message returned when the user pool has an import job running.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserImportInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserImportInProgressException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserImportInProgressException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserImportInProgressException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserImportInProgressException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserImportInProgressException {}
/// See [`UserImportInProgressException`](crate::error::UserImportInProgressException)
pub mod user_import_in_progress_exception {
    /// A builder for [`UserImportInProgressException`](crate::error::UserImportInProgressException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the user pool has an import job running.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserImportInProgressException`](crate::error::UserImportInProgressException)
        pub fn build(self) -> crate::error::UserImportInProgressException {
            crate::error::UserImportInProgressException {
                message: self.message,
            }
        }
    }
}
impl UserImportInProgressException {
    /// Creates a new builder-style object to manufacture [`UserImportInProgressException`](crate::error::UserImportInProgressException)
    pub fn builder() -> crate::error::user_import_in_progress_exception::Builder {
        crate::error::user_import_in_progress_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the trust relationship is invalid for the role provided
/// for SMS configuration. This can happen if you do not trust <b>cognito-idp.amazonaws.com</b> or the external ID provided in the role does
/// not match what is provided in the SMS configuration for the user pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSmsRoleTrustRelationshipException {
    /// <p>The message returned when the role trust relationship for the SMS message is
    /// invalid.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSmsRoleTrustRelationshipException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSmsRoleTrustRelationshipException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSmsRoleTrustRelationshipException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSmsRoleTrustRelationshipException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSmsRoleTrustRelationshipException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSmsRoleTrustRelationshipException {}
/// See [`InvalidSmsRoleTrustRelationshipException`](crate::error::InvalidSmsRoleTrustRelationshipException)
pub mod invalid_sms_role_trust_relationship_exception {
    /// A builder for [`InvalidSmsRoleTrustRelationshipException`](crate::error::InvalidSmsRoleTrustRelationshipException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the role trust relationship for the SMS message is
        /// invalid.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSmsRoleTrustRelationshipException`](crate::error::InvalidSmsRoleTrustRelationshipException)
        pub fn build(self) -> crate::error::InvalidSmsRoleTrustRelationshipException {
            crate::error::InvalidSmsRoleTrustRelationshipException {
                message: self.message,
            }
        }
    }
}
impl InvalidSmsRoleTrustRelationshipException {
    /// Creates a new builder-style object to manufacture [`InvalidSmsRoleTrustRelationshipException`](crate::error::InvalidSmsRoleTrustRelationshipException)
    pub fn builder() -> crate::error::invalid_sms_role_trust_relationship_exception::Builder {
        crate::error::invalid_sms_role_trust_relationship_exception::Builder::default()
    }
}

/// <p>This exception is returned when the role provided for SMS configuration does not have
/// permission to publish using Amazon SNS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSmsRoleAccessPolicyException {
    /// <p>The message retuned when the invalid SMS role access policy exception is
    /// thrown.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSmsRoleAccessPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSmsRoleAccessPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSmsRoleAccessPolicyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSmsRoleAccessPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSmsRoleAccessPolicyException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSmsRoleAccessPolicyException {}
/// See [`InvalidSmsRoleAccessPolicyException`](crate::error::InvalidSmsRoleAccessPolicyException)
pub mod invalid_sms_role_access_policy_exception {
    /// A builder for [`InvalidSmsRoleAccessPolicyException`](crate::error::InvalidSmsRoleAccessPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message retuned when the invalid SMS role access policy exception is
        /// thrown.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSmsRoleAccessPolicyException`](crate::error::InvalidSmsRoleAccessPolicyException)
        pub fn build(self) -> crate::error::InvalidSmsRoleAccessPolicyException {
            crate::error::InvalidSmsRoleAccessPolicyException {
                message: self.message,
            }
        }
    }
}
impl InvalidSmsRoleAccessPolicyException {
    /// Creates a new builder-style object to manufacture [`InvalidSmsRoleAccessPolicyException`](crate::error::InvalidSmsRoleAccessPolicyException)
    pub fn builder() -> crate::error::invalid_sms_role_access_policy_exception::Builder {
        crate::error::invalid_sms_role_access_policy_exception::Builder::default()
    }
}

/// <p>This exception is thrown when Amazon Cognito is not allowed to use your email
/// identity. HTTP status code: 400.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEmailRoleAccessPolicyException {
    /// <p>The message returned when you have an unverified email address or the identity policy
    /// is not set on an email address that Amazon Cognito can access.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEmailRoleAccessPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEmailRoleAccessPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEmailRoleAccessPolicyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEmailRoleAccessPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEmailRoleAccessPolicyException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEmailRoleAccessPolicyException {}
/// See [`InvalidEmailRoleAccessPolicyException`](crate::error::InvalidEmailRoleAccessPolicyException)
pub mod invalid_email_role_access_policy_exception {
    /// A builder for [`InvalidEmailRoleAccessPolicyException`](crate::error::InvalidEmailRoleAccessPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when you have an unverified email address or the identity policy
        /// is not set on an email address that Amazon Cognito can access.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEmailRoleAccessPolicyException`](crate::error::InvalidEmailRoleAccessPolicyException)
        pub fn build(self) -> crate::error::InvalidEmailRoleAccessPolicyException {
            crate::error::InvalidEmailRoleAccessPolicyException {
                message: self.message,
            }
        }
    }
}
impl InvalidEmailRoleAccessPolicyException {
    /// Creates a new builder-style object to manufacture [`InvalidEmailRoleAccessPolicyException`](crate::error::InvalidEmailRoleAccessPolicyException)
    pub fn builder() -> crate::error::invalid_email_role_access_policy_exception::Builder {
        crate::error::invalid_email_role_access_policy_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters a user validation
/// exception with the AWS Lambda service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserLambdaValidationException {
    /// <p>The message returned when the Amazon Cognito service returns a user validation
    /// exception with the AWS Lambda service.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserLambdaValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserLambdaValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserLambdaValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserLambdaValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserLambdaValidationException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserLambdaValidationException {}
/// See [`UserLambdaValidationException`](crate::error::UserLambdaValidationException)
pub mod user_lambda_validation_exception {
    /// A builder for [`UserLambdaValidationException`](crate::error::UserLambdaValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service returns a user validation
        /// exception with the AWS Lambda service.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserLambdaValidationException`](crate::error::UserLambdaValidationException)
        pub fn build(self) -> crate::error::UserLambdaValidationException {
            crate::error::UserLambdaValidationException {
                message: self.message,
            }
        }
    }
}
impl UserLambdaValidationException {
    /// Creates a new builder-style object to manufacture [`UserLambdaValidationException`](crate::error::UserLambdaValidationException)
    pub fn builder() -> crate::error::user_lambda_validation_exception::Builder {
        crate::error::user_lambda_validation_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an unexpected
/// exception with the AWS Lambda service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnexpectedLambdaException {
    /// <p>The message returned when the Amazon Cognito service returns an unexpected AWS Lambda
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnexpectedLambdaException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnexpectedLambdaException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnexpectedLambdaException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnexpectedLambdaException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnexpectedLambdaException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnexpectedLambdaException {}
/// See [`UnexpectedLambdaException`](crate::error::UnexpectedLambdaException)
pub mod unexpected_lambda_exception {
    /// A builder for [`UnexpectedLambdaException`](crate::error::UnexpectedLambdaException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service returns an unexpected AWS Lambda
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnexpectedLambdaException`](crate::error::UnexpectedLambdaException)
        pub fn build(self) -> crate::error::UnexpectedLambdaException {
            crate::error::UnexpectedLambdaException {
                message: self.message,
            }
        }
    }
}
impl UnexpectedLambdaException {
    /// Creates a new builder-style object to manufacture [`UnexpectedLambdaException`](crate::error::UnexpectedLambdaException)
    pub fn builder() -> crate::error::unexpected_lambda_exception::Builder {
        crate::error::unexpected_lambda_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an invalid AWS
/// Lambda response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidLambdaResponseException {
    /// <p>The message returned when the Amazon Cognito service throws an invalid AWS Lambda
    /// response exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidLambdaResponseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidLambdaResponseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidLambdaResponseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLambdaResponseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLambdaResponseException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLambdaResponseException {}
/// See [`InvalidLambdaResponseException`](crate::error::InvalidLambdaResponseException)
pub mod invalid_lambda_response_exception {
    /// A builder for [`InvalidLambdaResponseException`](crate::error::InvalidLambdaResponseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service throws an invalid AWS Lambda
        /// response exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLambdaResponseException`](crate::error::InvalidLambdaResponseException)
        pub fn build(self) -> crate::error::InvalidLambdaResponseException {
            crate::error::InvalidLambdaResponseException {
                message: self.message,
            }
        }
    }
}
impl InvalidLambdaResponseException {
    /// Creates a new builder-style object to manufacture [`InvalidLambdaResponseException`](crate::error::InvalidLambdaResponseException)
    pub fn builder() -> crate::error::invalid_lambda_response_exception::Builder {
        crate::error::invalid_lambda_response_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a verification code fails to deliver
/// successfully.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CodeDeliveryFailureException {
    /// <p>The message sent when a verification code fails to deliver successfully.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CodeDeliveryFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CodeDeliveryFailureException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CodeDeliveryFailureException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CodeDeliveryFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CodeDeliveryFailureException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for CodeDeliveryFailureException {}
/// See [`CodeDeliveryFailureException`](crate::error::CodeDeliveryFailureException)
pub mod code_delivery_failure_exception {
    /// A builder for [`CodeDeliveryFailureException`](crate::error::CodeDeliveryFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message sent when a verification code fails to deliver successfully.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CodeDeliveryFailureException`](crate::error::CodeDeliveryFailureException)
        pub fn build(self) -> crate::error::CodeDeliveryFailureException {
            crate::error::CodeDeliveryFailureException {
                message: self.message,
            }
        }
    }
}
impl CodeDeliveryFailureException {
    /// Creates a new builder-style object to manufacture [`CodeDeliveryFailureException`](crate::error::CodeDeliveryFailureException)
    pub fn builder() -> crate::error::code_delivery_failure_exception::Builder {
        crate::error::code_delivery_failure_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a user tries to confirm the account with an email or
/// phone number that has already been supplied as an alias from a different account. This
/// exception tells user that an account with this email or phone already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AliasExistsException {
    /// <p>The message sent to the user when an alias exists.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AliasExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AliasExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AliasExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AliasExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AliasExistsException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for AliasExistsException {}
/// See [`AliasExistsException`](crate::error::AliasExistsException)
pub mod alias_exists_exception {
    /// A builder for [`AliasExistsException`](crate::error::AliasExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message sent to the user when an alias exists.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AliasExistsException`](crate::error::AliasExistsException)
        pub fn build(self) -> crate::error::AliasExistsException {
            crate::error::AliasExistsException {
                message: self.message,
            }
        }
    }
}
impl AliasExistsException {
    /// Creates a new builder-style object to manufacture [`AliasExistsException`](crate::error::AliasExistsException)
    pub fn builder() -> crate::error::alias_exists_exception::Builder {
        crate::error::alias_exists_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the specified identifier is not supported.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedIdentityProviderException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedIdentityProviderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedIdentityProviderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedIdentityProviderException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedIdentityProviderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedIdentityProviderException")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedIdentityProviderException {}
/// See [`UnsupportedIdentityProviderException`](crate::error::UnsupportedIdentityProviderException)
pub mod unsupported_identity_provider_exception {
    /// A builder for [`UnsupportedIdentityProviderException`](crate::error::UnsupportedIdentityProviderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedIdentityProviderException`](crate::error::UnsupportedIdentityProviderException)
        pub fn build(self) -> crate::error::UnsupportedIdentityProviderException {
            crate::error::UnsupportedIdentityProviderException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedIdentityProviderException {
    /// Creates a new builder-style object to manufacture [`UnsupportedIdentityProviderException`](crate::error::UnsupportedIdentityProviderException)
    pub fn builder() -> crate::error::unsupported_identity_provider_exception::Builder {
        crate::error::unsupported_identity_provider_exception::Builder::default()
    }
}

/// <p>This exception is thrown when user pool add-ons are not enabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserPoolAddOnNotEnabledException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserPoolAddOnNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserPoolAddOnNotEnabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserPoolAddOnNotEnabledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserPoolAddOnNotEnabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserPoolAddOnNotEnabledException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserPoolAddOnNotEnabledException {}
/// See [`UserPoolAddOnNotEnabledException`](crate::error::UserPoolAddOnNotEnabledException)
pub mod user_pool_add_on_not_enabled_exception {
    /// A builder for [`UserPoolAddOnNotEnabledException`](crate::error::UserPoolAddOnNotEnabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserPoolAddOnNotEnabledException`](crate::error::UserPoolAddOnNotEnabledException)
        pub fn build(self) -> crate::error::UserPoolAddOnNotEnabledException {
            crate::error::UserPoolAddOnNotEnabledException {
                message: self.message,
            }
        }
    }
}
impl UserPoolAddOnNotEnabledException {
    /// Creates a new builder-style object to manufacture [`UserPoolAddOnNotEnabledException`](crate::error::UserPoolAddOnNotEnabledException)
    pub fn builder() -> crate::error::user_pool_add_on_not_enabled_exception::Builder {
        crate::error::user_pool_add_on_not_enabled_exception::Builder::default()
    }
}

/// <p>This exception is thrown when a precondition is not met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionNotMetException {
    /// <p>The message returned when a precondition is not met.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionNotMetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionNotMetException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionNotMetException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionNotMetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionNotMetException")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionNotMetException {}
/// See [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
pub mod precondition_not_met_exception {
    /// A builder for [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when a precondition is not met.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
        pub fn build(self) -> crate::error::PreconditionNotMetException {
            crate::error::PreconditionNotMetException {
                message: self.message,
            }
        }
    }
}
impl PreconditionNotMetException {
    /// Creates a new builder-style object to manufacture [`PreconditionNotMetException`](crate::error::PreconditionNotMetException)
    pub fn builder() -> crate::error::precondition_not_met_exception::Builder {
        crate::error::precondition_not_met_exception::Builder::default()
    }
}

/// <p>This exception is thrown when Amazon Cognito encounters a user name that already
/// exists in the user pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UsernameExistsException {
    /// <p>The message returned when Amazon Cognito throws a user name exists exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UsernameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UsernameExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UsernameExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UsernameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UsernameExistsException")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for UsernameExistsException {}
/// See [`UsernameExistsException`](crate::error::UsernameExistsException)
pub mod username_exists_exception {
    /// A builder for [`UsernameExistsException`](crate::error::UsernameExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when Amazon Cognito throws a user name exists exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UsernameExistsException`](crate::error::UsernameExistsException)
        pub fn build(self) -> crate::error::UsernameExistsException {
            crate::error::UsernameExistsException {
                message: self.message,
            }
        }
    }
}
impl UsernameExistsException {
    /// Creates a new builder-style object to manufacture [`UsernameExistsException`](crate::error::UsernameExistsException)
    pub fn builder() -> crate::error::username_exists_exception::Builder {
        crate::error::username_exists_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the Amazon Cognito service encounters an invalid
/// password.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPasswordException {
    /// <p>The message returned when the Amazon Cognito service throws an invalid user password
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPasswordException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPasswordException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPasswordException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPasswordException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPasswordException")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPasswordException {}
/// See [`InvalidPasswordException`](crate::error::InvalidPasswordException)
pub mod invalid_password_exception {
    /// A builder for [`InvalidPasswordException`](crate::error::InvalidPasswordException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service throws an invalid user password
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPasswordException`](crate::error::InvalidPasswordException)
        pub fn build(self) -> crate::error::InvalidPasswordException {
            crate::error::InvalidPasswordException {
                message: self.message,
            }
        }
    }
}
impl InvalidPasswordException {
    /// Creates a new builder-style object to manufacture [`InvalidPasswordException`](crate::error::InvalidPasswordException)
    pub fn builder() -> crate::error::invalid_password_exception::Builder {
        crate::error::invalid_password_exception::Builder::default()
    }
}

/// <p>This exception is thrown when an unsupported token is passed to an operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedTokenTypeException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedTokenTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedTokenTypeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedTokenTypeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedTokenTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedTokenTypeException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedTokenTypeException {}
/// See [`UnsupportedTokenTypeException`](crate::error::UnsupportedTokenTypeException)
pub mod unsupported_token_type_exception {
    /// A builder for [`UnsupportedTokenTypeException`](crate::error::UnsupportedTokenTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedTokenTypeException`](crate::error::UnsupportedTokenTypeException)
        pub fn build(self) -> crate::error::UnsupportedTokenTypeException {
            crate::error::UnsupportedTokenTypeException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedTokenTypeException {
    /// Creates a new builder-style object to manufacture [`UnsupportedTokenTypeException`](crate::error::UnsupportedTokenTypeException)
    pub fn builder() -> crate::error::unsupported_token_type_exception::Builder {
        crate::error::unsupported_token_type_exception::Builder::default()
    }
}

/// <p>This exception is thrown when you attempt to perform an operation that is not enabled for the user pool client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedOperationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedOperationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedOperationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedOperationException")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedOperationException {}
/// See [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
pub mod unsupported_operation_exception {
    /// A builder for [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
        pub fn build(self) -> crate::error::UnsupportedOperationException {
            crate::error::UnsupportedOperationException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedOperationException {
    /// Creates a new builder-style object to manufacture [`UnsupportedOperationException`](crate::error::UnsupportedOperationException)
    pub fn builder() -> crate::error::unsupported_operation_exception::Builder {
        crate::error::unsupported_operation_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the request is not authorized. This can happen due to an invalid access token in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnauthorizedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnauthorizedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnauthorizedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnauthorizedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnauthorizedException")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnauthorizedException {}
/// See [`UnauthorizedException`](crate::error::UnauthorizedException)
pub mod unauthorized_exception {
    /// A builder for [`UnauthorizedException`](crate::error::UnauthorizedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnauthorizedException`](crate::error::UnauthorizedException)
        pub fn build(self) -> crate::error::UnauthorizedException {
            crate::error::UnauthorizedException {
                message: self.message,
            }
        }
    }
}
impl UnauthorizedException {
    /// Creates a new builder-style object to manufacture [`UnauthorizedException`](crate::error::UnauthorizedException)
    pub fn builder() -> crate::error::unauthorized_exception::Builder {
        crate::error::unauthorized_exception::Builder::default()
    }
}

/// <p>This exception is thrown when Amazon Cognito cannot find a multi-factor authentication
/// (MFA) method.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MfaMethodNotFoundException {
    /// <p>The message returned when Amazon Cognito throws an MFA method not found
    /// exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MfaMethodNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MfaMethodNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MfaMethodNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MfaMethodNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MfaMethodNotFoundException [MFAMethodNotFoundException]")?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for MfaMethodNotFoundException {}
/// See [`MfaMethodNotFoundException`](crate::error::MfaMethodNotFoundException)
pub mod mfa_method_not_found_exception {
    /// A builder for [`MfaMethodNotFoundException`](crate::error::MfaMethodNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when Amazon Cognito throws an MFA method not found
        /// exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MfaMethodNotFoundException`](crate::error::MfaMethodNotFoundException)
        pub fn build(self) -> crate::error::MfaMethodNotFoundException {
            crate::error::MfaMethodNotFoundException {
                message: self.message,
            }
        }
    }
}
impl MfaMethodNotFoundException {
    /// Creates a new builder-style object to manufacture [`MfaMethodNotFoundException`](crate::error::MfaMethodNotFoundException)
    pub fn builder() -> crate::error::mfa_method_not_found_exception::Builder {
        crate::error::mfa_method_not_found_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the provider is already supported by the user
/// pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateProviderException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateProviderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateProviderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateProviderException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateProviderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateProviderException")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateProviderException {}
/// See [`DuplicateProviderException`](crate::error::DuplicateProviderException)
pub mod duplicate_provider_exception {
    /// A builder for [`DuplicateProviderException`](crate::error::DuplicateProviderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateProviderException`](crate::error::DuplicateProviderException)
        pub fn build(self) -> crate::error::DuplicateProviderException {
            crate::error::DuplicateProviderException {
                message: self.message,
            }
        }
    }
}
impl DuplicateProviderException {
    /// Creates a new builder-style object to manufacture [`DuplicateProviderException`](crate::error::DuplicateProviderException)
    pub fn builder() -> crate::error::duplicate_provider_exception::Builder {
        crate::error::duplicate_provider_exception::Builder::default()
    }
}

/// <p>This exception is thrown when Amazon Cognito encounters a group that already exists in
/// the user pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GroupExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GroupExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GroupExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GroupExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GroupExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GroupExistsException")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for GroupExistsException {}
/// See [`GroupExistsException`](crate::error::GroupExistsException)
pub mod group_exists_exception {
    /// A builder for [`GroupExistsException`](crate::error::GroupExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GroupExistsException`](crate::error::GroupExistsException)
        pub fn build(self) -> crate::error::GroupExistsException {
            crate::error::GroupExistsException {
                message: self.message,
            }
        }
    }
}
impl GroupExistsException {
    /// Creates a new builder-style object to manufacture [`GroupExistsException`](crate::error::GroupExistsException)
    pub fn builder() -> crate::error::group_exists_exception::Builder {
        crate::error::group_exists_exception::Builder::default()
    }
}

/// <p>This exception is thrown when the user has made too many failed attempts for a given
/// action (e.g., sign in).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyFailedAttemptsException {
    /// <p>The message returned when the Amazon Cognito service returns a too many failed
    /// attempts exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyFailedAttemptsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyFailedAttemptsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyFailedAttemptsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyFailedAttemptsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyFailedAttemptsException")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyFailedAttemptsException {}
/// See [`TooManyFailedAttemptsException`](crate::error::TooManyFailedAttemptsException)
pub mod too_many_failed_attempts_exception {
    /// A builder for [`TooManyFailedAttemptsException`](crate::error::TooManyFailedAttemptsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the Amazon Cognito service returns a too many failed
        /// attempts exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyFailedAttemptsException`](crate::error::TooManyFailedAttemptsException)
        pub fn build(self) -> crate::error::TooManyFailedAttemptsException {
            crate::error::TooManyFailedAttemptsException {
                message: self.message,
            }
        }
    }
}
impl TooManyFailedAttemptsException {
    /// Creates a new builder-style object to manufacture [`TooManyFailedAttemptsException`](crate::error::TooManyFailedAttemptsException)
    pub fn builder() -> crate::error::too_many_failed_attempts_exception::Builder {
        crate::error::too_many_failed_attempts_exception::Builder::default()
    }
}

/// <p>The request failed because the user is in an unsupported state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedUserStateException {
    /// <p>The message returned when the user is in an unsupported state.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedUserStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedUserStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedUserStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedUserStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedUserStateException")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedUserStateException {}
/// See [`UnsupportedUserStateException`](crate::error::UnsupportedUserStateException)
pub mod unsupported_user_state_exception {
    /// A builder for [`UnsupportedUserStateException`](crate::error::UnsupportedUserStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message returned when the user is in an unsupported state.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedUserStateException`](crate::error::UnsupportedUserStateException)
        pub fn build(self) -> crate::error::UnsupportedUserStateException {
            crate::error::UnsupportedUserStateException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedUserStateException {
    /// Creates a new builder-style object to manufacture [`UnsupportedUserStateException`](crate::error::UnsupportedUserStateException)
    pub fn builder() -> crate::error::unsupported_user_state_exception::Builder {
        crate::error::unsupported_user_state_exception::Builder::default()
    }
}
