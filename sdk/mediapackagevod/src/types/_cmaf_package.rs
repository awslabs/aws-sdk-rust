// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// A CMAF packaging configuration.
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CmafPackage {
    /// A CMAF encryption configuration.
    pub encryption: ::std::option::Option<crate::types::CmafEncryption>,
    /// A list of HLS manifest configurations.
    pub hls_manifests: ::std::option::Option<::std::vec::Vec<crate::types::HlsManifest>>,
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    pub include_encoder_configuration_in_segments: ::std::option::Option<bool>,
    /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
    pub segment_duration_seconds: ::std::option::Option<i32>,
}
impl CmafPackage {
    /// A CMAF encryption configuration.
    pub fn encryption(&self) -> ::std::option::Option<&crate::types::CmafEncryption> {
        self.encryption.as_ref()
    }
    /// A list of HLS manifest configurations.
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.hls_manifests.is_none()`.
    pub fn hls_manifests(&self) -> &[crate::types::HlsManifest] {
        self.hls_manifests.as_deref().unwrap_or_default()
    }
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    pub fn include_encoder_configuration_in_segments(&self) -> ::std::option::Option<bool> {
        self.include_encoder_configuration_in_segments
    }
    /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
    pub fn segment_duration_seconds(&self) -> ::std::option::Option<i32> {
        self.segment_duration_seconds
    }
}
impl CmafPackage {
    /// Creates a new builder-style object to manufacture [`CmafPackage`](crate::types::CmafPackage).
    pub fn builder() -> crate::types::builders::CmafPackageBuilder {
        crate::types::builders::CmafPackageBuilder::default()
    }
}

/// A builder for [`CmafPackage`](crate::types::CmafPackage).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CmafPackageBuilder {
    pub(crate) encryption: ::std::option::Option<crate::types::CmafEncryption>,
    pub(crate) hls_manifests: ::std::option::Option<::std::vec::Vec<crate::types::HlsManifest>>,
    pub(crate) include_encoder_configuration_in_segments: ::std::option::Option<bool>,
    pub(crate) segment_duration_seconds: ::std::option::Option<i32>,
}
impl CmafPackageBuilder {
    /// A CMAF encryption configuration.
    pub fn encryption(mut self, input: crate::types::CmafEncryption) -> Self {
        self.encryption = ::std::option::Option::Some(input);
        self
    }
    /// A CMAF encryption configuration.
    pub fn set_encryption(mut self, input: ::std::option::Option<crate::types::CmafEncryption>) -> Self {
        self.encryption = input;
        self
    }
    /// A CMAF encryption configuration.
    pub fn get_encryption(&self) -> &::std::option::Option<crate::types::CmafEncryption> {
        &self.encryption
    }
    /// Appends an item to `hls_manifests`.
    ///
    /// To override the contents of this collection use [`set_hls_manifests`](Self::set_hls_manifests).
    ///
    /// A list of HLS manifest configurations.
    pub fn hls_manifests(mut self, input: crate::types::HlsManifest) -> Self {
        let mut v = self.hls_manifests.unwrap_or_default();
        v.push(input);
        self.hls_manifests = ::std::option::Option::Some(v);
        self
    }
    /// A list of HLS manifest configurations.
    pub fn set_hls_manifests(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::HlsManifest>>) -> Self {
        self.hls_manifests = input;
        self
    }
    /// A list of HLS manifest configurations.
    pub fn get_hls_manifests(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::HlsManifest>> {
        &self.hls_manifests
    }
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    pub fn include_encoder_configuration_in_segments(mut self, input: bool) -> Self {
        self.include_encoder_configuration_in_segments = ::std::option::Option::Some(input);
        self
    }
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    pub fn set_include_encoder_configuration_in_segments(mut self, input: ::std::option::Option<bool>) -> Self {
        self.include_encoder_configuration_in_segments = input;
        self
    }
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    pub fn get_include_encoder_configuration_in_segments(&self) -> &::std::option::Option<bool> {
        &self.include_encoder_configuration_in_segments
    }
    /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
    pub fn segment_duration_seconds(mut self, input: i32) -> Self {
        self.segment_duration_seconds = ::std::option::Option::Some(input);
        self
    }
    /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
    pub fn set_segment_duration_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.segment_duration_seconds = input;
        self
    }
    /// Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
    pub fn get_segment_duration_seconds(&self) -> &::std::option::Option<i32> {
        &self.segment_duration_seconds
    }
    /// Consumes the builder and constructs a [`CmafPackage`](crate::types::CmafPackage).
    pub fn build(self) -> crate::types::CmafPackage {
        crate::types::CmafPackage {
            encryption: self.encryption,
            hls_manifests: self.hls_manifests,
            include_encoder_configuration_in_segments: self.include_encoder_configuration_in_segments,
            segment_duration_seconds: self.segment_duration_seconds,
        }
    }
}
