// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::start_browser_session::_start_browser_session_input::StartBrowserSessionInputBuilder;

pub use crate::operation::start_browser_session::_start_browser_session_output::StartBrowserSessionOutputBuilder;

impl crate::operation::start_browser_session::builders::StartBrowserSessionInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::start_browser_session::StartBrowserSessionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_browser_session::StartBrowserSessionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.start_browser_session();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `StartBrowserSession`.
///
/// <p>Creates and initializes a browser session in Amazon Bedrock AgentCore. The session enables agents to navigate and interact with web content, extract information from websites, and perform web-based tasks as part of their response generation.</p>
/// <p>To create a session, you must specify a browser identifier and a name. You can also configure the viewport dimensions to control the visible area of web content. The session remains active until it times out or you explicitly stop it using the <code>StopBrowserSession</code> operation.</p>
/// <p>The following operations are related to <code>StartBrowserSession</code>:</p>
/// <ul>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/bedrock-agentcore/latest/APIReference/API_GetBrowserSession.html">GetBrowserSession</a></p></li>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/bedrock-agentcore/latest/APIReference/API_UpdateBrowserStream.html">UpdateBrowserStream</a></p></li>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/bedrock-agentcore/latest/APIReference/API_SaveBrowserSessionProfile.html">SaveBrowserSessionProfile</a></p></li>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/bedrock-agentcore/latest/APIReference/API_StopBrowserSession.html">StopBrowserSession</a></p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct StartBrowserSessionFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::start_browser_session::builders::StartBrowserSessionInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::start_browser_session::StartBrowserSessionOutput,
        crate::operation::start_browser_session::StartBrowserSessionError,
    > for StartBrowserSessionFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::start_browser_session::StartBrowserSessionOutput,
            crate::operation::start_browser_session::StartBrowserSessionError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl StartBrowserSessionFluentBuilder {
    /// Creates a new `StartBrowserSessionFluentBuilder`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the StartBrowserSession as a reference.
    pub fn as_input(&self) -> &crate::operation::start_browser_session::builders::StartBrowserSessionInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::start_browser_session::StartBrowserSessionOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::start_browser_session::StartBrowserSessionError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::start_browser_session::StartBrowserSession::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::start_browser_session::StartBrowserSession::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::start_browser_session::StartBrowserSessionOutput,
        crate::operation::start_browser_session::StartBrowserSessionError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn trace_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.trace_id(input.into());
        self
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn set_trace_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_trace_id(input);
        self
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn get_trace_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_trace_id()
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn trace_parent(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.trace_parent(input.into());
        self
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn set_trace_parent(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_trace_parent(input);
        self
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn get_trace_parent(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_trace_parent()
    }
    /// <p>The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.</p>
    pub fn browser_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.browser_identifier(input.into());
        self
    }
    /// <p>The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.</p>
    pub fn set_browser_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_browser_identifier(input);
        self
    }
    /// <p>The unique identifier of the browser to use for this session. This identifier specifies which browser environment to initialize for the session.</p>
    pub fn get_browser_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_browser_identifier()
    }
    /// <p>The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the browser session. This name helps you identify and manage the session. The name does not need to be unique.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).</p>
    pub fn session_timeout_seconds(mut self, input: i32) -> Self {
        self.inner = self.inner.session_timeout_seconds(input);
        self
    }
    /// <p>The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).</p>
    pub fn set_session_timeout_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_session_timeout_seconds(input);
        self
    }
    /// <p>The time in seconds after which the session automatically terminates if there is no activity. The default value is 3600 seconds (1 hour). The minimum allowed value is 60 seconds, and the maximum allowed value is 28800 seconds (8 hours).</p>
    pub fn get_session_timeout_seconds(&self) -> &::std::option::Option<i32> {
        self.inner.get_session_timeout_seconds()
    }
    /// <p>The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock AgentCore uses a default viewport size.</p>
    pub fn view_port(mut self, input: crate::types::ViewPort) -> Self {
        self.inner = self.inner.view_port(input);
        self
    }
    /// <p>The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock AgentCore uses a default viewport size.</p>
    pub fn set_view_port(mut self, input: ::std::option::Option<crate::types::ViewPort>) -> Self {
        self.inner = self.inner.set_view_port(input);
        self
    }
    /// <p>The dimensions of the browser viewport for this session. This determines the visible area of the web content and affects how web pages are rendered. If not specified, Amazon Bedrock AgentCore uses a default viewport size.</p>
    pub fn get_view_port(&self) -> &::std::option::Option<crate::types::ViewPort> {
        self.inner.get_view_port()
    }
    ///
    /// Appends an item to `extensions`.
    ///
    /// To override the contents of this collection use [`set_extensions`](Self::set_extensions).
    ///
    /// <p>A list of browser extensions to load into the browser session.</p>
    pub fn extensions(mut self, input: crate::types::BrowserExtension) -> Self {
        self.inner = self.inner.extensions(input);
        self
    }
    /// <p>A list of browser extensions to load into the browser session.</p>
    pub fn set_extensions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::BrowserExtension>>) -> Self {
        self.inner = self.inner.set_extensions(input);
        self
    }
    /// <p>A list of browser extensions to load into the browser session.</p>
    pub fn get_extensions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::BrowserExtension>> {
        self.inner.get_extensions()
    }
    /// <p>The browser profile configuration to use for this session. A browser profile contains persistent data such as cookies and local storage that can be reused across multiple browser sessions. If specified, the session initializes with the profile's stored data, enabling continuity for tasks that require authentication or personalized settings.</p>
    pub fn profile_configuration(mut self, input: crate::types::BrowserProfileConfiguration) -> Self {
        self.inner = self.inner.profile_configuration(input);
        self
    }
    /// <p>The browser profile configuration to use for this session. A browser profile contains persistent data such as cookies and local storage that can be reused across multiple browser sessions. If specified, the session initializes with the profile's stored data, enabling continuity for tasks that require authentication or personalized settings.</p>
    pub fn set_profile_configuration(mut self, input: ::std::option::Option<crate::types::BrowserProfileConfiguration>) -> Self {
        self.inner = self.inner.set_profile_configuration(input);
        self
    }
    /// <p>The browser profile configuration to use for this session. A browser profile contains persistent data such as cookies and local storage that can be reused across multiple browser sessions. If specified, the session initializes with the profile's stored data, enabling continuity for tasks that require authentication or personalized settings.</p>
    pub fn get_profile_configuration(&self) -> &::std::option::Option<crate::types::BrowserProfileConfiguration> {
        self.inner.get_profile_configuration()
    }
    /// <p>Optional proxy configuration for routing browser traffic through customer-specified proxy servers. When provided, enables HTTP Basic authentication via Amazon Web Services Secrets Manager and domain-based routing rules. Requires <code>secretsmanager:GetSecretValue</code> IAM permission for the specified secret ARNs.</p>
    pub fn proxy_configuration(mut self, input: crate::types::ProxyConfiguration) -> Self {
        self.inner = self.inner.proxy_configuration(input);
        self
    }
    /// <p>Optional proxy configuration for routing browser traffic through customer-specified proxy servers. When provided, enables HTTP Basic authentication via Amazon Web Services Secrets Manager and domain-based routing rules. Requires <code>secretsmanager:GetSecretValue</code> IAM permission for the specified secret ARNs.</p>
    pub fn set_proxy_configuration(mut self, input: ::std::option::Option<crate::types::ProxyConfiguration>) -> Self {
        self.inner = self.inner.set_proxy_configuration(input);
        self
    }
    /// <p>Optional proxy configuration for routing browser traffic through customer-specified proxy servers. When provided, enables HTTP Basic authentication via Amazon Web Services Secrets Manager and domain-based routing rules. Requires <code>secretsmanager:GetSecretValue</code> IAM permission for the specified secret ARNs.</p>
    pub fn get_proxy_configuration(&self) -> &::std::option::Option<crate::types::ProxyConfiguration> {
        self.inner.get_proxy_configuration()
    }
    /// <p>A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock AgentCore ignores the request, but does not return an error. This parameter helps prevent the creation of duplicate sessions if there are temporary network issues.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
}
