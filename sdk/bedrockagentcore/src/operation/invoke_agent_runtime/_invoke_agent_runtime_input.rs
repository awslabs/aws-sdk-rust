// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct InvokeAgentRuntimeInput {
    /// <p>The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.</p>
    pub content_type: ::std::option::Option<::std::string::String>,
    /// <p>The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.</p>
    pub accept: ::std::option::Option<::std::string::String>,
    /// <p>The identifier of the MCP session.</p>
    pub mcp_session_id: ::std::option::Option<::std::string::String>,
    /// <p>The identifier of the runtime session.</p>
    pub runtime_session_id: ::std::option::Option<::std::string::String>,
    /// <p>The version of the MCP protocol being used.</p>
    pub mcp_protocol_version: ::std::option::Option<::std::string::String>,
    /// <p>The identifier of the runtime user.</p>
    pub runtime_user_id: ::std::option::Option<::std::string::String>,
    /// <p>The trace identifier for request tracking.</p>
    pub trace_id: ::std::option::Option<::std::string::String>,
    /// <p>The parent trace information for distributed tracing.</p>
    pub trace_parent: ::std::option::Option<::std::string::String>,
    /// <p>The trace state information for distributed tracing.</p>
    pub trace_state: ::std::option::Option<::std::string::String>,
    /// <p>Additional context information for distributed tracing.</p>
    pub baggage: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.</p>
    pub agent_runtime_arn: ::std::option::Option<::std::string::String>,
    /// <p>The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.</p>
    pub qualifier: ::std::option::Option<::std::string::String>,
    /// <p>The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.</p>
    pub payload: ::std::option::Option<::aws_smithy_types::Blob>,
}
impl InvokeAgentRuntimeInput {
    /// <p>The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.</p>
    pub fn content_type(&self) -> ::std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.</p>
    pub fn accept(&self) -> ::std::option::Option<&str> {
        self.accept.as_deref()
    }
    /// <p>The identifier of the MCP session.</p>
    pub fn mcp_session_id(&self) -> ::std::option::Option<&str> {
        self.mcp_session_id.as_deref()
    }
    /// <p>The identifier of the runtime session.</p>
    pub fn runtime_session_id(&self) -> ::std::option::Option<&str> {
        self.runtime_session_id.as_deref()
    }
    /// <p>The version of the MCP protocol being used.</p>
    pub fn mcp_protocol_version(&self) -> ::std::option::Option<&str> {
        self.mcp_protocol_version.as_deref()
    }
    /// <p>The identifier of the runtime user.</p>
    pub fn runtime_user_id(&self) -> ::std::option::Option<&str> {
        self.runtime_user_id.as_deref()
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn trace_id(&self) -> ::std::option::Option<&str> {
        self.trace_id.as_deref()
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn trace_parent(&self) -> ::std::option::Option<&str> {
        self.trace_parent.as_deref()
    }
    /// <p>The trace state information for distributed tracing.</p>
    pub fn trace_state(&self) -> ::std::option::Option<&str> {
        self.trace_state.as_deref()
    }
    /// <p>Additional context information for distributed tracing.</p>
    pub fn baggage(&self) -> ::std::option::Option<&str> {
        self.baggage.as_deref()
    }
    /// <p>The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.</p>
    pub fn agent_runtime_arn(&self) -> ::std::option::Option<&str> {
        self.agent_runtime_arn.as_deref()
    }
    /// <p>The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.</p>
    pub fn qualifier(&self) -> ::std::option::Option<&str> {
        self.qualifier.as_deref()
    }
    /// <p>The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.</p>
    pub fn payload(&self) -> ::std::option::Option<&::aws_smithy_types::Blob> {
        self.payload.as_ref()
    }
}
impl ::std::fmt::Debug for InvokeAgentRuntimeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvokeAgentRuntimeInput");
        formatter.field("content_type", &self.content_type);
        formatter.field("accept", &self.accept);
        formatter.field("mcp_session_id", &self.mcp_session_id);
        formatter.field("runtime_session_id", &self.runtime_session_id);
        formatter.field("mcp_protocol_version", &self.mcp_protocol_version);
        formatter.field("runtime_user_id", &self.runtime_user_id);
        formatter.field("trace_id", &self.trace_id);
        formatter.field("trace_parent", &self.trace_parent);
        formatter.field("trace_state", &self.trace_state);
        formatter.field("baggage", &self.baggage);
        formatter.field("agent_runtime_arn", &self.agent_runtime_arn);
        formatter.field("qualifier", &self.qualifier);
        formatter.field("payload", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl InvokeAgentRuntimeInput {
    /// Creates a new builder-style object to manufacture [`InvokeAgentRuntimeInput`](crate::operation::invoke_agent_runtime::InvokeAgentRuntimeInput).
    pub fn builder() -> crate::operation::invoke_agent_runtime::builders::InvokeAgentRuntimeInputBuilder {
        crate::operation::invoke_agent_runtime::builders::InvokeAgentRuntimeInputBuilder::default()
    }
}

/// A builder for [`InvokeAgentRuntimeInput`](crate::operation::invoke_agent_runtime::InvokeAgentRuntimeInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct InvokeAgentRuntimeInputBuilder {
    pub(crate) content_type: ::std::option::Option<::std::string::String>,
    pub(crate) accept: ::std::option::Option<::std::string::String>,
    pub(crate) mcp_session_id: ::std::option::Option<::std::string::String>,
    pub(crate) runtime_session_id: ::std::option::Option<::std::string::String>,
    pub(crate) mcp_protocol_version: ::std::option::Option<::std::string::String>,
    pub(crate) runtime_user_id: ::std::option::Option<::std::string::String>,
    pub(crate) trace_id: ::std::option::Option<::std::string::String>,
    pub(crate) trace_parent: ::std::option::Option<::std::string::String>,
    pub(crate) trace_state: ::std::option::Option<::std::string::String>,
    pub(crate) baggage: ::std::option::Option<::std::string::String>,
    pub(crate) agent_runtime_arn: ::std::option::Option<::std::string::String>,
    pub(crate) qualifier: ::std::option::Option<::std::string::String>,
    pub(crate) payload: ::std::option::Option<::aws_smithy_types::Blob>,
}
impl InvokeAgentRuntimeInputBuilder {
    /// <p>The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.</p>
    pub fn content_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.</p>
    pub fn set_content_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_type = input;
        self
    }
    /// <p>The MIME type of the input data in the payload. This tells the agent runtime how to interpret the payload data. Common values include application/json for JSON data.</p>
    pub fn get_content_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_type
    }
    /// <p>The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.</p>
    pub fn accept(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.accept = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.</p>
    pub fn set_accept(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.accept = input;
        self
    }
    /// <p>The desired MIME type for the response from the agent runtime. This tells the agent runtime what format to use for the response data. Common values include application/json for JSON data.</p>
    pub fn get_accept(&self) -> &::std::option::Option<::std::string::String> {
        &self.accept
    }
    /// <p>The identifier of the MCP session.</p>
    pub fn mcp_session_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.mcp_session_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the MCP session.</p>
    pub fn set_mcp_session_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.mcp_session_id = input;
        self
    }
    /// <p>The identifier of the MCP session.</p>
    pub fn get_mcp_session_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.mcp_session_id
    }
    /// <p>The identifier of the runtime session.</p>
    pub fn runtime_session_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.runtime_session_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the runtime session.</p>
    pub fn set_runtime_session_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.runtime_session_id = input;
        self
    }
    /// <p>The identifier of the runtime session.</p>
    pub fn get_runtime_session_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.runtime_session_id
    }
    /// <p>The version of the MCP protocol being used.</p>
    pub fn mcp_protocol_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.mcp_protocol_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version of the MCP protocol being used.</p>
    pub fn set_mcp_protocol_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.mcp_protocol_version = input;
        self
    }
    /// <p>The version of the MCP protocol being used.</p>
    pub fn get_mcp_protocol_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.mcp_protocol_version
    }
    /// <p>The identifier of the runtime user.</p>
    pub fn runtime_user_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.runtime_user_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the runtime user.</p>
    pub fn set_runtime_user_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.runtime_user_id = input;
        self
    }
    /// <p>The identifier of the runtime user.</p>
    pub fn get_runtime_user_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.runtime_user_id
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn trace_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.trace_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn set_trace_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.trace_id = input;
        self
    }
    /// <p>The trace identifier for request tracking.</p>
    pub fn get_trace_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.trace_id
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn trace_parent(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.trace_parent = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn set_trace_parent(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.trace_parent = input;
        self
    }
    /// <p>The parent trace information for distributed tracing.</p>
    pub fn get_trace_parent(&self) -> &::std::option::Option<::std::string::String> {
        &self.trace_parent
    }
    /// <p>The trace state information for distributed tracing.</p>
    pub fn trace_state(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.trace_state = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The trace state information for distributed tracing.</p>
    pub fn set_trace_state(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.trace_state = input;
        self
    }
    /// <p>The trace state information for distributed tracing.</p>
    pub fn get_trace_state(&self) -> &::std::option::Option<::std::string::String> {
        &self.trace_state
    }
    /// <p>Additional context information for distributed tracing.</p>
    pub fn baggage(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.baggage = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Additional context information for distributed tracing.</p>
    pub fn set_baggage(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.baggage = input;
        self
    }
    /// <p>Additional context information for distributed tracing.</p>
    pub fn get_baggage(&self) -> &::std::option::Option<::std::string::String> {
        &self.baggage
    }
    /// <p>The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.</p>
    /// This field is required.
    pub fn agent_runtime_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.agent_runtime_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.</p>
    pub fn set_agent_runtime_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.agent_runtime_arn = input;
        self
    }
    /// <p>The Amazon Web Services Resource Name (ARN) of the agent runtime to invoke. The ARN uniquely identifies the agent runtime resource in Amazon Bedrock.</p>
    pub fn get_agent_runtime_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.agent_runtime_arn
    }
    /// <p>The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.</p>
    pub fn qualifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.qualifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.</p>
    pub fn set_qualifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.qualifier = input;
        self
    }
    /// <p>The qualifier to use for the agent runtime. This can be a version number or an alias name that points to a specific version. If not specified, Amazon Bedrock uses the default version of the agent runtime.</p>
    pub fn get_qualifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.qualifier
    }
    /// <p>The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.</p>
    /// This field is required.
    pub fn payload(mut self, input: ::aws_smithy_types::Blob) -> Self {
        self.payload = ::std::option::Option::Some(input);
        self
    }
    /// <p>The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.</p>
    pub fn set_payload(mut self, input: ::std::option::Option<::aws_smithy_types::Blob>) -> Self {
        self.payload = input;
        self
    }
    /// <p>The input data to send to the agent runtime. The format of this data depends on the specific agent configuration and must match the specified content type. For most agents, this is a JSON object containing the user's request.</p>
    pub fn get_payload(&self) -> &::std::option::Option<::aws_smithy_types::Blob> {
        &self.payload
    }
    /// Consumes the builder and constructs a [`InvokeAgentRuntimeInput`](crate::operation::invoke_agent_runtime::InvokeAgentRuntimeInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::invoke_agent_runtime::InvokeAgentRuntimeInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::invoke_agent_runtime::InvokeAgentRuntimeInput {
            content_type: self.content_type,
            accept: self.accept,
            mcp_session_id: self.mcp_session_id,
            runtime_session_id: self.runtime_session_id,
            mcp_protocol_version: self.mcp_protocol_version,
            runtime_user_id: self.runtime_user_id,
            trace_id: self.trace_id,
            trace_parent: self.trace_parent,
            trace_state: self.trace_state,
            baggage: self.baggage,
            agent_runtime_arn: self.agent_runtime_arn,
            qualifier: self.qualifier,
            payload: self.payload,
        })
    }
}
impl ::std::fmt::Debug for InvokeAgentRuntimeInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("InvokeAgentRuntimeInputBuilder");
        formatter.field("content_type", &self.content_type);
        formatter.field("accept", &self.accept);
        formatter.field("mcp_session_id", &self.mcp_session_id);
        formatter.field("runtime_session_id", &self.runtime_session_id);
        formatter.field("mcp_protocol_version", &self.mcp_protocol_version);
        formatter.field("runtime_user_id", &self.runtime_user_id);
        formatter.field("trace_id", &self.trace_id);
        formatter.field("trace_parent", &self.trace_parent);
        formatter.field("trace_state", &self.trace_state);
        formatter.field("baggage", &self.baggage);
        formatter.field("agent_runtime_arn", &self.agent_runtime_arn);
        formatter.field("qualifier", &self.qualifier);
        formatter.field("payload", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
