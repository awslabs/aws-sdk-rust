// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`CreateProfileInput`](crate::input::CreateProfileInput).
pub mod create_profile_input {
    
    /// A builder for [`CreateProfileInput`](crate::input::CreateProfileInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) require_instance_properties: std::option::Option<bool>,
        pub(crate) session_policy: std::option::Option<std::string::String>,
        pub(crate) role_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) managed_policy_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) duration_seconds: std::option::Option<i32>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Specifies whether instance properties are required in <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> requests with this profile. </p>
        pub fn require_instance_properties(mut self, input: bool) -> Self {
            self.require_instance_properties = Some(input);
            self
        }
        /// <p>Specifies whether instance properties are required in <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> requests with this profile. </p>
        pub fn set_require_instance_properties(mut self, input: std::option::Option<bool>) -> Self {
            self.require_instance_properties = input; self
        }
        /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
        pub fn session_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_policy = Some(input.into());
            self
        }
        /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
        pub fn set_session_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_policy = input; self
        }
        /// Appends an item to `role_arns`.
        ///
        /// To override the contents of this collection use [`set_role_arns`](Self::set_role_arns).
        ///
        /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
        pub fn role_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.role_arns.unwrap_or_default();
                            v.push(input.into());
                            self.role_arns = Some(v);
                            self
        }
        /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
        pub fn set_role_arns(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.role_arns = input; self
        }
        /// Appends an item to `managed_policy_arns`.
        ///
        /// To override the contents of this collection use [`set_managed_policy_arns`](Self::set_managed_policy_arns).
        ///
        /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
        pub fn managed_policy_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.managed_policy_arns.unwrap_or_default();
                            v.push(input.into());
                            self.managed_policy_arns = Some(v);
                            self
        }
        /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
        pub fn set_managed_policy_arns(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.managed_policy_arns = input; self
        }
        /// <p> The number of seconds the vended session credentials are valid for. </p>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        /// <p> The number of seconds the vended session credentials are valid for. </p>
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input; self
        }
        /// <p>Specifies whether the profile is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the profile is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to attach to the profile.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags to attach to the profile.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateProfileInput`](crate::input::CreateProfileInput).
        pub fn build(self) -> Result<crate::input::CreateProfileInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateProfileInput {
                    name: self.name
                    ,
                    require_instance_properties: self.require_instance_properties
                    ,
                    session_policy: self.session_policy
                    ,
                    role_arns: self.role_arns
                    ,
                    managed_policy_arns: self.managed_policy_arns
                    ,
                    duration_seconds: self.duration_seconds
                    ,
                    enabled: self.enabled
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateProfileInput {
    /// Consumes the builder and constructs an Operation<[`CreateProfile`](crate::operation::CreateProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateProfile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateProfileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/profiles").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateProfileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_profile(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateProfile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateProfile", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateProfileInput`](crate::input::CreateProfileInput).
    pub fn builder() -> crate::input::create_profile_input::Builder {
        crate::input::create_profile_input::Builder::default()
    }
}

/// See [`CreateTrustAnchorInput`](crate::input::CreateTrustAnchorInput).
pub mod create_trust_anchor_input {
    
    /// A builder for [`CreateTrustAnchorInput`](crate::input::CreateTrustAnchorInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::Source>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the trust anchor.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the trust anchor.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The trust anchor type and its related certificate data.</p>
        pub fn source(mut self, input: crate::model::Source) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The trust anchor type and its related certificate data.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::Source>) -> Self {
            self.source = input; self
        }
        /// <p>Specifies whether the trust anchor is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the trust anchor is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to attach to the trust anchor.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags to attach to the trust anchor.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CreateTrustAnchorInput`](crate::input::CreateTrustAnchorInput).
        pub fn build(self) -> Result<crate::input::CreateTrustAnchorInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateTrustAnchorInput {
                    name: self.name
                    ,
                    source: self.source
                    ,
                    enabled: self.enabled
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl CreateTrustAnchorInput {
    /// Consumes the builder and constructs an Operation<[`CreateTrustAnchor`](crate::operation::CreateTrustAnchor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateTrustAnchor, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateTrustAnchorInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/trustanchors").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateTrustAnchorInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_trust_anchor(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateTrustAnchor::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateTrustAnchor", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateTrustAnchorInput`](crate::input::CreateTrustAnchorInput).
    pub fn builder() -> crate::input::create_trust_anchor_input::Builder {
        crate::input::create_trust_anchor_input::Builder::default()
    }
}

/// See [`DeleteCrlInput`](crate::input::DeleteCrlInput).
pub mod delete_crl_input {
    
    /// A builder for [`DeleteCrlInput`](crate::input::DeleteCrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn crl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.crl_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn set_crl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crl_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteCrlInput`](crate::input::DeleteCrlInput).
        pub fn build(self) -> Result<crate::input::DeleteCrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteCrlInput {
                    crl_id: self.crl_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteCrlInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCrl`](crate::operation::DeleteCrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteCrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteCrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.crl_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))?;
                let crl_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if crl_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))
                            }
                write!(output, "/crl/{crlId}", crlId = crl_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteCrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteCrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteCrl", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteCrlInput`](crate::input::DeleteCrlInput).
    pub fn builder() -> crate::input::delete_crl_input::Builder {
        crate::input::delete_crl_input::Builder::default()
    }
}

/// See [`DeleteProfileInput`](crate::input::DeleteProfileInput).
pub mod delete_profile_input {
    
    /// A builder for [`DeleteProfileInput`](crate::input::DeleteProfileInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the profile.</p>
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteProfileInput`](crate::input::DeleteProfileInput).
        pub fn build(self) -> Result<crate::input::DeleteProfileInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteProfileInput {
                    profile_id: self.profile_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteProfileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteProfile`](crate::operation::DeleteProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteProfile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteProfileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.profile_id;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))?;
                let profile_id = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if profile_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))
                            }
                write!(output, "/profile/{profileId}", profileId = profile_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteProfileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteProfile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteProfile", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteProfileInput`](crate::input::DeleteProfileInput).
    pub fn builder() -> crate::input::delete_profile_input::Builder {
        crate::input::delete_profile_input::Builder::default()
    }
}

/// See [`DeleteTrustAnchorInput`](crate::input::DeleteTrustAnchorInput).
pub mod delete_trust_anchor_input {
    
    /// A builder for [`DeleteTrustAnchorInput`](crate::input::DeleteTrustAnchorInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trust_anchor_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn trust_anchor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trust_anchor_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn set_trust_anchor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trust_anchor_id = input; self
        }
        /// Consumes the builder and constructs a [`DeleteTrustAnchorInput`](crate::input::DeleteTrustAnchorInput).
        pub fn build(self) -> Result<crate::input::DeleteTrustAnchorInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DeleteTrustAnchorInput {
                    trust_anchor_id: self.trust_anchor_id
                    ,
                }
            )
        }
    }
    
    
}
impl DeleteTrustAnchorInput {
    /// Consumes the builder and constructs an Operation<[`DeleteTrustAnchor`](crate::operation::DeleteTrustAnchor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DeleteTrustAnchor, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DeleteTrustAnchorInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.trust_anchor_id;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))?;
                let trust_anchor_id = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if trust_anchor_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))
                            }
                write!(output, "/trustanchor/{trustAnchorId}", trustAnchorId = trust_anchor_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DeleteTrustAnchorInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DeleteTrustAnchor::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteTrustAnchor", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DeleteTrustAnchorInput`](crate::input::DeleteTrustAnchorInput).
    pub fn builder() -> crate::input::delete_trust_anchor_input::Builder {
        crate::input::delete_trust_anchor_input::Builder::default()
    }
}

/// See [`DisableCrlInput`](crate::input::DisableCrlInput).
pub mod disable_crl_input {
    
    /// A builder for [`DisableCrlInput`](crate::input::DisableCrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn crl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.crl_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn set_crl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crl_id = input; self
        }
        /// Consumes the builder and constructs a [`DisableCrlInput`](crate::input::DisableCrlInput).
        pub fn build(self) -> Result<crate::input::DisableCrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisableCrlInput {
                    crl_id: self.crl_id
                    ,
                }
            )
        }
    }
    
    
}
impl DisableCrlInput {
    /// Consumes the builder and constructs an Operation<[`DisableCrl`](crate::operation::DisableCrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisableCrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisableCrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.crl_id;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))?;
                let crl_id = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if crl_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))
                            }
                write!(output, "/crl/{crlId}/disable", crlId = crl_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisableCrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisableCrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisableCrl", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisableCrlInput`](crate::input::DisableCrlInput).
    pub fn builder() -> crate::input::disable_crl_input::Builder {
        crate::input::disable_crl_input::Builder::default()
    }
}

/// See [`DisableProfileInput`](crate::input::DisableProfileInput).
pub mod disable_profile_input {
    
    /// A builder for [`DisableProfileInput`](crate::input::DisableProfileInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the profile.</p>
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input; self
        }
        /// Consumes the builder and constructs a [`DisableProfileInput`](crate::input::DisableProfileInput).
        pub fn build(self) -> Result<crate::input::DisableProfileInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisableProfileInput {
                    profile_id: self.profile_id
                    ,
                }
            )
        }
    }
    
    
}
impl DisableProfileInput {
    /// Consumes the builder and constructs an Operation<[`DisableProfile`](crate::operation::DisableProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisableProfile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisableProfileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.profile_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))?;
                let profile_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if profile_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))
                            }
                write!(output, "/profile/{profileId}/disable", profileId = profile_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisableProfileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisableProfile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisableProfile", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisableProfileInput`](crate::input::DisableProfileInput).
    pub fn builder() -> crate::input::disable_profile_input::Builder {
        crate::input::disable_profile_input::Builder::default()
    }
}

/// See [`DisableTrustAnchorInput`](crate::input::DisableTrustAnchorInput).
pub mod disable_trust_anchor_input {
    
    /// A builder for [`DisableTrustAnchorInput`](crate::input::DisableTrustAnchorInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trust_anchor_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn trust_anchor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trust_anchor_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn set_trust_anchor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trust_anchor_id = input; self
        }
        /// Consumes the builder and constructs a [`DisableTrustAnchorInput`](crate::input::DisableTrustAnchorInput).
        pub fn build(self) -> Result<crate::input::DisableTrustAnchorInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::DisableTrustAnchorInput {
                    trust_anchor_id: self.trust_anchor_id
                    ,
                }
            )
        }
    }
    
    
}
impl DisableTrustAnchorInput {
    /// Consumes the builder and constructs an Operation<[`DisableTrustAnchor`](crate::operation::DisableTrustAnchor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::DisableTrustAnchor, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::DisableTrustAnchorInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.trust_anchor_id;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))?;
                let trust_anchor_id = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if trust_anchor_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))
                            }
                write!(output, "/trustanchor/{trustAnchorId}/disable", trustAnchorId = trust_anchor_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::DisableTrustAnchorInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::DisableTrustAnchor::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DisableTrustAnchor", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`DisableTrustAnchorInput`](crate::input::DisableTrustAnchorInput).
    pub fn builder() -> crate::input::disable_trust_anchor_input::Builder {
        crate::input::disable_trust_anchor_input::Builder::default()
    }
}

/// See [`EnableCrlInput`](crate::input::EnableCrlInput).
pub mod enable_crl_input {
    
    /// A builder for [`EnableCrlInput`](crate::input::EnableCrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn crl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.crl_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn set_crl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crl_id = input; self
        }
        /// Consumes the builder and constructs a [`EnableCrlInput`](crate::input::EnableCrlInput).
        pub fn build(self) -> Result<crate::input::EnableCrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::EnableCrlInput {
                    crl_id: self.crl_id
                    ,
                }
            )
        }
    }
    
    
}
impl EnableCrlInput {
    /// Consumes the builder and constructs an Operation<[`EnableCrl`](crate::operation::EnableCrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::EnableCrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::EnableCrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.crl_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))?;
                let crl_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if crl_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))
                            }
                write!(output, "/crl/{crlId}/enable", crlId = crl_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::EnableCrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::EnableCrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("EnableCrl", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`EnableCrlInput`](crate::input::EnableCrlInput).
    pub fn builder() -> crate::input::enable_crl_input::Builder {
        crate::input::enable_crl_input::Builder::default()
    }
}

/// See [`EnableProfileInput`](crate::input::EnableProfileInput).
pub mod enable_profile_input {
    
    /// A builder for [`EnableProfileInput`](crate::input::EnableProfileInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the profile.</p>
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input; self
        }
        /// Consumes the builder and constructs a [`EnableProfileInput`](crate::input::EnableProfileInput).
        pub fn build(self) -> Result<crate::input::EnableProfileInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::EnableProfileInput {
                    profile_id: self.profile_id
                    ,
                }
            )
        }
    }
    
    
}
impl EnableProfileInput {
    /// Consumes the builder and constructs an Operation<[`EnableProfile`](crate::operation::EnableProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::EnableProfile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::EnableProfileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_8 = &_input.profile_id;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))?;
                let profile_id = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if profile_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))
                            }
                write!(output, "/profile/{profileId}/enable", profileId = profile_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::EnableProfileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::EnableProfile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("EnableProfile", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`EnableProfileInput`](crate::input::EnableProfileInput).
    pub fn builder() -> crate::input::enable_profile_input::Builder {
        crate::input::enable_profile_input::Builder::default()
    }
}

/// See [`EnableTrustAnchorInput`](crate::input::EnableTrustAnchorInput).
pub mod enable_trust_anchor_input {
    
    /// A builder for [`EnableTrustAnchorInput`](crate::input::EnableTrustAnchorInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trust_anchor_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn trust_anchor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trust_anchor_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn set_trust_anchor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trust_anchor_id = input; self
        }
        /// Consumes the builder and constructs a [`EnableTrustAnchorInput`](crate::input::EnableTrustAnchorInput).
        pub fn build(self) -> Result<crate::input::EnableTrustAnchorInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::EnableTrustAnchorInput {
                    trust_anchor_id: self.trust_anchor_id
                    ,
                }
            )
        }
    }
    
    
}
impl EnableTrustAnchorInput {
    /// Consumes the builder and constructs an Operation<[`EnableTrustAnchor`](crate::operation::EnableTrustAnchor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::EnableTrustAnchor, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::EnableTrustAnchorInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.trust_anchor_id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))?;
                let trust_anchor_id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if trust_anchor_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))
                            }
                write!(output, "/trustanchor/{trustAnchorId}/enable", trustAnchorId = trust_anchor_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::EnableTrustAnchorInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::EnableTrustAnchor::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("EnableTrustAnchor", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`EnableTrustAnchorInput`](crate::input::EnableTrustAnchorInput).
    pub fn builder() -> crate::input::enable_trust_anchor_input::Builder {
        crate::input::enable_trust_anchor_input::Builder::default()
    }
}

/// See [`GetCrlInput`](crate::input::GetCrlInput).
pub mod get_crl_input {
    
    /// A builder for [`GetCrlInput`](crate::input::GetCrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crl_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn crl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.crl_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn set_crl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crl_id = input; self
        }
        /// Consumes the builder and constructs a [`GetCrlInput`](crate::input::GetCrlInput).
        pub fn build(self) -> Result<crate::input::GetCrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetCrlInput {
                    crl_id: self.crl_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetCrlInput {
    /// Consumes the builder and constructs an Operation<[`GetCrl`](crate::operation::GetCrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetCrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetCrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.crl_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))?;
                let crl_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if crl_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))
                            }
                write!(output, "/crl/{crlId}", crlId = crl_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetCrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetCrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetCrl", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetCrlInput`](crate::input::GetCrlInput).
    pub fn builder() -> crate::input::get_crl_input::Builder {
        crate::input::get_crl_input::Builder::default()
    }
}

/// See [`GetProfileInput`](crate::input::GetProfileInput).
pub mod get_profile_input {
    
    /// A builder for [`GetProfileInput`](crate::input::GetProfileInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the profile.</p>
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input; self
        }
        /// Consumes the builder and constructs a [`GetProfileInput`](crate::input::GetProfileInput).
        pub fn build(self) -> Result<crate::input::GetProfileInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetProfileInput {
                    profile_id: self.profile_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetProfileInput {
    /// Consumes the builder and constructs an Operation<[`GetProfile`](crate::operation::GetProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetProfile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetProfileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.profile_id;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))?;
                let profile_id = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if profile_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))
                            }
                write!(output, "/profile/{profileId}", profileId = profile_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetProfileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetProfile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetProfile", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetProfileInput`](crate::input::GetProfileInput).
    pub fn builder() -> crate::input::get_profile_input::Builder {
        crate::input::get_profile_input::Builder::default()
    }
}

/// See [`GetSubjectInput`](crate::input::GetSubjectInput).
pub mod get_subject_input {
    
    /// A builder for [`GetSubjectInput`](crate::input::GetSubjectInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subject_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the subject. </p>
        pub fn subject_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the subject. </p>
        pub fn set_subject_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject_id = input; self
        }
        /// Consumes the builder and constructs a [`GetSubjectInput`](crate::input::GetSubjectInput).
        pub fn build(self) -> Result<crate::input::GetSubjectInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetSubjectInput {
                    subject_id: self.subject_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetSubjectInput {
    /// Consumes the builder and constructs an Operation<[`GetSubject`](crate::operation::GetSubject)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetSubject, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetSubjectInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.subject_id;
                let input_12 = input_12.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("subject_id", "cannot be empty or unset"))?;
                let subject_id = aws_smithy_http::label::fmt_string(input_12, aws_smithy_http::label::EncodingStrategy::Default);
                if subject_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("subject_id", "cannot be empty or unset"))
                            }
                write!(output, "/subject/{subjectId}", subjectId = subject_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetSubjectInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetSubject::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetSubject", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetSubjectInput`](crate::input::GetSubjectInput).
    pub fn builder() -> crate::input::get_subject_input::Builder {
        crate::input::get_subject_input::Builder::default()
    }
}

/// See [`GetTrustAnchorInput`](crate::input::GetTrustAnchorInput).
pub mod get_trust_anchor_input {
    
    /// A builder for [`GetTrustAnchorInput`](crate::input::GetTrustAnchorInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trust_anchor_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn trust_anchor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trust_anchor_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn set_trust_anchor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trust_anchor_id = input; self
        }
        /// Consumes the builder and constructs a [`GetTrustAnchorInput`](crate::input::GetTrustAnchorInput).
        pub fn build(self) -> Result<crate::input::GetTrustAnchorInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetTrustAnchorInput {
                    trust_anchor_id: self.trust_anchor_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetTrustAnchorInput {
    /// Consumes the builder and constructs an Operation<[`GetTrustAnchor`](crate::operation::GetTrustAnchor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetTrustAnchor, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetTrustAnchorInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.trust_anchor_id;
                let input_13 = input_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))?;
                let trust_anchor_id = aws_smithy_http::label::fmt_string(input_13, aws_smithy_http::label::EncodingStrategy::Default);
                if trust_anchor_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))
                            }
                write!(output, "/trustanchor/{trustAnchorId}", trustAnchorId = trust_anchor_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetTrustAnchorInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetTrustAnchor::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetTrustAnchor", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetTrustAnchorInput`](crate::input::GetTrustAnchorInput).
    pub fn builder() -> crate::input::get_trust_anchor_input::Builder {
        crate::input::get_trust_anchor_input::Builder::default()
    }
}

/// See [`ImportCrlInput`](crate::input::ImportCrlInput).
pub mod import_crl_input {
    
    /// A builder for [`ImportCrlInput`](crate::input::ImportCrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) crl_data: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) trust_anchor_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the certificate revocation list (CRL).</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the certificate revocation list (CRL).</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The x509 v3 specified certificate revocation list</p>
        pub fn crl_data(mut self, input: aws_smithy_types::Blob) -> Self {
            self.crl_data = Some(input);
            self
        }
        /// <p>The x509 v3 specified certificate revocation list</p>
        pub fn set_crl_data(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.crl_data = input; self
        }
        /// <p>Specifies whether the certificate revocation list (CRL) is enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the certificate revocation list (CRL) is enabled.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A list of tags to attach to the certificate revocation list (CRL).</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>A list of tags to attach to the certificate revocation list (CRL).</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// <p>The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.</p>
        pub fn trust_anchor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.trust_anchor_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.</p>
        pub fn set_trust_anchor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trust_anchor_arn = input; self
        }
        /// Consumes the builder and constructs a [`ImportCrlInput`](crate::input::ImportCrlInput).
        pub fn build(self) -> Result<crate::input::ImportCrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ImportCrlInput {
                    name: self.name
                    ,
                    crl_data: self.crl_data
                    ,
                    enabled: self.enabled
                    ,
                    tags: self.tags
                    ,
                    trust_anchor_arn: self.trust_anchor_arn
                    ,
                }
            )
        }
    }
    
    
}
impl ImportCrlInput {
    /// Consumes the builder and constructs an Operation<[`ImportCrl`](crate::operation::ImportCrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ImportCrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ImportCrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/crls").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ImportCrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_import_crl(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ImportCrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ImportCrl", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ImportCrlInput`](crate::input::ImportCrlInput).
    pub fn builder() -> crate::input::import_crl_input::Builder {
        crate::input::import_crl_input::Builder::default()
    }
}

/// See [`ListCrlsInput`](crate::input::ListCrlsInput).
pub mod list_crls_input {
    
    /// A builder for [`ListCrlsInput`](crate::input::ListCrlsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input; self
        }
        /// Consumes the builder and constructs a [`ListCrlsInput`](crate::input::ListCrlsInput).
        pub fn build(self) -> Result<crate::input::ListCrlsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListCrlsInput {
                    next_token: self.next_token
                    ,
                    page_size: self.page_size
                    ,
                }
            )
        }
    }
    
    
}
impl ListCrlsInput {
    /// Consumes the builder and constructs an Operation<[`ListCrls`](crate::operation::ListCrls)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListCrls, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListCrlsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/crls").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListCrlsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_14) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_14));
                    }
                }
                if let Some(inner_15) = &_input.page_size {
                    if *inner_15 != 0 {
                        query.push_kv("pageSize", aws_smithy_types::primitive::Encoder::from(*inner_15).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListCrlsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListCrls::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListCrls", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCrlsInput`](crate::input::ListCrlsInput).
    pub fn builder() -> crate::input::list_crls_input::Builder {
        crate::input::list_crls_input::Builder::default()
    }
}

/// See [`ListProfilesInput`](crate::input::ListProfilesInput).
pub mod list_profiles_input {
    
    /// A builder for [`ListProfilesInput`](crate::input::ListProfilesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input; self
        }
        /// Consumes the builder and constructs a [`ListProfilesInput`](crate::input::ListProfilesInput).
        pub fn build(self) -> Result<crate::input::ListProfilesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListProfilesInput {
                    next_token: self.next_token
                    ,
                    page_size: self.page_size
                    ,
                }
            )
        }
    }
    
    
}
impl ListProfilesInput {
    /// Consumes the builder and constructs an Operation<[`ListProfiles`](crate::operation::ListProfiles)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListProfiles, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListProfilesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/profiles").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListProfilesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_16) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_16));
                    }
                }
                if let Some(inner_17) = &_input.page_size {
                    if *inner_17 != 0 {
                        query.push_kv("pageSize", aws_smithy_types::primitive::Encoder::from(*inner_17).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListProfilesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListProfiles::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListProfiles", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListProfilesInput`](crate::input::ListProfilesInput).
    pub fn builder() -> crate::input::list_profiles_input::Builder {
        crate::input::list_profiles_input::Builder::default()
    }
}

/// See [`ListSubjectsInput`](crate::input::ListSubjectsInput).
pub mod list_subjects_input {
    
    /// A builder for [`ListSubjectsInput`](crate::input::ListSubjectsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input; self
        }
        /// Consumes the builder and constructs a [`ListSubjectsInput`](crate::input::ListSubjectsInput).
        pub fn build(self) -> Result<crate::input::ListSubjectsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListSubjectsInput {
                    next_token: self.next_token
                    ,
                    page_size: self.page_size
                    ,
                }
            )
        }
    }
    
    
}
impl ListSubjectsInput {
    /// Consumes the builder and constructs an Operation<[`ListSubjects`](crate::operation::ListSubjects)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListSubjects, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListSubjectsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/subjects").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListSubjectsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_18) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_18));
                    }
                }
                if let Some(inner_19) = &_input.page_size {
                    if *inner_19 != 0 {
                        query.push_kv("pageSize", aws_smithy_types::primitive::Encoder::from(*inner_19).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListSubjectsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListSubjects::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListSubjects", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListSubjectsInput`](crate::input::ListSubjectsInput).
    pub fn builder() -> crate::input::list_subjects_input::Builder {
        crate::input::list_subjects_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {
    
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(self) -> Result<crate::input::ListTagsForResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTagsForResourceInput {
                    resource_arn: self.resource_arn
                    ,
                }
            )
        }
    }
    
    
}
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTagsForResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTagsForResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/ListTagsForResource").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListTagsForResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_20 = &_input.resource_arn;
                let inner_20 = inner_20.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"))?;
                if inner_20.is_empty() {
                    return Err(aws_smithy_http::operation::error::BuildError::missing_field("resource_arn", "cannot be empty or unset"));
                }
                query.push_kv("resourceArn", &aws_smithy_http::query::fmt_string(&inner_20));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTagsForResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTagsForResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTagsForResource", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTrustAnchorsInput`](crate::input::ListTrustAnchorsInput).
pub mod list_trust_anchors_input {
    
    /// A builder for [`ListTrustAnchorsInput`](crate::input::ListTrustAnchorsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) page_size: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn page_size(mut self, input: i32) -> Self {
            self.page_size = Some(input);
            self
        }
        /// <p>The number of resources in the paginated list. </p>
        pub fn set_page_size(mut self, input: std::option::Option<i32>) -> Self {
            self.page_size = input; self
        }
        /// Consumes the builder and constructs a [`ListTrustAnchorsInput`](crate::input::ListTrustAnchorsInput).
        pub fn build(self) -> Result<crate::input::ListTrustAnchorsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTrustAnchorsInput {
                    next_token: self.next_token
                    ,
                    page_size: self.page_size
                    ,
                }
            )
        }
    }
    
    
}
impl ListTrustAnchorsInput {
    /// Consumes the builder and constructs an Operation<[`ListTrustAnchors`](crate::operation::ListTrustAnchors)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTrustAnchors, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTrustAnchorsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/trustanchors").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListTrustAnchorsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_21) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_21));
                    }
                }
                if let Some(inner_22) = &_input.page_size {
                    if *inner_22 != 0 {
                        query.push_kv("pageSize", aws_smithy_types::primitive::Encoder::from(*inner_22).encode());
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTrustAnchorsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTrustAnchors::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTrustAnchors", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTrustAnchorsInput`](crate::input::ListTrustAnchorsInput).
    pub fn builder() -> crate::input::list_trust_anchors_input::Builder {
        crate::input::list_trust_anchors_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {
    
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to attach to the resource.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags to attach to the resource.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(self) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::TagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::TagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::TagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/TagResource").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::TagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("TagResource", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {
    
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>A list of keys. Tag keys are the unique identifiers of tags. </p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
                            v.push(input.into());
                            self.tag_keys = Some(v);
                            self
        }
        /// <p>A list of keys. Tag keys are the unique identifiers of tags. </p>
        pub fn set_tag_keys(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.tag_keys = input; self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(self) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UntagResourceInput {
                    resource_arn: self.resource_arn
                    ,
                    tag_keys: self.tag_keys
                    ,
                }
            )
        }
    }
    
    
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UntagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UntagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/UntagResource").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UntagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_untag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UntagResource", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateCrlInput`](crate::input::UpdateCrlInput).
pub mod update_crl_input {
    
    /// A builder for [`UpdateCrlInput`](crate::input::UpdateCrlInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) crl_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) crl_data: std::option::Option<aws_smithy_types::Blob>,
    }
    impl Builder {
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn crl_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.crl_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the certificate revocation list (CRL).</p>
        pub fn set_crl_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.crl_id = input; self
        }
        /// <p>The name of the Crl.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Crl.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The x509 v3 specified certificate revocation list</p>
        pub fn crl_data(mut self, input: aws_smithy_types::Blob) -> Self {
            self.crl_data = Some(input);
            self
        }
        /// <p>The x509 v3 specified certificate revocation list</p>
        pub fn set_crl_data(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.crl_data = input; self
        }
        /// Consumes the builder and constructs a [`UpdateCrlInput`](crate::input::UpdateCrlInput).
        pub fn build(self) -> Result<crate::input::UpdateCrlInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateCrlInput {
                    crl_id: self.crl_id
                    ,
                    name: self.name
                    ,
                    crl_data: self.crl_data
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateCrlInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCrl`](crate::operation::UpdateCrl)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateCrl, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateCrlInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.crl_id;
                let input_23 = input_23.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))?;
                let crl_id = aws_smithy_http::label::fmt_string(input_23, aws_smithy_http::label::EncodingStrategy::Default);
                if crl_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("crl_id", "cannot be empty or unset"))
                            }
                write!(output, "/crl/{crlId}", crlId = crl_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateCrlInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_crl(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateCrl::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateCrl", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateCrlInput`](crate::input::UpdateCrlInput).
    pub fn builder() -> crate::input::update_crl_input::Builder {
        crate::input::update_crl_input::Builder::default()
    }
}

/// See [`UpdateProfileInput`](crate::input::UpdateProfileInput).
pub mod update_profile_input {
    
    /// A builder for [`UpdateProfileInput`](crate::input::UpdateProfileInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) profile_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) session_policy: std::option::Option<std::string::String>,
        pub(crate) role_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) managed_policy_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier of the profile.</p>
        pub fn profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.profile_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the profile.</p>
        pub fn set_profile_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.profile_id = input; self
        }
        /// <p>The name of the profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
        pub fn session_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_policy = Some(input.into());
            self
        }
        /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
        pub fn set_session_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_policy = input; self
        }
        /// Appends an item to `role_arns`.
        ///
        /// To override the contents of this collection use [`set_role_arns`](Self::set_role_arns).
        ///
        /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
        pub fn role_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.role_arns.unwrap_or_default();
                            v.push(input.into());
                            self.role_arns = Some(v);
                            self
        }
        /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
        pub fn set_role_arns(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.role_arns = input; self
        }
        /// Appends an item to `managed_policy_arns`.
        ///
        /// To override the contents of this collection use [`set_managed_policy_arns`](Self::set_managed_policy_arns).
        ///
        /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
        pub fn managed_policy_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.managed_policy_arns.unwrap_or_default();
                            v.push(input.into());
                            self.managed_policy_arns = Some(v);
                            self
        }
        /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
        pub fn set_managed_policy_arns(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.managed_policy_arns = input; self
        }
        /// <p> The number of seconds the vended session credentials are valid for. </p>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        /// <p> The number of seconds the vended session credentials are valid for. </p>
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input; self
        }
        /// Consumes the builder and constructs a [`UpdateProfileInput`](crate::input::UpdateProfileInput).
        pub fn build(self) -> Result<crate::input::UpdateProfileInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateProfileInput {
                    profile_id: self.profile_id
                    ,
                    name: self.name
                    ,
                    session_policy: self.session_policy
                    ,
                    role_arns: self.role_arns
                    ,
                    managed_policy_arns: self.managed_policy_arns
                    ,
                    duration_seconds: self.duration_seconds
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateProfileInput {
    /// Consumes the builder and constructs an Operation<[`UpdateProfile`](crate::operation::UpdateProfile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateProfile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateProfileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.profile_id;
                let input_24 = input_24.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))?;
                let profile_id = aws_smithy_http::label::fmt_string(input_24, aws_smithy_http::label::EncodingStrategy::Default);
                if profile_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("profile_id", "cannot be empty or unset"))
                            }
                write!(output, "/profile/{profileId}", profileId = profile_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateProfileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_profile(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateProfile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateProfile", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateProfileInput`](crate::input::UpdateProfileInput).
    pub fn builder() -> crate::input::update_profile_input::Builder {
        crate::input::update_profile_input::Builder::default()
    }
}

/// See [`UpdateTrustAnchorInput`](crate::input::UpdateTrustAnchorInput).
pub mod update_trust_anchor_input {
    
    /// A builder for [`UpdateTrustAnchorInput`](crate::input::UpdateTrustAnchorInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) trust_anchor_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<crate::model::Source>,
    }
    impl Builder {
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn trust_anchor_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trust_anchor_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the trust anchor.</p>
        pub fn set_trust_anchor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trust_anchor_id = input; self
        }
        /// <p>The name of the trust anchor.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the trust anchor.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The trust anchor type and its related certificate data.</p>
        pub fn source(mut self, input: crate::model::Source) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The trust anchor type and its related certificate data.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::Source>) -> Self {
            self.source = input; self
        }
        /// Consumes the builder and constructs a [`UpdateTrustAnchorInput`](crate::input::UpdateTrustAnchorInput).
        pub fn build(self) -> Result<crate::input::UpdateTrustAnchorInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateTrustAnchorInput {
                    trust_anchor_id: self.trust_anchor_id
                    ,
                    name: self.name
                    ,
                    source: self.source
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateTrustAnchorInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTrustAnchor`](crate::operation::UpdateTrustAnchor)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateTrustAnchor, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateTrustAnchorInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_25 = &_input.trust_anchor_id;
                let input_25 = input_25.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))?;
                let trust_anchor_id = aws_smithy_http::label::fmt_string(input_25, aws_smithy_http::label::EncodingStrategy::Default);
                if trust_anchor_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("trust_anchor_id", "cannot be empty or unset"))
                            }
                write!(output, "/trustanchor/{trustAnchorId}", trustAnchorId = trust_anchor_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateTrustAnchorInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_trust_anchor(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateTrustAnchor::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateTrustAnchor", "rolesanywhere"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateTrustAnchorInput`](crate::input::UpdateTrustAnchorInput).
    pub fn builder() -> crate::input::update_trust_anchor_input::Builder {
        crate::input::update_trust_anchor_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnableTrustAnchorInput  {
    /// <p>The unique identifier of the trust anchor.</p>
    #[doc(hidden)]
    pub trust_anchor_id: std::option::Option<std::string::String>,
}
impl EnableTrustAnchorInput {
    /// <p>The unique identifier of the trust anchor.</p>
    pub fn trust_anchor_id(&self) -> std::option::Option<& str> {
        self.trust_anchor_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisableTrustAnchorInput  {
    /// <p>The unique identifier of the trust anchor.</p>
    #[doc(hidden)]
    pub trust_anchor_id: std::option::Option<std::string::String>,
}
impl DisableTrustAnchorInput {
    /// <p>The unique identifier of the trust anchor.</p>
    pub fn trust_anchor_id(&self) -> std::option::Option<& str> {
        self.trust_anchor_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTrustAnchorsInput  {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of resources in the paginated list. </p>
    #[doc(hidden)]
    pub page_size: std::option::Option<i32>,
}
impl ListTrustAnchorsInput {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The number of resources in the paginated list. </p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTrustAnchorInput  {
    /// <p>The name of the trust anchor.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The trust anchor type and its related certificate data.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::Source>,
    /// <p>Specifies whether the trust anchor is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The tags to attach to the trust anchor.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateTrustAnchorInput {
    /// <p>The name of the trust anchor.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The trust anchor type and its related certificate data.</p>
    pub fn source(&self) -> std::option::Option<& crate::model::Source> {
        self.source.as_ref()
    }
    /// <p>Specifies whether the trust anchor is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The tags to attach to the trust anchor.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteTrustAnchorInput  {
    /// <p>The unique identifier of the trust anchor.</p>
    #[doc(hidden)]
    pub trust_anchor_id: std::option::Option<std::string::String>,
}
impl DeleteTrustAnchorInput {
    /// <p>The unique identifier of the trust anchor.</p>
    pub fn trust_anchor_id(&self) -> std::option::Option<& str> {
        self.trust_anchor_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateTrustAnchorInput  {
    /// <p>The unique identifier of the trust anchor.</p>
    #[doc(hidden)]
    pub trust_anchor_id: std::option::Option<std::string::String>,
    /// <p>The name of the trust anchor.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The trust anchor type and its related certificate data.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::Source>,
}
impl UpdateTrustAnchorInput {
    /// <p>The unique identifier of the trust anchor.</p>
    pub fn trust_anchor_id(&self) -> std::option::Option<& str> {
        self.trust_anchor_id.as_deref()
    }
    /// <p>The name of the trust anchor.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The trust anchor type and its related certificate data.</p>
    pub fn source(&self) -> std::option::Option<& crate::model::Source> {
        self.source.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTrustAnchorInput  {
    /// <p>The unique identifier of the trust anchor.</p>
    #[doc(hidden)]
    pub trust_anchor_id: std::option::Option<std::string::String>,
}
impl GetTrustAnchorInput {
    /// <p>The unique identifier of the trust anchor.</p>
    pub fn trust_anchor_id(&self) -> std::option::Option<& str> {
        self.trust_anchor_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListSubjectsInput  {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of resources in the paginated list. </p>
    #[doc(hidden)]
    pub page_size: std::option::Option<i32>,
}
impl ListSubjectsInput {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The number of resources in the paginated list. </p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSubjectInput  {
    /// <p>The unique identifier of the subject. </p>
    #[doc(hidden)]
    pub subject_id: std::option::Option<std::string::String>,
}
impl GetSubjectInput {
    /// <p>The unique identifier of the subject. </p>
    pub fn subject_id(&self) -> std::option::Option<& str> {
        self.subject_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnableProfileInput  {
    /// <p>The unique identifier of the profile.</p>
    #[doc(hidden)]
    pub profile_id: std::option::Option<std::string::String>,
}
impl EnableProfileInput {
    /// <p>The unique identifier of the profile.</p>
    pub fn profile_id(&self) -> std::option::Option<& str> {
        self.profile_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisableProfileInput  {
    /// <p>The unique identifier of the profile.</p>
    #[doc(hidden)]
    pub profile_id: std::option::Option<std::string::String>,
}
impl DisableProfileInput {
    /// <p>The unique identifier of the profile.</p>
    pub fn profile_id(&self) -> std::option::Option<& str> {
        self.profile_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListProfilesInput  {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of resources in the paginated list. </p>
    #[doc(hidden)]
    pub page_size: std::option::Option<i32>,
}
impl ListProfilesInput {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The number of resources in the paginated list. </p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateProfileInput  {
    /// <p>The name of the profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies whether instance properties are required in <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> requests with this profile. </p>
    #[doc(hidden)]
    pub require_instance_properties: std::option::Option<bool>,
    /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
    #[doc(hidden)]
    pub session_policy: std::option::Option<std::string::String>,
    /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
    #[doc(hidden)]
    pub role_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
    #[doc(hidden)]
    pub managed_policy_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The number of seconds the vended session credentials are valid for. </p>
    #[doc(hidden)]
    pub duration_seconds: std::option::Option<i32>,
    /// <p>Specifies whether the profile is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The tags to attach to the profile.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateProfileInput {
    /// <p>The name of the profile.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Specifies whether instance properties are required in <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> requests with this profile. </p>
    pub fn require_instance_properties(&self) -> std::option::Option<bool> {
        self.require_instance_properties
    }
    /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
    pub fn session_policy(&self) -> std::option::Option<& str> {
        self.session_policy.as_deref()
    }
    /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
    pub fn role_arns(&self) -> std::option::Option<& [std::string::String]> {
        self.role_arns.as_deref()
    }
    /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
    pub fn managed_policy_arns(&self) -> std::option::Option<& [std::string::String]> {
        self.managed_policy_arns.as_deref()
    }
    /// <p> The number of seconds the vended session credentials are valid for. </p>
    pub fn duration_seconds(&self) -> std::option::Option<i32> {
        self.duration_seconds
    }
    /// <p>Specifies whether the profile is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The tags to attach to the profile.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteProfileInput  {
    /// <p>The unique identifier of the profile.</p>
    #[doc(hidden)]
    pub profile_id: std::option::Option<std::string::String>,
}
impl DeleteProfileInput {
    /// <p>The unique identifier of the profile.</p>
    pub fn profile_id(&self) -> std::option::Option<& str> {
        self.profile_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateProfileInput  {
    /// <p>The unique identifier of the profile.</p>
    #[doc(hidden)]
    pub profile_id: std::option::Option<std::string::String>,
    /// <p>The name of the profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
    #[doc(hidden)]
    pub session_policy: std::option::Option<std::string::String>,
    /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
    #[doc(hidden)]
    pub role_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
    #[doc(hidden)]
    pub managed_policy_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The number of seconds the vended session credentials are valid for. </p>
    #[doc(hidden)]
    pub duration_seconds: std::option::Option<i32>,
}
impl UpdateProfileInput {
    /// <p>The unique identifier of the profile.</p>
    pub fn profile_id(&self) -> std::option::Option<& str> {
        self.profile_id.as_deref()
    }
    /// <p>The name of the profile.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A session policy that applies to the trust boundary of the vended session credentials. </p>
    pub fn session_policy(&self) -> std::option::Option<& str> {
        self.session_policy.as_deref()
    }
    /// <p>A list of IAM roles that this profile can assume in a <a href="https://docs.aws.amazon.com/rolesanywhere/latest/APIReference/API_CreateSession.html">CreateSession</a> operation.</p>
    pub fn role_arns(&self) -> std::option::Option<& [std::string::String]> {
        self.role_arns.as_deref()
    }
    /// <p>A list of managed policy ARNs that apply to the vended session credentials. </p>
    pub fn managed_policy_arns(&self) -> std::option::Option<& [std::string::String]> {
        self.managed_policy_arns.as_deref()
    }
    /// <p> The number of seconds the vended session credentials are valid for. </p>
    pub fn duration_seconds(&self) -> std::option::Option<i32> {
        self.duration_seconds
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetProfileInput  {
    /// <p>The unique identifier of the profile.</p>
    #[doc(hidden)]
    pub profile_id: std::option::Option<std::string::String>,
}
impl GetProfileInput {
    /// <p>The unique identifier of the profile.</p>
    pub fn profile_id(&self) -> std::option::Option<& str> {
        self.profile_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EnableCrlInput  {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub crl_id: std::option::Option<std::string::String>,
}
impl EnableCrlInput {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    pub fn crl_id(&self) -> std::option::Option<& str> {
        self.crl_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisableCrlInput  {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub crl_id: std::option::Option<std::string::String>,
}
impl DisableCrlInput {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    pub fn crl_id(&self) -> std::option::Option<& str> {
        self.crl_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCrlsInput  {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The number of resources in the paginated list. </p>
    #[doc(hidden)]
    pub page_size: std::option::Option<i32>,
}
impl ListCrlsInput {
    /// <p>A token that indicates where the output should continue from, if a previous operation did not show all results. To get the next results, call the operation again with this value.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The number of resources in the paginated list. </p>
    pub fn page_size(&self) -> std::option::Option<i32> {
        self.page_size
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImportCrlInput  {
    /// <p>The name of the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The x509 v3 specified certificate revocation list</p>
    #[doc(hidden)]
    pub crl_data: std::option::Option<aws_smithy_types::Blob>,
    /// <p>Specifies whether the certificate revocation list (CRL) is enabled.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>A list of tags to attach to the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.</p>
    #[doc(hidden)]
    pub trust_anchor_arn: std::option::Option<std::string::String>,
}
impl ImportCrlInput {
    /// <p>The name of the certificate revocation list (CRL).</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The x509 v3 specified certificate revocation list</p>
    pub fn crl_data(&self) -> std::option::Option<& aws_smithy_types::Blob> {
        self.crl_data.as_ref()
    }
    /// <p>Specifies whether the certificate revocation list (CRL) is enabled.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>A list of tags to attach to the certificate revocation list (CRL).</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The ARN of the TrustAnchor the certificate revocation list (CRL) will provide revocation for.</p>
    pub fn trust_anchor_arn(&self) -> std::option::Option<& str> {
        self.trust_anchor_arn.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCrlInput  {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub crl_id: std::option::Option<std::string::String>,
}
impl DeleteCrlInput {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    pub fn crl_id(&self) -> std::option::Option<& str> {
        self.crl_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCrlInput  {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub crl_id: std::option::Option<std::string::String>,
    /// <p>The name of the Crl.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The x509 v3 specified certificate revocation list</p>
    #[doc(hidden)]
    pub crl_data: std::option::Option<aws_smithy_types::Blob>,
}
impl UpdateCrlInput {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    pub fn crl_id(&self) -> std::option::Option<& str> {
        self.crl_id.as_deref()
    }
    /// <p>The name of the Crl.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The x509 v3 specified certificate revocation list</p>
    pub fn crl_data(&self) -> std::option::Option<& aws_smithy_types::Blob> {
        self.crl_data.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCrlInput  {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    #[doc(hidden)]
    pub crl_id: std::option::Option<std::string::String>,
}
impl GetCrlInput {
    /// <p>The unique identifier of the certificate revocation list (CRL).</p>
    pub fn crl_id(&self) -> std::option::Option<& str> {
        self.crl_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput  {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>A list of keys. Tag keys are the unique identifiers of tags. </p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>A list of keys. Tag keys are the unique identifiers of tags. </p>
    pub fn tag_keys(&self) -> std::option::Option<& [std::string::String]> {
        self.tag_keys.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput  {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags to attach to the resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tags to attach to the resource.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput  {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
}

