// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Fields to be used while uploading the attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UploadMetadata {
    /// <p>This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html">StartAttachmentUpload</a>.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
    /// <p>The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    #[doc(hidden)]
    pub url_expiry: std::option::Option<std::string::String>,
    /// <p>The headers to be provided while uploading the file to the URL.</p>
    #[doc(hidden)]
    pub headers_to_include:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UploadMetadata {
    /// <p>This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html">StartAttachmentUpload</a>.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    pub fn url_expiry(&self) -> std::option::Option<&str> {
        self.url_expiry.as_deref()
    }
    /// <p>The headers to be provided while uploading the file to the URL.</p>
    pub fn headers_to_include(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.headers_to_include.as_ref()
    }
}
/// See [`UploadMetadata`](crate::model::UploadMetadata).
pub mod upload_metadata {

    /// A builder for [`UploadMetadata`](crate::model::UploadMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) url_expiry: std::option::Option<std::string::String>,
        pub(crate) headers_to_include: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html">StartAttachmentUpload</a>.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to <a href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html">StartAttachmentUpload</a>.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn url_expiry(mut self, input: impl Into<std::string::String>) -> Self {
            self.url_expiry = Some(input.into());
            self
        }
        /// <p>The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn set_url_expiry(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url_expiry = input;
            self
        }
        /// Adds a key-value pair to `headers_to_include`.
        ///
        /// To override the contents of this collection use [`set_headers_to_include`](Self::set_headers_to_include).
        ///
        /// <p>The headers to be provided while uploading the file to the URL.</p>
        pub fn headers_to_include(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.headers_to_include.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.headers_to_include = Some(hash_map);
            self
        }
        /// <p>The headers to be provided while uploading the file to the URL.</p>
        pub fn set_headers_to_include(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.headers_to_include = input;
            self
        }
        /// Consumes the builder and constructs a [`UploadMetadata`](crate::model::UploadMetadata).
        pub fn build(self) -> crate::model::UploadMetadata {
            crate::model::UploadMetadata {
                url: self.url,
                url_expiry: self.url_expiry,
                headers_to_include: self.headers_to_include,
            }
        }
    }
}
impl UploadMetadata {
    /// Creates a new builder-style object to manufacture [`UploadMetadata`](crate::model::UploadMetadata).
    pub fn builder() -> crate::model::upload_metadata::Builder {
        crate::model::upload_metadata::Builder::default()
    }
}

/// <p>An item - message or event - that has been sent. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Item {
    /// <p>The time when the message or event was sent.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    #[doc(hidden)]
    pub absolute_time: std::option::Option<std::string::String>,
    /// <p>The content of the message or event.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The type of content of the item.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
    /// <p>The ID of the item.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Type of the item: message or event. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ChatItemType>,
    /// <p>The ID of the sender in the session.</p>
    #[doc(hidden)]
    pub participant_id: std::option::Option<std::string::String>,
    /// <p>The chat display name of the sender.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The role of the sender. For example, is it a customer, agent, or system.</p>
    #[doc(hidden)]
    pub participant_role: std::option::Option<crate::model::ParticipantRole>,
    /// <p>Provides information about the attachments.</p>
    #[doc(hidden)]
    pub attachments: std::option::Option<std::vec::Vec<crate::model::AttachmentItem>>,
    /// <p>The metadata related to the message. Currently this supports only information related to message receipts.</p>
    #[doc(hidden)]
    pub message_metadata: std::option::Option<crate::model::MessageMetadata>,
    /// <p>The contactId on which the transcript item was originally sent. This field is only populated for persistent chats when the transcript item is from the past chat session. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
    #[doc(hidden)]
    pub related_contact_id: std::option::Option<std::string::String>,
    /// <p>The contactId on which the transcript item was originally sent. This field is populated only when the transcript item is from the current chat session.</p>
    #[doc(hidden)]
    pub contact_id: std::option::Option<std::string::String>,
}
impl Item {
    /// <p>The time when the message or event was sent.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    pub fn absolute_time(&self) -> std::option::Option<&str> {
        self.absolute_time.as_deref()
    }
    /// <p>The content of the message or event.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The type of content of the item.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>The ID of the item.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Type of the item: message or event. </p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ChatItemType> {
        self.r#type.as_ref()
    }
    /// <p>The ID of the sender in the session.</p>
    pub fn participant_id(&self) -> std::option::Option<&str> {
        self.participant_id.as_deref()
    }
    /// <p>The chat display name of the sender.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The role of the sender. For example, is it a customer, agent, or system.</p>
    pub fn participant_role(&self) -> std::option::Option<&crate::model::ParticipantRole> {
        self.participant_role.as_ref()
    }
    /// <p>Provides information about the attachments.</p>
    pub fn attachments(&self) -> std::option::Option<&[crate::model::AttachmentItem]> {
        self.attachments.as_deref()
    }
    /// <p>The metadata related to the message. Currently this supports only information related to message receipts.</p>
    pub fn message_metadata(&self) -> std::option::Option<&crate::model::MessageMetadata> {
        self.message_metadata.as_ref()
    }
    /// <p>The contactId on which the transcript item was originally sent. This field is only populated for persistent chats when the transcript item is from the past chat session. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
    pub fn related_contact_id(&self) -> std::option::Option<&str> {
        self.related_contact_id.as_deref()
    }
    /// <p>The contactId on which the transcript item was originally sent. This field is populated only when the transcript item is from the current chat session.</p>
    pub fn contact_id(&self) -> std::option::Option<&str> {
        self.contact_id.as_deref()
    }
}
/// See [`Item`](crate::model::Item).
pub mod item {

    /// A builder for [`Item`](crate::model::Item).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) absolute_time: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ChatItemType>,
        pub(crate) participant_id: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) participant_role: std::option::Option<crate::model::ParticipantRole>,
        pub(crate) attachments: std::option::Option<std::vec::Vec<crate::model::AttachmentItem>>,
        pub(crate) message_metadata: std::option::Option<crate::model::MessageMetadata>,
        pub(crate) related_contact_id: std::option::Option<std::string::String>,
        pub(crate) contact_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time when the message or event was sent.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn absolute_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.absolute_time = Some(input.into());
            self
        }
        /// <p>The time when the message or event was sent.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn set_absolute_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.absolute_time = input;
            self
        }
        /// <p>The content of the message or event.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The content of the message or event.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The type of content of the item.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The type of content of the item.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>The ID of the item.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the item.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Type of the item: message or event. </p>
        pub fn r#type(mut self, input: crate::model::ChatItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type of the item: message or event. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ChatItemType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ID of the sender in the session.</p>
        pub fn participant_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.participant_id = Some(input.into());
            self
        }
        /// <p>The ID of the sender in the session.</p>
        pub fn set_participant_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.participant_id = input;
            self
        }
        /// <p>The chat display name of the sender.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The chat display name of the sender.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The role of the sender. For example, is it a customer, agent, or system.</p>
        pub fn participant_role(mut self, input: crate::model::ParticipantRole) -> Self {
            self.participant_role = Some(input);
            self
        }
        /// <p>The role of the sender. For example, is it a customer, agent, or system.</p>
        pub fn set_participant_role(
            mut self,
            input: std::option::Option<crate::model::ParticipantRole>,
        ) -> Self {
            self.participant_role = input;
            self
        }
        /// Appends an item to `attachments`.
        ///
        /// To override the contents of this collection use [`set_attachments`](Self::set_attachments).
        ///
        /// <p>Provides information about the attachments.</p>
        pub fn attachments(mut self, input: crate::model::AttachmentItem) -> Self {
            let mut v = self.attachments.unwrap_or_default();
            v.push(input);
            self.attachments = Some(v);
            self
        }
        /// <p>Provides information about the attachments.</p>
        pub fn set_attachments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AttachmentItem>>,
        ) -> Self {
            self.attachments = input;
            self
        }
        /// <p>The metadata related to the message. Currently this supports only information related to message receipts.</p>
        pub fn message_metadata(mut self, input: crate::model::MessageMetadata) -> Self {
            self.message_metadata = Some(input);
            self
        }
        /// <p>The metadata related to the message. Currently this supports only information related to message receipts.</p>
        pub fn set_message_metadata(
            mut self,
            input: std::option::Option<crate::model::MessageMetadata>,
        ) -> Self {
            self.message_metadata = input;
            self
        }
        /// <p>The contactId on which the transcript item was originally sent. This field is only populated for persistent chats when the transcript item is from the past chat session. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
        pub fn related_contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.related_contact_id = Some(input.into());
            self
        }
        /// <p>The contactId on which the transcript item was originally sent. This field is only populated for persistent chats when the transcript item is from the past chat session. For more information, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable persistent chat</a>.</p>
        pub fn set_related_contact_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.related_contact_id = input;
            self
        }
        /// <p>The contactId on which the transcript item was originally sent. This field is populated only when the transcript item is from the current chat session.</p>
        pub fn contact_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_id = Some(input.into());
            self
        }
        /// <p>The contactId on which the transcript item was originally sent. This field is populated only when the transcript item is from the current chat session.</p>
        pub fn set_contact_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Item`](crate::model::Item).
        pub fn build(self) -> crate::model::Item {
            crate::model::Item {
                absolute_time: self.absolute_time,
                content: self.content,
                content_type: self.content_type,
                id: self.id,
                r#type: self.r#type,
                participant_id: self.participant_id,
                display_name: self.display_name,
                participant_role: self.participant_role,
                attachments: self.attachments,
                message_metadata: self.message_metadata,
                related_contact_id: self.related_contact_id,
                contact_id: self.contact_id,
            }
        }
    }
}
impl Item {
    /// Creates a new builder-style object to manufacture [`Item`](crate::model::Item).
    pub fn builder() -> crate::model::item::Builder {
        crate::model::item::Builder::default()
    }
}

/// <p>Contains metadata related to a message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MessageMetadata {
    /// <p>The identifier of the message that contains the metadata information. </p>
    #[doc(hidden)]
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The list of receipt information for a message for different recipients.</p>
    #[doc(hidden)]
    pub receipts: std::option::Option<std::vec::Vec<crate::model::Receipt>>,
}
impl MessageMetadata {
    /// <p>The identifier of the message that contains the metadata information. </p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>The list of receipt information for a message for different recipients.</p>
    pub fn receipts(&self) -> std::option::Option<&[crate::model::Receipt]> {
        self.receipts.as_deref()
    }
}
/// See [`MessageMetadata`](crate::model::MessageMetadata).
pub mod message_metadata {

    /// A builder for [`MessageMetadata`](crate::model::MessageMetadata).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) receipts: std::option::Option<std::vec::Vec<crate::model::Receipt>>,
    }
    impl Builder {
        /// <p>The identifier of the message that contains the metadata information. </p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The identifier of the message that contains the metadata information. </p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// Appends an item to `receipts`.
        ///
        /// To override the contents of this collection use [`set_receipts`](Self::set_receipts).
        ///
        /// <p>The list of receipt information for a message for different recipients.</p>
        pub fn receipts(mut self, input: crate::model::Receipt) -> Self {
            let mut v = self.receipts.unwrap_or_default();
            v.push(input);
            self.receipts = Some(v);
            self
        }
        /// <p>The list of receipt information for a message for different recipients.</p>
        pub fn set_receipts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Receipt>>,
        ) -> Self {
            self.receipts = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageMetadata`](crate::model::MessageMetadata).
        pub fn build(self) -> crate::model::MessageMetadata {
            crate::model::MessageMetadata {
                message_id: self.message_id,
                receipts: self.receipts,
            }
        }
    }
}
impl MessageMetadata {
    /// Creates a new builder-style object to manufacture [`MessageMetadata`](crate::model::MessageMetadata).
    pub fn builder() -> crate::model::message_metadata::Builder {
        crate::model::message_metadata::Builder::default()
    }
}

/// <p>The receipt for the message delivered to the recipient.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Receipt {
    /// <p>The time when the message was delivered to the recipient.</p>
    #[doc(hidden)]
    pub delivered_timestamp: std::option::Option<std::string::String>,
    /// <p>The time when the message was read by the recipient.</p>
    #[doc(hidden)]
    pub read_timestamp: std::option::Option<std::string::String>,
    /// <p>The identifier of the recipient of the message. </p>
    #[doc(hidden)]
    pub recipient_participant_id: std::option::Option<std::string::String>,
}
impl Receipt {
    /// <p>The time when the message was delivered to the recipient.</p>
    pub fn delivered_timestamp(&self) -> std::option::Option<&str> {
        self.delivered_timestamp.as_deref()
    }
    /// <p>The time when the message was read by the recipient.</p>
    pub fn read_timestamp(&self) -> std::option::Option<&str> {
        self.read_timestamp.as_deref()
    }
    /// <p>The identifier of the recipient of the message. </p>
    pub fn recipient_participant_id(&self) -> std::option::Option<&str> {
        self.recipient_participant_id.as_deref()
    }
}
/// See [`Receipt`](crate::model::Receipt).
pub mod receipt {

    /// A builder for [`Receipt`](crate::model::Receipt).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivered_timestamp: std::option::Option<std::string::String>,
        pub(crate) read_timestamp: std::option::Option<std::string::String>,
        pub(crate) recipient_participant_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The time when the message was delivered to the recipient.</p>
        pub fn delivered_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivered_timestamp = Some(input.into());
            self
        }
        /// <p>The time when the message was delivered to the recipient.</p>
        pub fn set_delivered_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.delivered_timestamp = input;
            self
        }
        /// <p>The time when the message was read by the recipient.</p>
        pub fn read_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.read_timestamp = Some(input.into());
            self
        }
        /// <p>The time when the message was read by the recipient.</p>
        pub fn set_read_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.read_timestamp = input;
            self
        }
        /// <p>The identifier of the recipient of the message. </p>
        pub fn recipient_participant_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recipient_participant_id = Some(input.into());
            self
        }
        /// <p>The identifier of the recipient of the message. </p>
        pub fn set_recipient_participant_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recipient_participant_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Receipt`](crate::model::Receipt).
        pub fn build(self) -> crate::model::Receipt {
            crate::model::Receipt {
                delivered_timestamp: self.delivered_timestamp,
                read_timestamp: self.read_timestamp,
                recipient_participant_id: self.recipient_participant_id,
            }
        }
    }
}
impl Receipt {
    /// Creates a new builder-style object to manufacture [`Receipt`](crate::model::Receipt).
    pub fn builder() -> crate::model::receipt::Builder {
        crate::model::receipt::Builder::default()
    }
}

/// <p>The case-insensitive input to indicate standard MIME type that describes the format of the file that will be uploaded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AttachmentItem {
    /// <p>Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>A case-sensitive name of the attachment being uploaded.</p>
    #[doc(hidden)]
    pub attachment_name: std::option::Option<std::string::String>,
    /// <p>Status of the attachment.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ArtifactStatus>,
}
impl AttachmentItem {
    /// <p>Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
    /// <p>A unique identifier for the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
    /// <p>A case-sensitive name of the attachment being uploaded.</p>
    pub fn attachment_name(&self) -> std::option::Option<&str> {
        self.attachment_name.as_deref()
    }
    /// <p>Status of the attachment.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::ArtifactStatus> {
        self.status.as_ref()
    }
}
/// See [`AttachmentItem`](crate::model::AttachmentItem).
pub mod attachment_item {

    /// A builder for [`AttachmentItem`](crate::model::AttachmentItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content_type: std::option::Option<std::string::String>,
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) attachment_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::ArtifactStatus>,
    }
    impl Builder {
        /// <p>Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>Describes the MIME file type of the attachment. For a list of supported file types, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html">Feature specifications</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// <p>A unique identifier for the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// <p>A case-sensitive name of the attachment being uploaded.</p>
        pub fn attachment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_name = Some(input.into());
            self
        }
        /// <p>A case-sensitive name of the attachment being uploaded.</p>
        pub fn set_attachment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_name = input;
            self
        }
        /// <p>Status of the attachment.</p>
        pub fn status(mut self, input: crate::model::ArtifactStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the attachment.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::ArtifactStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`AttachmentItem`](crate::model::AttachmentItem).
        pub fn build(self) -> crate::model::AttachmentItem {
            crate::model::AttachmentItem {
                content_type: self.content_type,
                attachment_id: self.attachment_id,
                attachment_name: self.attachment_name,
                status: self.status,
            }
        }
    }
}
impl AttachmentItem {
    /// Creates a new builder-style object to manufacture [`AttachmentItem`](crate::model::AttachmentItem).
    pub fn builder() -> crate::model::attachment_item::Builder {
        crate::model::attachment_item::Builder::default()
    }
}

/// When writing a match expression against `ArtifactStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let artifactstatus = unimplemented!();
/// match artifactstatus {
///     ArtifactStatus::Approved => { /* ... */ },
///     ArtifactStatus::InProgress => { /* ... */ },
///     ArtifactStatus::Rejected => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `artifactstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ArtifactStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ArtifactStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ArtifactStatus::NewFeature` is defined.
/// Specifically, when `artifactstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ArtifactStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ArtifactStatus {
    #[allow(missing_docs)] // documentation missing in model
    Approved,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ArtifactStatus {
    fn from(s: &str) -> Self {
        match s {
            "APPROVED" => ArtifactStatus::Approved,
            "IN_PROGRESS" => ArtifactStatus::InProgress,
            "REJECTED" => ArtifactStatus::Rejected,
            other => ArtifactStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ArtifactStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ArtifactStatus::from(s))
    }
}
impl ArtifactStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ArtifactStatus::Approved => "APPROVED",
            ArtifactStatus::InProgress => "IN_PROGRESS",
            ArtifactStatus::Rejected => "REJECTED",
            ArtifactStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPROVED", "IN_PROGRESS", "REJECTED"]
    }
}
impl AsRef<str> for ArtifactStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ParticipantRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let participantrole = unimplemented!();
/// match participantrole {
///     ParticipantRole::Agent => { /* ... */ },
///     ParticipantRole::Customer => { /* ... */ },
///     ParticipantRole::System => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `participantrole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ParticipantRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ParticipantRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ParticipantRole::NewFeature` is defined.
/// Specifically, when `participantrole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ParticipantRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ParticipantRole {
    #[allow(missing_docs)] // documentation missing in model
    Agent,
    #[allow(missing_docs)] // documentation missing in model
    Customer,
    #[allow(missing_docs)] // documentation missing in model
    System,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ParticipantRole {
    fn from(s: &str) -> Self {
        match s {
            "AGENT" => ParticipantRole::Agent,
            "CUSTOMER" => ParticipantRole::Customer,
            "SYSTEM" => ParticipantRole::System,
            other => ParticipantRole::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ParticipantRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ParticipantRole::from(s))
    }
}
impl ParticipantRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ParticipantRole::Agent => "AGENT",
            ParticipantRole::Customer => "CUSTOMER",
            ParticipantRole::System => "SYSTEM",
            ParticipantRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AGENT", "CUSTOMER", "SYSTEM"]
    }
}
impl AsRef<str> for ParticipantRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ChatItemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let chatitemtype = unimplemented!();
/// match chatitemtype {
///     ChatItemType::Attachment => { /* ... */ },
///     ChatItemType::ChatEnded => { /* ... */ },
///     ChatItemType::ConnectionAck => { /* ... */ },
///     ChatItemType::Event => { /* ... */ },
///     ChatItemType::Message => { /* ... */ },
///     ChatItemType::MessageDelivered => { /* ... */ },
///     ChatItemType::MessageRead => { /* ... */ },
///     ChatItemType::ParticipantJoined => { /* ... */ },
///     ChatItemType::ParticipantLeft => { /* ... */ },
///     ChatItemType::TransferFailed => { /* ... */ },
///     ChatItemType::TransferSucceeded => { /* ... */ },
///     ChatItemType::Typing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `chatitemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChatItemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChatItemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChatItemType::NewFeature` is defined.
/// Specifically, when `chatitemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChatItemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChatItemType {
    #[allow(missing_docs)] // documentation missing in model
    Attachment,
    #[allow(missing_docs)] // documentation missing in model
    ChatEnded,
    #[allow(missing_docs)] // documentation missing in model
    ConnectionAck,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    Message,
    #[allow(missing_docs)] // documentation missing in model
    MessageDelivered,
    #[allow(missing_docs)] // documentation missing in model
    MessageRead,
    #[allow(missing_docs)] // documentation missing in model
    ParticipantJoined,
    #[allow(missing_docs)] // documentation missing in model
    ParticipantLeft,
    #[allow(missing_docs)] // documentation missing in model
    TransferFailed,
    #[allow(missing_docs)] // documentation missing in model
    TransferSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    Typing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChatItemType {
    fn from(s: &str) -> Self {
        match s {
            "ATTACHMENT" => ChatItemType::Attachment,
            "CHAT_ENDED" => ChatItemType::ChatEnded,
            "CONNECTION_ACK" => ChatItemType::ConnectionAck,
            "EVENT" => ChatItemType::Event,
            "MESSAGE" => ChatItemType::Message,
            "MESSAGE_DELIVERED" => ChatItemType::MessageDelivered,
            "MESSAGE_READ" => ChatItemType::MessageRead,
            "PARTICIPANT_JOINED" => ChatItemType::ParticipantJoined,
            "PARTICIPANT_LEFT" => ChatItemType::ParticipantLeft,
            "TRANSFER_FAILED" => ChatItemType::TransferFailed,
            "TRANSFER_SUCCEEDED" => ChatItemType::TransferSucceeded,
            "TYPING" => ChatItemType::Typing,
            other => ChatItemType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChatItemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChatItemType::from(s))
    }
}
impl ChatItemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChatItemType::Attachment => "ATTACHMENT",
            ChatItemType::ChatEnded => "CHAT_ENDED",
            ChatItemType::ConnectionAck => "CONNECTION_ACK",
            ChatItemType::Event => "EVENT",
            ChatItemType::Message => "MESSAGE",
            ChatItemType::MessageDelivered => "MESSAGE_DELIVERED",
            ChatItemType::MessageRead => "MESSAGE_READ",
            ChatItemType::ParticipantJoined => "PARTICIPANT_JOINED",
            ChatItemType::ParticipantLeft => "PARTICIPANT_LEFT",
            ChatItemType::TransferFailed => "TRANSFER_FAILED",
            ChatItemType::TransferSucceeded => "TRANSFER_SUCCEEDED",
            ChatItemType::Typing => "TYPING",
            ChatItemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ATTACHMENT",
            "CHAT_ENDED",
            "CONNECTION_ACK",
            "EVENT",
            "MESSAGE",
            "MESSAGE_DELIVERED",
            "MESSAGE_READ",
            "PARTICIPANT_JOINED",
            "PARTICIPANT_LEFT",
            "TRANSFER_FAILED",
            "TRANSFER_SUCCEEDED",
            "TYPING",
        ]
    }
}
impl AsRef<str> for ChatItemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filtering option for where to start. For example, if you sent 100 messages, start with message 50. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartPosition {
    /// <p>The ID of the message or event where to start. </p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The time in ISO format where to start.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    #[doc(hidden)]
    pub absolute_time: std::option::Option<std::string::String>,
    /// <p>The start position of the most recent message where you want to start. </p>
    #[doc(hidden)]
    pub most_recent: i32,
}
impl StartPosition {
    /// <p>The ID of the message or event where to start. </p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The time in ISO format where to start.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    pub fn absolute_time(&self) -> std::option::Option<&str> {
        self.absolute_time.as_deref()
    }
    /// <p>The start position of the most recent message where you want to start. </p>
    pub fn most_recent(&self) -> i32 {
        self.most_recent
    }
}
/// See [`StartPosition`](crate::model::StartPosition).
pub mod start_position {

    /// A builder for [`StartPosition`](crate::model::StartPosition).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) absolute_time: std::option::Option<std::string::String>,
        pub(crate) most_recent: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the message or event where to start. </p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the message or event where to start. </p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The time in ISO format where to start.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn absolute_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.absolute_time = Some(input.into());
            self
        }
        /// <p>The time in ISO format where to start.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn set_absolute_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.absolute_time = input;
            self
        }
        /// <p>The start position of the most recent message where you want to start. </p>
        pub fn most_recent(mut self, input: i32) -> Self {
            self.most_recent = Some(input);
            self
        }
        /// <p>The start position of the most recent message where you want to start. </p>
        pub fn set_most_recent(mut self, input: std::option::Option<i32>) -> Self {
            self.most_recent = input;
            self
        }
        /// Consumes the builder and constructs a [`StartPosition`](crate::model::StartPosition).
        pub fn build(self) -> crate::model::StartPosition {
            crate::model::StartPosition {
                id: self.id,
                absolute_time: self.absolute_time,
                most_recent: self.most_recent.unwrap_or_default(),
            }
        }
    }
}
impl StartPosition {
    /// Creates a new builder-style object to manufacture [`StartPosition`](crate::model::StartPosition).
    pub fn builder() -> crate::model::start_position::Builder {
        crate::model::start_position::Builder::default()
    }
}

/// When writing a match expression against `SortKey`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sortkey = unimplemented!();
/// match sortkey {
///     SortKey::Ascending => { /* ... */ },
///     SortKey::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sortkey` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SortKey::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SortKey::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SortKey::NewFeature` is defined.
/// Specifically, when `sortkey` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SortKey::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SortKey {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SortKey {
    fn from(s: &str) -> Self {
        match s {
            "ASCENDING" => SortKey::Ascending,
            "DESCENDING" => SortKey::Descending,
            other => SortKey::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SortKey {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SortKey::from(s))
    }
}
impl SortKey {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SortKey::Ascending => "ASCENDING",
            SortKey::Descending => "DESCENDING",
            SortKey::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASCENDING", "DESCENDING"]
    }
}
impl AsRef<str> for SortKey {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ScanDirection`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let scandirection = unimplemented!();
/// match scandirection {
///     ScanDirection::Backward => { /* ... */ },
///     ScanDirection::Forward => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `scandirection` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScanDirection::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScanDirection::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScanDirection::NewFeature` is defined.
/// Specifically, when `scandirection` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScanDirection::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScanDirection {
    #[allow(missing_docs)] // documentation missing in model
    Backward,
    #[allow(missing_docs)] // documentation missing in model
    Forward,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScanDirection {
    fn from(s: &str) -> Self {
        match s {
            "BACKWARD" => ScanDirection::Backward,
            "FORWARD" => ScanDirection::Forward,
            other => ScanDirection::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScanDirection {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScanDirection::from(s))
    }
}
impl ScanDirection {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScanDirection::Backward => "BACKWARD",
            ScanDirection::Forward => "FORWARD",
            ScanDirection::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BACKWARD", "FORWARD"]
    }
}
impl AsRef<str> for ScanDirection {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Connection credentials. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionCredentials {
    /// <p>The connection token.</p>
    #[doc(hidden)]
    pub connection_token: std::option::Option<std::string::String>,
    /// <p>The expiration of the token.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    #[doc(hidden)]
    pub expiry: std::option::Option<std::string::String>,
}
impl ConnectionCredentials {
    /// <p>The connection token.</p>
    pub fn connection_token(&self) -> std::option::Option<&str> {
        self.connection_token.as_deref()
    }
    /// <p>The expiration of the token.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    pub fn expiry(&self) -> std::option::Option<&str> {
        self.expiry.as_deref()
    }
}
/// See [`ConnectionCredentials`](crate::model::ConnectionCredentials).
pub mod connection_credentials {

    /// A builder for [`ConnectionCredentials`](crate::model::ConnectionCredentials).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_token: std::option::Option<std::string::String>,
        pub(crate) expiry: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The connection token.</p>
        pub fn connection_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_token = Some(input.into());
            self
        }
        /// <p>The connection token.</p>
        pub fn set_connection_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_token = input;
            self
        }
        /// <p>The expiration of the token.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn expiry(mut self, input: impl Into<std::string::String>) -> Self {
            self.expiry = Some(input.into());
            self
        }
        /// <p>The expiration of the token.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn set_expiry(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expiry = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionCredentials`](crate::model::ConnectionCredentials).
        pub fn build(self) -> crate::model::ConnectionCredentials {
            crate::model::ConnectionCredentials {
                connection_token: self.connection_token,
                expiry: self.expiry,
            }
        }
    }
}
impl ConnectionCredentials {
    /// Creates a new builder-style object to manufacture [`ConnectionCredentials`](crate::model::ConnectionCredentials).
    pub fn builder() -> crate::model::connection_credentials::Builder {
        crate::model::connection_credentials::Builder::default()
    }
}

/// <p>The websocket for the participant's connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Websocket {
    /// <p>The URL of the websocket.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
    /// <p>The URL expiration timestamp in ISO date format.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    #[doc(hidden)]
    pub connection_expiry: std::option::Option<std::string::String>,
}
impl Websocket {
    /// <p>The URL of the websocket.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
    /// <p>The URL expiration timestamp in ISO date format.</p>
    /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
    pub fn connection_expiry(&self) -> std::option::Option<&str> {
        self.connection_expiry.as_deref()
    }
}
/// See [`Websocket`](crate::model::Websocket).
pub mod websocket {

    /// A builder for [`Websocket`](crate::model::Websocket).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) url: std::option::Option<std::string::String>,
        pub(crate) connection_expiry: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URL of the websocket.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL of the websocket.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// <p>The URL expiration timestamp in ISO date format.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn connection_expiry(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_expiry = Some(input.into());
            self
        }
        /// <p>The URL expiration timestamp in ISO date format.</p>
        /// <p>It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.</p>
        pub fn set_connection_expiry(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_expiry = input;
            self
        }
        /// Consumes the builder and constructs a [`Websocket`](crate::model::Websocket).
        pub fn build(self) -> crate::model::Websocket {
            crate::model::Websocket {
                url: self.url,
                connection_expiry: self.connection_expiry,
            }
        }
    }
}
impl Websocket {
    /// Creates a new builder-style object to manufacture [`Websocket`](crate::model::Websocket).
    pub fn builder() -> crate::model::websocket::Builder {
        crate::model::websocket::Builder::default()
    }
}

/// When writing a match expression against `ConnectionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectiontype = unimplemented!();
/// match connectiontype {
///     ConnectionType::ConnectionCredentials => { /* ... */ },
///     ConnectionType::Websocket => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionType::NewFeature` is defined.
/// Specifically, when `connectiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionType {
    #[allow(missing_docs)] // documentation missing in model
    ConnectionCredentials,
    #[allow(missing_docs)] // documentation missing in model
    Websocket,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectionType {
    fn from(s: &str) -> Self {
        match s {
            "CONNECTION_CREDENTIALS" => ConnectionType::ConnectionCredentials,
            "WEBSOCKET" => ConnectionType::Websocket,
            other => ConnectionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ConnectionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionType::from(s))
    }
}
impl ConnectionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionType::ConnectionCredentials => "CONNECTION_CREDENTIALS",
            ConnectionType::Websocket => "WEBSOCKET",
            ConnectionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONNECTION_CREDENTIALS", "WEBSOCKET"]
    }
}
impl AsRef<str> for ConnectionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
