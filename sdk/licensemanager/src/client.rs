// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_grant(&self) -> fluent_builders::AcceptGrant<C> {
        fluent_builders::AcceptGrant::new(self.handle.clone())
    }
    pub fn check_in_license(&self) -> fluent_builders::CheckInLicense<C> {
        fluent_builders::CheckInLicense::new(self.handle.clone())
    }
    pub fn checkout_borrow_license(&self) -> fluent_builders::CheckoutBorrowLicense<C> {
        fluent_builders::CheckoutBorrowLicense::new(self.handle.clone())
    }
    pub fn checkout_license(&self) -> fluent_builders::CheckoutLicense<C> {
        fluent_builders::CheckoutLicense::new(self.handle.clone())
    }
    pub fn create_grant(&self) -> fluent_builders::CreateGrant<C> {
        fluent_builders::CreateGrant::new(self.handle.clone())
    }
    pub fn create_grant_version(&self) -> fluent_builders::CreateGrantVersion<C> {
        fluent_builders::CreateGrantVersion::new(self.handle.clone())
    }
    pub fn create_license(&self) -> fluent_builders::CreateLicense<C> {
        fluent_builders::CreateLicense::new(self.handle.clone())
    }
    pub fn create_license_configuration(&self) -> fluent_builders::CreateLicenseConfiguration<C> {
        fluent_builders::CreateLicenseConfiguration::new(self.handle.clone())
    }
    pub fn create_license_manager_report_generator(
        &self,
    ) -> fluent_builders::CreateLicenseManagerReportGenerator<C> {
        fluent_builders::CreateLicenseManagerReportGenerator::new(self.handle.clone())
    }
    pub fn create_license_version(&self) -> fluent_builders::CreateLicenseVersion<C> {
        fluent_builders::CreateLicenseVersion::new(self.handle.clone())
    }
    pub fn create_token(&self) -> fluent_builders::CreateToken<C> {
        fluent_builders::CreateToken::new(self.handle.clone())
    }
    pub fn delete_grant(&self) -> fluent_builders::DeleteGrant<C> {
        fluent_builders::DeleteGrant::new(self.handle.clone())
    }
    pub fn delete_license(&self) -> fluent_builders::DeleteLicense<C> {
        fluent_builders::DeleteLicense::new(self.handle.clone())
    }
    pub fn delete_license_configuration(&self) -> fluent_builders::DeleteLicenseConfiguration<C> {
        fluent_builders::DeleteLicenseConfiguration::new(self.handle.clone())
    }
    pub fn delete_license_manager_report_generator(
        &self,
    ) -> fluent_builders::DeleteLicenseManagerReportGenerator<C> {
        fluent_builders::DeleteLicenseManagerReportGenerator::new(self.handle.clone())
    }
    pub fn delete_token(&self) -> fluent_builders::DeleteToken<C> {
        fluent_builders::DeleteToken::new(self.handle.clone())
    }
    pub fn extend_license_consumption(&self) -> fluent_builders::ExtendLicenseConsumption<C> {
        fluent_builders::ExtendLicenseConsumption::new(self.handle.clone())
    }
    pub fn get_access_token(&self) -> fluent_builders::GetAccessToken<C> {
        fluent_builders::GetAccessToken::new(self.handle.clone())
    }
    pub fn get_grant(&self) -> fluent_builders::GetGrant<C> {
        fluent_builders::GetGrant::new(self.handle.clone())
    }
    pub fn get_license(&self) -> fluent_builders::GetLicense<C> {
        fluent_builders::GetLicense::new(self.handle.clone())
    }
    pub fn get_license_configuration(&self) -> fluent_builders::GetLicenseConfiguration<C> {
        fluent_builders::GetLicenseConfiguration::new(self.handle.clone())
    }
    pub fn get_license_manager_report_generator(
        &self,
    ) -> fluent_builders::GetLicenseManagerReportGenerator<C> {
        fluent_builders::GetLicenseManagerReportGenerator::new(self.handle.clone())
    }
    pub fn get_license_usage(&self) -> fluent_builders::GetLicenseUsage<C> {
        fluent_builders::GetLicenseUsage::new(self.handle.clone())
    }
    pub fn get_service_settings(&self) -> fluent_builders::GetServiceSettings<C> {
        fluent_builders::GetServiceSettings::new(self.handle.clone())
    }
    pub fn list_associations_for_license_configuration(
        &self,
    ) -> fluent_builders::ListAssociationsForLicenseConfiguration<C> {
        fluent_builders::ListAssociationsForLicenseConfiguration::new(self.handle.clone())
    }
    pub fn list_distributed_grants(&self) -> fluent_builders::ListDistributedGrants<C> {
        fluent_builders::ListDistributedGrants::new(self.handle.clone())
    }
    pub fn list_failures_for_license_configuration_operations(
        &self,
    ) -> fluent_builders::ListFailuresForLicenseConfigurationOperations<C> {
        fluent_builders::ListFailuresForLicenseConfigurationOperations::new(self.handle.clone())
    }
    pub fn list_license_configurations(&self) -> fluent_builders::ListLicenseConfigurations<C> {
        fluent_builders::ListLicenseConfigurations::new(self.handle.clone())
    }
    pub fn list_license_manager_report_generators(
        &self,
    ) -> fluent_builders::ListLicenseManagerReportGenerators<C> {
        fluent_builders::ListLicenseManagerReportGenerators::new(self.handle.clone())
    }
    pub fn list_licenses(&self) -> fluent_builders::ListLicenses<C> {
        fluent_builders::ListLicenses::new(self.handle.clone())
    }
    pub fn list_license_specifications_for_resource(
        &self,
    ) -> fluent_builders::ListLicenseSpecificationsForResource<C> {
        fluent_builders::ListLicenseSpecificationsForResource::new(self.handle.clone())
    }
    pub fn list_license_versions(&self) -> fluent_builders::ListLicenseVersions<C> {
        fluent_builders::ListLicenseVersions::new(self.handle.clone())
    }
    pub fn list_received_grants(&self) -> fluent_builders::ListReceivedGrants<C> {
        fluent_builders::ListReceivedGrants::new(self.handle.clone())
    }
    pub fn list_received_licenses(&self) -> fluent_builders::ListReceivedLicenses<C> {
        fluent_builders::ListReceivedLicenses::new(self.handle.clone())
    }
    pub fn list_resource_inventory(&self) -> fluent_builders::ListResourceInventory<C> {
        fluent_builders::ListResourceInventory::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_tokens(&self) -> fluent_builders::ListTokens<C> {
        fluent_builders::ListTokens::new(self.handle.clone())
    }
    pub fn list_usage_for_license_configuration(
        &self,
    ) -> fluent_builders::ListUsageForLicenseConfiguration<C> {
        fluent_builders::ListUsageForLicenseConfiguration::new(self.handle.clone())
    }
    pub fn reject_grant(&self) -> fluent_builders::RejectGrant<C> {
        fluent_builders::RejectGrant::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_license_configuration(&self) -> fluent_builders::UpdateLicenseConfiguration<C> {
        fluent_builders::UpdateLicenseConfiguration::new(self.handle.clone())
    }
    pub fn update_license_manager_report_generator(
        &self,
    ) -> fluent_builders::UpdateLicenseManagerReportGenerator<C> {
        fluent_builders::UpdateLicenseManagerReportGenerator::new(self.handle.clone())
    }
    pub fn update_license_specifications_for_resource(
        &self,
    ) -> fluent_builders::UpdateLicenseSpecificationsForResource<C> {
        fluent_builders::UpdateLicenseSpecificationsForResource::new(self.handle.clone())
    }
    pub fn update_service_settings(&self) -> fluent_builders::UpdateServiceSettings<C> {
        fluent_builders::UpdateServiceSettings::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptGrant<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_grant_input::Builder,
    }
    impl<C> AcceptGrant<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptGrantOutput,
            smithy_http::result::SdkError<crate::error::AcceptGrantError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the grant.</p>
        pub fn grant_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arn(input);
            self
        }
        pub fn set_grant_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckInLicense<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::check_in_license_input::Builder,
    }
    impl<C> CheckInLicense<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckInLicenseOutput,
            smithy_http::result::SdkError<crate::error::CheckInLicenseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>License consumption token.</p>
        pub fn license_consumption_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_consumption_token(input);
            self
        }
        pub fn set_license_consumption_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_consumption_token(input);
            self
        }
        /// <p>License beneficiary.</p>
        pub fn beneficiary(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.beneficiary(input);
            self
        }
        pub fn set_beneficiary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_beneficiary(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckoutBorrowLicense<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::checkout_borrow_license_input::Builder,
    }
    impl<C> CheckoutBorrowLicense<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckoutBorrowLicenseOutput,
            smithy_http::result::SdkError<crate::error::CheckoutBorrowLicenseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license. The license must use the borrow consumption configuration.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>License entitlements. Partial checkouts are not supported.</p>
        pub fn entitlements(mut self, inp: impl Into<crate::model::EntitlementData>) -> Self {
            self.inner = self.inner.entitlements(inp);
            self
        }
        pub fn set_entitlements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntitlementData>>,
        ) -> Self {
            self.inner = self.inner.set_entitlements(input);
            self
        }
        /// <p>Digital signature method. The possible value is JSON Web Signature (JWS) algorithm PS384.
        /// For more information, see <a href="https://tools.ietf.org/html/rfc7518#section-3.5">RFC 7518 Digital Signature with RSASSA-PSS</a>.</p>
        pub fn digital_signature_method(
            mut self,
            input: crate::model::DigitalSignatureMethod,
        ) -> Self {
            self.inner = self.inner.digital_signature_method(input);
            self
        }
        pub fn set_digital_signature_method(
            mut self,
            input: std::option::Option<crate::model::DigitalSignatureMethod>,
        ) -> Self {
            self.inner = self.inner.set_digital_signature_method(input);
            self
        }
        /// <p>Node ID.</p>
        pub fn node_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_id(input);
            self
        }
        pub fn set_node_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_node_id(input);
            self
        }
        /// <p>Information about constraints.</p>
        pub fn checkout_metadata(mut self, inp: impl Into<crate::model::Metadata>) -> Self {
            self.inner = self.inner.checkout_metadata(inp);
            self
        }
        pub fn set_checkout_metadata(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Metadata>>,
        ) -> Self {
            self.inner = self.inner.set_checkout_metadata(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CheckoutLicense<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::checkout_license_input::Builder,
    }
    impl<C> CheckoutLicense<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CheckoutLicenseOutput,
            smithy_http::result::SdkError<crate::error::CheckoutLicenseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Product SKU.</p>
        pub fn product_sku(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_sku(input);
            self
        }
        pub fn set_product_sku(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_product_sku(input);
            self
        }
        /// <p>Checkout type.</p>
        pub fn checkout_type(mut self, input: crate::model::CheckoutType) -> Self {
            self.inner = self.inner.checkout_type(input);
            self
        }
        pub fn set_checkout_type(
            mut self,
            input: std::option::Option<crate::model::CheckoutType>,
        ) -> Self {
            self.inner = self.inner.set_checkout_type(input);
            self
        }
        /// <p>Key fingerprint identifying the license.</p>
        pub fn key_fingerprint(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_fingerprint(input);
            self
        }
        pub fn set_key_fingerprint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_key_fingerprint(input);
            self
        }
        /// <p>License entitlements.</p>
        pub fn entitlements(mut self, inp: impl Into<crate::model::EntitlementData>) -> Self {
            self.inner = self.inner.entitlements(inp);
            self
        }
        pub fn set_entitlements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EntitlementData>>,
        ) -> Self {
            self.inner = self.inner.set_entitlements(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>License beneficiary.</p>
        pub fn beneficiary(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.beneficiary(input);
            self
        }
        pub fn set_beneficiary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_beneficiary(input);
            self
        }
        /// <p>Node ID.</p>
        pub fn node_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_id(input);
            self
        }
        pub fn set_node_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_node_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGrant<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_grant_input::Builder,
    }
    impl<C> CreateGrant<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGrantOutput,
            smithy_http::result::SdkError<crate::error::CreateGrantError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Grant name.</p>
        pub fn grant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_name(input);
            self
        }
        pub fn set_grant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_name(input);
            self
        }
        /// <p>Amazon Resource Name (ARN) of the license.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>The grant principals.</p>
        pub fn principals(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principals(inp);
            self
        }
        pub fn set_principals(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_principals(input);
            self
        }
        /// <p>Home Region of the grant.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_region(input);
            self
        }
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_home_region(input);
            self
        }
        /// <p>Allowed operations for the grant.</p>
        pub fn allowed_operations(
            mut self,
            inp: impl Into<crate::model::AllowedOperation>,
        ) -> Self {
            self.inner = self.inner.allowed_operations(inp);
            self
        }
        pub fn set_allowed_operations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AllowedOperation>>,
        ) -> Self {
            self.inner = self.inner.set_allowed_operations(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateGrantVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_grant_version_input::Builder,
    }
    impl<C> CreateGrantVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateGrantVersionOutput,
            smithy_http::result::SdkError<crate::error::CreateGrantVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Amazon Resource Name (ARN) of the grant.</p>
        pub fn grant_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arn(input);
            self
        }
        pub fn set_grant_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_arn(input);
            self
        }
        /// <p>Grant name.</p>
        pub fn grant_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_name(input);
            self
        }
        pub fn set_grant_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_name(input);
            self
        }
        /// <p>Allowed operations for the grant.</p>
        pub fn allowed_operations(
            mut self,
            inp: impl Into<crate::model::AllowedOperation>,
        ) -> Self {
            self.inner = self.inner.allowed_operations(inp);
            self
        }
        pub fn set_allowed_operations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AllowedOperation>>,
        ) -> Self {
            self.inner = self.inner.set_allowed_operations(input);
            self
        }
        /// <p>Grant status.</p>
        pub fn status(mut self, input: crate::model::GrantStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::GrantStatus>) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status_reason(input);
            self
        }
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_status_reason(input);
            self
        }
        /// <p>Current version of the grant.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_version(input);
            self
        }
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLicense<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_license_input::Builder,
    }
    impl<C> CreateLicense<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLicenseOutput,
            smithy_http::result::SdkError<crate::error::CreateLicenseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>License name.</p>
        pub fn license_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_name(input);
            self
        }
        pub fn set_license_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_name(input);
            self
        }
        /// <p>Product name.</p>
        pub fn product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_name(input);
            self
        }
        pub fn set_product_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_product_name(input);
            self
        }
        /// <p>Product SKU.</p>
        pub fn product_sku(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_sku(input);
            self
        }
        pub fn set_product_sku(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_product_sku(input);
            self
        }
        /// <p>License issuer.</p>
        pub fn issuer(mut self, input: crate::model::Issuer) -> Self {
            self.inner = self.inner.issuer(input);
            self
        }
        pub fn set_issuer(mut self, input: std::option::Option<crate::model::Issuer>) -> Self {
            self.inner = self.inner.set_issuer(input);
            self
        }
        /// <p>Home Region for the license.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_region(input);
            self
        }
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_home_region(input);
            self
        }
        /// <p>Date and time range during which the license is valid, in ISO8601-UTC format.</p>
        pub fn validity(mut self, input: crate::model::DatetimeRange) -> Self {
            self.inner = self.inner.validity(input);
            self
        }
        pub fn set_validity(
            mut self,
            input: std::option::Option<crate::model::DatetimeRange>,
        ) -> Self {
            self.inner = self.inner.set_validity(input);
            self
        }
        /// <p>License entitlements.</p>
        pub fn entitlements(mut self, inp: impl Into<crate::model::Entitlement>) -> Self {
            self.inner = self.inner.entitlements(inp);
            self
        }
        pub fn set_entitlements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entitlement>>,
        ) -> Self {
            self.inner = self.inner.set_entitlements(input);
            self
        }
        /// <p>License beneficiary.</p>
        pub fn beneficiary(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.beneficiary(input);
            self
        }
        pub fn set_beneficiary(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_beneficiary(input);
            self
        }
        /// <p>Configuration for consumption of the license. Choose a provisional configuration for workloads
        /// running with continuous connectivity. Choose a borrow configuration for workloads with offline
        /// usage.</p>
        pub fn consumption_configuration(
            mut self,
            input: crate::model::ConsumptionConfiguration,
        ) -> Self {
            self.inner = self.inner.consumption_configuration(input);
            self
        }
        pub fn set_consumption_configuration(
            mut self,
            input: std::option::Option<crate::model::ConsumptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_consumption_configuration(input);
            self
        }
        /// <p>Information about the license.</p>
        pub fn license_metadata(mut self, inp: impl Into<crate::model::Metadata>) -> Self {
            self.inner = self.inner.license_metadata(inp);
            self
        }
        pub fn set_license_metadata(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Metadata>>,
        ) -> Self {
            self.inner = self.inner.set_license_metadata(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLicenseConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_license_configuration_input::Builder,
    }
    impl<C> CreateLicenseConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLicenseConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateLicenseConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the license configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Description of the license configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Dimension used to track the license inventory.</p>
        pub fn license_counting_type(mut self, input: crate::model::LicenseCountingType) -> Self {
            self.inner = self.inner.license_counting_type(input);
            self
        }
        pub fn set_license_counting_type(
            mut self,
            input: std::option::Option<crate::model::LicenseCountingType>,
        ) -> Self {
            self.inner = self.inner.set_license_counting_type(input);
            self
        }
        /// <p>Number of licenses managed by the license configuration.</p>
        pub fn license_count(mut self, input: i64) -> Self {
            self.inner = self.inner.license_count(input);
            self
        }
        pub fn set_license_count(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_license_count(input);
            self
        }
        /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit
        /// blocks the launch of new instances.</p>
        pub fn license_count_hard_limit(mut self, input: bool) -> Self {
            self.inner = self.inner.license_count_hard_limit(input);
            self
        }
        pub fn set_license_count_hard_limit(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_license_count_hard_limit(input);
            self
        }
        /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules
        /// vary by dimension, as follows.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Cores</code> dimension: <code>allowedTenancy</code> |
        /// <code>licenseAffinityToHost</code> |
        /// <code>maximumCores</code> | <code>minimumCores</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Instances</code> dimension: <code>allowedTenancy</code> |
        /// <code>maximumCores</code> | <code>minimumCores</code> |
        /// <code>maximumSockets</code> | <code>minimumSockets</code> |
        /// <code>maximumVcpus</code> | <code>minimumVcpus</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Sockets</code> dimension: <code>allowedTenancy</code> |
        /// <code>licenseAffinityToHost</code> |
        /// <code>maximumSockets</code> | <code>minimumSockets</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>vCPUs</code> dimension: <code>allowedTenancy</code> |
        /// <code>honorVcpuOptimization</code> |
        /// <code>maximumVcpus</code> | <code>minimumVcpus</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible
        /// values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and
        /// <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are
        /// <code>True</code> and <code>False</code>.</p>
        pub fn license_rules(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_rules(inp);
            self
        }
        pub fn set_license_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_license_rules(input);
            self
        }
        /// <p>Tags to add to the license configuration.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>When true, disassociates a resource when software is uninstalled.</p>
        pub fn disassociate_when_not_found(mut self, input: bool) -> Self {
            self.inner = self.inner.disassociate_when_not_found(input);
            self
        }
        pub fn set_disassociate_when_not_found(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_disassociate_when_not_found(input);
            self
        }
        /// <p>Product information.</p>
        pub fn product_information_list(
            mut self,
            inp: impl Into<crate::model::ProductInformation>,
        ) -> Self {
            self.inner = self.inner.product_information_list(inp);
            self
        }
        pub fn set_product_information_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductInformation>>,
        ) -> Self {
            self.inner = self.inner.set_product_information_list(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLicenseManagerReportGenerator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_license_manager_report_generator_input::Builder,
    }
    impl<C> CreateLicenseManagerReportGenerator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLicenseManagerReportGeneratorOutput,
            smithy_http::result::SdkError<crate::error::CreateLicenseManagerReportGeneratorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Name of the report generator.</p>
        pub fn report_generator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_generator_name(input);
            self
        }
        pub fn set_report_generator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_generator_name(input);
            self
        }
        /// <p>Type of reports to generate. The following report types an be generated:</p>
        /// <ul>
        /// <li>
        /// <p>License configuration report - Reports on the number and details of consumed licenses for a license configuration.</p>
        /// </li>
        /// <li>
        /// <p>Resource report - Reports on the tracked licenses and resource consumption for a license configuration.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, inp: impl Into<crate::model::ReportType>) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReportType>>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>Defines the type of license configuration the report generator tracks.</p>
        pub fn report_context(mut self, input: crate::model::ReportContext) -> Self {
            self.inner = self.inner.report_context(input);
            self
        }
        pub fn set_report_context(
            mut self,
            input: std::option::Option<crate::model::ReportContext>,
        ) -> Self {
            self.inner = self.inner.set_report_context(input);
            self
        }
        /// <p>Frequency by which reports are generated.  Reports can be generated daily, monthly, or weekly.</p>
        pub fn report_frequency(mut self, input: crate::model::ReportFrequency) -> Self {
            self.inner = self.inner.report_frequency(input);
            self
        }
        pub fn set_report_frequency(
            mut self,
            input: std::option::Option<crate::model::ReportFrequency>,
        ) -> Self {
            self.inner = self.inner.set_report_frequency(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Description of the report generator.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Tags to add to the report generator.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLicenseVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_license_version_input::Builder,
    }
    impl<C> CreateLicenseVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLicenseVersionOutput,
            smithy_http::result::SdkError<crate::error::CreateLicenseVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>License name.</p>
        pub fn license_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_name(input);
            self
        }
        pub fn set_license_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_name(input);
            self
        }
        /// <p>Product name.</p>
        pub fn product_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.product_name(input);
            self
        }
        pub fn set_product_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_product_name(input);
            self
        }
        /// <p>License issuer.</p>
        pub fn issuer(mut self, input: crate::model::Issuer) -> Self {
            self.inner = self.inner.issuer(input);
            self
        }
        pub fn set_issuer(mut self, input: std::option::Option<crate::model::Issuer>) -> Self {
            self.inner = self.inner.set_issuer(input);
            self
        }
        /// <p>Home Region of the license.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.home_region(input);
            self
        }
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_home_region(input);
            self
        }
        /// <p>Date and time range during which the license is valid, in ISO8601-UTC format.</p>
        pub fn validity(mut self, input: crate::model::DatetimeRange) -> Self {
            self.inner = self.inner.validity(input);
            self
        }
        pub fn set_validity(
            mut self,
            input: std::option::Option<crate::model::DatetimeRange>,
        ) -> Self {
            self.inner = self.inner.set_validity(input);
            self
        }
        /// <p>Information about the license.</p>
        pub fn license_metadata(mut self, inp: impl Into<crate::model::Metadata>) -> Self {
            self.inner = self.inner.license_metadata(inp);
            self
        }
        pub fn set_license_metadata(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Metadata>>,
        ) -> Self {
            self.inner = self.inner.set_license_metadata(input);
            self
        }
        /// <p>License entitlements.</p>
        pub fn entitlements(mut self, inp: impl Into<crate::model::Entitlement>) -> Self {
            self.inner = self.inner.entitlements(inp);
            self
        }
        pub fn set_entitlements(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entitlement>>,
        ) -> Self {
            self.inner = self.inner.set_entitlements(input);
            self
        }
        /// <p>Configuration for consumption of the license. Choose a provisional configuration for workloads
        /// running with continuous connectivity. Choose a borrow configuration for workloads with offline
        /// usage.</p>
        pub fn consumption_configuration(
            mut self,
            input: crate::model::ConsumptionConfiguration,
        ) -> Self {
            self.inner = self.inner.consumption_configuration(input);
            self
        }
        pub fn set_consumption_configuration(
            mut self,
            input: std::option::Option<crate::model::ConsumptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_consumption_configuration(input);
            self
        }
        /// <p>License status.</p>
        pub fn status(mut self, input: crate::model::LicenseStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::LicenseStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Current version of the license.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_version(input);
            self
        }
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_token_input::Builder,
    }
    impl<C> CreateToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTokenOutput,
            smithy_http::result::SdkError<crate::error::CreateTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license. The ARN is mapped to the aud claim of the
        /// JWT token.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>Amazon Resource Name (ARN) of the IAM roles to embed in the token.
        /// License Manager does not check whether the roles are in use.</p>
        pub fn role_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arns(inp);
            self
        }
        pub fn set_role_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_role_arns(input);
            self
        }
        /// <p>Token expiration, in days, counted from token creation. The default is 365 days.</p>
        pub fn expiration_in_days(mut self, input: i32) -> Self {
            self.inner = self.inner.expiration_in_days(input);
            self
        }
        pub fn set_expiration_in_days(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_expiration_in_days(input);
            self
        }
        /// <p>Data specified by the caller to be included in the JWT token. The data is mapped
        /// to the amr claim of the JWT token.</p>
        pub fn token_properties(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_properties(inp);
            self
        }
        pub fn set_token_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_token_properties(input);
            self
        }
        /// <p>Idempotency token, valid for 10 minutes.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGrant<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_grant_input::Builder,
    }
    impl<C> DeleteGrant<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGrantOutput,
            smithy_http::result::SdkError<crate::error::DeleteGrantError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the grant.</p>
        pub fn grant_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arn(input);
            self
        }
        pub fn set_grant_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_arn(input);
            self
        }
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status_reason(input);
            self
        }
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_status_reason(input);
            self
        }
        /// <p>Current version of the grant.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLicense<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_license_input::Builder,
    }
    impl<C> DeleteLicense<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLicenseOutput,
            smithy_http::result::SdkError<crate::error::DeleteLicenseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>Current version of the license.</p>
        pub fn source_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_version(input);
            self
        }
        pub fn set_source_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLicenseConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_license_configuration_input::Builder,
    }
    impl<C> DeleteLicenseConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLicenseConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteLicenseConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>ID of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arn(input);
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLicenseManagerReportGenerator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_license_manager_report_generator_input::Builder,
    }
    impl<C> DeleteLicenseManagerReportGenerator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLicenseManagerReportGeneratorOutput,
            smithy_http::result::SdkError<crate::error::DeleteLicenseManagerReportGeneratorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Number (ARN) of the report generator that will be deleted.</p>
        pub fn license_manager_report_generator_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.license_manager_report_generator_arn(input);
            self
        }
        pub fn set_license_manager_report_generator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_manager_report_generator_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_token_input::Builder,
    }
    impl<C> DeleteToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTokenOutput,
            smithy_http::result::SdkError<crate::error::DeleteTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token ID.</p>
        pub fn token_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_id(input);
            self
        }
        pub fn set_token_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExtendLicenseConsumption<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::extend_license_consumption_input::Builder,
    }
    impl<C> ExtendLicenseConsumption<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExtendLicenseConsumptionOutput,
            smithy_http::result::SdkError<crate::error::ExtendLicenseConsumptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>License consumption token.</p>
        pub fn license_consumption_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_consumption_token(input);
            self
        }
        pub fn set_license_consumption_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_consumption_token(input);
            self
        }
        /// <p>Checks whether you have the required permissions for the action, without actually making the request. Provides an error response if you do not have the required permissions.</p>
        pub fn dry_run(mut self, input: bool) -> Self {
            self.inner = self.inner.dry_run(input);
            self
        }
        pub fn set_dry_run(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_dry_run(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_token_input::Builder,
    }
    impl<C> GetAccessToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessTokenOutput,
            smithy_http::result::SdkError<crate::error::GetAccessTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Refresh token, encoded as a JWT token.</p>
        pub fn token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token(input);
            self
        }
        pub fn set_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token(input);
            self
        }
        /// <p>Token properties to validate against those present in the JWT token.</p>
        pub fn token_properties(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_properties(inp);
            self
        }
        pub fn set_token_properties(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_token_properties(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetGrant<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_grant_input::Builder,
    }
    impl<C> GetGrant<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetGrantOutput,
            smithy_http::result::SdkError<crate::error::GetGrantError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the grant.</p>
        pub fn grant_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arn(input);
            self
        }
        pub fn set_grant_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_arn(input);
            self
        }
        /// <p>Grant version.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLicense<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_license_input::Builder,
    }
    impl<C> GetLicense<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLicenseOutput,
            smithy_http::result::SdkError<crate::error::GetLicenseError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>License version.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLicenseConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_license_configuration_input::Builder,
    }
    impl<C> GetLicenseConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLicenseConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetLicenseConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arn(input);
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLicenseManagerReportGenerator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_license_manager_report_generator_input::Builder,
    }
    impl<C> GetLicenseManagerReportGenerator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLicenseManagerReportGeneratorOutput,
            smithy_http::result::SdkError<crate::error::GetLicenseManagerReportGeneratorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>mazon Resource Number (ARN) of the report generator to retrieve information on.</p>
        pub fn license_manager_report_generator_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.license_manager_report_generator_arn(input);
            self
        }
        pub fn set_license_manager_report_generator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_manager_report_generator_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLicenseUsage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_license_usage_input::Builder,
    }
    impl<C> GetLicenseUsage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLicenseUsageOutput,
            smithy_http::result::SdkError<crate::error::GetLicenseUsageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetServiceSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_service_settings_input::Builder,
    }
    impl<C> GetServiceSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetServiceSettingsOutput,
            smithy_http::result::SdkError<crate::error::GetServiceSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAssociationsForLicenseConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_associations_for_license_configuration_input::Builder,
    }
    impl<C> ListAssociationsForLicenseConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAssociationsForLicenseConfigurationOutput,
            smithy_http::result::SdkError<
                crate::error::ListAssociationsForLicenseConfigurationError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of a license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arn(input);
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arn(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDistributedGrants<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_distributed_grants_input::Builder,
    }
    impl<C> ListDistributedGrants<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDistributedGrantsOutput,
            smithy_http::result::SdkError<crate::error::ListDistributedGrantsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Names (ARNs) of the grants.</p>
        pub fn grant_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arns(inp);
            self
        }
        pub fn set_grant_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_grant_arns(input);
            self
        }
        /// <p>Filters to scope the results. The following filters are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LicenseArn</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GrantStatus</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GranteePrincipalARN</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ProductSKU</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LicenseIssuerName</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFailuresForLicenseConfigurationOperations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_failures_for_license_configuration_operations_input::Builder,
    }
    impl<C> ListFailuresForLicenseConfigurationOperations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFailuresForLicenseConfigurationOperationsOutput,
            smithy_http::result::SdkError<
                crate::error::ListFailuresForLicenseConfigurationOperationsError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arn(input);
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arn(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLicenseConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_license_configurations_input::Builder,
    }
    impl<C> ListLicenseConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLicenseConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListLicenseConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Names (ARN) of the license configurations.</p>
        pub fn license_configuration_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arns(inp);
            self
        }
        pub fn set_license_configuration_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arns(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Filters to scope the results. The following filters and logical operators
        /// are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>licenseCountingType</code> - The dimension on which licenses are counted.
        /// Possible values are <code>vCPU</code> | <code>Instance</code> | <code>Core</code> | <code>Socket</code>.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>enforceLicenseCount</code> - A Boolean value that indicates whether hard license enforcement is used.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>usagelimitExceeded</code> - A Boolean value that indicates whether the available licenses have been exceeded.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLicenseManagerReportGenerators<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_license_manager_report_generators_input::Builder,
    }
    impl<C> ListLicenseManagerReportGenerators<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLicenseManagerReportGeneratorsOutput,
            smithy_http::result::SdkError<crate::error::ListLicenseManagerReportGeneratorsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Filters to scope the results. The following filters are supported: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LicenseConfigurationArn</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLicenses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_licenses_input::Builder,
    }
    impl<C> ListLicenses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLicensesOutput,
            smithy_http::result::SdkError<crate::error::ListLicensesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Names (ARNs) of the licenses.</p>
        pub fn license_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arns(inp);
            self
        }
        pub fn set_license_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_license_arns(input);
            self
        }
        /// <p>Filters to scope the results. The following filters are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Beneficiary</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ProductSKU</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Fingerprint</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Status</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLicenseSpecificationsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_license_specifications_for_resource_input::Builder,
    }
    impl<C> ListLicenseSpecificationsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLicenseSpecificationsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListLicenseSpecificationsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of a resource that has an associated license configuration.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLicenseVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_license_versions_input::Builder,
    }
    impl<C> ListLicenseVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLicenseVersionsOutput,
            smithy_http::result::SdkError<crate::error::ListLicenseVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license.</p>
        pub fn license_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arn(input);
            self
        }
        pub fn set_license_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_license_arn(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReceivedGrants<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_received_grants_input::Builder,
    }
    impl<C> ListReceivedGrants<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReceivedGrantsOutput,
            smithy_http::result::SdkError<crate::error::ListReceivedGrantsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Names (ARNs) of the grants.</p>
        pub fn grant_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arns(inp);
            self
        }
        pub fn set_grant_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_grant_arns(input);
            self
        }
        /// <p>Filters to scope the results. The following filters are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ProductSKU</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LicenseIssuerName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>LicenseArn</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GrantStatus</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GranterAccountId</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListReceivedLicenses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_received_licenses_input::Builder,
    }
    impl<C> ListReceivedLicenses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListReceivedLicensesOutput,
            smithy_http::result::SdkError<crate::error::ListReceivedLicensesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Names (ARNs) of the licenses.</p>
        pub fn license_arns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_arns(inp);
            self
        }
        pub fn set_license_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_license_arns(input);
            self
        }
        /// <p>Filters to scope the results. The following filters are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ProductSKU</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Status</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Fingerprint</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IssuerName</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Beneficiary</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListResourceInventory<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_resource_inventory_input::Builder,
    }
    impl<C> ListResourceInventory<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListResourceInventoryOutput,
            smithy_http::result::SdkError<crate::error::ListResourceInventoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Filters to scope the results. The following filters and logical operators
        /// are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>account_id</code> - The ID of the AWS account that owns the resource.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>application_name</code> - The name of the application.
        /// Logical operators are <code>EQUALS</code> | <code>BEGINS_WITH</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>license_included</code> - The type of license included.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.
        /// Possible values are <code>sql-server-enterprise</code> |
        /// <code>sql-server-standard</code> |
        /// <code>sql-server-web</code> |  
        /// <code>windows-server-datacenter</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>platform</code> - The platform of the resource.
        /// Logical operators are <code>EQUALS</code> | <code>BEGINS_WITH</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resource_id</code> - The ID of the resource.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>tag:<key></code> - The key/value combination of a tag assigned
        /// to the resource. Logical operators are <code>EQUALS</code> (single account) or
        /// <code>EQUALS</code> | <code>NOT_EQUALS</code> (cross account).</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::InventoryFilter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InventoryFilter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTokens<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tokens_input::Builder,
    }
    impl<C> ListTokens<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTokensOutput,
            smithy_http::result::SdkError<crate::error::ListTokensError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Token IDs.</p>
        pub fn token_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_ids(inp);
            self
        }
        pub fn set_token_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_token_ids(input);
            self
        }
        /// <p>Filters to scope the results. The following filter is supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>LicenseArns</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUsageForLicenseConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_usage_for_license_configuration_input::Builder,
    }
    impl<C> ListUsageForLicenseConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUsageForLicenseConfigurationOutput,
            smithy_http::result::SdkError<crate::error::ListUsageForLicenseConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arn(input);
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arn(input);
            self
        }
        /// <p>Maximum number of results to return in a single call.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>Token for the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>Filters to scope the results. The following filters and logical operators
        /// are supported:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>resourceArn</code> - The ARN of the license configuration resource.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resourceType</code> - The resource type (<code>EC2_INSTANCE</code> | <code>EC2_HOST</code> | <code>EC2_AMI</code> | <code>SYSTEMS_MANAGER_MANAGED_INSTANCE</code>).
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>resourceAccount</code> - The ID of the account that owns the resource.
        /// Logical operators are <code>EQUALS</code> | <code>NOT_EQUALS</code>.</p>
        /// </li>
        /// </ul>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RejectGrant<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::reject_grant_input::Builder,
    }
    impl<C> RejectGrant<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RejectGrantOutput,
            smithy_http::result::SdkError<crate::error::RejectGrantError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the grant.</p>
        pub fn grant_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_arn(input);
            self
        }
        pub fn set_grant_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>One or more tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>Keys identifying the tags to remove.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLicenseConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_license_configuration_input::Builder,
    }
    impl<C> UpdateLicenseConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLicenseConfigurationOutput,
            smithy_http::result::SdkError<crate::error::UpdateLicenseConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the license configuration.</p>
        pub fn license_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_configuration_arn(input);
            self
        }
        pub fn set_license_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_arn(input);
            self
        }
        /// <p>New status of the license configuration.</p>
        pub fn license_configuration_status(
            mut self,
            input: crate::model::LicenseConfigurationStatus,
        ) -> Self {
            self.inner = self.inner.license_configuration_status(input);
            self
        }
        pub fn set_license_configuration_status(
            mut self,
            input: std::option::Option<crate::model::LicenseConfigurationStatus>,
        ) -> Self {
            self.inner = self.inner.set_license_configuration_status(input);
            self
        }
        /// <p>New license rule. The only rule that you can add after you create a license
        /// configuration is licenseAffinityToHost.</p>
        pub fn license_rules(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.license_rules(inp);
            self
        }
        pub fn set_license_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_license_rules(input);
            self
        }
        /// <p>New number of licenses managed by the license configuration.</p>
        pub fn license_count(mut self, input: i64) -> Self {
            self.inner = self.inner.license_count(input);
            self
        }
        pub fn set_license_count(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_license_count(input);
            self
        }
        /// <p>New hard limit of the number of available licenses.</p>
        pub fn license_count_hard_limit(mut self, input: bool) -> Self {
            self.inner = self.inner.license_count_hard_limit(input);
            self
        }
        pub fn set_license_count_hard_limit(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_license_count_hard_limit(input);
            self
        }
        /// <p>New name of the license configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>New description of the license configuration.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>New product information.</p>
        pub fn product_information_list(
            mut self,
            inp: impl Into<crate::model::ProductInformation>,
        ) -> Self {
            self.inner = self.inner.product_information_list(inp);
            self
        }
        pub fn set_product_information_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ProductInformation>>,
        ) -> Self {
            self.inner = self.inner.set_product_information_list(input);
            self
        }
        /// <p>When true, disassociates a resource when software is uninstalled.</p>
        pub fn disassociate_when_not_found(mut self, input: bool) -> Self {
            self.inner = self.inner.disassociate_when_not_found(input);
            self
        }
        pub fn set_disassociate_when_not_found(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_disassociate_when_not_found(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLicenseManagerReportGenerator<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_license_manager_report_generator_input::Builder,
    }
    impl<C> UpdateLicenseManagerReportGenerator<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLicenseManagerReportGeneratorOutput,
            smithy_http::result::SdkError<crate::error::UpdateLicenseManagerReportGeneratorError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Number (ARN) of the report generator to update.</p>
        pub fn license_manager_report_generator_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.license_manager_report_generator_arn(input);
            self
        }
        pub fn set_license_manager_report_generator_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_license_manager_report_generator_arn(input);
            self
        }
        /// <p>Name of the report generator.</p>
        pub fn report_generator_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.report_generator_name(input);
            self
        }
        pub fn set_report_generator_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_report_generator_name(input);
            self
        }
        /// <p>Type of reports to generate. The following report types an be generated:</p>
        /// <ul>
        /// <li>
        /// <p>License configuration report - Reports on the number and details of consumed licenses for a license configuration.</p>
        /// </li>
        /// <li>
        /// <p>Resource report - Reports on the tracked licenses and resource consumption for a license configuration.</p>
        /// </li>
        /// </ul>
        pub fn r#type(mut self, inp: impl Into<crate::model::ReportType>) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReportType>>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
        /// <p>?</p>
        pub fn report_context(mut self, input: crate::model::ReportContext) -> Self {
            self.inner = self.inner.report_context(input);
            self
        }
        pub fn set_report_context(
            mut self,
            input: std::option::Option<crate::model::ReportContext>,
        ) -> Self {
            self.inner = self.inner.set_report_context(input);
            self
        }
        /// <p>Frequency by which reports are generated.  The following options are avaiable:</p>
        /// <p>??? What are the APi value options?</p>
        pub fn report_frequency(mut self, input: crate::model::ReportFrequency) -> Self {
            self.inner = self.inner.report_frequency(input);
            self
        }
        pub fn set_report_frequency(
            mut self,
            input: std::option::Option<crate::model::ReportFrequency>,
        ) -> Self {
            self.inner = self.inner.set_report_frequency(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Description of the report generator.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLicenseSpecificationsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_license_specifications_for_resource_input::Builder,
    }
    impl<C> UpdateLicenseSpecificationsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLicenseSpecificationsForResourceOutput,
            smithy_http::result::SdkError<
                crate::error::UpdateLicenseSpecificationsForResourceError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the AWS resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>ARNs of the license configurations to add.</p>
        pub fn add_license_specifications(
            mut self,
            inp: impl Into<crate::model::LicenseSpecification>,
        ) -> Self {
            self.inner = self.inner.add_license_specifications(inp);
            self
        }
        pub fn set_add_license_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LicenseSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_add_license_specifications(input);
            self
        }
        /// <p>ARNs of the license configurations to remove.</p>
        pub fn remove_license_specifications(
            mut self,
            inp: impl Into<crate::model::LicenseSpecification>,
        ) -> Self {
            self.inner = self.inner.remove_license_specifications(inp);
            self
        }
        pub fn set_remove_license_specifications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LicenseSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_remove_license_specifications(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateServiceSettings<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_service_settings_input::Builder,
    }
    impl<C> UpdateServiceSettings<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateServiceSettingsOutput,
            smithy_http::result::SdkError<crate::error::UpdateServiceSettingsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Amazon Resource Name (ARN) of the Amazon S3 bucket where the License Manager information is stored.</p>
        pub fn s3_bucket_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_bucket_arn(input);
            self
        }
        pub fn set_s3_bucket_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_s3_bucket_arn(input);
            self
        }
        /// <p>Amazon Resource Name (ARN) of the Amazon SNS topic used for License Manager alerts.</p>
        pub fn sns_topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.sns_topic_arn(input);
            self
        }
        pub fn set_sns_topic_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_sns_topic_arn(input);
            self
        }
        /// <p>Enables integration with AWS Organizations for cross-account discovery.</p>
        pub fn organization_configuration(
            mut self,
            input: crate::model::OrganizationConfiguration,
        ) -> Self {
            self.inner = self.inner.organization_configuration(input);
            self
        }
        pub fn set_organization_configuration(
            mut self,
            input: std::option::Option<crate::model::OrganizationConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_organization_configuration(input);
            self
        }
        /// <p>Activates cross-account discovery.</p>
        pub fn enable_cross_accounts_discovery(mut self, input: bool) -> Self {
            self.inner = self.inner.enable_cross_accounts_discovery(input);
            self
        }
        pub fn set_enable_cross_accounts_discovery(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_enable_cross_accounts_discovery(input);
            self
        }
    }
}
