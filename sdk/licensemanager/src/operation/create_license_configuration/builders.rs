// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_license_configuration::_create_license_configuration_output::CreateLicenseConfigurationOutputBuilder;

pub use crate::operation::create_license_configuration::_create_license_configuration_input::CreateLicenseConfigurationInputBuilder;

impl crate::operation::create_license_configuration::builders::CreateLicenseConfigurationInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_license_configuration::CreateLicenseConfigurationOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_license_configuration::CreateLicenseConfigurationError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_license_configuration();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateLicenseConfiguration`.
///
/// <p>Creates a license configuration.</p>
/// <p>A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager. Components include specifications for the license type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy, Dedicated Instance, Dedicated Host, or all of these), license affinity to host (how long a license must be associated with a host), and the number of licenses purchased and used.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateLicenseConfigurationFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_license_configuration::builders::CreateLicenseConfigurationInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_license_configuration::CreateLicenseConfigurationOutput,
        crate::operation::create_license_configuration::CreateLicenseConfigurationError,
    > for CreateLicenseConfigurationFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_license_configuration::CreateLicenseConfigurationOutput,
            crate::operation::create_license_configuration::CreateLicenseConfigurationError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateLicenseConfigurationFluentBuilder {
    /// Creates a new `CreateLicenseConfiguration`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateLicenseConfiguration as a reference.
    pub fn as_input(&self) -> &crate::operation::create_license_configuration::builders::CreateLicenseConfigurationInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_license_configuration::CreateLicenseConfigurationOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_license_configuration::CreateLicenseConfigurationError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_license_configuration::CreateLicenseConfiguration::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_license_configuration::CreateLicenseConfiguration::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_license_configuration::CreateLicenseConfigurationOutput,
        crate::operation::create_license_configuration::CreateLicenseConfigurationError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>Name of the license configuration.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>Name of the license configuration.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>Name of the license configuration.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>Description of the license configuration.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>Description of the license configuration.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>Description of the license configuration.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>Dimension used to track the license inventory.</p>
    pub fn license_counting_type(mut self, input: crate::types::LicenseCountingType) -> Self {
        self.inner = self.inner.license_counting_type(input);
        self
    }
    /// <p>Dimension used to track the license inventory.</p>
    pub fn set_license_counting_type(mut self, input: ::std::option::Option<crate::types::LicenseCountingType>) -> Self {
        self.inner = self.inner.set_license_counting_type(input);
        self
    }
    /// <p>Dimension used to track the license inventory.</p>
    pub fn get_license_counting_type(&self) -> &::std::option::Option<crate::types::LicenseCountingType> {
        self.inner.get_license_counting_type()
    }
    /// <p>Number of licenses managed by the license configuration.</p>
    pub fn license_count(mut self, input: i64) -> Self {
        self.inner = self.inner.license_count(input);
        self
    }
    /// <p>Number of licenses managed by the license configuration.</p>
    pub fn set_license_count(mut self, input: ::std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_license_count(input);
        self
    }
    /// <p>Number of licenses managed by the license configuration.</p>
    pub fn get_license_count(&self) -> &::std::option::Option<i64> {
        self.inner.get_license_count()
    }
    /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.</p>
    pub fn license_count_hard_limit(mut self, input: bool) -> Self {
        self.inner = self.inner.license_count_hard_limit(input);
        self
    }
    /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.</p>
    pub fn set_license_count_hard_limit(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_license_count_hard_limit(input);
        self
    }
    /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.</p>
    pub fn get_license_count_hard_limit(&self) -> &::std::option::Option<bool> {
        self.inner.get_license_count_hard_limit()
    }
    ///
    /// Appends an item to `LicenseRules`.
    ///
    /// To override the contents of this collection use [`set_license_rules`](Self::set_license_rules).
    ///
    /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.</p>
    /// <ul>
    /// <li>
    /// <p><code>Cores</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumCores</code> | <code>minimumCores</code></p></li>
    /// <li>
    /// <p><code>Instances</code> dimension: <code>allowedTenancy</code> | <code>maximumCores</code> | <code>minimumCores</code> | <code>maximumSockets</code> | <code>minimumSockets</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code></p></li>
    /// <li>
    /// <p><code>Sockets</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumSockets</code> | <code>minimumSockets</code></p></li>
    /// <li>
    /// <p><code>vCPUs</code> dimension: <code>allowedTenancy</code> | <code>honorVcpuOptimization</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code></p></li>
    /// </ul>
    /// <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are <code>True</code> and <code>False</code>.</p>
    pub fn license_rules(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.license_rules(input.into());
        self
    }
    /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.</p>
    /// <ul>
    /// <li>
    /// <p><code>Cores</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumCores</code> | <code>minimumCores</code></p></li>
    /// <li>
    /// <p><code>Instances</code> dimension: <code>allowedTenancy</code> | <code>maximumCores</code> | <code>minimumCores</code> | <code>maximumSockets</code> | <code>minimumSockets</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code></p></li>
    /// <li>
    /// <p><code>Sockets</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumSockets</code> | <code>minimumSockets</code></p></li>
    /// <li>
    /// <p><code>vCPUs</code> dimension: <code>allowedTenancy</code> | <code>honorVcpuOptimization</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code></p></li>
    /// </ul>
    /// <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are <code>True</code> and <code>False</code>.</p>
    pub fn set_license_rules(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_license_rules(input);
        self
    }
    /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.</p>
    /// <ul>
    /// <li>
    /// <p><code>Cores</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumCores</code> | <code>minimumCores</code></p></li>
    /// <li>
    /// <p><code>Instances</code> dimension: <code>allowedTenancy</code> | <code>maximumCores</code> | <code>minimumCores</code> | <code>maximumSockets</code> | <code>minimumSockets</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code></p></li>
    /// <li>
    /// <p><code>Sockets</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumSockets</code> | <code>minimumSockets</code></p></li>
    /// <li>
    /// <p><code>vCPUs</code> dimension: <code>allowedTenancy</code> | <code>honorVcpuOptimization</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code></p></li>
    /// </ul>
    /// <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are <code>True</code> and <code>False</code>.</p>
    pub fn get_license_rules(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_license_rules()
    }
    ///
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags to add to the license configuration.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>Tags to add to the license configuration.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>Tags to add to the license configuration.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        self.inner.get_tags()
    }
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    pub fn disassociate_when_not_found(mut self, input: bool) -> Self {
        self.inner = self.inner.disassociate_when_not_found(input);
        self
    }
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    pub fn set_disassociate_when_not_found(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_disassociate_when_not_found(input);
        self
    }
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    pub fn get_disassociate_when_not_found(&self) -> &::std::option::Option<bool> {
        self.inner.get_disassociate_when_not_found()
    }
    ///
    /// Appends an item to `ProductInformationList`.
    ///
    /// To override the contents of this collection use [`set_product_information_list`](Self::set_product_information_list).
    ///
    /// <p>Product information.</p>
    pub fn product_information_list(mut self, input: crate::types::ProductInformation) -> Self {
        self.inner = self.inner.product_information_list(input);
        self
    }
    /// <p>Product information.</p>
    pub fn set_product_information_list(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::ProductInformation>>) -> Self {
        self.inner = self.inner.set_product_information_list(input);
        self
    }
    /// <p>Product information.</p>
    pub fn get_product_information_list(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::ProductInformation>> {
        self.inner.get_product_information_list()
    }
}
