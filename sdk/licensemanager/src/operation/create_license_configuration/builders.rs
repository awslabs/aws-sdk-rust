// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_license_configuration::_create_license_configuration_output::CreateLicenseConfigurationOutputBuilder;

pub use crate::operation::create_license_configuration::_create_license_configuration_input::CreateLicenseConfigurationInputBuilder;

/// Fluent builder constructing a request to `CreateLicenseConfiguration`.
/// 
/// <p>Creates a license configuration.</p> 
/// <p>A license configuration is an abstraction of a customer license agreement that can be consumed and enforced by License Manager. Components include specifications for the license type (licensing by instance, socket, CPU, or vCPU), allowed tenancy (shared tenancy, Dedicated Instance, Dedicated Host, or all of these), license affinity to host (how long a license must be associated with a host), and the number of licenses purchased and used.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct CreateLicenseConfigurationFluentBuilder {
                handle: std::sync::Arc<crate::client::Handle>,
                inner: crate::operation::create_license_configuration::builders::CreateLicenseConfigurationInputBuilder
            }
impl CreateLicenseConfigurationFluentBuilder  {
    /// Creates a new `CreateLicenseConfiguration`.
                    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
                        Self { handle, inner: Default::default() }
                    }
    
                    /// Consume this builder, creating a customizable operation that can be modified before being
                    /// sent. The operation's inner [http::Request] can be modified as well.
                    pub async fn customize(self) -> std::result::Result<
                        crate::client::customize::CustomizableOperation<crate::operation::create_license_configuration::CreateLicenseConfiguration, aws_http::retry::AwsResponseRetryClassifier,>,
                        aws_smithy_http::result::SdkError<crate::operation::create_license_configuration::CreateLicenseConfigurationError>
                    >  {
                        let handle = self.handle.clone();
                        let operation = self.inner.build().map_err(aws_smithy_http::result::SdkError::construction_failure)?
                            .make_operation(&handle.conf)
                            .await
                            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
                        Ok(crate::client::customize::CustomizableOperation { handle, operation })
                    }
    
                    /// Sends the request and returns the response.
                    ///
                    /// If an error occurs, an `SdkError` will be returned with additional details that
                    /// can be matched against.
                    ///
                    /// By default, any retryable failures will be retried twice. Retry behavior
                    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
                    /// set when configuring the client.
                    pub async fn send(self) -> std::result::Result<crate::operation::create_license_configuration::CreateLicenseConfigurationOutput, aws_smithy_http::result::SdkError<crate::operation::create_license_configuration::CreateLicenseConfigurationError>>
                     {
                        let op = self.inner.build().map_err(aws_smithy_http::result::SdkError::construction_failure)?
                            .make_operation(&self.handle.conf)
                            .await
                            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
                        self.handle.client.call(op).await
                    }
    /// <p>Name of the license configuration.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>Name of the license configuration.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>Description of the license configuration.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>Description of the license configuration.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>Dimension used to track the license inventory.</p>
    pub fn license_counting_type(mut self, input: crate::types::LicenseCountingType) -> Self {
        self.inner = self.inner.license_counting_type(input);
        self
    }
    /// <p>Dimension used to track the license inventory.</p>
    pub fn set_license_counting_type(mut self, input: std::option::Option<crate::types::LicenseCountingType>) -> Self {
        self.inner = self.inner.set_license_counting_type(input);
        self
    }
    /// <p>Number of licenses managed by the license configuration.</p>
    pub fn license_count(mut self, input: i64) -> Self {
        self.inner = self.inner.license_count(input);
        self
    }
    /// <p>Number of licenses managed by the license configuration.</p>
    pub fn set_license_count(mut self, input: std::option::Option<i64>) -> Self {
        self.inner = self.inner.set_license_count(input);
        self
    }
    /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.</p>
    pub fn license_count_hard_limit(mut self, input: bool) -> Self {
        self.inner = self.inner.license_count_hard_limit(input);
        self
    }
    /// <p>Indicates whether hard or soft license enforcement is used. Exceeding a hard limit blocks the launch of new instances.</p>
    pub fn set_license_count_hard_limit(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_license_count_hard_limit(input);
        self
    }
    /// Appends an item to `LicenseRules`.
    ///
    /// To override the contents of this collection use [`set_license_rules`](Self::set_license_rules).
    ///
    /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.</p> 
    /// <ul> 
    /// <li> <p> <code>Cores</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumCores</code> | <code>minimumCores</code> </p> </li> 
    /// <li> <p> <code>Instances</code> dimension: <code>allowedTenancy</code> | <code>maximumCores</code> | <code>minimumCores</code> | <code>maximumSockets</code> | <code>minimumSockets</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code> </p> </li> 
    /// <li> <p> <code>Sockets</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumSockets</code> | <code>minimumSockets</code> </p> </li> 
    /// <li> <p> <code>vCPUs</code> dimension: <code>allowedTenancy</code> | <code>honorVcpuOptimization</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code> </p> </li> 
    /// </ul> 
    /// <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are <code>True</code> and <code>False</code>.</p>
    pub fn license_rules(mut self, input: impl Into<std::string::String>) -> Self {
        self.inner = self.inner.license_rules(input.into());
        self
    }
    /// <p>License rules. The syntax is #name=value (for example, #allowedTenancy=EC2-DedicatedHost). The available rules vary by dimension, as follows.</p> 
    /// <ul> 
    /// <li> <p> <code>Cores</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumCores</code> | <code>minimumCores</code> </p> </li> 
    /// <li> <p> <code>Instances</code> dimension: <code>allowedTenancy</code> | <code>maximumCores</code> | <code>minimumCores</code> | <code>maximumSockets</code> | <code>minimumSockets</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code> </p> </li> 
    /// <li> <p> <code>Sockets</code> dimension: <code>allowedTenancy</code> | <code>licenseAffinityToHost</code> | <code>maximumSockets</code> | <code>minimumSockets</code> </p> </li> 
    /// <li> <p> <code>vCPUs</code> dimension: <code>allowedTenancy</code> | <code>honorVcpuOptimization</code> | <code>maximumVcpus</code> | <code>minimumVcpus</code> </p> </li> 
    /// </ul> 
    /// <p>The unit for <code>licenseAffinityToHost</code> is days and the range is 1 to 180. The possible values for <code>allowedTenancy</code> are <code>EC2-Default</code>, <code>EC2-DedicatedHost</code>, and <code>EC2-DedicatedInstance</code>. The possible values for <code>honorVcpuOptimization</code> are <code>True</code> and <code>False</code>.</p>
    pub fn set_license_rules(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        self.inner = self.inner.set_license_rules(input);
        self
    }
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags to add to the license configuration.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>Tags to add to the license configuration.</p>
    pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    pub fn disassociate_when_not_found(mut self, input: bool) -> Self {
        self.inner = self.inner.disassociate_when_not_found(input);
        self
    }
    /// <p>When true, disassociates a resource when software is uninstalled.</p>
    pub fn set_disassociate_when_not_found(mut self, input: std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_disassociate_when_not_found(input);
        self
    }
    /// Appends an item to `ProductInformationList`.
    ///
    /// To override the contents of this collection use [`set_product_information_list`](Self::set_product_information_list).
    ///
    /// <p>Product information.</p>
    pub fn product_information_list(mut self, input: crate::types::ProductInformation) -> Self {
        self.inner = self.inner.product_information_list(input);
        self
    }
    /// <p>Product information.</p>
    pub fn set_product_information_list(mut self, input: std::option::Option<std::vec::Vec<crate::types::ProductInformation>>) -> Self {
        self.inner = self.inner.set_product_information_list(input);
        self
    }
}

