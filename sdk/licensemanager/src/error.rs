// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptGrantError {
    pub kind: AcceptGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptGrantErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptGrantErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::ValidationException(_inner) => _inner.fmt(f),
            AcceptGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptGrantError {
    fn code(&self) -> Option<&str> {
        AcceptGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptGrantError {
    pub fn new(kind: AcceptGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AcceptGrantErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, AcceptGrantErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptGrantErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptGrantErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptGrantErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, AcceptGrantErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, AcceptGrantErrorKind::ValidationException(_))
    }
}
impl std::error::Error for AcceptGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptGrantErrorKind::AccessDeniedException(_inner) => Some(_inner),
            AcceptGrantErrorKind::AuthorizationException(_inner) => Some(_inner),
            AcceptGrantErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            AcceptGrantErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            AcceptGrantErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            AcceptGrantErrorKind::ServerInternalException(_inner) => Some(_inner),
            AcceptGrantErrorKind::ValidationException(_inner) => Some(_inner),
            AcceptGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckInLicenseError {
    pub kind: CheckInLicenseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckInLicenseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    ConflictException(crate::error::ConflictException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckInLicenseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckInLicenseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CheckInLicenseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckInLicenseError {
    fn code(&self) -> Option<&str> {
        CheckInLicenseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckInLicenseError {
    pub fn new(kind: CheckInLicenseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckInLicenseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckInLicenseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckInLicenseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckInLicenseErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CheckInLicenseErrorKind::ConflictException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckInLicenseErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckInLicenseErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckInLicenseErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckInLicenseErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CheckInLicenseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CheckInLicenseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckInLicenseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::AuthorizationException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::ConflictException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::ServerInternalException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::ValidationException(_inner) => Some(_inner),
            CheckInLicenseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckoutBorrowLicenseError {
    pub kind: CheckoutBorrowLicenseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckoutBorrowLicenseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    EntitlementNotAllowedException(crate::error::EntitlementNotAllowedException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoEntitlementsAllowedException(crate::error::NoEntitlementsAllowedException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    UnsupportedDigitalSignatureMethodException(
        crate::error::UnsupportedDigitalSignatureMethodException,
    ),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckoutBorrowLicenseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckoutBorrowLicenseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::EntitlementNotAllowedException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::NoEntitlementsAllowedException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::RedirectException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::UnsupportedDigitalSignatureMethodException(_inner) => {
                _inner.fmt(f)
            }
            CheckoutBorrowLicenseErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CheckoutBorrowLicenseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckoutBorrowLicenseError {
    fn code(&self) -> Option<&str> {
        CheckoutBorrowLicenseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckoutBorrowLicenseError {
    pub fn new(kind: CheckoutBorrowLicenseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckoutBorrowLicenseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckoutBorrowLicenseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_entitlement_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::EntitlementNotAllowedException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_entitlements_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::NoEntitlementsAllowedException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::RedirectException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_unsupported_digital_signature_method_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::UnsupportedDigitalSignatureMethodException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutBorrowLicenseErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CheckoutBorrowLicenseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckoutBorrowLicenseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::AuthorizationException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::EntitlementNotAllowedException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::NoEntitlementsAllowedException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::RedirectException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::ServerInternalException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::UnsupportedDigitalSignatureMethodException(_inner) => {
                Some(_inner)
            }
            CheckoutBorrowLicenseErrorKind::ValidationException(_inner) => Some(_inner),
            CheckoutBorrowLicenseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CheckoutLicenseError {
    pub kind: CheckoutLicenseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CheckoutLicenseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    NoEntitlementsAllowedException(crate::error::NoEntitlementsAllowedException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    UnsupportedDigitalSignatureMethodException(
        crate::error::UnsupportedDigitalSignatureMethodException,
    ),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CheckoutLicenseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CheckoutLicenseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::NoEntitlementsAllowedException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::RedirectException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::UnsupportedDigitalSignatureMethodException(_inner) => {
                _inner.fmt(f)
            }
            CheckoutLicenseErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CheckoutLicenseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CheckoutLicenseError {
    fn code(&self) -> Option<&str> {
        CheckoutLicenseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CheckoutLicenseError {
    pub fn new(kind: CheckoutLicenseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CheckoutLicenseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CheckoutLicenseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_no_entitlements_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::NoEntitlementsAllowedException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(&self.kind, CheckoutLicenseErrorKind::RedirectException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_unsupported_digital_signature_method_exception(&self) -> bool {
        matches!(
            &self.kind,
            CheckoutLicenseErrorKind::UnsupportedDigitalSignatureMethodException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CheckoutLicenseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CheckoutLicenseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CheckoutLicenseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::AuthorizationException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::NoEntitlementsAllowedException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::RedirectException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::ServerInternalException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::UnsupportedDigitalSignatureMethodException(_inner) => {
                Some(_inner)
            }
            CheckoutLicenseErrorKind::ValidationException(_inner) => Some(_inner),
            CheckoutLicenseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGrantError {
    pub kind: CreateGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGrantErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGrantErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGrantError {
    fn code(&self) -> Option<&str> {
        CreateGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGrantError {
    pub fn new(kind: CreateGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateGrantErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGrantErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateGrantErrorKind::AuthorizationException(_inner) => Some(_inner),
            CreateGrantErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateGrantErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CreateGrantErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateGrantErrorKind::ServerInternalException(_inner) => Some(_inner),
            CreateGrantErrorKind::ValidationException(_inner) => Some(_inner),
            CreateGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGrantVersionError {
    pub kind: CreateGrantVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGrantVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGrantVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGrantVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateGrantVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGrantVersionError {
    fn code(&self) -> Option<&str> {
        CreateGrantVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGrantVersionError {
    pub fn new(kind: CreateGrantVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGrantVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGrantVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGrantVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateGrantVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGrantVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::AuthorizationException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::ServerInternalException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::ValidationException(_inner) => Some(_inner),
            CreateGrantVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLicenseError {
    pub kind: CreateLicenseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLicenseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLicenseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLicenseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::RedirectException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateLicenseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLicenseError {
    fn code(&self) -> Option<&str> {
        CreateLicenseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLicenseError {
    pub fn new(kind: CreateLicenseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLicenseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLicenseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateLicenseErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(&self.kind, CreateLicenseErrorKind::RedirectException(_))
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateLicenseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateLicenseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLicenseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateLicenseErrorKind::AuthorizationException(_inner) => Some(_inner),
            CreateLicenseErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateLicenseErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CreateLicenseErrorKind::RedirectException(_inner) => Some(_inner),
            CreateLicenseErrorKind::ServerInternalException(_inner) => Some(_inner),
            CreateLicenseErrorKind::ValidationException(_inner) => Some(_inner),
            CreateLicenseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLicenseConfigurationError {
    pub kind: CreateLicenseConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLicenseConfigurationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLicenseConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLicenseConfigurationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateLicenseConfigurationErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CreateLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConfigurationErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CreateLicenseConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLicenseConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateLicenseConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLicenseConfigurationError {
    pub fn new(kind: CreateLicenseConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLicenseConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLicenseConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConfigurationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConfigurationErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConfigurationErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConfigurationErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConfigurationErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for CreateLicenseConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLicenseConfigurationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateLicenseConfigurationErrorKind::AuthorizationException(_inner) => Some(_inner),
            CreateLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CreateLicenseConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConfigurationErrorKind::ServerInternalException(_inner) => Some(_inner),
            CreateLicenseConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLicenseConversionTaskForResourceError {
    pub kind: CreateLicenseConversionTaskForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLicenseConversionTaskForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLicenseConversionTaskForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLicenseConversionTaskForResourceErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConversionTaskForResourceErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConversionTaskForResourceErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            CreateLicenseConversionTaskForResourceErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConversionTaskForResourceErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConversionTaskForResourceErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseConversionTaskForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLicenseConversionTaskForResourceError {
    fn code(&self) -> Option<&str> {
        CreateLicenseConversionTaskForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLicenseConversionTaskForResourceError {
    pub fn new(
        kind: CreateLicenseConversionTaskForResourceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLicenseConversionTaskForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLicenseConversionTaskForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConversionTaskForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConversionTaskForResourceErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConversionTaskForResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConversionTaskForResourceErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConversionTaskForResourceErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseConversionTaskForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateLicenseConversionTaskForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLicenseConversionTaskForResourceErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConversionTaskForResourceErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConversionTaskForResourceErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            CreateLicenseConversionTaskForResourceErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConversionTaskForResourceErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConversionTaskForResourceErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            CreateLicenseConversionTaskForResourceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLicenseManagerReportGeneratorError {
    pub kind: CreateLicenseManagerReportGeneratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLicenseManagerReportGeneratorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLicenseManagerReportGeneratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            CreateLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            CreateLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            CreateLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLicenseManagerReportGeneratorError {
    fn code(&self) -> Option<&str> {
        CreateLicenseManagerReportGeneratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLicenseManagerReportGeneratorError {
    pub fn new(
        kind: CreateLicenseManagerReportGeneratorErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseManagerReportGeneratorErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateLicenseManagerReportGeneratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            CreateLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            CreateLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(
                _inner,
            ) => Some(_inner),
            CreateLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            CreateLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            CreateLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLicenseVersionError {
    pub kind: CreateLicenseVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLicenseVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    ConflictException(crate::error::ConflictException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLicenseVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLicenseVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::RedirectException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateLicenseVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLicenseVersionError {
    fn code(&self) -> Option<&str> {
        CreateLicenseVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLicenseVersionError {
    pub fn new(kind: CreateLicenseVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLicenseVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLicenseVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::RedirectException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLicenseVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateLicenseVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLicenseVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::AuthorizationException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::RedirectException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::ServerInternalException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::ValidationException(_inner) => Some(_inner),
            CreateLicenseVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTokenError {
    pub kind: CreateTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTokenErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTokenErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::RedirectException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTokenError {
    fn code(&self) -> Option<&str> {
        CreateTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTokenError {
    pub fn new(kind: CreateTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateTokenErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, CreateTokenErrorKind::AuthorizationException(_))
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTokenErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(&self.kind, CreateTokenErrorKind::RedirectException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTokenErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTokenErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateTokenErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateTokenErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTokenErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateTokenErrorKind::AuthorizationException(_inner) => Some(_inner),
            CreateTokenErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            CreateTokenErrorKind::RedirectException(_inner) => Some(_inner),
            CreateTokenErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            CreateTokenErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateTokenErrorKind::ServerInternalException(_inner) => Some(_inner),
            CreateTokenErrorKind::ValidationException(_inner) => Some(_inner),
            CreateTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGrantError {
    pub kind: DeleteGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGrantErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGrantErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGrantError {
    fn code(&self) -> Option<&str> {
        DeleteGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGrantError {
    pub fn new(kind: DeleteGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteGrantErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, DeleteGrantErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGrantErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGrantErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGrantErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteGrantErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteGrantErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGrantErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteGrantErrorKind::AuthorizationException(_inner) => Some(_inner),
            DeleteGrantErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteGrantErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            DeleteGrantErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            DeleteGrantErrorKind::ServerInternalException(_inner) => Some(_inner),
            DeleteGrantErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLicenseError {
    pub kind: DeleteLicenseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLicenseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    ConflictException(crate::error::ConflictException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLicenseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLicenseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::RedirectException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteLicenseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLicenseError {
    fn code(&self) -> Option<&str> {
        DeleteLicenseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLicenseError {
    pub fn new(kind: DeleteLicenseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLicenseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLicenseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteLicenseErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteLicenseErrorKind::ConflictException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(&self.kind, DeleteLicenseErrorKind::RedirectException(_))
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteLicenseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteLicenseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLicenseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::AuthorizationException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::RedirectException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::ServerInternalException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteLicenseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLicenseConfigurationError {
    pub kind: DeleteLicenseConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLicenseConfigurationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLicenseConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLicenseConfigurationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteLicenseConfigurationErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            DeleteLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseConfigurationErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            DeleteLicenseConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLicenseConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteLicenseConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLicenseConfigurationError {
    pub fn new(kind: DeleteLicenseConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLicenseConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLicenseConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseConfigurationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseConfigurationErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseConfigurationErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseConfigurationErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for DeleteLicenseConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLicenseConfigurationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteLicenseConfigurationErrorKind::AuthorizationException(_inner) => Some(_inner),
            DeleteLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            DeleteLicenseConfigurationErrorKind::ServerInternalException(_inner) => Some(_inner),
            DeleteLicenseConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLicenseManagerReportGeneratorError {
    pub kind: DeleteLicenseManagerReportGeneratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLicenseManagerReportGeneratorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLicenseManagerReportGeneratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            DeleteLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            DeleteLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLicenseManagerReportGeneratorError {
    fn code(&self) -> Option<&str> {
        DeleteLicenseManagerReportGeneratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLicenseManagerReportGeneratorError {
    pub fn new(
        kind: DeleteLicenseManagerReportGeneratorErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLicenseManagerReportGeneratorErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteLicenseManagerReportGeneratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            DeleteLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(
                _inner,
            ) => Some(_inner),
            DeleteLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DeleteLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteTokenError {
    pub kind: DeleteTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteTokenErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    RedirectException(crate::error::RedirectException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteTokenErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::RedirectException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteTokenError {
    fn code(&self) -> Option<&str> {
        DeleteTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteTokenError {
    pub fn new(kind: DeleteTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteTokenErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, DeleteTokenErrorKind::AuthorizationException(_))
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTokenErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_redirect_exception(&self) -> bool {
        matches!(&self.kind, DeleteTokenErrorKind::RedirectException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteTokenErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteTokenErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteTokenErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteTokenErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteTokenErrorKind::AuthorizationException(_inner) => Some(_inner),
            DeleteTokenErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            DeleteTokenErrorKind::RedirectException(_inner) => Some(_inner),
            DeleteTokenErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteTokenErrorKind::ServerInternalException(_inner) => Some(_inner),
            DeleteTokenErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ExtendLicenseConsumptionError {
    pub kind: ExtendLicenseConsumptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ExtendLicenseConsumptionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ExtendLicenseConsumptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ExtendLicenseConsumptionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ExtendLicenseConsumptionErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ExtendLicenseConsumptionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ExtendLicenseConsumptionErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ExtendLicenseConsumptionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ExtendLicenseConsumptionErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ExtendLicenseConsumptionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ExtendLicenseConsumptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ExtendLicenseConsumptionError {
    fn code(&self) -> Option<&str> {
        ExtendLicenseConsumptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ExtendLicenseConsumptionError {
    pub fn new(kind: ExtendLicenseConsumptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ExtendLicenseConsumptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ExtendLicenseConsumptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ExtendLicenseConsumptionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ExtendLicenseConsumptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ExtendLicenseConsumptionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ExtendLicenseConsumptionErrorKind::AuthorizationException(_inner) => Some(_inner),
            ExtendLicenseConsumptionErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ExtendLicenseConsumptionErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ExtendLicenseConsumptionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ExtendLicenseConsumptionErrorKind::ServerInternalException(_inner) => Some(_inner),
            ExtendLicenseConsumptionErrorKind::ValidationException(_inner) => Some(_inner),
            ExtendLicenseConsumptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccessTokenError {
    pub kind: GetAccessTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccessTokenErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccessTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccessTokenErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAccessTokenErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetAccessTokenErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetAccessTokenErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetAccessTokenErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetAccessTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccessTokenError {
    fn code(&self) -> Option<&str> {
        GetAccessTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccessTokenError {
    pub fn new(kind: GetAccessTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccessTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccessTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccessTokenErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccessTokenErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccessTokenErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccessTokenErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetAccessTokenErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetAccessTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccessTokenErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAccessTokenErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetAccessTokenErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetAccessTokenErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetAccessTokenErrorKind::ValidationException(_inner) => Some(_inner),
            GetAccessTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGrantError {
    pub kind: GetGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGrantErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGrantErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGrantError {
    fn code(&self) -> Option<&str> {
        GetGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGrantError {
    pub fn new(kind: GetGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetGrantErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, GetGrantErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGrantErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, GetGrantErrorKind::RateLimitExceededException(_))
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGrantErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, GetGrantErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetGrantErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGrantErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetGrantErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetGrantErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetGrantErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetGrantErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            GetGrantErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetGrantErrorKind::ValidationException(_inner) => Some(_inner),
            GetGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLicenseError {
    pub kind: GetLicenseErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLicenseErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLicenseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLicenseErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLicenseErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetLicenseErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetLicenseErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetLicenseErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetLicenseErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetLicenseErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLicenseError {
    fn code(&self) -> Option<&str> {
        GetLicenseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLicenseError {
    pub fn new(kind: GetLicenseErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLicenseErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLicenseErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetLicenseErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, GetLicenseErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, GetLicenseErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetLicenseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetLicenseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLicenseErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLicenseErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetLicenseErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetLicenseErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetLicenseErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetLicenseErrorKind::ValidationException(_inner) => Some(_inner),
            GetLicenseErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLicenseConfigurationError {
    pub kind: GetLicenseConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLicenseConfigurationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLicenseConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLicenseConfigurationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLicenseConfigurationErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetLicenseConfigurationErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetLicenseConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLicenseConfigurationError {
    fn code(&self) -> Option<&str> {
        GetLicenseConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLicenseConfigurationError {
    pub fn new(kind: GetLicenseConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLicenseConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLicenseConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConfigurationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConfigurationErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConfigurationErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConfigurationErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for GetLicenseConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLicenseConfigurationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLicenseConfigurationErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetLicenseConfigurationErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetLicenseConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLicenseConversionTaskError {
    pub kind: GetLicenseConversionTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLicenseConversionTaskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLicenseConversionTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLicenseConversionTaskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLicenseConversionTaskErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetLicenseConversionTaskErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseConversionTaskErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetLicenseConversionTaskErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetLicenseConversionTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLicenseConversionTaskError {
    fn code(&self) -> Option<&str> {
        GetLicenseConversionTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLicenseConversionTaskError {
    pub fn new(kind: GetLicenseConversionTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLicenseConversionTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLicenseConversionTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConversionTaskErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConversionTaskErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConversionTaskErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConversionTaskErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseConversionTaskErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for GetLicenseConversionTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLicenseConversionTaskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLicenseConversionTaskErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetLicenseConversionTaskErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetLicenseConversionTaskErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetLicenseConversionTaskErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetLicenseConversionTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLicenseManagerReportGeneratorError {
    pub kind: GetLicenseManagerReportGeneratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLicenseManagerReportGeneratorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLicenseManagerReportGeneratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            GetLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLicenseManagerReportGeneratorError {
    fn code(&self) -> Option<&str> {
        GetLicenseManagerReportGeneratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLicenseManagerReportGeneratorError {
    pub fn new(kind: GetLicenseManagerReportGeneratorErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseManagerReportGeneratorErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetLicenseManagerReportGeneratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            GetLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => Some(_inner),
            GetLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLicenseUsageError {
    pub kind: GetLicenseUsageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLicenseUsageErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLicenseUsageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLicenseUsageErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLicenseUsageErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetLicenseUsageErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            GetLicenseUsageErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetLicenseUsageErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetLicenseUsageErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetLicenseUsageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLicenseUsageError {
    fn code(&self) -> Option<&str> {
        GetLicenseUsageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLicenseUsageError {
    pub fn new(kind: GetLicenseUsageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLicenseUsageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLicenseUsageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseUsageErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseUsageErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseUsageErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseUsageErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLicenseUsageErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetLicenseUsageErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetLicenseUsageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLicenseUsageErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLicenseUsageErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetLicenseUsageErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            GetLicenseUsageErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetLicenseUsageErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetLicenseUsageErrorKind::ValidationException(_inner) => Some(_inner),
            GetLicenseUsageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceSettingsError {
    pub kind: GetServiceSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceSettingsErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            GetServiceSettingsErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            GetServiceSettingsErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            GetServiceSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceSettingsError {
    fn code(&self) -> Option<&str> {
        GetServiceSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceSettingsError {
    pub fn new(kind: GetServiceSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceSettingsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceSettingsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceSettingsErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for GetServiceSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceSettingsErrorKind::AuthorizationException(_inner) => Some(_inner),
            GetServiceSettingsErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            GetServiceSettingsErrorKind::ServerInternalException(_inner) => Some(_inner),
            GetServiceSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssociationsForLicenseConfigurationError {
    pub kind: ListAssociationsForLicenseConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssociationsForLicenseConfigurationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    FilterLimitExceededException(crate::error::FilterLimitExceededException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssociationsForLicenseConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssociationsForLicenseConfigurationErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListAssociationsForLicenseConfigurationErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            ListAssociationsForLicenseConfigurationErrorKind::FilterLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            ListAssociationsForLicenseConfigurationErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            ListAssociationsForLicenseConfigurationErrorKind::RateLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            ListAssociationsForLicenseConfigurationErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            ListAssociationsForLicenseConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAssociationsForLicenseConfigurationError {
    fn code(&self) -> Option<&str> {
        ListAssociationsForLicenseConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssociationsForLicenseConfigurationError {
    pub fn new(
        kind: ListAssociationsForLicenseConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssociationsForLicenseConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssociationsForLicenseConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsForLicenseConfigurationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsForLicenseConfigurationErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_filter_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsForLicenseConfigurationErrorKind::FilterLimitExceededException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsForLicenseConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsForLicenseConfigurationErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociationsForLicenseConfigurationErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListAssociationsForLicenseConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssociationsForLicenseConfigurationErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListAssociationsForLicenseConfigurationErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            ListAssociationsForLicenseConfigurationErrorKind::FilterLimitExceededException(
                _inner,
            ) => Some(_inner),
            ListAssociationsForLicenseConfigurationErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            ListAssociationsForLicenseConfigurationErrorKind::RateLimitExceededException(
                _inner,
            ) => Some(_inner),
            ListAssociationsForLicenseConfigurationErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            ListAssociationsForLicenseConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDistributedGrantsError {
    pub kind: ListDistributedGrantsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDistributedGrantsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDistributedGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDistributedGrantsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListDistributedGrantsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDistributedGrantsError {
    fn code(&self) -> Option<&str> {
        ListDistributedGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDistributedGrantsError {
    pub fn new(kind: ListDistributedGrantsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDistributedGrantsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDistributedGrantsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDistributedGrantsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListDistributedGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDistributedGrantsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::ValidationException(_inner) => Some(_inner),
            ListDistributedGrantsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFailuresForLicenseConfigurationOperationsError {
    pub kind: ListFailuresForLicenseConfigurationOperationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFailuresForLicenseConfigurationOperationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListFailuresForLicenseConfigurationOperationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFailuresForLicenseConfigurationOperationsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::AuthorizationException(_inner) =>
            _inner.fmt(f)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::RateLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::ServerInternalException(_inner) =>
            _inner.fmt(f)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListFailuresForLicenseConfigurationOperationsError {
    fn code(&self) -> Option<&str> {
        ListFailuresForLicenseConfigurationOperationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListFailuresForLicenseConfigurationOperationsError {
    pub fn new(
        kind: ListFailuresForLicenseConfigurationOperationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListFailuresForLicenseConfigurationOperationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListFailuresForLicenseConfigurationOperationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFailuresForLicenseConfigurationOperationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFailuresForLicenseConfigurationOperationsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFailuresForLicenseConfigurationOperationsErrorKind::InvalidParameterValueException(
                _
            )
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFailuresForLicenseConfigurationOperationsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListFailuresForLicenseConfigurationOperationsErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListFailuresForLicenseConfigurationOperationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFailuresForLicenseConfigurationOperationsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::AuthorizationException(_inner) =>
            Some(_inner)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::RateLimitExceededException(_inner) =>
            Some(_inner)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::ServerInternalException(_inner) =>
            Some(_inner)
            ,
            ListFailuresForLicenseConfigurationOperationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLicenseConfigurationsError {
    pub kind: ListLicenseConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLicenseConfigurationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    FilterLimitExceededException(crate::error::FilterLimitExceededException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLicenseConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLicenseConfigurationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListLicenseConfigurationsErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListLicenseConfigurationsErrorKind::FilterLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseConfigurationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseConfigurationsErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListLicenseConfigurationsErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListLicenseConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLicenseConfigurationsError {
    fn code(&self) -> Option<&str> {
        ListLicenseConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLicenseConfigurationsError {
    pub fn new(kind: ListLicenseConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLicenseConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLicenseConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConfigurationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConfigurationsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_filter_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConfigurationsErrorKind::FilterLimitExceededException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConfigurationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConfigurationsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConfigurationsErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListLicenseConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLicenseConfigurationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListLicenseConfigurationsErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListLicenseConfigurationsErrorKind::FilterLimitExceededException(_inner) => {
                Some(_inner)
            }
            ListLicenseConfigurationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListLicenseConfigurationsErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListLicenseConfigurationsErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListLicenseConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLicenseConversionTasksError {
    pub kind: ListLicenseConversionTasksErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLicenseConversionTasksErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLicenseConversionTasksError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLicenseConversionTasksErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListLicenseConversionTasksErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListLicenseConversionTasksErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseConversionTasksErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseConversionTasksErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListLicenseConversionTasksErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLicenseConversionTasksError {
    fn code(&self) -> Option<&str> {
        ListLicenseConversionTasksError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLicenseConversionTasksError {
    pub fn new(kind: ListLicenseConversionTasksErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLicenseConversionTasksErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLicenseConversionTasksErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConversionTasksErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConversionTasksErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConversionTasksErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConversionTasksErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseConversionTasksErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListLicenseConversionTasksError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLicenseConversionTasksErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListLicenseConversionTasksErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListLicenseConversionTasksErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListLicenseConversionTasksErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListLicenseConversionTasksErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListLicenseConversionTasksErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLicenseManagerReportGeneratorsError {
    pub kind: ListLicenseManagerReportGeneratorsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLicenseManagerReportGeneratorsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLicenseManagerReportGeneratorsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLicenseManagerReportGeneratorsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseManagerReportGeneratorsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLicenseManagerReportGeneratorsError {
    fn code(&self) -> Option<&str> {
        ListLicenseManagerReportGeneratorsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLicenseManagerReportGeneratorsError {
    pub fn new(
        kind: ListLicenseManagerReportGeneratorsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLicenseManagerReportGeneratorsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLicenseManagerReportGeneratorsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseManagerReportGeneratorsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListLicenseManagerReportGeneratorsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLicenseManagerReportGeneratorsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            ListLicenseManagerReportGeneratorsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLicensesError {
    pub kind: ListLicensesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLicensesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLicensesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLicensesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListLicensesErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListLicensesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListLicensesErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListLicensesErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListLicensesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListLicensesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLicensesError {
    fn code(&self) -> Option<&str> {
        ListLicensesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLicensesError {
    pub fn new(kind: ListLicensesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLicensesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLicensesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListLicensesErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, ListLicensesErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicensesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicensesErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicensesErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListLicensesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListLicensesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLicensesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListLicensesErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListLicensesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListLicensesErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListLicensesErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListLicensesErrorKind::ValidationException(_inner) => Some(_inner),
            ListLicensesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLicenseSpecificationsForResourceError {
    pub kind: ListLicenseSpecificationsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLicenseSpecificationsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLicenseSpecificationsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLicenseSpecificationsForResourceErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseSpecificationsForResourceErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseSpecificationsForResourceErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            ListLicenseSpecificationsForResourceErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseSpecificationsForResourceErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            ListLicenseSpecificationsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLicenseSpecificationsForResourceError {
    fn code(&self) -> Option<&str> {
        ListLicenseSpecificationsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLicenseSpecificationsForResourceError {
    pub fn new(
        kind: ListLicenseSpecificationsForResourceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLicenseSpecificationsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLicenseSpecificationsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseSpecificationsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseSpecificationsForResourceErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseSpecificationsForResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseSpecificationsForResourceErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseSpecificationsForResourceErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListLicenseSpecificationsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLicenseSpecificationsForResourceErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListLicenseSpecificationsForResourceErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            ListLicenseSpecificationsForResourceErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            ListLicenseSpecificationsForResourceErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            ListLicenseSpecificationsForResourceErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            ListLicenseSpecificationsForResourceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLicenseVersionsError {
    pub kind: ListLicenseVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLicenseVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListLicenseVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLicenseVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListLicenseVersionsErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListLicenseVersionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListLicenseVersionsErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListLicenseVersionsErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListLicenseVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListLicenseVersionsError {
    fn code(&self) -> Option<&str> {
        ListLicenseVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListLicenseVersionsError {
    pub fn new(kind: ListLicenseVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListLicenseVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListLicenseVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseVersionsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseVersionsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseVersionsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListLicenseVersionsErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListLicenseVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLicenseVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListLicenseVersionsErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListLicenseVersionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListLicenseVersionsErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListLicenseVersionsErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListLicenseVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReceivedGrantsError {
    pub kind: ListReceivedGrantsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReceivedGrantsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReceivedGrantsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReceivedGrantsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListReceivedGrantsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReceivedGrantsError {
    fn code(&self) -> Option<&str> {
        ListReceivedGrantsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReceivedGrantsError {
    pub fn new(kind: ListReceivedGrantsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReceivedGrantsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReceivedGrantsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedGrantsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListReceivedGrantsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReceivedGrantsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::ValidationException(_inner) => Some(_inner),
            ListReceivedGrantsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReceivedLicensesError {
    pub kind: ListReceivedLicensesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReceivedLicensesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReceivedLicensesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReceivedLicensesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListReceivedLicensesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReceivedLicensesError {
    fn code(&self) -> Option<&str> {
        ListReceivedLicensesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReceivedLicensesError {
    pub fn new(kind: ListReceivedLicensesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReceivedLicensesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReceivedLicensesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListReceivedLicensesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListReceivedLicensesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReceivedLicensesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::ValidationException(_inner) => Some(_inner),
            ListReceivedLicensesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourceInventoryError {
    pub kind: ListResourceInventoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourceInventoryErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    FailedDependencyException(crate::error::FailedDependencyException),
    FilterLimitExceededException(crate::error::FilterLimitExceededException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourceInventoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourceInventoryErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::FailedDependencyException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::FilterLimitExceededException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListResourceInventoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourceInventoryError {
    fn code(&self) -> Option<&str> {
        ListResourceInventoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourceInventoryError {
    pub fn new(kind: ListResourceInventoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourceInventoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourceInventoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_failed_dependency_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::FailedDependencyException(_)
        )
    }
    pub fn is_filter_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::FilterLimitExceededException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourceInventoryErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListResourceInventoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourceInventoryErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::FailedDependencyException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::FilterLimitExceededException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListResourceInventoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTokensError {
    pub kind: ListTokensErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTokensErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTokensError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTokensErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTokensErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            ListTokensErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            ListTokensErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            ListTokensErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTokensErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTokensError {
    fn code(&self) -> Option<&str> {
        ListTokensError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTokensError {
    pub fn new(kind: ListTokensErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTokensErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTokensErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListTokensErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, ListTokensErrorKind::AuthorizationException(_))
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTokensErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, ListTokensErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListTokensErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListTokensError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTokensErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTokensErrorKind::AuthorizationException(_inner) => Some(_inner),
            ListTokensErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            ListTokensErrorKind::ServerInternalException(_inner) => Some(_inner),
            ListTokensErrorKind::ValidationException(_inner) => Some(_inner),
            ListTokensErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUsageForLicenseConfigurationError {
    pub kind: ListUsageForLicenseConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUsageForLicenseConfigurationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    FilterLimitExceededException(crate::error::FilterLimitExceededException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUsageForLicenseConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUsageForLicenseConfigurationErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListUsageForLicenseConfigurationErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            ListUsageForLicenseConfigurationErrorKind::FilterLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListUsageForLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListUsageForLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            ListUsageForLicenseConfigurationErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            ListUsageForLicenseConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUsageForLicenseConfigurationError {
    fn code(&self) -> Option<&str> {
        ListUsageForLicenseConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUsageForLicenseConfigurationError {
    pub fn new(kind: ListUsageForLicenseConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUsageForLicenseConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUsageForLicenseConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsageForLicenseConfigurationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsageForLicenseConfigurationErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_filter_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsageForLicenseConfigurationErrorKind::FilterLimitExceededException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsageForLicenseConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsageForLicenseConfigurationErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUsageForLicenseConfigurationErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for ListUsageForLicenseConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUsageForLicenseConfigurationErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListUsageForLicenseConfigurationErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            ListUsageForLicenseConfigurationErrorKind::FilterLimitExceededException(_inner) => {
                Some(_inner)
            }
            ListUsageForLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListUsageForLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            ListUsageForLicenseConfigurationErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            ListUsageForLicenseConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectGrantError {
    pub kind: RejectGrantErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectGrantErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectGrantError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectGrantErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::ResourceLimitExceededException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::ValidationException(_inner) => _inner.fmt(f),
            RejectGrantErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectGrantError {
    fn code(&self) -> Option<&str> {
        RejectGrantError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RejectGrantError {
    pub fn new(kind: RejectGrantErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectGrantErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectGrantErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, RejectGrantErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, RejectGrantErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectGrantErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectGrantErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectGrantErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, RejectGrantErrorKind::ServerInternalException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, RejectGrantErrorKind::ValidationException(_))
    }
}
impl std::error::Error for RejectGrantError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectGrantErrorKind::AccessDeniedException(_inner) => Some(_inner),
            RejectGrantErrorKind::AuthorizationException(_inner) => Some(_inner),
            RejectGrantErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            RejectGrantErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            RejectGrantErrorKind::ResourceLimitExceededException(_inner) => Some(_inner),
            RejectGrantErrorKind::ServerInternalException(_inner) => Some(_inner),
            RejectGrantErrorKind::ValidationException(_inner) => Some(_inner),
            RejectGrantErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AuthorizationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ServerInternalException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::AuthorizationException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            TagResourceErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            TagResourceErrorKind::ServerInternalException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::AuthorizationException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UntagResourceErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            UntagResourceErrorKind::ServerInternalException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLicenseConfigurationError {
    pub kind: UpdateLicenseConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLicenseConfigurationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLicenseConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLicenseConfigurationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateLicenseConfigurationErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            UpdateLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseConfigurationErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            UpdateLicenseConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLicenseConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateLicenseConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLicenseConfigurationError {
    pub fn new(kind: UpdateLicenseConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLicenseConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLicenseConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseConfigurationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseConfigurationErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseConfigurationErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseConfigurationErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseConfigurationErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for UpdateLicenseConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLicenseConfigurationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateLicenseConfigurationErrorKind::AuthorizationException(_inner) => Some(_inner),
            UpdateLicenseConfigurationErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseConfigurationErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            UpdateLicenseConfigurationErrorKind::ResourceLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseConfigurationErrorKind::ServerInternalException(_inner) => Some(_inner),
            UpdateLicenseConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLicenseManagerReportGeneratorError {
    pub kind: UpdateLicenseManagerReportGeneratorErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLicenseManagerReportGeneratorErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ResourceLimitExceededException(crate::error::ResourceLimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServerInternalException(crate::error::ServerInternalException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLicenseManagerReportGeneratorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            UpdateLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            UpdateLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLicenseManagerReportGeneratorError {
    fn code(&self) -> Option<&str> {
        UpdateLicenseManagerReportGeneratorError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLicenseManagerReportGeneratorError {
    pub fn new(
        kind: UpdateLicenseManagerReportGeneratorErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLicenseManagerReportGeneratorErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_resource_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::ServerInternalException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseManagerReportGeneratorErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateLicenseManagerReportGeneratorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLicenseManagerReportGeneratorErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            UpdateLicenseManagerReportGeneratorErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::ResourceLimitExceededException(
                _inner,
            ) => Some(_inner),
            UpdateLicenseManagerReportGeneratorErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseManagerReportGeneratorErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLicenseSpecificationsForResourceError {
    pub kind: UpdateLicenseSpecificationsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLicenseSpecificationsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidResourceStateException(crate::error::InvalidResourceStateException),
    LicenseUsageException(crate::error::LicenseUsageException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLicenseSpecificationsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLicenseSpecificationsForResourceErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::AuthorizationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::InvalidParameterValueException(
                _inner,
            ) => _inner.fmt(f),
            UpdateLicenseSpecificationsForResourceErrorKind::InvalidResourceStateException(
                _inner,
            ) => _inner.fmt(f),
            UpdateLicenseSpecificationsForResourceErrorKind::LicenseUsageException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::RateLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::ServerInternalException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLicenseSpecificationsForResourceError {
    fn code(&self) -> Option<&str> {
        UpdateLicenseSpecificationsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLicenseSpecificationsForResourceError {
    pub fn new(
        kind: UpdateLicenseSpecificationsForResourceErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLicenseSpecificationsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLicenseSpecificationsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_resource_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::InvalidResourceStateException(_)
        )
    }
    pub fn is_license_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::LicenseUsageException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLicenseSpecificationsForResourceErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for UpdateLicenseSpecificationsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLicenseSpecificationsForResourceErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::AuthorizationException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::InvalidParameterValueException(
                _inner,
            ) => Some(_inner),
            UpdateLicenseSpecificationsForResourceErrorKind::InvalidResourceStateException(
                _inner,
            ) => Some(_inner),
            UpdateLicenseSpecificationsForResourceErrorKind::LicenseUsageException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::RateLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::ServerInternalException(_inner) => {
                Some(_inner)
            }
            UpdateLicenseSpecificationsForResourceErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceSettingsError {
    pub kind: UpdateServiceSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    AuthorizationException(crate::error::AuthorizationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    RateLimitExceededException(crate::error::RateLimitExceededException),
    ServerInternalException(crate::error::ServerInternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServiceSettingsErrorKind::AuthorizationException(_inner) => _inner.fmt(f),
            UpdateServiceSettingsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            UpdateServiceSettingsErrorKind::RateLimitExceededException(_inner) => _inner.fmt(f),
            UpdateServiceSettingsErrorKind::ServerInternalException(_inner) => _inner.fmt(f),
            UpdateServiceSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateServiceSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateServiceSettingsError {
    pub fn new(kind: UpdateServiceSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_authorization_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingsErrorKind::AuthorizationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_rate_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingsErrorKind::RateLimitExceededException(_)
        )
    }
    pub fn is_server_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceSettingsErrorKind::ServerInternalException(_)
        )
    }
}
impl std::error::Error for UpdateServiceSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServiceSettingsErrorKind::AuthorizationException(_inner) => Some(_inner),
            UpdateServiceSettingsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            UpdateServiceSettingsErrorKind::RateLimitExceededException(_inner) => Some(_inner),
            UpdateServiceSettingsErrorKind::ServerInternalException(_inner) => Some(_inner),
            UpdateServiceSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The server experienced an internal error. Try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServerInternalException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServerInternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServerInternalException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServerInternalException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServerInternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServerInternalException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServerInternalException {}
/// See [`ServerInternalException`](crate::error::ServerInternalException)
pub mod server_internal_exception {
    /// A builder for [`ServerInternalException`](crate::error::ServerInternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServerInternalException`](crate::error::ServerInternalException)
        pub fn build(self) -> crate::error::ServerInternalException {
            crate::error::ServerInternalException {
                message: self.message,
            }
        }
    }
}
impl ServerInternalException {
    /// Creates a new builder-style object to manufacture [`ServerInternalException`](crate::error::ServerInternalException)
    pub fn builder() -> crate::error::server_internal_exception::Builder {
        crate::error::server_internal_exception::Builder::default()
    }
}

/// <p>Too many requests have been submitted. Try again after a brief wait.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RateLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RateLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RateLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RateLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RateLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RateLimitExceededException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for RateLimitExceededException {}
/// See [`RateLimitExceededException`](crate::error::RateLimitExceededException)
pub mod rate_limit_exceeded_exception {
    /// A builder for [`RateLimitExceededException`](crate::error::RateLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RateLimitExceededException`](crate::error::RateLimitExceededException)
        pub fn build(self) -> crate::error::RateLimitExceededException {
            crate::error::RateLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl RateLimitExceededException {
    /// Creates a new builder-style object to manufacture [`RateLimitExceededException`](crate::error::RateLimitExceededException)
    pub fn builder() -> crate::error::rate_limit_exceeded_exception::Builder {
        crate::error::rate_limit_exceeded_exception::Builder::default()
    }
}

/// <p>One or more parameter values are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
pub mod invalid_parameter_value_exception {
    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// <p>The Amazon Web Services user account does not have permission to perform the action. Check the IAM
/// policy associated with this account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationException {}
/// See [`AuthorizationException`](crate::error::AuthorizationException)
pub mod authorization_exception {
    /// A builder for [`AuthorizationException`](crate::error::AuthorizationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationException`](crate::error::AuthorizationException)
        pub fn build(self) -> crate::error::AuthorizationException {
            crate::error::AuthorizationException {
                message: self.message,
            }
        }
    }
}
impl AuthorizationException {
    /// Creates a new builder-style object to manufacture [`AuthorizationException`](crate::error::AuthorizationException)
    pub fn builder() -> crate::error::authorization_exception::Builder {
        crate::error::authorization_exception::Builder::default()
    }
}

/// <p>Access to resource denied.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>You do not have enough licenses available to support a new resource launch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LicenseUsageException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LicenseUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LicenseUsageException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LicenseUsageException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LicenseUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LicenseUsageException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LicenseUsageException {}
/// See [`LicenseUsageException`](crate::error::LicenseUsageException)
pub mod license_usage_exception {
    /// A builder for [`LicenseUsageException`](crate::error::LicenseUsageException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LicenseUsageException`](crate::error::LicenseUsageException)
        pub fn build(self) -> crate::error::LicenseUsageException {
            crate::error::LicenseUsageException {
                message: self.message,
            }
        }
    }
}
impl LicenseUsageException {
    /// Creates a new builder-style object to manufacture [`LicenseUsageException`](crate::error::LicenseUsageException)
    pub fn builder() -> crate::error::license_usage_exception::Builder {
        crate::error::license_usage_exception::Builder::default()
    }
}

/// <p>License Manager cannot allocate a license to a resource because of its state. </p>
/// <p>For example, you cannot allocate a license to an instance in the process of shutting
/// down.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResourceStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceStateException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceStateException {}
/// See [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
pub mod invalid_resource_state_exception {
    /// A builder for [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
        pub fn build(self) -> crate::error::InvalidResourceStateException {
            crate::error::InvalidResourceStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidResourceStateException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceStateException`](crate::error::InvalidResourceStateException)
    pub fn builder() -> crate::error::invalid_resource_state_exception::Builder {
        crate::error::invalid_resource_state_exception::Builder::default()
    }
}

/// <p>The provided input is not valid. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The resource cannot be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>Your resource limits have been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceLimitExceededException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceLimitExceededException {}
/// See [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
pub mod resource_limit_exceeded_exception {
    /// A builder for [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
        pub fn build(self) -> crate::error::ResourceLimitExceededException {
            crate::error::ResourceLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ResourceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ResourceLimitExceededException`](crate::error::ResourceLimitExceededException)
    pub fn builder() -> crate::error::resource_limit_exceeded_exception::Builder {
        crate::error::resource_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The request uses too many filters or too many filter values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilterLimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FilterLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilterLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FilterLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FilterLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FilterLimitExceededException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for FilterLimitExceededException {}
/// See [`FilterLimitExceededException`](crate::error::FilterLimitExceededException)
pub mod filter_limit_exceeded_exception {
    /// A builder for [`FilterLimitExceededException`](crate::error::FilterLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterLimitExceededException`](crate::error::FilterLimitExceededException)
        pub fn build(self) -> crate::error::FilterLimitExceededException {
            crate::error::FilterLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl FilterLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FilterLimitExceededException`](crate::error::FilterLimitExceededException)
    pub fn builder() -> crate::error::filter_limit_exceeded_exception::Builder {
        crate::error::filter_limit_exceeded_exception::Builder::default()
    }
}

/// <p>A dependency required to run the API is missing.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FailedDependencyException {
    pub message: std::option::Option<std::string::String>,
    pub error_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FailedDependencyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailedDependencyException");
        formatter.field("message", &self.message);
        formatter.field("error_code", &self.error_code);
        formatter.finish()
    }
}
impl FailedDependencyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FailedDependencyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FailedDependencyException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for FailedDependencyException {}
/// See [`FailedDependencyException`](crate::error::FailedDependencyException)
pub mod failed_dependency_exception {
    /// A builder for [`FailedDependencyException`](crate::error::FailedDependencyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedDependencyException`](crate::error::FailedDependencyException)
        pub fn build(self) -> crate::error::FailedDependencyException {
            crate::error::FailedDependencyException {
                message: self.message,
                error_code: self.error_code,
            }
        }
    }
}
impl FailedDependencyException {
    /// Creates a new builder-style object to manufacture [`FailedDependencyException`](crate::error::FailedDependencyException)
    pub fn builder() -> crate::error::failed_dependency_exception::Builder {
        crate::error::failed_dependency_exception::Builder::default()
    }
}

/// <p>This is not the correct Region for the resource. Try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RedirectException {
    pub location: std::option::Option<std::string::String>,
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RedirectException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RedirectException");
        formatter.field("location", &self.location);
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RedirectException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RedirectException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RedirectException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for RedirectException {}
/// See [`RedirectException`](crate::error::RedirectException)
pub mod redirect_exception {
    /// A builder for [`RedirectException`](crate::error::RedirectException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) location: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn location(mut self, input: impl Into<std::string::String>) -> Self {
            self.location = Some(input.into());
            self
        }
        pub fn set_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.location = input;
            self
        }
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RedirectException`](crate::error::RedirectException)
        pub fn build(self) -> crate::error::RedirectException {
            crate::error::RedirectException {
                location: self.location,
                message: self.message,
            }
        }
    }
}
impl RedirectException {
    /// Creates a new builder-style object to manufacture [`RedirectException`](crate::error::RedirectException)
    pub fn builder() -> crate::error::redirect_exception::Builder {
        crate::error::redirect_exception::Builder::default()
    }
}

/// <p>There was a conflict processing the request. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The digital signature method is unsupported. Try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedDigitalSignatureMethodException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UnsupportedDigitalSignatureMethodException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedDigitalSignatureMethodException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UnsupportedDigitalSignatureMethodException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedDigitalSignatureMethodException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedDigitalSignatureMethodException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedDigitalSignatureMethodException {}
/// See [`UnsupportedDigitalSignatureMethodException`](crate::error::UnsupportedDigitalSignatureMethodException)
pub mod unsupported_digital_signature_method_exception {
    /// A builder for [`UnsupportedDigitalSignatureMethodException`](crate::error::UnsupportedDigitalSignatureMethodException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedDigitalSignatureMethodException`](crate::error::UnsupportedDigitalSignatureMethodException)
        pub fn build(self) -> crate::error::UnsupportedDigitalSignatureMethodException {
            crate::error::UnsupportedDigitalSignatureMethodException {
                message: self.message,
            }
        }
    }
}
impl UnsupportedDigitalSignatureMethodException {
    /// Creates a new builder-style object to manufacture [`UnsupportedDigitalSignatureMethodException`](crate::error::UnsupportedDigitalSignatureMethodException)
    pub fn builder() -> crate::error::unsupported_digital_signature_method_exception::Builder {
        crate::error::unsupported_digital_signature_method_exception::Builder::default()
    }
}

/// <p>There are no entitlements found for this license, or the entitlement maximum count is reached.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoEntitlementsAllowedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoEntitlementsAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoEntitlementsAllowedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoEntitlementsAllowedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoEntitlementsAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoEntitlementsAllowedException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoEntitlementsAllowedException {}
/// See [`NoEntitlementsAllowedException`](crate::error::NoEntitlementsAllowedException)
pub mod no_entitlements_allowed_exception {
    /// A builder for [`NoEntitlementsAllowedException`](crate::error::NoEntitlementsAllowedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoEntitlementsAllowedException`](crate::error::NoEntitlementsAllowedException)
        pub fn build(self) -> crate::error::NoEntitlementsAllowedException {
            crate::error::NoEntitlementsAllowedException {
                message: self.message,
            }
        }
    }
}
impl NoEntitlementsAllowedException {
    /// Creates a new builder-style object to manufacture [`NoEntitlementsAllowedException`](crate::error::NoEntitlementsAllowedException)
    pub fn builder() -> crate::error::no_entitlements_allowed_exception::Builder {
        crate::error::no_entitlements_allowed_exception::Builder::default()
    }
}

/// <p>The entitlement is not allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EntitlementNotAllowedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EntitlementNotAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EntitlementNotAllowedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EntitlementNotAllowedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EntitlementNotAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EntitlementNotAllowedException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for EntitlementNotAllowedException {}
/// See [`EntitlementNotAllowedException`](crate::error::EntitlementNotAllowedException)
pub mod entitlement_not_allowed_exception {
    /// A builder for [`EntitlementNotAllowedException`](crate::error::EntitlementNotAllowedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EntitlementNotAllowedException`](crate::error::EntitlementNotAllowedException)
        pub fn build(self) -> crate::error::EntitlementNotAllowedException {
            crate::error::EntitlementNotAllowedException {
                message: self.message,
            }
        }
    }
}
impl EntitlementNotAllowedException {
    /// Creates a new builder-style object to manufacture [`EntitlementNotAllowedException`](crate::error::EntitlementNotAllowedException)
    pub fn builder() -> crate::error::entitlement_not_allowed_exception::Builder {
        crate::error::entitlement_not_allowed_exception::Builder::default()
    }
}
