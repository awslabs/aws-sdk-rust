// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn assume_role(&self) -> fluent_builders::AssumeRole<C> {
        fluent_builders::AssumeRole::new(self.handle.clone())
    }
    pub fn assume_role_with_saml(&self) -> fluent_builders::AssumeRoleWithSAML<C> {
        fluent_builders::AssumeRoleWithSAML::new(self.handle.clone())
    }
    pub fn assume_role_with_web_identity(&self) -> fluent_builders::AssumeRoleWithWebIdentity<C> {
        fluent_builders::AssumeRoleWithWebIdentity::new(self.handle.clone())
    }
    pub fn decode_authorization_message(&self) -> fluent_builders::DecodeAuthorizationMessage<C> {
        fluent_builders::DecodeAuthorizationMessage::new(self.handle.clone())
    }
    pub fn get_access_key_info(&self) -> fluent_builders::GetAccessKeyInfo<C> {
        fluent_builders::GetAccessKeyInfo::new(self.handle.clone())
    }
    pub fn get_caller_identity(&self) -> fluent_builders::GetCallerIdentity<C> {
        fluent_builders::GetCallerIdentity::new(self.handle.clone())
    }
    pub fn get_federation_token(&self) -> fluent_builders::GetFederationToken<C> {
        fluent_builders::GetFederationToken::new(self.handle.clone())
    }
    pub fn get_session_token(&self) -> fluent_builders::GetSessionToken<C> {
        fluent_builders::GetSessionToken::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssumeRole<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::assume_role_input::Builder,
    }
    impl<C> AssumeRole<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AssumeRoleOutput,
            smithy_http::result::SdkError<crate::error::AssumeRoleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the role to assume.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// <p>An identifier for the assumed role session.</p>
        /// <p>Use the role session name to uniquely identify a session when the same role is assumed
        /// by different principals or for different reasons. In cross-account scenarios, the role
        /// session name is visible to, and can be logged by the account that owns the role. The role
        /// session name is also used in the ARN of the assumed role principal. This means that
        /// subsequent cross-account API requests that use the temporary security credentials will
        /// expose the role session name to the external account in their AWS CloudTrail logs.</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn role_session_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_session_name(inp);
            self
        }
        pub fn set_role_session_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_role_session_name(inp);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
        /// managed session policies. The policies must exist in the same account as the role.</p>
        /// <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
        /// plaintext that you use for both inline and managed session policies can't exceed 2,048
        /// characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
        /// Service Namespaces</a> in the AWS General Reference.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        /// <p>Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn policy_arns(mut self, inp: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            self.inner = self.inner.policy_arns(inp);
            self
        }
        pub fn set_policy_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.inner = self.inner.set_policy_arns(inp);
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>This parameter is optional. Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        pub fn set_policy(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(inp);
            self
        }
        /// <p>The duration, in seconds, of the role session. The value specified can can range from
        /// 900 seconds (15 minutes) up to the maximum session duration that is set for the role. The
        /// maximum session duration setting can have a value from 1 hour to 12 hours. If you specify a
        /// value higher than this setting or the administrator setting (whichever is lower), the
        /// operation fails. For example, if you specify a session duration of 12 hours, but your
        /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
        /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
        /// Maximum Session Duration Setting for a Role</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>By default, the value is set to <code>3600</code> seconds. </p>
        /// <note>
        /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
        /// session that you might request using the returned credentials. The request to the
        /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
        /// parameter that specifies the maximum length of the console session. For more
        /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
        /// that Enables Federated Users to Access the AWS Management Console</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn duration_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_seconds(inp);
            self
        }
        pub fn set_duration_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_seconds(inp);
            self
        }
        /// <p>A list of session tags that you want to pass. Each session tag consists of a key name
        /// and an associated value. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging AWS STS
        /// Sessions</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
        /// tag keys can’t exceed 128 characters, and the values can’t exceed 256 characters. For these
        /// and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
        /// and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        /// <p>You can pass a session tag with the same key as a tag that is already
        /// attached to the role. When you do, session tags override a role tag with the same key. </p>
        /// <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
        /// cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
        /// that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
        /// <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
        /// and <code>department</code> are not saved as separate tags, and the session tag passed in
        /// the request takes precedence over the role tag.</p>
        /// <p>Additionally, if you used temporary credentials to perform this operation, the new
        /// session inherits any transitive session tags from the calling session. If you pass a
        /// session tag with the same key as an inherited tag, the operation fails. To view the
        /// inherited tags for a session, see the AWS CloudTrail logs. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/session-tags.html#id_session-tags_ctlogs">Viewing Session Tags in CloudTrail</a> in the
        /// <i>IAM User Guide</i>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>A list of keys for session tags that you want to set as transitive. If you set a tag key
        /// as transitive, the corresponding key and value passes to subsequent sessions in a role
        /// chain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
        /// with Session Tags</a> in the <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. When you set session tags as transitive, the session policy
        /// and session tags packed binary limit is not affected.</p>
        /// <p>If you choose not to specify a transitive tag key, then no tags are passed from this
        /// session to any subsequent sessions.</p>
        pub fn transitive_tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.transitive_tag_keys(inp);
            self
        }
        pub fn set_transitive_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_transitive_tag_keys(inp);
            self
        }
        /// <p>A unique identifier that might be required when you assume a role in another account. If
        /// the administrator of the account to which the role belongs provided you with an external
        /// ID, then provide that value in the <code>ExternalId</code> parameter. This value can be any
        /// string, such as a passphrase or account number. A cross-account role is usually set up to
        /// trust everyone in an account. Therefore, the administrator of the trusting account might
        /// send an external ID to the administrator of the trusted account. That way, only someone
        /// with the ID can assume the role, rather than everyone in the account. For more information
        /// about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
        /// When Granting Access to Your AWS Resources to a Third Party</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>The regex used to validate this parameter is a string of
        /// characters consisting of upper- and lower-case alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(inp);
            self
        }
        pub fn set_external_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(inp);
            self
        }
        /// <p>The identification number of the MFA device that is associated with the user who is
        /// making the <code>AssumeRole</code> call. Specify this value if the trust policy of the role
        /// being assumed includes a condition that requires MFA authentication. The value is either
        /// the serial number for a hardware device (such as <code>GAHT12345678</code>) or an Amazon
        /// Resource Name (ARN) for a virtual device (such as
        /// <code>arn:aws:iam::123456789012:mfa/user</code>).</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>The value provided by the MFA device, if the trust policy of the role being assumed
        /// requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
        /// the role being assumed requires MFA and if the <code>TokenCode</code> value is missing or
        /// expired, the <code>AssumeRole</code> call returns an "access denied" error.</p>
        /// <p>The format for this parameter, as described by its regex pattern, is a sequence of six
        /// numeric digits.</p>
        pub fn token_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_code(inp);
            self
        }
        pub fn set_token_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token_code(inp);
            self
        }
        /// <p>The source identity specified by the principal that is calling the
        /// <code>AssumeRole</code> operation.</p>
        /// <p>You can require users to specify a source identity when they assume a role. You do this
        /// by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
        /// use source identity information in AWS CloudTrail logs to determine who took actions with a role.
        /// You can use the <code>aws:SourceIdentity</code> condition key to further control access to
        /// AWS resources based on the value of source identity. For more information about using
        /// source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
        /// actions taken with assumed roles</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of upper-
        /// and lower-case alphanumeric characters with no spaces. You can also include underscores or
        /// any of the following characters: =,.@-. You cannot use a value that begins with the text
        /// <code>aws:</code>. This prefix is reserved for AWS internal
        /// use.</p>
        pub fn source_identity(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_identity(inp);
            self
        }
        pub fn set_source_identity(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_identity(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssumeRoleWithSAML<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::assume_role_with_saml_input::Builder,
    }
    impl<C> AssumeRoleWithSAML<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AssumeRoleWithSAMLOutput,
            smithy_http::result::SdkError<crate::error::AssumeRoleWithSAMLError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the
        /// IdP.</p>
        pub fn principal_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_arn(inp);
            self
        }
        pub fn set_principal_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_arn(inp);
            self
        }
        /// <p>The base64 encoded SAML authentication response provided by the IdP.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/create-role-saml-IdP-tasks.html">Configuring a Relying Party and
        /// Adding Claims</a> in the <i>IAM User Guide</i>. </p>
        pub fn saml_assertion(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.saml_assertion(inp);
            self
        }
        pub fn set_saml_assertion(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_saml_assertion(inp);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
        /// managed session policies. The policies must exist in the same account as the role.</p>
        /// <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
        /// plaintext that you use for both inline and managed session policies can't exceed 2,048
        /// characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
        /// Service Namespaces</a> in the AWS General Reference.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        /// <p>Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn policy_arns(mut self, inp: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            self.inner = self.inner.policy_arns(inp);
            self
        }
        pub fn set_policy_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.inner = self.inner.set_policy_arns(inp);
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>This parameter is optional. Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>. </p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        pub fn set_policy(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(inp);
            self
        }
        /// <p>The duration, in seconds, of the role session. Your role session lasts for the duration
        /// that you specify for the <code>DurationSeconds</code> parameter, or until the time
        /// specified in the SAML authentication response's <code>SessionNotOnOrAfter</code> value,
        /// whichever is shorter. You can provide a <code>DurationSeconds</code> value from 900 seconds
        /// (15 minutes) up to the maximum session duration setting for the role. This setting can have
        /// a value from 1 hour to 12 hours. If you specify a value higher than this setting, the
        /// operation fails. For example, if you specify a session duration of 12 hours, but your
        /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
        /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
        /// Maximum Session Duration Setting for a Role</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>By default, the value is set to <code>3600</code> seconds. </p>
        /// <note>
        /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
        /// session that you might request using the returned credentials. The request to the
        /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
        /// parameter that specifies the maximum length of the console session. For more
        /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
        /// that Enables Federated Users to Access the AWS Management Console</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn duration_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_seconds(inp);
            self
        }
        pub fn set_duration_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_seconds(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssumeRoleWithWebIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::assume_role_with_web_identity_input::Builder,
    }
    impl<C> AssumeRoleWithWebIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::AssumeRoleWithWebIdentityOutput,
            smithy_http::result::SdkError<crate::error::AssumeRoleWithWebIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
        pub fn role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(inp);
            self
        }
        pub fn set_role_arn(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(inp);
            self
        }
        /// <p>An identifier for the assumed role session. Typically, you pass the name or identifier
        /// that is associated with the user who is using your application. That way, the temporary
        /// security credentials that your application will use are associated with that user. This
        /// session name is included as part of the ARN and assumed role ID in the
        /// <code>AssumedRoleUser</code> response element.</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn role_session_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_session_name(inp);
            self
        }
        pub fn set_role_session_name(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_role_session_name(inp);
            self
        }
        /// <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
        /// provider. Your application must get this token by authenticating the user who is using your
        /// application with a web identity provider before the application makes an
        /// <code>AssumeRoleWithWebIdentity</code> call. </p>
        pub fn web_identity_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.web_identity_token(inp);
            self
        }
        pub fn set_web_identity_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_web_identity_token(inp);
            self
        }
        /// <p>The fully qualified host component of the domain name of the identity provider.</p>
        /// <p>Specify this value only for OAuth 2.0 access tokens. Currently
        /// <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only supported
        /// identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
        /// numbers.</p>
        /// <p>Do not specify this value for OpenID Connect ID tokens.</p>
        pub fn provider_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.provider_id(inp);
            self
        }
        pub fn set_provider_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_provider_id(inp);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
        /// managed session policies. The policies must exist in the same account as the role.</p>
        /// <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
        /// plaintext that you use for both inline and managed session policies can't exceed 2,048
        /// characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
        /// Service Namespaces</a> in the AWS General Reference.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        /// <p>Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        pub fn policy_arns(mut self, inp: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            self.inner = self.inner.policy_arns(inp);
            self
        }
        pub fn set_policy_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.inner = self.inner.set_policy_arns(inp);
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>This parameter is optional. Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        pub fn set_policy(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(inp);
            self
        }
        /// <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
        /// minutes) up to the maximum session duration setting for the role. This setting can have a
        /// value from 1 hour to 12 hours. If you specify a value higher than this setting, the
        /// operation fails. For example, if you specify a session duration of 12 hours, but your
        /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
        /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
        /// Maximum Session Duration Setting for a Role</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>By default, the value is set to <code>3600</code> seconds. </p>
        /// <note>
        /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
        /// session that you might request using the returned credentials. The request to the
        /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
        /// parameter that specifies the maximum length of the console session. For more
        /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
        /// that Enables Federated Users to Access the AWS Management Console</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn duration_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_seconds(inp);
            self
        }
        pub fn set_duration_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_seconds(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DecodeAuthorizationMessage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::decode_authorization_message_input::Builder,
    }
    impl<C> DecodeAuthorizationMessage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DecodeAuthorizationMessageOutput,
            smithy_http::result::SdkError<crate::error::DecodeAuthorizationMessageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The encoded message that was returned with the response.</p>
        pub fn encoded_message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.encoded_message(inp);
            self
        }
        pub fn set_encoded_message(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_encoded_message(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessKeyInfo<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_key_info_input::Builder,
    }
    impl<C> GetAccessKeyInfo<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetAccessKeyInfoOutput,
            smithy_http::result::SdkError<crate::error::GetAccessKeyInfoError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of an access key.</p>
        /// <p>This parameter allows (through its regex pattern) a string of characters that can
        /// consist of any upper- or lowercase letter or digit.</p>
        pub fn access_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_key_id(inp);
            self
        }
        pub fn set_access_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_access_key_id(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCallerIdentity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_caller_identity_input::Builder,
    }
    impl<C> GetCallerIdentity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetCallerIdentityOutput,
            smithy_http::result::SdkError<crate::error::GetCallerIdentityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFederationToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_federation_token_input::Builder,
    }
    impl<C> GetFederationToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetFederationTokenOutput,
            smithy_http::result::SdkError<crate::error::GetFederationTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the federated user. The name is used as an identifier for the temporary
        /// security credentials (such as <code>Bob</code>). For example, you can reference the
        /// federated user name in a resource-based policy, such as in an Amazon S3 bucket policy.</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
        /// this operation. You can pass a single JSON policy document to use as an inline session
        /// policy. You can also specify up to 10 managed policies to use as managed session
        /// policies.</p>
        /// <p>This parameter is optional. However, if you do not pass any session policies, then the
        /// resulting federated user session has no permissions.</p>
        /// <p>When you pass session policies, the session permissions are the intersection of the
        /// IAM user policies and the session policies that you pass. This gives you a way to further
        /// restrict the permissions for a federated user. You cannot use session policies to grant
        /// more permissions than those that are defined in the permissions policy of the IAM user.
        /// For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
        /// the <i>IAM User Guide</i>.</p>
        /// <p>The resulting credentials can be used to access a resource that has a resource-based
        /// policy. If that policy specifically references the federated user session in the
        /// <code>Principal</code> element of the policy, the session has the permissions allowed by
        /// the policy. These permissions are granted in addition to the permissions that are granted
        /// by the session policies.</p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(inp);
            self
        }
        pub fn set_policy(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(inp);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as a
        /// managed session policy. The policies must exist in the same account as the IAM user that
        /// is requesting federated access.</p>
        /// <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
        /// this operation. You can pass a single JSON policy document to use as an inline session
        /// policy. You can also specify up to 10 managed policies to use as managed session policies.
        /// The plaintext that you use for both inline and managed session policies can't exceed 2,048
        /// characters. You can provide up to 10 managed policy ARNs. For more information about ARNs,
        /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
        /// Resource Names (ARNs) and AWS Service Namespaces</a> in the AWS General Reference.</p>
        /// <p>This parameter is optional. However, if you do not pass any session policies, then the
        /// resulting federated user session has no permissions.</p>
        /// <p>When you pass session policies, the session permissions are the intersection of the
        /// IAM user policies and the session policies that you pass. This gives you a way to further
        /// restrict the permissions for a federated user. You cannot use session policies to grant
        /// more permissions than those that are defined in the permissions policy of the IAM user.
        /// For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
        /// the <i>IAM User Guide</i>.</p>
        /// <p>The resulting credentials can be used to access a resource that has a resource-based
        /// policy. If that policy specifically references the federated user session in the
        /// <code>Principal</code> element of the policy, the session has the permissions allowed by
        /// the policy. These permissions are granted in addition to the permissions that are granted
        /// by the session policies.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy_arns(mut self, inp: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            self.inner = self.inner.policy_arns(inp);
            self
        }
        pub fn set_policy_arns(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.inner = self.inner.set_policy_arns(inp);
            self
        }
        /// <p>The duration, in seconds, that the session should last. Acceptable durations for
        /// federation sessions range from 900 seconds (15 minutes) to 129,600 seconds (36 hours), with
        /// 43,200 seconds (12 hours) as the default. Sessions obtained using AWS account root user
        /// credentials are restricted to a maximum of 3,600 seconds (one hour). If the specified
        /// duration is longer than one hour, the session obtained by using root user credentials
        /// defaults to one hour.</p>
        pub fn duration_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_seconds(inp);
            self
        }
        pub fn set_duration_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_seconds(inp);
            self
        }
        /// <p>A list of session tags. Each session tag consists of a key name and an associated value.
        /// For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
        /// tag keys can’t exceed 128 characters and the values can’t exceed 256 characters. For these
        /// and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
        /// and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        /// <p>You can pass a session tag with the same key as a tag that is already
        /// attached to the user you are federating. When you do, session tags override a user tag with
        /// the same key. </p>
        /// <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
        /// cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
        /// that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
        /// <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
        /// and <code>department</code> are not saved as separate tags, and the session tag passed in
        /// the request takes precedence over the role tag.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSessionToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_session_token_input::Builder,
    }
    impl<C> GetSessionToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetSessionTokenOutput,
            smithy_http::result::SdkError<crate::error::GetSessionTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The duration, in seconds, that the credentials should remain valid. Acceptable
        /// durations for IAM user sessions range from 900 seconds (15 minutes) to 129,600 seconds
        /// (36 hours), with 43,200 seconds (12 hours) as the default. Sessions for AWS account
        /// owners are restricted to a maximum of 3,600 seconds (one hour). If the duration is
        /// longer than one hour, the session for AWS account owners defaults to one hour.</p>
        pub fn duration_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.duration_seconds(inp);
            self
        }
        pub fn set_duration_seconds(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_duration_seconds(inp);
            self
        }
        /// <p>The identification number of the MFA device that is associated with the IAM user who
        /// is making the <code>GetSessionToken</code> call. Specify this value if the IAM user
        /// has a policy that requires MFA authentication. The value is either the serial number for
        /// a hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
        /// for a virtual device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
        /// find the device for an IAM user by going to the AWS Management Console and viewing the user's
        /// security credentials. </p>
        /// <p>The regex used to validate this parameter is a string of
        /// characters consisting of upper- and lower-case alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn serial_number(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.serial_number(inp);
            self
        }
        pub fn set_serial_number(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_serial_number(inp);
            self
        }
        /// <p>The value provided by the MFA device, if MFA is required. If any policy requires the
        /// IAM user to submit an MFA code, specify this value. If MFA authentication is required,
        /// the user must provide a code when requesting a set of temporary security credentials. A
        /// user who fails to provide the code receives an "access denied" response when requesting
        /// resources that require MFA authentication.</p>
        /// <p>The format for this parameter, as described by its regex pattern, is a sequence of six
        /// numeric digits.</p>
        pub fn token_code(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_code(inp);
            self
        }
        pub fn set_token_code(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token_code(inp);
            self
        }
    }
}
