// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AssumeRoleInput`](crate::input::AssumeRoleInput)
pub mod assume_role_input {
    /// A builder for [`AssumeRoleInput`](crate::input::AssumeRoleInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) role_session_name: std::option::Option<std::string::String>,
        pub(crate) policy_arns:
            std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) duration_seconds: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) transitive_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) token_code: std::option::Option<std::string::String>,
        pub(crate) source_identity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the role to assume.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>An identifier for the assumed role session.</p>
        /// <p>Use the role session name to uniquely identify a session when the same role is assumed
        /// by different principals or for different reasons. In cross-account scenarios, the role
        /// session name is visible to, and can be logged by the account that owns the role. The role
        /// session name is also used in the ARN of the assumed role principal. This means that
        /// subsequent cross-account API requests that use the temporary security credentials will
        /// expose the role session name to the external account in their AWS CloudTrail logs.</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn role_session_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_session_name = Some(input.into());
            self
        }
        pub fn set_role_session_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.role_session_name = input;
            self
        }
        pub fn policy_arns(mut self, input: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            let mut v = self.policy_arns.unwrap_or_default();
            v.push(input.into());
            self.policy_arns = Some(v);
            self
        }
        pub fn set_policy_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.policy_arns = input;
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>This parameter is optional. Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>The duration, in seconds, of the role session. The value specified can can range from
        /// 900 seconds (15 minutes) up to the maximum session duration that is set for the role. The
        /// maximum session duration setting can have a value from 1 hour to 12 hours. If you specify a
        /// value higher than this setting or the administrator setting (whichever is lower), the
        /// operation fails. For example, if you specify a session duration of 12 hours, but your
        /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
        /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
        /// Maximum Session Duration Setting for a Role</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>By default, the value is set to <code>3600</code> seconds. </p>
        /// <note>
        /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
        /// session that you might request using the returned credentials. The request to the
        /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
        /// parameter that specifies the maximum length of the console session. For more
        /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
        /// that Enables Federated Users to Access the AWS Management Console</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn transitive_tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.transitive_tag_keys.unwrap_or_default();
            v.push(input.into());
            self.transitive_tag_keys = Some(v);
            self
        }
        pub fn set_transitive_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transitive_tag_keys = input;
            self
        }
        /// <p>A unique identifier that might be required when you assume a role in another account. If
        /// the administrator of the account to which the role belongs provided you with an external
        /// ID, then provide that value in the <code>ExternalId</code> parameter. This value can be any
        /// string, such as a passphrase or account number. A cross-account role is usually set up to
        /// trust everyone in an account. Therefore, the administrator of the trusting account might
        /// send an external ID to the administrator of the trusted account. That way, only someone
        /// with the ID can assume the role, rather than everyone in the account. For more information
        /// about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
        /// When Granting Access to Your AWS Resources to a Third Party</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>The regex used to validate this parameter is a string of
        /// characters consisting of upper- and lower-case alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The identification number of the MFA device that is associated with the user who is
        /// making the <code>AssumeRole</code> call. Specify this value if the trust policy of the role
        /// being assumed includes a condition that requires MFA authentication. The value is either
        /// the serial number for a hardware device (such as <code>GAHT12345678</code>) or an Amazon
        /// Resource Name (ARN) for a virtual device (such as
        /// <code>arn:aws:iam::123456789012:mfa/user</code>).</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>The value provided by the MFA device, if the trust policy of the role being assumed
        /// requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
        /// the role being assumed requires MFA and if the <code>TokenCode</code> value is missing or
        /// expired, the <code>AssumeRole</code> call returns an "access denied" error.</p>
        /// <p>The format for this parameter, as described by its regex pattern, is a sequence of six
        /// numeric digits.</p>
        pub fn token_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_code = Some(input.into());
            self
        }
        pub fn set_token_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_code = input;
            self
        }
        /// <p>The source identity specified by the principal that is calling the
        /// <code>AssumeRole</code> operation.</p>
        /// <p>You can require users to specify a source identity when they assume a role. You do this
        /// by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
        /// use source identity information in AWS CloudTrail logs to determine who took actions with a role.
        /// You can use the <code>aws:SourceIdentity</code> condition key to further control access to
        /// AWS resources based on the value of source identity. For more information about using
        /// source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
        /// actions taken with assumed roles</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>The regex used to validate this parameter is a string of characters consisting of upper-
        /// and lower-case alphanumeric characters with no spaces. You can also include underscores or
        /// any of the following characters: =,.@-. You cannot use a value that begins with the text
        /// <code>aws:</code>. This prefix is reserved for AWS internal
        /// use.</p>
        pub fn source_identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.source_identity = Some(input.into());
            self
        }
        pub fn set_source_identity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.source_identity = input;
            self
        }
        /// Consumes the builder and constructs a [`AssumeRoleInput`](crate::input::AssumeRoleInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::AssumeRoleInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::AssumeRoleInput {
                role_arn: self.role_arn,
                role_session_name: self.role_session_name,
                policy_arns: self.policy_arns,
                policy: self.policy,
                duration_seconds: self.duration_seconds,
                tags: self.tags,
                transitive_tag_keys: self.transitive_tag_keys,
                external_id: self.external_id,
                serial_number: self.serial_number,
                token_code: self.token_code,
                source_identity: self.source_identity,
            })
        }
    }
}
#[doc(hidden)]
pub type AssumeRoleInputOperationOutputAlias = crate::operation::AssumeRole;
#[doc(hidden)]
pub type AssumeRoleInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssumeRoleInput {
    /// Consumes the builder and constructs an Operation<[`AssumeRole`](crate::operation::AssumeRole)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssumeRole,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_assume_role(&self).map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AssumeRole::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new("AssumeRole", "sts"));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssumeRoleInput`](crate::input::AssumeRoleInput)
    pub fn builder() -> crate::input::assume_role_input::Builder {
        crate::input::assume_role_input::Builder::default()
    }
}

/// See [`AssumeRoleWithSamlInput`](crate::input::AssumeRoleWithSamlInput)
pub mod assume_role_with_saml_input {
    /// A builder for [`AssumeRoleWithSamlInput`](crate::input::AssumeRoleWithSamlInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) principal_arn: std::option::Option<std::string::String>,
        pub(crate) saml_assertion: std::option::Option<std::string::String>,
        pub(crate) policy_arns:
            std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the
        /// IdP.</p>
        pub fn principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_arn = Some(input.into());
            self
        }
        pub fn set_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.principal_arn = input;
            self
        }
        /// <p>The base64 encoded SAML authentication response provided by the IdP.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/create-role-saml-IdP-tasks.html">Configuring a Relying Party and
        /// Adding Claims</a> in the <i>IAM User Guide</i>. </p>
        pub fn saml_assertion(mut self, input: impl Into<std::string::String>) -> Self {
            self.saml_assertion = Some(input.into());
            self
        }
        pub fn set_saml_assertion(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.saml_assertion = input;
            self
        }
        pub fn policy_arns(mut self, input: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            let mut v = self.policy_arns.unwrap_or_default();
            v.push(input.into());
            self.policy_arns = Some(v);
            self
        }
        pub fn set_policy_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.policy_arns = input;
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>This parameter is optional. Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>. </p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>The duration, in seconds, of the role session. Your role session lasts for the duration
        /// that you specify for the <code>DurationSeconds</code> parameter, or until the time
        /// specified in the SAML authentication response's <code>SessionNotOnOrAfter</code> value,
        /// whichever is shorter. You can provide a <code>DurationSeconds</code> value from 900 seconds
        /// (15 minutes) up to the maximum session duration setting for the role. This setting can have
        /// a value from 1 hour to 12 hours. If you specify a value higher than this setting, the
        /// operation fails. For example, if you specify a session duration of 12 hours, but your
        /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
        /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
        /// Maximum Session Duration Setting for a Role</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>By default, the value is set to <code>3600</code> seconds. </p>
        /// <note>
        /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
        /// session that you might request using the returned credentials. The request to the
        /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
        /// parameter that specifies the maximum length of the console session. For more
        /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
        /// that Enables Federated Users to Access the AWS Management Console</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`AssumeRoleWithSamlInput`](crate::input::AssumeRoleWithSamlInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssumeRoleWithSamlInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssumeRoleWithSamlInput {
                role_arn: self.role_arn,
                principal_arn: self.principal_arn,
                saml_assertion: self.saml_assertion,
                policy_arns: self.policy_arns,
                policy: self.policy,
                duration_seconds: self.duration_seconds,
            })
        }
    }
}
#[doc(hidden)]
pub type AssumeRoleWithSAMLInputOperationOutputAlias = crate::operation::AssumeRoleWithSAML;
#[doc(hidden)]
pub type AssumeRoleWithSAMLInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssumeRoleWithSamlInput {
    /// Consumes the builder and constructs an Operation<[`AssumeRoleWithSAML`](crate::operation::AssumeRoleWithSAML)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssumeRoleWithSAML,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_assume_role_with_saml(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AssumeRoleWithSAML::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AssumeRoleWithSAML",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssumeRoleWithSamlInput`](crate::input::AssumeRoleWithSamlInput)
    pub fn builder() -> crate::input::assume_role_with_saml_input::Builder {
        crate::input::assume_role_with_saml_input::Builder::default()
    }
}

/// See [`AssumeRoleWithWebIdentityInput`](crate::input::AssumeRoleWithWebIdentityInput)
pub mod assume_role_with_web_identity_input {
    /// A builder for [`AssumeRoleWithWebIdentityInput`](crate::input::AssumeRoleWithWebIdentityInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) role_session_name: std::option::Option<std::string::String>,
        pub(crate) web_identity_token: std::option::Option<std::string::String>,
        pub(crate) provider_id: std::option::Option<std::string::String>,
        pub(crate) policy_arns:
            std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>An identifier for the assumed role session. Typically, you pass the name or identifier
        /// that is associated with the user who is using your application. That way, the temporary
        /// security credentials that your application will use are associated with that user. This
        /// session name is included as part of the ARN and assumed role ID in the
        /// <code>AssumedRoleUser</code> response element.</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn role_session_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_session_name = Some(input.into());
            self
        }
        pub fn set_role_session_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.role_session_name = input;
            self
        }
        /// <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
        /// provider. Your application must get this token by authenticating the user who is using your
        /// application with a web identity provider before the application makes an
        /// <code>AssumeRoleWithWebIdentity</code> call. </p>
        pub fn web_identity_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_identity_token = Some(input.into());
            self
        }
        pub fn set_web_identity_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.web_identity_token = input;
            self
        }
        /// <p>The fully qualified host component of the domain name of the identity provider.</p>
        /// <p>Specify this value only for OAuth 2.0 access tokens. Currently
        /// <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only supported
        /// identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
        /// numbers.</p>
        /// <p>Do not specify this value for OpenID Connect ID tokens.</p>
        pub fn provider_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider_id = Some(input.into());
            self
        }
        pub fn set_provider_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider_id = input;
            self
        }
        pub fn policy_arns(mut self, input: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            let mut v = self.policy_arns.unwrap_or_default();
            v.push(input.into());
            self.policy_arns = Some(v);
            self
        }
        pub fn set_policy_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.policy_arns = input;
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>This parameter is optional. Passing policies to this operation returns new
        /// temporary credentials. The resulting session's permissions are the intersection of the
        /// role's identity-based policy and the session policies. You can use the role's temporary
        /// credentials in subsequent AWS API calls to access resources in the account that owns
        /// the role. You cannot use session policies to grant more permissions than those allowed
        /// by the identity-based policy of the role that is being assumed. For more information, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
        /// Policies</a> in the <i>IAM User Guide</i>.</p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        /// <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
        /// minutes) up to the maximum session duration setting for the role. This setting can have a
        /// value from 1 hour to 12 hours. If you specify a value higher than this setting, the
        /// operation fails. For example, if you specify a session duration of 12 hours, but your
        /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
        /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
        /// Maximum Session Duration Setting for a Role</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// <p>By default, the value is set to <code>3600</code> seconds. </p>
        /// <note>
        /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
        /// session that you might request using the returned credentials. The request to the
        /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
        /// parameter that specifies the maximum length of the console session. For more
        /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
        /// that Enables Federated Users to Access the AWS Management Console</a> in the
        /// <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`AssumeRoleWithWebIdentityInput`](crate::input::AssumeRoleWithWebIdentityInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssumeRoleWithWebIdentityInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssumeRoleWithWebIdentityInput {
                role_arn: self.role_arn,
                role_session_name: self.role_session_name,
                web_identity_token: self.web_identity_token,
                provider_id: self.provider_id,
                policy_arns: self.policy_arns,
                policy: self.policy,
                duration_seconds: self.duration_seconds,
            })
        }
    }
}
#[doc(hidden)]
pub type AssumeRoleWithWebIdentityInputOperationOutputAlias =
    crate::operation::AssumeRoleWithWebIdentity;
#[doc(hidden)]
pub type AssumeRoleWithWebIdentityInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl AssumeRoleWithWebIdentityInput {
    /// Consumes the builder and constructs an Operation<[`AssumeRoleWithWebIdentity`](crate::operation::AssumeRoleWithWebIdentity)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::AssumeRoleWithWebIdentity,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_assume_role_with_web_identity(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::AssumeRoleWithWebIdentity::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "AssumeRoleWithWebIdentity",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssumeRoleWithWebIdentityInput`](crate::input::AssumeRoleWithWebIdentityInput)
    pub fn builder() -> crate::input::assume_role_with_web_identity_input::Builder {
        crate::input::assume_role_with_web_identity_input::Builder::default()
    }
}

/// See [`DecodeAuthorizationMessageInput`](crate::input::DecodeAuthorizationMessageInput)
pub mod decode_authorization_message_input {
    /// A builder for [`DecodeAuthorizationMessageInput`](crate::input::DecodeAuthorizationMessageInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encoded_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encoded message that was returned with the response.</p>
        pub fn encoded_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.encoded_message = Some(input.into());
            self
        }
        pub fn set_encoded_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encoded_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DecodeAuthorizationMessageInput`](crate::input::DecodeAuthorizationMessageInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DecodeAuthorizationMessageInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DecodeAuthorizationMessageInput {
                encoded_message: self.encoded_message,
            })
        }
    }
}
#[doc(hidden)]
pub type DecodeAuthorizationMessageInputOperationOutputAlias =
    crate::operation::DecodeAuthorizationMessage;
#[doc(hidden)]
pub type DecodeAuthorizationMessageInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl DecodeAuthorizationMessageInput {
    /// Consumes the builder and constructs an Operation<[`DecodeAuthorizationMessage`](crate::operation::DecodeAuthorizationMessage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::DecodeAuthorizationMessage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body =
                crate::operation_ser::serialize_operation_decode_authorization_message(&self)
                    .map_err(|err| {
                        smithy_http::operation::BuildError::SerializationError(err.into())
                    })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DecodeAuthorizationMessage::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DecodeAuthorizationMessage",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DecodeAuthorizationMessageInput`](crate::input::DecodeAuthorizationMessageInput)
    pub fn builder() -> crate::input::decode_authorization_message_input::Builder {
        crate::input::decode_authorization_message_input::Builder::default()
    }
}

/// See [`GetAccessKeyInfoInput`](crate::input::GetAccessKeyInfoInput)
pub mod get_access_key_info_input {
    /// A builder for [`GetAccessKeyInfoInput`](crate::input::GetAccessKeyInfoInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of an access key.</p>
        /// <p>This parameter allows (through its regex pattern) a string of characters that can
        /// consist of any upper- or lowercase letter or digit.</p>
        pub fn access_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(input.into());
            self
        }
        pub fn set_access_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetAccessKeyInfoInput`](crate::input::GetAccessKeyInfoInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetAccessKeyInfoInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetAccessKeyInfoInput {
                access_key_id: self.access_key_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetAccessKeyInfoInputOperationOutputAlias = crate::operation::GetAccessKeyInfo;
#[doc(hidden)]
pub type GetAccessKeyInfoInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetAccessKeyInfoInput {
    /// Consumes the builder and constructs an Operation<[`GetAccessKeyInfo`](crate::operation::GetAccessKeyInfo)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetAccessKeyInfo,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_access_key_info(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetAccessKeyInfo::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetAccessKeyInfo",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetAccessKeyInfoInput`](crate::input::GetAccessKeyInfoInput)
    pub fn builder() -> crate::input::get_access_key_info_input::Builder {
        crate::input::get_access_key_info_input::Builder::default()
    }
}

/// See [`GetCallerIdentityInput`](crate::input::GetCallerIdentityInput)
pub mod get_caller_identity_input {
    /// A builder for [`GetCallerIdentityInput`](crate::input::GetCallerIdentityInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`GetCallerIdentityInput`](crate::input::GetCallerIdentityInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCallerIdentityInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCallerIdentityInput {})
        }
    }
}
#[doc(hidden)]
pub type GetCallerIdentityInputOperationOutputAlias = crate::operation::GetCallerIdentity;
#[doc(hidden)]
pub type GetCallerIdentityInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetCallerIdentityInput {
    /// Consumes the builder and constructs an Operation<[`GetCallerIdentity`](crate::operation::GetCallerIdentity)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetCallerIdentity,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_caller_identity(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetCallerIdentity::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetCallerIdentity",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCallerIdentityInput`](crate::input::GetCallerIdentityInput)
    pub fn builder() -> crate::input::get_caller_identity_input::Builder {
        crate::input::get_caller_identity_input::Builder::default()
    }
}

/// See [`GetFederationTokenInput`](crate::input::GetFederationTokenInput)
pub mod get_federation_token_input {
    /// A builder for [`GetFederationTokenInput`](crate::input::GetFederationTokenInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) policy: std::option::Option<std::string::String>,
        pub(crate) policy_arns:
            std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        pub(crate) duration_seconds: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The name of the federated user. The name is used as an identifier for the temporary
        /// security credentials (such as <code>Bob</code>). For example, you can reference the
        /// federated user name in a resource-based policy, such as in an Amazon S3 bucket policy.</p>
        /// <p>The regex used to validate this parameter is a string of characters
        /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
        /// also include underscores or any of the following characters: =,.@-</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
        /// <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
        /// this operation. You can pass a single JSON policy document to use as an inline session
        /// policy. You can also specify up to 10 managed policies to use as managed session
        /// policies.</p>
        /// <p>This parameter is optional. However, if you do not pass any session policies, then the
        /// resulting federated user session has no permissions.</p>
        /// <p>When you pass session policies, the session permissions are the intersection of the
        /// IAM user policies and the session policies that you pass. This gives you a way to further
        /// restrict the permissions for a federated user. You cannot use session policies to grant
        /// more permissions than those that are defined in the permissions policy of the IAM user.
        /// For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
        /// the <i>IAM User Guide</i>.</p>
        /// <p>The resulting credentials can be used to access a resource that has a resource-based
        /// policy. If that policy specifically references the federated user session in the
        /// <code>Principal</code> element of the policy, the session has the permissions allowed by
        /// the policy. These permissions are granted in addition to the permissions that are granted
        /// by the session policies.</p>
        /// <p>The plaintext that you use for both inline and managed session policies can't exceed
        /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
        /// character to the end of the valid character list (\u0020 through \u00FF). It can also
        /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
        /// characters.</p>
        /// <note>
        /// <p>An AWS conversion compresses the passed session policies and session tags into a
        /// packed binary format that has a separate limit. Your request can fail for this limit
        /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
        /// response element indicates by percentage how close the policies and tags for your
        /// request are to the upper size limit.
        /// </p>
        /// </note>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy = Some(input.into());
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy = input;
            self
        }
        pub fn policy_arns(mut self, input: impl Into<crate::model::PolicyDescriptorType>) -> Self {
            let mut v = self.policy_arns.unwrap_or_default();
            v.push(input.into());
            self.policy_arns = Some(v);
            self
        }
        pub fn set_policy_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
        ) -> Self {
            self.policy_arns = input;
            self
        }
        /// <p>The duration, in seconds, that the session should last. Acceptable durations for
        /// federation sessions range from 900 seconds (15 minutes) to 129,600 seconds (36 hours), with
        /// 43,200 seconds (12 hours) as the default. Sessions obtained using AWS account root user
        /// credentials are restricted to a maximum of 3,600 seconds (one hour). If the specified
        /// duration is longer than one hour, the session obtained by using root user credentials
        /// defaults to one hour.</p>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFederationTokenInput`](crate::input::GetFederationTokenInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetFederationTokenInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetFederationTokenInput {
                name: self.name,
                policy: self.policy,
                policy_arns: self.policy_arns,
                duration_seconds: self.duration_seconds,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type GetFederationTokenInputOperationOutputAlias = crate::operation::GetFederationToken;
#[doc(hidden)]
pub type GetFederationTokenInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetFederationTokenInput {
    /// Consumes the builder and constructs an Operation<[`GetFederationToken`](crate::operation::GetFederationToken)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetFederationToken,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_federation_token(&self)
                .map_err(|err| {
                    smithy_http::operation::BuildError::SerializationError(err.into())
                })?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetFederationToken::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetFederationToken",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetFederationTokenInput`](crate::input::GetFederationTokenInput)
    pub fn builder() -> crate::input::get_federation_token_input::Builder {
        crate::input::get_federation_token_input::Builder::default()
    }
}

/// See [`GetSessionTokenInput`](crate::input::GetSessionTokenInput)
pub mod get_session_token_input {
    /// A builder for [`GetSessionTokenInput`](crate::input::GetSessionTokenInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) duration_seconds: std::option::Option<i32>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) token_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The duration, in seconds, that the credentials should remain valid. Acceptable
        /// durations for IAM user sessions range from 900 seconds (15 minutes) to 129,600 seconds
        /// (36 hours), with 43,200 seconds (12 hours) as the default. Sessions for AWS account
        /// owners are restricted to a maximum of 3,600 seconds (one hour). If the duration is
        /// longer than one hour, the session for AWS account owners defaults to one hour.</p>
        pub fn duration_seconds(mut self, input: i32) -> Self {
            self.duration_seconds = Some(input);
            self
        }
        pub fn set_duration_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.duration_seconds = input;
            self
        }
        /// <p>The identification number of the MFA device that is associated with the IAM user who
        /// is making the <code>GetSessionToken</code> call. Specify this value if the IAM user
        /// has a policy that requires MFA authentication. The value is either the serial number for
        /// a hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
        /// for a virtual device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
        /// find the device for an IAM user by going to the AWS Management Console and viewing the user's
        /// security credentials. </p>
        /// <p>The regex used to validate this parameter is a string of
        /// characters consisting of upper- and lower-case alphanumeric characters with no spaces.
        /// You can also include underscores or any of the following characters: =,.@:/-</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>The value provided by the MFA device, if MFA is required. If any policy requires the
        /// IAM user to submit an MFA code, specify this value. If MFA authentication is required,
        /// the user must provide a code when requesting a set of temporary security credentials. A
        /// user who fails to provide the code receives an "access denied" response when requesting
        /// resources that require MFA authentication.</p>
        /// <p>The format for this parameter, as described by its regex pattern, is a sequence of six
        /// numeric digits.</p>
        pub fn token_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_code = Some(input.into());
            self
        }
        pub fn set_token_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_code = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSessionTokenInput`](crate::input::GetSessionTokenInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSessionTokenInput,
            smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSessionTokenInput {
                duration_seconds: self.duration_seconds,
                serial_number: self.serial_number,
                token_code: self.token_code,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSessionTokenInputOperationOutputAlias = crate::operation::GetSessionToken;
#[doc(hidden)]
pub type GetSessionTokenInputOperationRetryAlias = aws_http::AwsErrorRetryPolicy;
impl GetSessionTokenInput {
    /// Consumes the builder and constructs an Operation<[`GetSessionToken`](crate::operation::GetSessionToken)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        smithy_http::operation::Operation<
            crate::operation::GetSessionToken,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = self.request_builder_base()?;
            let body = crate::operation_ser::serialize_operation_get_session_token(&self).map_err(
                |err| smithy_http::operation::BuildError::SerializationError(err.into()),
            )?;
            let request = Self::assemble(request, body);
            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));
            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));
            #[allow(unused_mut)]
            let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
            request.config_mut().insert(signing_config);
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));
            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );
            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }
            aws_auth::provider::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );
            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetSessionToken::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetSessionToken",
                "sts",
            ));
            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    fn uri_base(&self, output: &mut String) -> Result<(), smithy_http::operation::BuildError> {
        write!(output, "/").expect("formatting should succeed");
        Ok(())
    }
    #[allow(clippy::unnecessary_wraps)]
    fn update_http_builder(
        &self,
        builder: http::request::Builder,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut uri = String::new();
        self.uri_base(&mut uri)?;
        Ok(builder.method("POST").uri(uri))
    }
    #[allow(clippy::unnecessary_wraps)]
    fn request_builder_base(
        &self,
    ) -> std::result::Result<http::request::Builder, smithy_http::operation::BuildError> {
        let mut builder = self.update_http_builder(http::request::Builder::new())?;
        if !builder
            .headers_ref()
            .map(|h| h.contains_key("content-type"))
            .unwrap_or(false)
        {
            builder = builder.header("content-type", "application/x-www-form-urlencoded");
        }
        Ok(builder)
    }
    fn assemble(
        mut builder: http::request::Builder,
        body: smithy_http::body::SdkBody,
    ) -> http::request::Request<smithy_http::body::SdkBody> {
        if let Some(content_length) = body.content_length() {
            builder = builder.header(http::header::CONTENT_LENGTH, content_length)
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSessionTokenInput`](crate::input::GetSessionTokenInput)
    pub fn builder() -> crate::input::get_session_token_input::Builder {
        crate::input::get_session_token_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSessionTokenInput {
    /// <p>The duration, in seconds, that the credentials should remain valid. Acceptable
    /// durations for IAM user sessions range from 900 seconds (15 minutes) to 129,600 seconds
    /// (36 hours), with 43,200 seconds (12 hours) as the default. Sessions for AWS account
    /// owners are restricted to a maximum of 3,600 seconds (one hour). If the duration is
    /// longer than one hour, the session for AWS account owners defaults to one hour.</p>
    pub duration_seconds: std::option::Option<i32>,
    /// <p>The identification number of the MFA device that is associated with the IAM user who
    /// is making the <code>GetSessionToken</code> call. Specify this value if the IAM user
    /// has a policy that requires MFA authentication. The value is either the serial number for
    /// a hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
    /// for a virtual device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
    /// find the device for an IAM user by going to the AWS Management Console and viewing the user's
    /// security credentials. </p>
    /// <p>The regex used to validate this parameter is a string of
    /// characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    /// You can also include underscores or any of the following characters: =,.@:/-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The value provided by the MFA device, if MFA is required. If any policy requires the
    /// IAM user to submit an MFA code, specify this value. If MFA authentication is required,
    /// the user must provide a code when requesting a set of temporary security credentials. A
    /// user who fails to provide the code receives an "access denied" response when requesting
    /// resources that require MFA authentication.</p>
    /// <p>The format for this parameter, as described by its regex pattern, is a sequence of six
    /// numeric digits.</p>
    pub token_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetSessionTokenInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSessionTokenInput");
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("token_code", &self.token_code);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetFederationTokenInput {
    /// <p>The name of the federated user. The name is used as an identifier for the temporary
    /// security credentials (such as <code>Bob</code>). For example, you can reference the
    /// federated user name in a resource-based policy, such as in an Amazon S3 bucket policy.</p>
    /// <p>The regex used to validate this parameter is a string of characters
    /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    /// also include underscores or any of the following characters: =,.@-</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    /// <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
    /// this operation. You can pass a single JSON policy document to use as an inline session
    /// policy. You can also specify up to 10 managed policies to use as managed session
    /// policies.</p>
    /// <p>This parameter is optional. However, if you do not pass any session policies, then the
    /// resulting federated user session has no permissions.</p>
    /// <p>When you pass session policies, the session permissions are the intersection of the
    /// IAM user policies and the session policies that you pass. This gives you a way to further
    /// restrict the permissions for a federated user. You cannot use session policies to grant
    /// more permissions than those that are defined in the permissions policy of the IAM user.
    /// For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
    /// the <i>IAM User Guide</i>.</p>
    /// <p>The resulting credentials can be used to access a resource that has a resource-based
    /// policy. If that policy specifically references the federated user session in the
    /// <code>Principal</code> element of the policy, the session has the permissions allowed by
    /// the policy. These permissions are granted in addition to the permissions that are granted
    /// by the session policies.</p>
    /// <p>The plaintext that you use for both inline and managed session policies can't exceed
    /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
    /// character to the end of the valid character list (\u0020 through \u00FF). It can also
    /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    /// characters.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as a
    /// managed session policy. The policies must exist in the same account as the IAM user that
    /// is requesting federated access.</p>
    /// <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
    /// this operation. You can pass a single JSON policy document to use as an inline session
    /// policy. You can also specify up to 10 managed policies to use as managed session policies.
    /// The plaintext that you use for both inline and managed session policies can't exceed 2,048
    /// characters. You can provide up to 10 managed policy ARNs. For more information about ARNs,
    /// see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    /// Resource Names (ARNs) and AWS Service Namespaces</a> in the AWS General Reference.</p>
    /// <p>This parameter is optional. However, if you do not pass any session policies, then the
    /// resulting federated user session has no permissions.</p>
    /// <p>When you pass session policies, the session permissions are the intersection of the
    /// IAM user policies and the session policies that you pass. This gives you a way to further
    /// restrict the permissions for a federated user. You cannot use session policies to grant
    /// more permissions than those that are defined in the permissions policy of the IAM user.
    /// For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
    /// the <i>IAM User Guide</i>.</p>
    /// <p>The resulting credentials can be used to access a resource that has a resource-based
    /// policy. If that policy specifically references the federated user session in the
    /// <code>Principal</code> element of the policy, the session has the permissions allowed by
    /// the policy. These permissions are granted in addition to the permissions that are granted
    /// by the session policies.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    pub policy_arns: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
    /// <p>The duration, in seconds, that the session should last. Acceptable durations for
    /// federation sessions range from 900 seconds (15 minutes) to 129,600 seconds (36 hours), with
    /// 43,200 seconds (12 hours) as the default. Sessions obtained using AWS account root user
    /// credentials are restricted to a maximum of 3,600 seconds (one hour). If the specified
    /// duration is longer than one hour, the session obtained by using root user credentials
    /// defaults to one hour.</p>
    pub duration_seconds: std::option::Option<i32>,
    /// <p>A list of session tags. Each session tag consists of a key name and an associated value.
    /// For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
    /// tag keys can’t exceed 128 characters and the values can’t exceed 256 characters. For these
    /// and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    /// and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    /// <p>You can pass a session tag with the same key as a tag that is already
    /// attached to the user you are federating. When you do, session tags override a user tag with
    /// the same key. </p>
    /// <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    /// cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
    /// that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
    /// <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
    /// and <code>department</code> are not saved as separate tags, and the session tag passed in
    /// the request takes precedence over the role tag.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for GetFederationTokenInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetFederationTokenInput");
        formatter.field("name", &self.name);
        formatter.field("policy", &self.policy);
        formatter.field("policy_arns", &self.policy_arns);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCallerIdentityInput {}
impl std::fmt::Debug for GetCallerIdentityInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCallerIdentityInput");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccessKeyInfoInput {
    /// <p>The identifier of an access key.</p>
    /// <p>This parameter allows (through its regex pattern) a string of characters that can
    /// consist of any upper- or lowercase letter or digit.</p>
    pub access_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetAccessKeyInfoInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccessKeyInfoInput");
        formatter.field("access_key_id", &self.access_key_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DecodeAuthorizationMessageInput {
    /// <p>The encoded message that was returned with the response.</p>
    pub encoded_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DecodeAuthorizationMessageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DecodeAuthorizationMessageInput");
        formatter.field("encoded_message", &self.encoded_message);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssumeRoleWithWebIdentityInput {
    /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An identifier for the assumed role session. Typically, you pass the name or identifier
    /// that is associated with the user who is using your application. That way, the temporary
    /// security credentials that your application will use are associated with that user. This
    /// session name is included as part of the ARN and assumed role ID in the
    /// <code>AssumedRoleUser</code> response element.</p>
    /// <p>The regex used to validate this parameter is a string of characters
    /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    /// also include underscores or any of the following characters: =,.@-</p>
    pub role_session_name: std::option::Option<std::string::String>,
    /// <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
    /// provider. Your application must get this token by authenticating the user who is using your
    /// application with a web identity provider before the application makes an
    /// <code>AssumeRoleWithWebIdentity</code> call. </p>
    pub web_identity_token: std::option::Option<std::string::String>,
    /// <p>The fully qualified host component of the domain name of the identity provider.</p>
    /// <p>Specify this value only for OAuth 2.0 access tokens. Currently
    /// <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only supported
    /// identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
    /// numbers.</p>
    /// <p>Do not specify this value for OpenID Connect ID tokens.</p>
    pub provider_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    /// managed session policies. The policies must exist in the same account as the role.</p>
    /// <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    /// plaintext that you use for both inline and managed session policies can't exceed 2,048
    /// characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    /// Service Namespaces</a> in the AWS General Reference.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    /// <p>Passing policies to this operation returns new
    /// temporary credentials. The resulting session's permissions are the intersection of the
    /// role's identity-based policy and the session policies. You can use the role's temporary
    /// credentials in subsequent AWS API calls to access resources in the account that owns
    /// the role. You cannot use session policies to grant more permissions than those allowed
    /// by the identity-based policy of the role that is being assumed. For more information, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    /// Policies</a> in the <i>IAM User Guide</i>.</p>
    pub policy_arns: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    /// <p>This parameter is optional. Passing policies to this operation returns new
    /// temporary credentials. The resulting session's permissions are the intersection of the
    /// role's identity-based policy and the session policies. You can use the role's temporary
    /// credentials in subsequent AWS API calls to access resources in the account that owns
    /// the role. You cannot use session policies to grant more permissions than those allowed
    /// by the identity-based policy of the role that is being assumed. For more information, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    /// Policies</a> in the <i>IAM User Guide</i>.</p>
    /// <p>The plaintext that you use for both inline and managed session policies can't exceed
    /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
    /// character to the end of the valid character list (\u0020 through \u00FF). It can also
    /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    /// characters.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
    /// minutes) up to the maximum session duration setting for the role. This setting can have a
    /// value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    /// operation fails. For example, if you specify a session duration of 12 hours, but your
    /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
    /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    /// Maximum Session Duration Setting for a Role</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>By default, the value is set to <code>3600</code> seconds. </p>
    /// <note>
    /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    /// session that you might request using the returned credentials. The request to the
    /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    /// parameter that specifies the maximum length of the console session. For more
    /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    /// that Enables Federated Users to Access the AWS Management Console</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// </note>
    pub duration_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for AssumeRoleWithWebIdentityInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssumeRoleWithWebIdentityInput");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("role_session_name", &self.role_session_name);
        formatter.field("web_identity_token", &self.web_identity_token);
        formatter.field("provider_id", &self.provider_id);
        formatter.field("policy_arns", &self.policy_arns);
        formatter.field("policy", &self.policy);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssumeRoleWithSamlInput {
    /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the
    /// IdP.</p>
    pub principal_arn: std::option::Option<std::string::String>,
    /// <p>The base64 encoded SAML authentication response provided by the IdP.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/create-role-saml-IdP-tasks.html">Configuring a Relying Party and
    /// Adding Claims</a> in the <i>IAM User Guide</i>. </p>
    pub saml_assertion: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    /// managed session policies. The policies must exist in the same account as the role.</p>
    /// <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    /// plaintext that you use for both inline and managed session policies can't exceed 2,048
    /// characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    /// Service Namespaces</a> in the AWS General Reference.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    /// <p>Passing policies to this operation returns new
    /// temporary credentials. The resulting session's permissions are the intersection of the
    /// role's identity-based policy and the session policies. You can use the role's temporary
    /// credentials in subsequent AWS API calls to access resources in the account that owns
    /// the role. You cannot use session policies to grant more permissions than those allowed
    /// by the identity-based policy of the role that is being assumed. For more information, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    /// Policies</a> in the <i>IAM User Guide</i>.</p>
    pub policy_arns: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    /// <p>This parameter is optional. Passing policies to this operation returns new
    /// temporary credentials. The resulting session's permissions are the intersection of the
    /// role's identity-based policy and the session policies. You can use the role's temporary
    /// credentials in subsequent AWS API calls to access resources in the account that owns
    /// the role. You cannot use session policies to grant more permissions than those allowed
    /// by the identity-based policy of the role that is being assumed. For more information, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    /// Policies</a> in the <i>IAM User Guide</i>. </p>
    /// <p>The plaintext that you use for both inline and managed session policies can't exceed
    /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
    /// character to the end of the valid character list (\u0020 through \u00FF). It can also
    /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    /// characters.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The duration, in seconds, of the role session. Your role session lasts for the duration
    /// that you specify for the <code>DurationSeconds</code> parameter, or until the time
    /// specified in the SAML authentication response's <code>SessionNotOnOrAfter</code> value,
    /// whichever is shorter. You can provide a <code>DurationSeconds</code> value from 900 seconds
    /// (15 minutes) up to the maximum session duration setting for the role. This setting can have
    /// a value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    /// operation fails. For example, if you specify a session duration of 12 hours, but your
    /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
    /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    /// Maximum Session Duration Setting for a Role</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>By default, the value is set to <code>3600</code> seconds. </p>
    /// <note>
    /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    /// session that you might request using the returned credentials. The request to the
    /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    /// parameter that specifies the maximum length of the console session. For more
    /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    /// that Enables Federated Users to Access the AWS Management Console</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// </note>
    pub duration_seconds: std::option::Option<i32>,
}
impl std::fmt::Debug for AssumeRoleWithSamlInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssumeRoleWithSamlInput");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("principal_arn", &self.principal_arn);
        formatter.field("saml_assertion", &self.saml_assertion);
        formatter.field("policy_arns", &self.policy_arns);
        formatter.field("policy", &self.policy);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssumeRoleInput {
    /// <p>The Amazon Resource Name (ARN) of the role to assume.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An identifier for the assumed role session.</p>
    /// <p>Use the role session name to uniquely identify a session when the same role is assumed
    /// by different principals or for different reasons. In cross-account scenarios, the role
    /// session name is visible to, and can be logged by the account that owns the role. The role
    /// session name is also used in the ARN of the assumed role principal. This means that
    /// subsequent cross-account API requests that use the temporary security credentials will
    /// expose the role session name to the external account in their AWS CloudTrail logs.</p>
    /// <p>The regex used to validate this parameter is a string of characters
    /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    /// also include underscores or any of the following characters: =,.@-</p>
    pub role_session_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    /// managed session policies. The policies must exist in the same account as the role.</p>
    /// <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    /// plaintext that you use for both inline and managed session policies can't exceed 2,048
    /// characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    /// Service Namespaces</a> in the AWS General Reference.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    /// <p>Passing policies to this operation returns new
    /// temporary credentials. The resulting session's permissions are the intersection of the
    /// role's identity-based policy and the session policies. You can use the role's temporary
    /// credentials in subsequent AWS API calls to access resources in the account that owns
    /// the role. You cannot use session policies to grant more permissions than those allowed
    /// by the identity-based policy of the role that is being assumed. For more information, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    /// Policies</a> in the <i>IAM User Guide</i>.</p>
    pub policy_arns: std::option::Option<std::vec::Vec<crate::model::PolicyDescriptorType>>,
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    /// <p>This parameter is optional. Passing policies to this operation returns new
    /// temporary credentials. The resulting session's permissions are the intersection of the
    /// role's identity-based policy and the session policies. You can use the role's temporary
    /// credentials in subsequent AWS API calls to access resources in the account that owns
    /// the role. You cannot use session policies to grant more permissions than those allowed
    /// by the identity-based policy of the role that is being assumed. For more information, see
    /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    /// Policies</a> in the <i>IAM User Guide</i>.</p>
    /// <p>The plaintext that you use for both inline and managed session policies can't exceed
    /// 2,048 characters. The JSON policy characters can be any ASCII character from the space
    /// character to the end of the valid character list (\u0020 through \u00FF). It can also
    /// include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    /// characters.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    pub policy: std::option::Option<std::string::String>,
    /// <p>The duration, in seconds, of the role session. The value specified can can range from
    /// 900 seconds (15 minutes) up to the maximum session duration that is set for the role. The
    /// maximum session duration setting can have a value from 1 hour to 12 hours. If you specify a
    /// value higher than this setting or the administrator setting (whichever is lower), the
    /// operation fails. For example, if you specify a session duration of 12 hours, but your
    /// administrator set the maximum session duration to 6 hours, your operation fails. To learn
    /// how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    /// Maximum Session Duration Setting for a Role</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>By default, the value is set to <code>3600</code> seconds. </p>
    /// <note>
    /// <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    /// session that you might request using the returned credentials. The request to the
    /// federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    /// parameter that specifies the maximum length of the console session. For more
    /// information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    /// that Enables Federated Users to Access the AWS Management Console</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// </note>
    pub duration_seconds: std::option::Option<i32>,
    /// <p>A list of session tags that you want to pass. Each session tag consists of a key name
    /// and an associated value. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging AWS STS
    /// Sessions</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
    /// tag keys can’t exceed 128 characters, and the values can’t exceed 256 characters. For these
    /// and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    /// and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    /// <note>
    /// <p>An AWS conversion compresses the passed session policies and session tags into a
    /// packed binary format that has a separate limit. Your request can fail for this limit
    /// even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    /// response element indicates by percentage how close the policies and tags for your
    /// request are to the upper size limit.
    /// </p>
    /// </note>
    /// <p>You can pass a session tag with the same key as a tag that is already
    /// attached to the role. When you do, session tags override a role tag with the same key. </p>
    /// <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    /// cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
    /// that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
    /// <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
    /// and <code>department</code> are not saved as separate tags, and the session tag passed in
    /// the request takes precedence over the role tag.</p>
    /// <p>Additionally, if you used temporary credentials to perform this operation, the new
    /// session inherits any transitive session tags from the calling session. If you pass a
    /// session tag with the same key as an inherited tag, the operation fails. To view the
    /// inherited tags for a session, see the AWS CloudTrail logs. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/session-tags.html#id_session-tags_ctlogs">Viewing Session Tags in CloudTrail</a> in the
    /// <i>IAM User Guide</i>.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A list of keys for session tags that you want to set as transitive. If you set a tag key
    /// as transitive, the corresponding key and value passes to subsequent sessions in a role
    /// chain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
    /// with Session Tags</a> in the <i>IAM User Guide</i>.</p>
    /// <p>This parameter is optional. When you set session tags as transitive, the session policy
    /// and session tags packed binary limit is not affected.</p>
    /// <p>If you choose not to specify a transitive tag key, then no tags are passed from this
    /// session to any subsequent sessions.</p>
    pub transitive_tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A unique identifier that might be required when you assume a role in another account. If
    /// the administrator of the account to which the role belongs provided you with an external
    /// ID, then provide that value in the <code>ExternalId</code> parameter. This value can be any
    /// string, such as a passphrase or account number. A cross-account role is usually set up to
    /// trust everyone in an account. Therefore, the administrator of the trusting account might
    /// send an external ID to the administrator of the trusted account. That way, only someone
    /// with the ID can assume the role, rather than everyone in the account. For more information
    /// about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
    /// When Granting Access to Your AWS Resources to a Third Party</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>The regex used to validate this parameter is a string of
    /// characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    /// You can also include underscores or any of the following characters: =,.@:/-</p>
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The identification number of the MFA device that is associated with the user who is
    /// making the <code>AssumeRole</code> call. Specify this value if the trust policy of the role
    /// being assumed includes a condition that requires MFA authentication. The value is either
    /// the serial number for a hardware device (such as <code>GAHT12345678</code>) or an Amazon
    /// Resource Name (ARN) for a virtual device (such as
    /// <code>arn:aws:iam::123456789012:mfa/user</code>).</p>
    /// <p>The regex used to validate this parameter is a string of characters
    /// consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    /// also include underscores or any of the following characters: =,.@-</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The value provided by the MFA device, if the trust policy of the role being assumed
    /// requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
    /// the role being assumed requires MFA and if the <code>TokenCode</code> value is missing or
    /// expired, the <code>AssumeRole</code> call returns an "access denied" error.</p>
    /// <p>The format for this parameter, as described by its regex pattern, is a sequence of six
    /// numeric digits.</p>
    pub token_code: std::option::Option<std::string::String>,
    /// <p>The source identity specified by the principal that is calling the
    /// <code>AssumeRole</code> operation.</p>
    /// <p>You can require users to specify a source identity when they assume a role. You do this
    /// by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
    /// use source identity information in AWS CloudTrail logs to determine who took actions with a role.
    /// You can use the <code>aws:SourceIdentity</code> condition key to further control access to
    /// AWS resources based on the value of source identity. For more information about using
    /// source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    /// actions taken with assumed roles</a> in the
    /// <i>IAM User Guide</i>.</p>
    /// <p>The regex used to validate this parameter is a string of characters consisting of upper-
    /// and lower-case alphanumeric characters with no spaces. You can also include underscores or
    /// any of the following characters: =,.@-. You cannot use a value that begins with the text
    /// <code>aws:</code>. This prefix is reserved for AWS internal
    /// use.</p>
    pub source_identity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AssumeRoleInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssumeRoleInput");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("role_session_name", &self.role_session_name);
        formatter.field("policy_arns", &self.policy_arns);
        formatter.field("policy", &self.policy);
        formatter.field("duration_seconds", &self.duration_seconds);
        formatter.field("tags", &self.tags);
        formatter.field("transitive_tag_keys", &self.transitive_tag_keys);
        formatter.field("external_id", &self.external_id);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("token_code", &self.token_code);
        formatter.field("source_identity", &self.source_identity);
        formatter.finish()
    }
}
