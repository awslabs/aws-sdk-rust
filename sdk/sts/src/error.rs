// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssumeRoleError {
    pub kind: AssumeRoleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssumeRoleErrorKind {
    ExpiredTokenError(crate::error::ExpiredTokenError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PackedPolicyTooLargeError(crate::error::PackedPolicyTooLargeError),
    RegionDisabledError(crate::error::RegionDisabledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssumeRoleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssumeRoleErrorKind::ExpiredTokenError(_inner) => _inner.fmt(f),
            AssumeRoleErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            AssumeRoleErrorKind::PackedPolicyTooLargeError(_inner) => _inner.fmt(f),
            AssumeRoleErrorKind::RegionDisabledError(_inner) => _inner.fmt(f),
            AssumeRoleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssumeRoleError {
    fn code(&self) -> Option<&str> {
        AssumeRoleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssumeRoleError {
    pub fn new(kind: AssumeRoleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssumeRoleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssumeRoleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_expired_token_error(&self) -> bool {
        matches!(&self.kind, AssumeRoleErrorKind::ExpiredTokenError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_packed_policy_too_large_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleErrorKind::PackedPolicyTooLargeError(_)
        )
    }
    pub fn is_region_disabled_error(&self) -> bool {
        matches!(&self.kind, AssumeRoleErrorKind::RegionDisabledError(_))
    }
}
impl std::error::Error for AssumeRoleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssumeRoleErrorKind::ExpiredTokenError(_inner) => Some(_inner),
            AssumeRoleErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            AssumeRoleErrorKind::PackedPolicyTooLargeError(_inner) => Some(_inner),
            AssumeRoleErrorKind::RegionDisabledError(_inner) => Some(_inner),
            AssumeRoleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssumeRoleWithSAMLError {
    pub kind: AssumeRoleWithSAMLErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssumeRoleWithSAMLErrorKind {
    ExpiredTokenError(crate::error::ExpiredTokenError),
    IDPRejectedClaimError(crate::error::IDPRejectedClaimError),
    InvalidIdentityTokenError(crate::error::InvalidIdentityTokenError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PackedPolicyTooLargeError(crate::error::PackedPolicyTooLargeError),
    RegionDisabledError(crate::error::RegionDisabledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssumeRoleWithSAMLError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssumeRoleWithSAMLErrorKind::ExpiredTokenError(_inner) => _inner.fmt(f),
            AssumeRoleWithSAMLErrorKind::IDPRejectedClaimError(_inner) => _inner.fmt(f),
            AssumeRoleWithSAMLErrorKind::InvalidIdentityTokenError(_inner) => _inner.fmt(f),
            AssumeRoleWithSAMLErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            AssumeRoleWithSAMLErrorKind::PackedPolicyTooLargeError(_inner) => _inner.fmt(f),
            AssumeRoleWithSAMLErrorKind::RegionDisabledError(_inner) => _inner.fmt(f),
            AssumeRoleWithSAMLErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssumeRoleWithSAMLError {
    fn code(&self) -> Option<&str> {
        AssumeRoleWithSAMLError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssumeRoleWithSAMLError {
    pub fn new(kind: AssumeRoleWithSAMLErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssumeRoleWithSAMLErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssumeRoleWithSAMLErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_expired_token_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithSAMLErrorKind::ExpiredTokenError(_)
        )
    }
    pub fn is_idp_rejected_claim_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithSAMLErrorKind::IDPRejectedClaimError(_)
        )
    }
    pub fn is_invalid_identity_token_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithSAMLErrorKind::InvalidIdentityTokenError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithSAMLErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_packed_policy_too_large_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithSAMLErrorKind::PackedPolicyTooLargeError(_)
        )
    }
    pub fn is_region_disabled_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithSAMLErrorKind::RegionDisabledError(_)
        )
    }
}
impl std::error::Error for AssumeRoleWithSAMLError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssumeRoleWithSAMLErrorKind::ExpiredTokenError(_inner) => Some(_inner),
            AssumeRoleWithSAMLErrorKind::IDPRejectedClaimError(_inner) => Some(_inner),
            AssumeRoleWithSAMLErrorKind::InvalidIdentityTokenError(_inner) => Some(_inner),
            AssumeRoleWithSAMLErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            AssumeRoleWithSAMLErrorKind::PackedPolicyTooLargeError(_inner) => Some(_inner),
            AssumeRoleWithSAMLErrorKind::RegionDisabledError(_inner) => Some(_inner),
            AssumeRoleWithSAMLErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssumeRoleWithWebIdentityError {
    pub kind: AssumeRoleWithWebIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssumeRoleWithWebIdentityErrorKind {
    ExpiredTokenError(crate::error::ExpiredTokenError),
    IDPCommunicationErrorError(crate::error::IDPCommunicationErrorError),
    IDPRejectedClaimError(crate::error::IDPRejectedClaimError),
    InvalidIdentityTokenError(crate::error::InvalidIdentityTokenError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PackedPolicyTooLargeError(crate::error::PackedPolicyTooLargeError),
    RegionDisabledError(crate::error::RegionDisabledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssumeRoleWithWebIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssumeRoleWithWebIdentityErrorKind::ExpiredTokenError(_inner) => _inner.fmt(f),
            AssumeRoleWithWebIdentityErrorKind::IDPCommunicationErrorError(_inner) => _inner.fmt(f),
            AssumeRoleWithWebIdentityErrorKind::IDPRejectedClaimError(_inner) => _inner.fmt(f),
            AssumeRoleWithWebIdentityErrorKind::InvalidIdentityTokenError(_inner) => _inner.fmt(f),
            AssumeRoleWithWebIdentityErrorKind::MalformedPolicyDocumentError(_inner) => {
                _inner.fmt(f)
            }
            AssumeRoleWithWebIdentityErrorKind::PackedPolicyTooLargeError(_inner) => _inner.fmt(f),
            AssumeRoleWithWebIdentityErrorKind::RegionDisabledError(_inner) => _inner.fmt(f),
            AssumeRoleWithWebIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssumeRoleWithWebIdentityError {
    fn code(&self) -> Option<&str> {
        AssumeRoleWithWebIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssumeRoleWithWebIdentityError {
    pub fn new(kind: AssumeRoleWithWebIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssumeRoleWithWebIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssumeRoleWithWebIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_expired_token_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::ExpiredTokenError(_)
        )
    }
    pub fn is_idp_communication_error_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::IDPCommunicationErrorError(_)
        )
    }
    pub fn is_idp_rejected_claim_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::IDPRejectedClaimError(_)
        )
    }
    pub fn is_invalid_identity_token_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::InvalidIdentityTokenError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_packed_policy_too_large_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::PackedPolicyTooLargeError(_)
        )
    }
    pub fn is_region_disabled_error(&self) -> bool {
        matches!(
            &self.kind,
            AssumeRoleWithWebIdentityErrorKind::RegionDisabledError(_)
        )
    }
}
impl std::error::Error for AssumeRoleWithWebIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssumeRoleWithWebIdentityErrorKind::ExpiredTokenError(_inner) => Some(_inner),
            AssumeRoleWithWebIdentityErrorKind::IDPCommunicationErrorError(_inner) => Some(_inner),
            AssumeRoleWithWebIdentityErrorKind::IDPRejectedClaimError(_inner) => Some(_inner),
            AssumeRoleWithWebIdentityErrorKind::InvalidIdentityTokenError(_inner) => Some(_inner),
            AssumeRoleWithWebIdentityErrorKind::MalformedPolicyDocumentError(_inner) => {
                Some(_inner)
            }
            AssumeRoleWithWebIdentityErrorKind::PackedPolicyTooLargeError(_inner) => Some(_inner),
            AssumeRoleWithWebIdentityErrorKind::RegionDisabledError(_inner) => Some(_inner),
            AssumeRoleWithWebIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DecodeAuthorizationMessageError {
    pub kind: DecodeAuthorizationMessageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DecodeAuthorizationMessageErrorKind {
    InvalidAuthorizationMessageError(crate::error::InvalidAuthorizationMessageError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DecodeAuthorizationMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DecodeAuthorizationMessageErrorKind::InvalidAuthorizationMessageError(_inner) => {
                _inner.fmt(f)
            }
            DecodeAuthorizationMessageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DecodeAuthorizationMessageError {
    fn code(&self) -> Option<&str> {
        DecodeAuthorizationMessageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DecodeAuthorizationMessageError {
    pub fn new(kind: DecodeAuthorizationMessageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DecodeAuthorizationMessageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DecodeAuthorizationMessageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_authorization_message_error(&self) -> bool {
        matches!(
            &self.kind,
            DecodeAuthorizationMessageErrorKind::InvalidAuthorizationMessageError(_)
        )
    }
}
impl std::error::Error for DecodeAuthorizationMessageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DecodeAuthorizationMessageErrorKind::InvalidAuthorizationMessageError(_inner) => {
                Some(_inner)
            }
            DecodeAuthorizationMessageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccessKeyInfoError {
    pub kind: GetAccessKeyInfoErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccessKeyInfoErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccessKeyInfoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccessKeyInfoErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccessKeyInfoError {
    fn code(&self) -> Option<&str> {
        GetAccessKeyInfoError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccessKeyInfoError {
    pub fn new(kind: GetAccessKeyInfoErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccessKeyInfoErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccessKeyInfoErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetAccessKeyInfoError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccessKeyInfoErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCallerIdentityError {
    pub kind: GetCallerIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCallerIdentityErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCallerIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCallerIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCallerIdentityError {
    fn code(&self) -> Option<&str> {
        GetCallerIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCallerIdentityError {
    pub fn new(kind: GetCallerIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCallerIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCallerIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for GetCallerIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCallerIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFederationTokenError {
    pub kind: GetFederationTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFederationTokenErrorKind {
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PackedPolicyTooLargeError(crate::error::PackedPolicyTooLargeError),
    RegionDisabledError(crate::error::RegionDisabledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFederationTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFederationTokenErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::PackedPolicyTooLargeError(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::RegionDisabledError(_inner) => _inner.fmt(f),
            GetFederationTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFederationTokenError {
    fn code(&self) -> Option<&str> {
        GetFederationTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFederationTokenError {
    pub fn new(kind: GetFederationTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFederationTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFederationTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_packed_policy_too_large_error(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::PackedPolicyTooLargeError(_)
        )
    }
    pub fn is_region_disabled_error(&self) -> bool {
        matches!(
            &self.kind,
            GetFederationTokenErrorKind::RegionDisabledError(_)
        )
    }
}
impl std::error::Error for GetFederationTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFederationTokenErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            GetFederationTokenErrorKind::PackedPolicyTooLargeError(_inner) => Some(_inner),
            GetFederationTokenErrorKind::RegionDisabledError(_inner) => Some(_inner),
            GetFederationTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSessionTokenError {
    pub kind: GetSessionTokenErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSessionTokenErrorKind {
    RegionDisabledError(crate::error::RegionDisabledError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSessionTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSessionTokenErrorKind::RegionDisabledError(_inner) => _inner.fmt(f),
            GetSessionTokenErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSessionTokenError {
    fn code(&self) -> Option<&str> {
        GetSessionTokenError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSessionTokenError {
    pub fn new(kind: GetSessionTokenErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSessionTokenErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSessionTokenErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_region_disabled_error(&self) -> bool {
        matches!(&self.kind, GetSessionTokenErrorKind::RegionDisabledError(_))
    }
}
impl std::error::Error for GetSessionTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSessionTokenErrorKind::RegionDisabledError(_inner) => Some(_inner),
            GetSessionTokenErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>STS is not activated in the requested region for the account that is being asked to
/// generate credentials. The account administrator must use the IAM console to activate STS
/// in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
/// Deactivating AWS STS in an AWS Region</a> in the <i>IAM User
/// Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegionDisabledError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RegionDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegionDisabledError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RegionDisabledError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RegionDisabledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RegionDisabledError [RegionDisabledException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for RegionDisabledError {}
/// See [`RegionDisabledError`](crate::error::RegionDisabledError)
pub mod region_disabled_error {
    /// A builder for [`RegionDisabledError`](crate::error::RegionDisabledError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RegionDisabledError`](crate::error::RegionDisabledError)
        pub fn build(self) -> crate::error::RegionDisabledError {
            crate::error::RegionDisabledError {
                message: self.message,
            }
        }
    }
}
impl RegionDisabledError {
    /// Creates a new builder-style object to manufacture [`RegionDisabledError`](crate::error::RegionDisabledError)
    pub fn builder() -> crate::error::region_disabled_error::Builder {
        crate::error::region_disabled_error::Builder::default()
    }
}

/// <p>The request was rejected because the total packed size of the session policies and
/// session tags combined was too large. An AWS conversion compresses the session policy
/// document, session policy ARNs, and session tags into a packed binary format that has a
/// separate limit. The error message indicates by percentage how close the policies and
/// tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in
/// the <i>IAM User Guide</i>.</p>
/// <p>You could receive this error even though you meet other defined session policy and
/// session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">IAM and STS Entity
/// Character Limits</a> in the <i>IAM User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PackedPolicyTooLargeError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PackedPolicyTooLargeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PackedPolicyTooLargeError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PackedPolicyTooLargeError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PackedPolicyTooLargeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "PackedPolicyTooLargeError [PackedPolicyTooLargeException]"
        )?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for PackedPolicyTooLargeError {}
/// See [`PackedPolicyTooLargeError`](crate::error::PackedPolicyTooLargeError)
pub mod packed_policy_too_large_error {
    /// A builder for [`PackedPolicyTooLargeError`](crate::error::PackedPolicyTooLargeError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PackedPolicyTooLargeError`](crate::error::PackedPolicyTooLargeError)
        pub fn build(self) -> crate::error::PackedPolicyTooLargeError {
            crate::error::PackedPolicyTooLargeError {
                message: self.message,
            }
        }
    }
}
impl PackedPolicyTooLargeError {
    /// Creates a new builder-style object to manufacture [`PackedPolicyTooLargeError`](crate::error::PackedPolicyTooLargeError)
    pub fn builder() -> crate::error::packed_policy_too_large_error::Builder {
        crate::error::packed_policy_too_large_error::Builder::default()
    }
}

/// <p>The request was rejected because the policy document was malformed. The error message
/// describes the specific error.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MalformedPolicyDocumentError [MalformedPolicyDocumentException]"
        )?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentError {}
/// See [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
pub mod malformed_policy_document_error {
    /// A builder for [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentError {
            crate::error::MalformedPolicyDocumentError {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentError {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    pub fn builder() -> crate::error::malformed_policy_document_error::Builder {
        crate::error::malformed_policy_document_error::Builder::default()
    }
}

/// <p>The error returned if the message passed to <code>DecodeAuthorizationMessage</code>
/// was invalid. This can happen if the token contains invalid characters, such as
/// linebreaks. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAuthorizationMessageError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAuthorizationMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAuthorizationMessageError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAuthorizationMessageError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthorizationMessageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidAuthorizationMessageError [InvalidAuthorizationMessageException]"
        )?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthorizationMessageError {}
/// See [`InvalidAuthorizationMessageError`](crate::error::InvalidAuthorizationMessageError)
pub mod invalid_authorization_message_error {
    /// A builder for [`InvalidAuthorizationMessageError`](crate::error::InvalidAuthorizationMessageError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthorizationMessageError`](crate::error::InvalidAuthorizationMessageError)
        pub fn build(self) -> crate::error::InvalidAuthorizationMessageError {
            crate::error::InvalidAuthorizationMessageError {
                message: self.message,
            }
        }
    }
}
impl InvalidAuthorizationMessageError {
    /// Creates a new builder-style object to manufacture [`InvalidAuthorizationMessageError`](crate::error::InvalidAuthorizationMessageError)
    pub fn builder() -> crate::error::invalid_authorization_message_error::Builder {
        crate::error::invalid_authorization_message_error::Builder::default()
    }
}

/// <p>The web identity token that was passed could not be validated by AWS. Get a new
/// identity token from the identity provider and then retry the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidIdentityTokenError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidIdentityTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidIdentityTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidIdentityTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidIdentityTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidIdentityTokenError [InvalidIdentityTokenException]"
        )?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidIdentityTokenError {}
/// See [`InvalidIdentityTokenError`](crate::error::InvalidIdentityTokenError)
pub mod invalid_identity_token_error {
    /// A builder for [`InvalidIdentityTokenError`](crate::error::InvalidIdentityTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidIdentityTokenError`](crate::error::InvalidIdentityTokenError)
        pub fn build(self) -> crate::error::InvalidIdentityTokenError {
            crate::error::InvalidIdentityTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidIdentityTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidIdentityTokenError`](crate::error::InvalidIdentityTokenError)
    pub fn builder() -> crate::error::invalid_identity_token_error::Builder {
        crate::error::invalid_identity_token_error::Builder::default()
    }
}

/// <p>The identity provider (IdP) reported that authentication failed. This might be because
/// the claim is invalid.</p>
/// <p>If this error is returned for the <code>AssumeRoleWithWebIdentity</code> operation, it
/// can also mean that the claim has expired or has been explicitly revoked. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IDPRejectedClaimError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IDPRejectedClaimError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IDPRejectedClaimError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IDPRejectedClaimError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IDPRejectedClaimError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IDPRejectedClaimError [IDPRejectedClaimException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for IDPRejectedClaimError {}
/// See [`IDPRejectedClaimError`](crate::error::IDPRejectedClaimError)
pub mod idp_rejected_claim_error {
    /// A builder for [`IDPRejectedClaimError`](crate::error::IDPRejectedClaimError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IDPRejectedClaimError`](crate::error::IDPRejectedClaimError)
        pub fn build(self) -> crate::error::IDPRejectedClaimError {
            crate::error::IDPRejectedClaimError {
                message: self.message,
            }
        }
    }
}
impl IDPRejectedClaimError {
    /// Creates a new builder-style object to manufacture [`IDPRejectedClaimError`](crate::error::IDPRejectedClaimError)
    pub fn builder() -> crate::error::idp_rejected_claim_error::Builder {
        crate::error::idp_rejected_claim_error::Builder::default()
    }
}

/// <p>The request could not be fulfilled because the identity provider (IDP) that
/// was asked to verify the incoming identity token could not be reached. This is often a
/// transient error caused by network conditions. Retry the request a limited number of
/// times so that you don't exceed the request rate. If the error persists, the
/// identity provider might be down or not responding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IDPCommunicationErrorError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IDPCommunicationErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IDPCommunicationErrorError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IDPCommunicationErrorError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IDPCommunicationErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "IDPCommunicationErrorError [IDPCommunicationErrorException]"
        )?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for IDPCommunicationErrorError {}
/// See [`IDPCommunicationErrorError`](crate::error::IDPCommunicationErrorError)
pub mod idp_communication_error_error {
    /// A builder for [`IDPCommunicationErrorError`](crate::error::IDPCommunicationErrorError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IDPCommunicationErrorError`](crate::error::IDPCommunicationErrorError)
        pub fn build(self) -> crate::error::IDPCommunicationErrorError {
            crate::error::IDPCommunicationErrorError {
                message: self.message,
            }
        }
    }
}
impl IDPCommunicationErrorError {
    /// Creates a new builder-style object to manufacture [`IDPCommunicationErrorError`](crate::error::IDPCommunicationErrorError)
    pub fn builder() -> crate::error::idp_communication_error_error::Builder {
        crate::error::idp_communication_error_error::Builder::default()
    }
}

/// <p>The web identity token that was passed is expired or is not valid. Get a new identity
/// token from the identity provider and then retry the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExpiredTokenError {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExpiredTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExpiredTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ExpiredTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ExpiredTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExpiredTokenError [ExpiredTokenException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ExpiredTokenError {}
/// See [`ExpiredTokenError`](crate::error::ExpiredTokenError)
pub mod expired_token_error {
    /// A builder for [`ExpiredTokenError`](crate::error::ExpiredTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ExpiredTokenError`](crate::error::ExpiredTokenError)
        pub fn build(self) -> crate::error::ExpiredTokenError {
            crate::error::ExpiredTokenError {
                message: self.message,
            }
        }
    }
}
impl ExpiredTokenError {
    /// Creates a new builder-style object to manufacture [`ExpiredTokenError`](crate::error::ExpiredTokenError)
    pub fn builder() -> crate::error::expired_token_error::Builder {
        crate::error::expired_token_error::Builder::default()
    }
}
