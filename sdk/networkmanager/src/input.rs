// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl AcceptAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`AcceptAttachment`](crate::operation::AcceptAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AcceptAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AcceptAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.attachment_id;
                let input_1 = input_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_1,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/attachments/{AttachmentId}/accept",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AcceptAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AcceptAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AcceptAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`AssociateConnectPeer`](crate::operation::AssociateConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.global_network_id;
                let input_2 = input_2.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_2,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connect-peer-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_connect_peer(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateCustomerGatewayInput {
    /// Consumes the builder and constructs an Operation<[`AssociateCustomerGateway`](crate::operation::AssociateCustomerGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateCustomerGateway,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateCustomerGatewayInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_3 = &_input.global_network_id;
                let input_3 = input_3.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_3,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/customer-gateway-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateCustomerGatewayInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_customer_gateway(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateCustomerGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateCustomerGateway",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateLinkInput {
    /// Consumes the builder and constructs an Operation<[`AssociateLink`](crate::operation::AssociateLink)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateLink,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateLinkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.global_network_id;
                let input_4 = input_4.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_4,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/link-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateLinkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_link(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateLink",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl AssociateTransitGatewayConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`AssociateTransitGatewayConnectPeer`](crate::operation::AssociateTransitGatewayConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateTransitGatewayConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::AssociateTransitGatewayConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.global_network_id;
                let input_5 = input_5.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_5,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/transit-gateway-connect-peer-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::AssociateTransitGatewayConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_associate_transit_gateway_connect_peer(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateTransitGatewayConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateTransitGatewayConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateConnectAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnectAttachment`](crate::operation::CreateConnectAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateConnectAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateConnectAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/connect-attachments").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateConnectAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_connect_attachment(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateConnectAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateConnectAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateConnectionInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnection`](crate::operation::CreateConnection)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateConnection,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateConnectionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.global_network_id;
                let input_6 = input_6.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_6,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connections",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateConnectionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_connection(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateConnection",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnectPeer`](crate::operation::CreateConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/connect-peers").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_connect_peer(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`CreateCoreNetwork`](crate::operation::CreateCoreNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCoreNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateCoreNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/core-networks").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateCoreNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_core_network(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateDeviceInput {
    /// Consumes the builder and constructs an Operation<[`CreateDevice`](crate::operation::CreateDevice)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDevice,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDeviceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.global_network_id;
                let input_7 = input_7.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_7,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/devices",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDeviceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_device(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDevice::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDevice",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateGlobalNetworkInput {
    /// Consumes the builder and constructs an Operation<[`CreateGlobalNetwork`](crate::operation::CreateGlobalNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateGlobalNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateGlobalNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/global-networks").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateGlobalNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_global_network(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateGlobalNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateGlobalNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateLinkInput {
    /// Consumes the builder and constructs an Operation<[`CreateLink`](crate::operation::CreateLink)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLink,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateLinkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_8 = &_input.global_network_id;
                let input_8 = input_8.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_8,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/links",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateLinkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_link(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLink",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateSiteInput {
    /// Consumes the builder and constructs an Operation<[`CreateSite`](crate::operation::CreateSite)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSite,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSiteInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.global_network_id;
                let input_9 = input_9.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_9,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/sites",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSiteInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_site(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSite::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSite",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateSiteToSiteVpnAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateSiteToSiteVpnAttachment`](crate::operation::CreateSiteToSiteVpnAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSiteToSiteVpnAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateSiteToSiteVpnAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/site-to-site-vpn-attachments").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateSiteToSiteVpnAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_site_to_site_vpn_attachment(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSiteToSiteVpnAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSiteToSiteVpnAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateTransitGatewayPeeringInput {
    /// Consumes the builder and constructs an Operation<[`CreateTransitGatewayPeering`](crate::operation::CreateTransitGatewayPeering)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTransitGatewayPeering,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTransitGatewayPeeringInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/transit-gateway-peerings").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTransitGatewayPeeringInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_transit_gateway_peering(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTransitGatewayPeering::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTransitGatewayPeering",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateTransitGatewayRouteTableAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateTransitGatewayRouteTableAttachment`](crate::operation::CreateTransitGatewayRouteTableAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTransitGatewayRouteTableAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTransitGatewayRouteTableAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/transit-gateway-route-table-attachments")
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTransitGatewayRouteTableAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_transit_gateway_route_table_attachment(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTransitGatewayRouteTableAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTransitGatewayRouteTableAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateVpcAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateVpcAttachment`](crate::operation::CreateVpcAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVpcAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateVpcAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/vpc-attachments").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateVpcAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_vpc_attachment(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVpcAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVpcAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAttachment`](crate::operation::DeleteAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.attachment_id;
                let input_10 = input_10.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_10,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/attachments/{AttachmentId}",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteConnectionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteConnection`](crate::operation::DeleteConnection)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteConnection,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteConnectionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_11 = &_input.global_network_id;
                let input_11 = input_11.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_11,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_12 = &_input.connection_id;
                let input_12 = input_12.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "connection_id",
                        "cannot be empty or unset",
                    )
                })?;
                let connection_id = aws_smithy_http::label::fmt_string(
                    input_12,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if connection_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "connection_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connections/{ConnectionId}",
                    GlobalNetworkId = global_network_id,
                    ConnectionId = connection_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteConnectionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteConnection",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`DeleteConnectPeer`](crate::operation::DeleteConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.connect_peer_id;
                let input_13 = input_13.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "connect_peer_id",
                        "cannot be empty or unset",
                    )
                })?;
                let connect_peer_id = aws_smithy_http::label::fmt_string(
                    input_13,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if connect_peer_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "connect_peer_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/connect-peers/{ConnectPeerId}",
                    ConnectPeerId = connect_peer_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCoreNetwork`](crate::operation::DeleteCoreNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCoreNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCoreNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.core_network_id;
                let input_14 = input_14.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_14,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}",
                    CoreNetworkId = core_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCoreNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteCoreNetworkPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCoreNetworkPolicyVersion`](crate::operation::DeleteCoreNetworkPolicyVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCoreNetworkPolicyVersion,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteCoreNetworkPolicyVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_15 = &_input.core_network_id;
                let input_15 = input_15.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_15,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_16 = &_input.policy_version_id;
                let input_16 = input_16.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "policy_version_id",
                        "cannot be empty or unset",
                    )
                })?;
                let mut policy_version_id_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_16);
                let policy_version_id = policy_version_id_encoder.encode();
                if policy_version_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "policy_version_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}/core-network-policy-versions/{PolicyVersionId}",
                    CoreNetworkId = core_network_id,
                    PolicyVersionId = policy_version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteCoreNetworkPolicyVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCoreNetworkPolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCoreNetworkPolicyVersion",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteDeviceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDevice`](crate::operation::DeleteDevice)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDevice,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteDeviceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_17 = &_input.global_network_id;
                let input_17 = input_17.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_17,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_18 = &_input.device_id;
                let input_18 = input_18.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "device_id",
                        "cannot be empty or unset",
                    )
                })?;
                let device_id = aws_smithy_http::label::fmt_string(
                    input_18,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if device_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "device_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/devices/{DeviceId}",
                    GlobalNetworkId = global_network_id,
                    DeviceId = device_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteDeviceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDevice::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDevice",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteGlobalNetworkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteGlobalNetwork`](crate::operation::DeleteGlobalNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteGlobalNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteGlobalNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_19 = &_input.global_network_id;
                let input_19 = input_19.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_19,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteGlobalNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteGlobalNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteGlobalNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteLinkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLink`](crate::operation::DeleteLink)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLink,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteLinkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_20 = &_input.global_network_id;
                let input_20 = input_20.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_20,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_21 = &_input.link_id;
                let input_21 = input_21.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "link_id",
                        "cannot be empty or unset",
                    )
                })?;
                let link_id = aws_smithy_http::label::fmt_string(
                    input_21,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if link_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "link_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/links/{LinkId}",
                    GlobalNetworkId = global_network_id,
                    LinkId = link_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteLinkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLink",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeletePeeringInput {
    /// Consumes the builder and constructs an Operation<[`DeletePeering`](crate::operation::DeletePeering)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeletePeering,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeletePeeringInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_22 = &_input.peering_id;
                let input_22 = input_22.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "peering_id",
                        "cannot be empty or unset",
                    )
                })?;
                let peering_id = aws_smithy_http::label::fmt_string(
                    input_22,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if peering_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "peering_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/peerings/{PeeringId}", PeeringId = peering_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeletePeeringInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeletePeering::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeletePeering",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteResourcePolicy`](crate::operation::DeleteResourcePolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteResourcePolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteResourcePolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_23 = &_input.resource_arn;
                let input_23 = input_23.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_23,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/resource-policy/{ResourceArn}",
                    ResourceArn = resource_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteResourcePolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteResourcePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteResourcePolicy",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeleteSiteInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSite`](crate::operation::DeleteSite)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSite,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeleteSiteInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_24 = &_input.global_network_id;
                let input_24 = input_24.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_24,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_25 = &_input.site_id;
                let input_25 = input_25.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "site_id",
                        "cannot be empty or unset",
                    )
                })?;
                let site_id = aws_smithy_http::label::fmt_string(
                    input_25,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if site_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "site_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/sites/{SiteId}",
                    GlobalNetworkId = global_network_id,
                    SiteId = site_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeleteSiteInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSite::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSite",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DeregisterTransitGatewayInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterTransitGateway`](crate::operation::DeregisterTransitGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeregisterTransitGateway,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DeregisterTransitGatewayInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_26 = &_input.global_network_id;
                let input_26 = input_26.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_26,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_27 = &_input.transit_gateway_arn;
                let input_27 = input_27.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "transit_gateway_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let transit_gateway_arn = aws_smithy_http::label::fmt_string(
                    input_27,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if transit_gateway_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "transit_gateway_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/global-networks/{GlobalNetworkId}/transit-gateway-registrations/{TransitGatewayArn}", GlobalNetworkId = global_network_id, TransitGatewayArn = transit_gateway_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DeregisterTransitGatewayInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeregisterTransitGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeregisterTransitGateway",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DescribeGlobalNetworksInput {
    /// Consumes the builder and constructs an Operation<[`DescribeGlobalNetworks`](crate::operation::DescribeGlobalNetworks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeGlobalNetworks,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DescribeGlobalNetworksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/global-networks").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DescribeGlobalNetworksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_28) = &_input.global_network_ids {
                    {
                        for inner_29 in inner_28 {
                            query.push_kv(
                                "globalNetworkIds",
                                &aws_smithy_http::query::fmt_string(&inner_29),
                            );
                        }
                    }
                }
                if let Some(inner_30) = &_input.max_results {
                    if *inner_30 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_30).encode(),
                        );
                    }
                }
                if let Some(inner_31) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_31));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DescribeGlobalNetworksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeGlobalNetworks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeGlobalNetworks",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateConnectPeer`](crate::operation::DisassociateConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_32 = &_input.global_network_id;
                let input_32 = input_32.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_32,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_33 = &_input.connect_peer_id;
                let input_33 = input_33.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "connect_peer_id",
                        "cannot be empty or unset",
                    )
                })?;
                let connect_peer_id = aws_smithy_http::label::fmt_string(
                    input_33,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if connect_peer_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "connect_peer_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connect-peer-associations/{ConnectPeerId}",
                    GlobalNetworkId = global_network_id,
                    ConnectPeerId = connect_peer_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateCustomerGatewayInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateCustomerGateway`](crate::operation::DisassociateCustomerGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateCustomerGateway,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateCustomerGatewayInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.global_network_id;
                let input_34 = input_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_34,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_35 = &_input.customer_gateway_arn;
                let input_35 = input_35.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "customer_gateway_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let customer_gateway_arn = aws_smithy_http::label::fmt_string(
                    input_35,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if customer_gateway_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "customer_gateway_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/global-networks/{GlobalNetworkId}/customer-gateway-associations/{CustomerGatewayArn}", GlobalNetworkId = global_network_id, CustomerGatewayArn = customer_gateway_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateCustomerGatewayInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateCustomerGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateCustomerGateway",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateLinkInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateLink`](crate::operation::DisassociateLink)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateLink,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateLinkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_36 = &_input.global_network_id;
                let input_36 = input_36.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_36,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/link-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::DisassociateLinkInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_37 = &_input.device_id;
                let inner_37 = inner_37.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "device_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_37.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "device_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("deviceId", &aws_smithy_http::query::fmt_string(&inner_37));
                let inner_38 = &_input.link_id;
                let inner_38 = inner_38.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "link_id",
                        "cannot be empty or unset",
                    )
                })?;
                if inner_38.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "link_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                query.push_kv("linkId", &aws_smithy_http::query::fmt_string(&inner_38));
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateLinkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateLink",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl DisassociateTransitGatewayConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateTransitGatewayConnectPeer`](crate::operation::DisassociateTransitGatewayConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateTransitGatewayConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::DisassociateTransitGatewayConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.global_network_id;
                let input_39 = input_39.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_39,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_40 = &_input.transit_gateway_connect_peer_arn;
                let input_40 = input_40.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "transit_gateway_connect_peer_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let transit_gateway_connect_peer_arn = aws_smithy_http::label::fmt_string(
                    input_40,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if transit_gateway_connect_peer_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "transit_gateway_connect_peer_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/global-networks/{GlobalNetworkId}/transit-gateway-connect-peer-associations/{TransitGatewayConnectPeerArn}", GlobalNetworkId = global_network_id, TransitGatewayConnectPeerArn = transit_gateway_connect_peer_arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::DisassociateTransitGatewayConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateTransitGatewayConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateTransitGatewayConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ExecuteCoreNetworkChangeSetInput {
    /// Consumes the builder and constructs an Operation<[`ExecuteCoreNetworkChangeSet`](crate::operation::ExecuteCoreNetworkChangeSet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ExecuteCoreNetworkChangeSet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ExecuteCoreNetworkChangeSetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_41 = &_input.core_network_id;
                let input_41 = input_41.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_41,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_42 = &_input.policy_version_id;
                let input_42 = input_42.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "policy_version_id",
                        "cannot be empty or unset",
                    )
                })?;
                let mut policy_version_id_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_42);
                let policy_version_id = policy_version_id_encoder.encode();
                if policy_version_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "policy_version_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/core-networks/{CoreNetworkId}/core-network-change-sets/{PolicyVersionId}/execute", CoreNetworkId = core_network_id, PolicyVersionId = policy_version_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ExecuteCoreNetworkChangeSetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ExecuteCoreNetworkChangeSet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ExecuteCoreNetworkChangeSet",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetConnectAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectAttachment`](crate::operation::GetConnectAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnectAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetConnectAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_43 = &_input.attachment_id;
                let input_43 = input_43.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_43,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/connect-attachments/{AttachmentId}",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetConnectAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnectAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnectAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetConnectionsInput {
    /// Consumes the builder and constructs an Operation<[`GetConnections`](crate::operation::GetConnections)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnections,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetConnectionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_44 = &_input.global_network_id;
                let input_44 = input_44.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_44,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connections",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetConnectionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_45) = &_input.connection_ids {
                    {
                        for inner_46 in inner_45 {
                            query.push_kv(
                                "connectionIds",
                                &aws_smithy_http::query::fmt_string(&inner_46),
                            );
                        }
                    }
                }
                if let Some(inner_47) = &_input.device_id {
                    {
                        query.push_kv("deviceId", &aws_smithy_http::query::fmt_string(&inner_47));
                    }
                }
                if let Some(inner_48) = &_input.max_results {
                    if *inner_48 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_48).encode(),
                        );
                    }
                }
                if let Some(inner_49) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_49));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetConnectionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnections::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnections",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectPeer`](crate::operation::GetConnectPeer)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnectPeer,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetConnectPeerInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_50 = &_input.connect_peer_id;
                let input_50 = input_50.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "connect_peer_id",
                        "cannot be empty or unset",
                    )
                })?;
                let connect_peer_id = aws_smithy_http::label::fmt_string(
                    input_50,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if connect_peer_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "connect_peer_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/connect-peers/{ConnectPeerId}",
                    ConnectPeerId = connect_peer_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetConnectPeerInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetConnectPeerAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectPeerAssociations`](crate::operation::GetConnectPeerAssociations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnectPeerAssociations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetConnectPeerAssociationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.global_network_id;
                let input_51 = input_51.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_51,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connect-peer-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetConnectPeerAssociationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_52) = &_input.connect_peer_ids {
                    {
                        for inner_53 in inner_52 {
                            query.push_kv(
                                "connectPeerIds",
                                &aws_smithy_http::query::fmt_string(&inner_53),
                            );
                        }
                    }
                }
                if let Some(inner_54) = &_input.max_results {
                    if *inner_54 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_54).encode(),
                        );
                    }
                }
                if let Some(inner_55) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_55));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetConnectPeerAssociationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnectPeerAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnectPeerAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetwork`](crate::operation::GetCoreNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCoreNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_56 = &_input.core_network_id;
                let input_56 = input_56.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_56,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}",
                    CoreNetworkId = core_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCoreNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCoreNetworkChangeEventsInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetworkChangeEvents`](crate::operation::GetCoreNetworkChangeEvents)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetworkChangeEvents,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCoreNetworkChangeEventsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_57 = &_input.core_network_id;
                let input_57 = input_57.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_57,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_58 = &_input.policy_version_id;
                let input_58 = input_58.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "policy_version_id",
                        "cannot be empty or unset",
                    )
                })?;
                let mut policy_version_id_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_58);
                let policy_version_id = policy_version_id_encoder.encode();
                if policy_version_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "policy_version_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}/core-network-change-events/{PolicyVersionId}",
                    CoreNetworkId = core_network_id,
                    PolicyVersionId = policy_version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetCoreNetworkChangeEventsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_59) = &_input.max_results {
                    if *inner_59 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_59).encode(),
                        );
                    }
                }
                if let Some(inner_60) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_60));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCoreNetworkChangeEventsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetworkChangeEvents::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetworkChangeEvents",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCoreNetworkChangeSetInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetworkChangeSet`](crate::operation::GetCoreNetworkChangeSet)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetworkChangeSet,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCoreNetworkChangeSetInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_61 = &_input.core_network_id;
                let input_61 = input_61.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_61,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_62 = &_input.policy_version_id;
                let input_62 = input_62.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "policy_version_id",
                        "cannot be empty or unset",
                    )
                })?;
                let mut policy_version_id_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_62);
                let policy_version_id = policy_version_id_encoder.encode();
                if policy_version_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "policy_version_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}/core-network-change-sets/{PolicyVersionId}",
                    CoreNetworkId = core_network_id,
                    PolicyVersionId = policy_version_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetCoreNetworkChangeSetInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_63) = &_input.max_results {
                    if *inner_63 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_63).encode(),
                        );
                    }
                }
                if let Some(inner_64) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_64));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCoreNetworkChangeSetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetworkChangeSet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetworkChangeSet",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCoreNetworkPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetworkPolicy`](crate::operation::GetCoreNetworkPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetworkPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCoreNetworkPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_65 = &_input.core_network_id;
                let input_65 = input_65.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_65,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}/core-network-policy",
                    CoreNetworkId = core_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetCoreNetworkPolicyInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_66) = &_input.policy_version_id {
                    if *inner_66 != 0 {
                        query.push_kv(
                            "policyVersionId",
                            aws_smithy_types::primitive::Encoder::from(*inner_66).encode(),
                        );
                    }
                }
                if let Some(inner_67) = &_input.alias {
                    {
                        query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_67));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCoreNetworkPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetworkPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetworkPolicy",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCustomerGatewayAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetCustomerGatewayAssociations`](crate::operation::GetCustomerGatewayAssociations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCustomerGatewayAssociations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCustomerGatewayAssociationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_68 = &_input.global_network_id;
                let input_68 = input_68.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_68,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/customer-gateway-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetCustomerGatewayAssociationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_69) = &_input.customer_gateway_arns {
                    {
                        for inner_70 in inner_69 {
                            query.push_kv(
                                "customerGatewayArns",
                                &aws_smithy_http::query::fmt_string(&inner_70),
                            );
                        }
                    }
                }
                if let Some(inner_71) = &_input.max_results {
                    if *inner_71 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_71).encode(),
                        );
                    }
                }
                if let Some(inner_72) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_72));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCustomerGatewayAssociationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCustomerGatewayAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCustomerGatewayAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetDevicesInput {
    /// Consumes the builder and constructs an Operation<[`GetDevices`](crate::operation::GetDevices)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDevices,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDevicesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_73 = &_input.global_network_id;
                let input_73 = input_73.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_73,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/devices",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetDevicesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_74) = &_input.device_ids {
                    {
                        for inner_75 in inner_74 {
                            query.push_kv(
                                "deviceIds",
                                &aws_smithy_http::query::fmt_string(&inner_75),
                            );
                        }
                    }
                }
                if let Some(inner_76) = &_input.site_id {
                    {
                        query.push_kv("siteId", &aws_smithy_http::query::fmt_string(&inner_76));
                    }
                }
                if let Some(inner_77) = &_input.max_results {
                    if *inner_77 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_77).encode(),
                        );
                    }
                }
                if let Some(inner_78) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_78));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDevicesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDevices::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDevices",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetLinkAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetLinkAssociations`](crate::operation::GetLinkAssociations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLinkAssociations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLinkAssociationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_79 = &_input.global_network_id;
                let input_79 = input_79.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_79,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/link-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetLinkAssociationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_80) = &_input.device_id {
                    {
                        query.push_kv("deviceId", &aws_smithy_http::query::fmt_string(&inner_80));
                    }
                }
                if let Some(inner_81) = &_input.link_id {
                    {
                        query.push_kv("linkId", &aws_smithy_http::query::fmt_string(&inner_81));
                    }
                }
                if let Some(inner_82) = &_input.max_results {
                    if *inner_82 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_82).encode(),
                        );
                    }
                }
                if let Some(inner_83) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_83));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLinkAssociationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLinkAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLinkAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetLinksInput {
    /// Consumes the builder and constructs an Operation<[`GetLinks`](crate::operation::GetLinks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLinks,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLinksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_84 = &_input.global_network_id;
                let input_84 = input_84.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_84,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/links",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetLinksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_85) = &_input.link_ids {
                    {
                        for inner_86 in inner_85 {
                            query
                                .push_kv("linkIds", &aws_smithy_http::query::fmt_string(&inner_86));
                        }
                    }
                }
                if let Some(inner_87) = &_input.site_id {
                    {
                        query.push_kv("siteId", &aws_smithy_http::query::fmt_string(&inner_87));
                    }
                }
                if let Some(inner_88) = &_input.r#type {
                    {
                        query.push_kv("type", &aws_smithy_http::query::fmt_string(&inner_88));
                    }
                }
                if let Some(inner_89) = &_input.provider {
                    {
                        query.push_kv("provider", &aws_smithy_http::query::fmt_string(&inner_89));
                    }
                }
                if let Some(inner_90) = &_input.max_results {
                    if *inner_90 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_90).encode(),
                        );
                    }
                }
                if let Some(inner_91) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_91));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLinksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetLinks::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetLinks",
                    "networkmanager",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetNetworkResourceCountsInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkResourceCounts`](crate::operation::GetNetworkResourceCounts)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkResourceCounts,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetNetworkResourceCountsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_92 = &_input.global_network_id;
                let input_92 = input_92.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_92,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/network-resource-count",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetNetworkResourceCountsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_93) = &_input.resource_type {
                    {
                        query.push_kv(
                            "resourceType",
                            &aws_smithy_http::query::fmt_string(&inner_93),
                        );
                    }
                }
                if let Some(inner_94) = &_input.max_results {
                    if *inner_94 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_94).encode(),
                        );
                    }
                }
                if let Some(inner_95) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_95));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetNetworkResourceCountsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkResourceCounts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkResourceCounts",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetNetworkResourceRelationshipsInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkResourceRelationships`](crate::operation::GetNetworkResourceRelationships)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkResourceRelationships,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetNetworkResourceRelationshipsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_96 = &_input.global_network_id;
                let input_96 = input_96.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_96,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/network-resource-relationships",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetNetworkResourceRelationshipsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_97) = &_input.core_network_id {
                    {
                        query.push_kv(
                            "coreNetworkId",
                            &aws_smithy_http::query::fmt_string(&inner_97),
                        );
                    }
                }
                if let Some(inner_98) = &_input.registered_gateway_arn {
                    {
                        query.push_kv(
                            "registeredGatewayArn",
                            &aws_smithy_http::query::fmt_string(&inner_98),
                        );
                    }
                }
                if let Some(inner_99) = &_input.aws_region {
                    {
                        query.push_kv("awsRegion", &aws_smithy_http::query::fmt_string(&inner_99));
                    }
                }
                if let Some(inner_100) = &_input.account_id {
                    {
                        query.push_kv("accountId", &aws_smithy_http::query::fmt_string(&inner_100));
                    }
                }
                if let Some(inner_101) = &_input.resource_type {
                    {
                        query.push_kv(
                            "resourceType",
                            &aws_smithy_http::query::fmt_string(&inner_101),
                        );
                    }
                }
                if let Some(inner_102) = &_input.resource_arn {
                    {
                        query.push_kv(
                            "resourceArn",
                            &aws_smithy_http::query::fmt_string(&inner_102),
                        );
                    }
                }
                if let Some(inner_103) = &_input.max_results {
                    if *inner_103 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_103).encode(),
                        );
                    }
                }
                if let Some(inner_104) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_104));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetNetworkResourceRelationshipsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkResourceRelationships::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkResourceRelationships",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetNetworkResourcesInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkResources`](crate::operation::GetNetworkResources)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkResources,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetNetworkResourcesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_105 = &_input.global_network_id;
                let input_105 = input_105.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_105,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/network-resources",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetNetworkResourcesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_106) = &_input.core_network_id {
                    {
                        query.push_kv(
                            "coreNetworkId",
                            &aws_smithy_http::query::fmt_string(&inner_106),
                        );
                    }
                }
                if let Some(inner_107) = &_input.registered_gateway_arn {
                    {
                        query.push_kv(
                            "registeredGatewayArn",
                            &aws_smithy_http::query::fmt_string(&inner_107),
                        );
                    }
                }
                if let Some(inner_108) = &_input.aws_region {
                    {
                        query.push_kv("awsRegion", &aws_smithy_http::query::fmt_string(&inner_108));
                    }
                }
                if let Some(inner_109) = &_input.account_id {
                    {
                        query.push_kv("accountId", &aws_smithy_http::query::fmt_string(&inner_109));
                    }
                }
                if let Some(inner_110) = &_input.resource_type {
                    {
                        query.push_kv(
                            "resourceType",
                            &aws_smithy_http::query::fmt_string(&inner_110),
                        );
                    }
                }
                if let Some(inner_111) = &_input.resource_arn {
                    {
                        query.push_kv(
                            "resourceArn",
                            &aws_smithy_http::query::fmt_string(&inner_111),
                        );
                    }
                }
                if let Some(inner_112) = &_input.max_results {
                    if *inner_112 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_112).encode(),
                        );
                    }
                }
                if let Some(inner_113) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_113));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetNetworkResourcesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkResources::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkResources",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetNetworkRoutesInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkRoutes`](crate::operation::GetNetworkRoutes)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkRoutes,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetNetworkRoutesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_114 = &_input.global_network_id;
                let input_114 = input_114.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_114,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/network-routes",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetNetworkRoutesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_network_routes(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkRoutes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkRoutes",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetNetworkTelemetryInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkTelemetry`](crate::operation::GetNetworkTelemetry)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkTelemetry,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetNetworkTelemetryInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_115 = &_input.global_network_id;
                let input_115 = input_115.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_115,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/network-telemetry",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetNetworkTelemetryInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_116) = &_input.core_network_id {
                    {
                        query.push_kv(
                            "coreNetworkId",
                            &aws_smithy_http::query::fmt_string(&inner_116),
                        );
                    }
                }
                if let Some(inner_117) = &_input.registered_gateway_arn {
                    {
                        query.push_kv(
                            "registeredGatewayArn",
                            &aws_smithy_http::query::fmt_string(&inner_117),
                        );
                    }
                }
                if let Some(inner_118) = &_input.aws_region {
                    {
                        query.push_kv("awsRegion", &aws_smithy_http::query::fmt_string(&inner_118));
                    }
                }
                if let Some(inner_119) = &_input.account_id {
                    {
                        query.push_kv("accountId", &aws_smithy_http::query::fmt_string(&inner_119));
                    }
                }
                if let Some(inner_120) = &_input.resource_type {
                    {
                        query.push_kv(
                            "resourceType",
                            &aws_smithy_http::query::fmt_string(&inner_120),
                        );
                    }
                }
                if let Some(inner_121) = &_input.resource_arn {
                    {
                        query.push_kv(
                            "resourceArn",
                            &aws_smithy_http::query::fmt_string(&inner_121),
                        );
                    }
                }
                if let Some(inner_122) = &_input.max_results {
                    if *inner_122 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_122).encode(),
                        );
                    }
                }
                if let Some(inner_123) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_123));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetNetworkTelemetryInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkTelemetry::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkTelemetry",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetResourcePolicy`](crate::operation::GetResourcePolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetResourcePolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetResourcePolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_124 = &_input.resource_arn;
                let input_124 = input_124.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_124,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/resource-policy/{ResourceArn}",
                    ResourceArn = resource_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetResourcePolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetResourcePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetResourcePolicy",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetRouteAnalysisInput {
    /// Consumes the builder and constructs an Operation<[`GetRouteAnalysis`](crate::operation::GetRouteAnalysis)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRouteAnalysis,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetRouteAnalysisInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_125 = &_input.global_network_id;
                let input_125 = input_125.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_125,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_126 = &_input.route_analysis_id;
                let input_126 = input_126.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "route_analysis_id",
                        "cannot be empty or unset",
                    )
                })?;
                let route_analysis_id = aws_smithy_http::label::fmt_string(
                    input_126,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if route_analysis_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "route_analysis_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/route-analyses/{RouteAnalysisId}",
                    GlobalNetworkId = global_network_id,
                    RouteAnalysisId = route_analysis_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetRouteAnalysisInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRouteAnalysis::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRouteAnalysis",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSitesInput {
    /// Consumes the builder and constructs an Operation<[`GetSites`](crate::operation::GetSites)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSites,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSitesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_127 = &_input.global_network_id;
                let input_127 = input_127.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_127,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/sites",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetSitesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_128) = &_input.site_ids {
                    {
                        for inner_129 in inner_128 {
                            query.push_kv(
                                "siteIds",
                                &aws_smithy_http::query::fmt_string(&inner_129),
                            );
                        }
                    }
                }
                if let Some(inner_130) = &_input.max_results {
                    if *inner_130 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_130).encode(),
                        );
                    }
                }
                if let Some(inner_131) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_131));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSitesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetSites::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetSites",
                    "networkmanager",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetSiteToSiteVpnAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetSiteToSiteVpnAttachment`](crate::operation::GetSiteToSiteVpnAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSiteToSiteVpnAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetSiteToSiteVpnAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_132 = &_input.attachment_id;
                let input_132 = input_132.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_132,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/site-to-site-vpn-attachments/{AttachmentId}",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetSiteToSiteVpnAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSiteToSiteVpnAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSiteToSiteVpnAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTransitGatewayConnectPeerAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetTransitGatewayConnectPeerAssociations`](crate::operation::GetTransitGatewayConnectPeerAssociations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTransitGatewayConnectPeerAssociations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_133 = &_input.global_network_id;
                let input_133 = input_133.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_133,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/transit-gateway-connect-peer-associations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_134) = &_input.transit_gateway_connect_peer_arns {
                    {
                        for inner_135 in inner_134 {
                            query.push_kv(
                                "transitGatewayConnectPeerArns",
                                &aws_smithy_http::query::fmt_string(&inner_135),
                            );
                        }
                    }
                }
                if let Some(inner_136) = &_input.max_results {
                    if *inner_136 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_136).encode(),
                        );
                    }
                }
                if let Some(inner_137) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_137));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTransitGatewayConnectPeerAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTransitGatewayConnectPeerAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTransitGatewayPeeringInput {
    /// Consumes the builder and constructs an Operation<[`GetTransitGatewayPeering`](crate::operation::GetTransitGatewayPeering)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTransitGatewayPeering,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTransitGatewayPeeringInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_138 = &_input.peering_id;
                let input_138 = input_138.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "peering_id",
                        "cannot be empty or unset",
                    )
                })?;
                let peering_id = aws_smithy_http::label::fmt_string(
                    input_138,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if peering_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "peering_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/transit-gateway-peerings/{PeeringId}",
                    PeeringId = peering_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTransitGatewayPeeringInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTransitGatewayPeering::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTransitGatewayPeering",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTransitGatewayRegistrationsInput {
    /// Consumes the builder and constructs an Operation<[`GetTransitGatewayRegistrations`](crate::operation::GetTransitGatewayRegistrations)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTransitGatewayRegistrations,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTransitGatewayRegistrationsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_139 = &_input.global_network_id;
                let input_139 = input_139.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_139,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/transit-gateway-registrations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::GetTransitGatewayRegistrationsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_140) = &_input.transit_gateway_arns {
                    {
                        for inner_141 in inner_140 {
                            query.push_kv(
                                "transitGatewayArns",
                                &aws_smithy_http::query::fmt_string(&inner_141),
                            );
                        }
                    }
                }
                if let Some(inner_142) = &_input.max_results {
                    if *inner_142 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_142).encode(),
                        );
                    }
                }
                if let Some(inner_143) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_143));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTransitGatewayRegistrationsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTransitGatewayRegistrations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTransitGatewayRegistrations",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTransitGatewayRouteTableAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetTransitGatewayRouteTableAttachment`](crate::operation::GetTransitGatewayRouteTableAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTransitGatewayRouteTableAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTransitGatewayRouteTableAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_144 = &_input.attachment_id;
                let input_144 = input_144.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_144,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/transit-gateway-route-table-attachments/{AttachmentId}",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTransitGatewayRouteTableAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTransitGatewayRouteTableAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTransitGatewayRouteTableAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetVpcAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetVpcAttachment`](crate::operation::GetVpcAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVpcAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetVpcAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_145 = &_input.attachment_id;
                let input_145 = input_145.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_145,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/vpc-attachments/{AttachmentId}",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetVpcAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVpcAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVpcAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListAttachmentsInput {
    /// Consumes the builder and constructs an Operation<[`ListAttachments`](crate::operation::ListAttachments)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAttachments,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListAttachmentsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/attachments").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListAttachmentsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_146) = &_input.core_network_id {
                    {
                        query.push_kv(
                            "coreNetworkId",
                            &aws_smithy_http::query::fmt_string(&inner_146),
                        );
                    }
                }
                if let Some(inner_147) = &_input.attachment_type {
                    {
                        query.push_kv(
                            "attachmentType",
                            &aws_smithy_http::query::fmt_string(&inner_147),
                        );
                    }
                }
                if let Some(inner_148) = &_input.edge_location {
                    {
                        query.push_kv(
                            "edgeLocation",
                            &aws_smithy_http::query::fmt_string(&inner_148),
                        );
                    }
                }
                if let Some(inner_149) = &_input.state {
                    {
                        query.push_kv("state", &aws_smithy_http::query::fmt_string(&inner_149));
                    }
                }
                if let Some(inner_150) = &_input.max_results {
                    if *inner_150 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_150).encode(),
                        );
                    }
                }
                if let Some(inner_151) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_151));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListAttachmentsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAttachments::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAttachments",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListConnectPeersInput {
    /// Consumes the builder and constructs an Operation<[`ListConnectPeers`](crate::operation::ListConnectPeers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListConnectPeers,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListConnectPeersInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/connect-peers").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListConnectPeersInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_152) = &_input.core_network_id {
                    {
                        query.push_kv(
                            "coreNetworkId",
                            &aws_smithy_http::query::fmt_string(&inner_152),
                        );
                    }
                }
                if let Some(inner_153) = &_input.connect_attachment_id {
                    {
                        query.push_kv(
                            "connectAttachmentId",
                            &aws_smithy_http::query::fmt_string(&inner_153),
                        );
                    }
                }
                if let Some(inner_154) = &_input.max_results {
                    if *inner_154 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_154).encode(),
                        );
                    }
                }
                if let Some(inner_155) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_155));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListConnectPeersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListConnectPeers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListConnectPeers",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListCoreNetworkPolicyVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListCoreNetworkPolicyVersions`](crate::operation::ListCoreNetworkPolicyVersions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCoreNetworkPolicyVersions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCoreNetworkPolicyVersionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_156 = &_input.core_network_id;
                let input_156 = input_156.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_156,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}/core-network-policy-versions",
                    CoreNetworkId = core_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCoreNetworkPolicyVersionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_157) = &_input.max_results {
                    if *inner_157 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_157).encode(),
                        );
                    }
                }
                if let Some(inner_158) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_158));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCoreNetworkPolicyVersionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCoreNetworkPolicyVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCoreNetworkPolicyVersions",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListCoreNetworksInput {
    /// Consumes the builder and constructs an Operation<[`ListCoreNetworks`](crate::operation::ListCoreNetworks)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCoreNetworks,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCoreNetworksInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/core-networks").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListCoreNetworksInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_159) = &_input.max_results {
                    if *inner_159 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_159).encode(),
                        );
                    }
                }
                if let Some(inner_160) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_160));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCoreNetworksInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCoreNetworks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCoreNetworks",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListOrganizationServiceAccessStatusInput {
    /// Consumes the builder and constructs an Operation<[`ListOrganizationServiceAccessStatus`](crate::operation::ListOrganizationServiceAccessStatus)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListOrganizationServiceAccessStatus,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListOrganizationServiceAccessStatusInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/organizations/service-access").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListOrganizationServiceAccessStatusInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_161) = &_input.max_results {
                    if *inner_161 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_161).encode(),
                        );
                    }
                }
                if let Some(inner_162) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_162));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListOrganizationServiceAccessStatusInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListOrganizationServiceAccessStatus::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListOrganizationServiceAccessStatus",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListPeeringsInput {
    /// Consumes the builder and constructs an Operation<[`ListPeerings`](crate::operation::ListPeerings)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListPeerings,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListPeeringsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/peerings").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListPeeringsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_163) = &_input.core_network_id {
                    {
                        query.push_kv(
                            "coreNetworkId",
                            &aws_smithy_http::query::fmt_string(&inner_163),
                        );
                    }
                }
                if let Some(inner_164) = &_input.peering_type {
                    {
                        query.push_kv(
                            "peeringType",
                            &aws_smithy_http::query::fmt_string(&inner_164),
                        );
                    }
                }
                if let Some(inner_165) = &_input.edge_location {
                    {
                        query.push_kv(
                            "edgeLocation",
                            &aws_smithy_http::query::fmt_string(&inner_165),
                        );
                    }
                }
                if let Some(inner_166) = &_input.state {
                    {
                        query.push_kv("state", &aws_smithy_http::query::fmt_string(&inner_166));
                    }
                }
                if let Some(inner_167) = &_input.max_results {
                    if *inner_167 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_167).encode(),
                        );
                    }
                }
                if let Some(inner_168) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_168));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListPeeringsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListPeerings::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListPeerings",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_169 = &_input.resource_arn;
                let input_169 = input_169.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_169,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutCoreNetworkPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutCoreNetworkPolicy`](crate::operation::PutCoreNetworkPolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutCoreNetworkPolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutCoreNetworkPolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_170 = &_input.core_network_id;
                let input_170 = input_170.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_170,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}/core-network-policy",
                    CoreNetworkId = core_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutCoreNetworkPolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_core_network_policy(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutCoreNetworkPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutCoreNetworkPolicy",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutResourcePolicy`](crate::operation::PutResourcePolicy)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutResourcePolicy,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutResourcePolicyInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_171 = &_input.resource_arn;
                let input_171 = input_171.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_171,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/resource-policy/{ResourceArn}",
                    ResourceArn = resource_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutResourcePolicyInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_resource_policy(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutResourcePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutResourcePolicy",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl RegisterTransitGatewayInput {
    /// Consumes the builder and constructs an Operation<[`RegisterTransitGateway`](crate::operation::RegisterTransitGateway)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterTransitGateway,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::RegisterTransitGatewayInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_172 = &_input.global_network_id;
                let input_172 = input_172.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_172,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/transit-gateway-registrations",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RegisterTransitGatewayInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_register_transit_gateway(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterTransitGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterTransitGateway",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl RejectAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`RejectAttachment`](crate::operation::RejectAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RejectAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::RejectAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_173 = &_input.attachment_id;
                let input_173 = input_173.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_173,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/attachments/{AttachmentId}/reject",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RejectAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RejectAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RejectAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl RestoreCoreNetworkPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`RestoreCoreNetworkPolicyVersion`](crate::operation::RestoreCoreNetworkPolicyVersion)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RestoreCoreNetworkPolicyVersion,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::RestoreCoreNetworkPolicyVersionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_174 = &_input.core_network_id;
                let input_174 = input_174.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_174,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_175 = &_input.policy_version_id;
                let input_175 = input_175.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "policy_version_id",
                        "cannot be empty or unset",
                    )
                })?;
                let mut policy_version_id_encoder =
                    aws_smithy_types::primitive::Encoder::from(*input_175);
                let policy_version_id = policy_version_id_encoder.encode();
                if policy_version_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "policy_version_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/core-networks/{CoreNetworkId}/core-network-policy-versions/{PolicyVersionId}/restore", CoreNetworkId = core_network_id, PolicyVersionId = policy_version_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::RestoreCoreNetworkPolicyVersionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RestoreCoreNetworkPolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RestoreCoreNetworkPolicyVersion",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartOrganizationServiceAccessUpdateInput {
    /// Consumes the builder and constructs an Operation<[`StartOrganizationServiceAccessUpdate`](crate::operation::StartOrganizationServiceAccessUpdate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartOrganizationServiceAccessUpdate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartOrganizationServiceAccessUpdateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/organizations/service-access").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartOrganizationServiceAccessUpdateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_organization_service_access_update(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartOrganizationServiceAccessUpdate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartOrganizationServiceAccessUpdate",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl StartRouteAnalysisInput {
    /// Consumes the builder and constructs an Operation<[`StartRouteAnalysis`](crate::operation::StartRouteAnalysis)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartRouteAnalysis,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::StartRouteAnalysisInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_176 = &_input.global_network_id;
                let input_176 = input_176.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_176,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/route-analyses",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::StartRouteAnalysisInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_start_route_analysis(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartRouteAnalysis::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartRouteAnalysis",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_177 = &_input.resource_arn;
                let input_177 = input_177.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_177,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_178 = &_input.resource_arn;
                let input_178 = input_178.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_178,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                    .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_179 = &_input.tag_keys;
                let inner_179 = inner_179.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "tag_keys",
                        "cannot be empty or unset",
                    )
                })?;
                for inner_180 in inner_179 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_180));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateConnectionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateConnection`](crate::operation::UpdateConnection)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateConnection,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateConnectionInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_181 = &_input.global_network_id;
                let input_181 = input_181.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_181,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_182 = &_input.connection_id;
                let input_182 = input_182.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "connection_id",
                        "cannot be empty or unset",
                    )
                })?;
                let connection_id = aws_smithy_http::label::fmt_string(
                    input_182,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if connection_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "connection_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/connections/{ConnectionId}",
                    GlobalNetworkId = global_network_id,
                    ConnectionId = connection_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateConnectionInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_connection(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateConnection",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCoreNetwork`](crate::operation::UpdateCoreNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCoreNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCoreNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_183 = &_input.core_network_id;
                let input_183 = input_183.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "core_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let core_network_id = aws_smithy_http::label::fmt_string(
                    input_183,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if core_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "core_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/core-networks/{CoreNetworkId}",
                    CoreNetworkId = core_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCoreNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_core_network(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateDeviceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDevice`](crate::operation::UpdateDevice)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDevice,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateDeviceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_184 = &_input.global_network_id;
                let input_184 = input_184.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_184,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_185 = &_input.device_id;
                let input_185 = input_185.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "device_id",
                        "cannot be empty or unset",
                    )
                })?;
                let device_id = aws_smithy_http::label::fmt_string(
                    input_185,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if device_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "device_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/devices/{DeviceId}",
                    GlobalNetworkId = global_network_id,
                    DeviceId = device_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateDeviceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_device(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDevice::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDevice",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateGlobalNetworkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGlobalNetwork`](crate::operation::UpdateGlobalNetwork)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateGlobalNetwork,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateGlobalNetworkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_186 = &_input.global_network_id;
                let input_186 = input_186.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_186,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}",
                    GlobalNetworkId = global_network_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateGlobalNetworkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_global_network(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateGlobalNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateGlobalNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateLinkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLink`](crate::operation::UpdateLink)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateLink,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateLinkInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_187 = &_input.global_network_id;
                let input_187 = input_187.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_187,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_188 = &_input.link_id;
                let input_188 = input_188.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "link_id",
                        "cannot be empty or unset",
                    )
                })?;
                let link_id = aws_smithy_http::label::fmt_string(
                    input_188,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if link_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "link_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/links/{LinkId}",
                    GlobalNetworkId = global_network_id,
                    LinkId = link_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateLinkInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_link(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateLink",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateNetworkResourceMetadataInput {
    /// Consumes the builder and constructs an Operation<[`UpdateNetworkResourceMetadata`](crate::operation::UpdateNetworkResourceMetadata)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateNetworkResourceMetadata,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateNetworkResourceMetadataInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_189 = &_input.global_network_id;
                let input_189 = input_189.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_189,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_190 = &_input.resource_arn;
                let input_190 = input_190.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "resource_arn",
                        "cannot be empty or unset",
                    )
                })?;
                let resource_arn = aws_smithy_http::label::fmt_string(
                    input_190,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if resource_arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "resource_arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/network-resources/{ResourceArn}/metadata",
                    GlobalNetworkId = global_network_id,
                    ResourceArn = resource_arn
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateNetworkResourceMetadataInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_network_resource_metadata(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateNetworkResourceMetadata::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateNetworkResourceMetadata",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateSiteInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSite`](crate::operation::UpdateSite)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSite,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateSiteInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_191 = &_input.global_network_id;
                let input_191 = input_191.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "global_network_id",
                        "cannot be empty or unset",
                    )
                })?;
                let global_network_id = aws_smithy_http::label::fmt_string(
                    input_191,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if global_network_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "global_network_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_192 = &_input.site_id;
                let input_192 = input_192.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "site_id",
                        "cannot be empty or unset",
                    )
                })?;
                let site_id = aws_smithy_http::label::fmt_string(
                    input_192,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if site_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "site_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/global-networks/{GlobalNetworkId}/sites/{SiteId}",
                    GlobalNetworkId = global_network_id,
                    SiteId = site_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateSiteInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_site(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSite::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSite",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateVpcAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVpcAttachment`](crate::operation::UpdateVpcAttachment)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVpcAttachment,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateVpcAttachmentInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_193 = &_input.attachment_id;
                let input_193 = input_193.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "attachment_id",
                        "cannot be empty or unset",
                    )
                })?;
                let attachment_id = aws_smithy_http::label::fmt_string(
                    input_193,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if attachment_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "attachment_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/vpc-attachments/{AttachmentId}",
                    AttachmentId = attachment_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateVpcAttachmentInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PATCH").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_vpc_attachment(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVpcAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVpcAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>Adds a subnet ARN to the VPC attachment.</p>
    #[doc(hidden)]
    pub add_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Removes a subnet ARN from the attachment.</p>
    #[doc(hidden)]
    pub remove_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Additional options for updating the VPC attachment. </p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::VpcOptions>,
}
impl UpdateVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
    /// <p>Adds a subnet ARN to the VPC attachment.</p>
    pub fn add_subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.add_subnet_arns.as_deref()
    }
    /// <p>Removes a subnet ARN from the attachment.</p>
    pub fn remove_subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.remove_subnet_arns.as_deref()
    }
    /// <p>Additional options for updating the VPC attachment. </p>
    pub fn options(&self) -> std::option::Option<&crate::model::VpcOptions> {
        self.options.as_ref()
    }
}
impl UpdateVpcAttachmentInput {
    /// Creates a new builder-style object to manufacture [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput).
    pub fn builder() -> crate::input::update_vpc_attachment_input::Builder {
        crate::input::update_vpc_attachment_input::Builder::default()
    }
}

/// See [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput).
pub mod update_vpc_attachment_input {

    /// A builder for [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) add_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) remove_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) options: std::option::Option<crate::model::VpcOptions>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Appends an item to `add_subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_add_subnet_arns`](Self::set_add_subnet_arns).
        ///
        /// <p>Adds a subnet ARN to the VPC attachment.</p>
        pub fn add_subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.add_subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.add_subnet_arns = Some(v);
            self
        }
        /// <p>Adds a subnet ARN to the VPC attachment.</p>
        pub fn set_add_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.add_subnet_arns = input;
            self
        }
        /// Appends an item to `remove_subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_remove_subnet_arns`](Self::set_remove_subnet_arns).
        ///
        /// <p>Removes a subnet ARN from the attachment.</p>
        pub fn remove_subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.remove_subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.remove_subnet_arns = Some(v);
            self
        }
        /// <p>Removes a subnet ARN from the attachment.</p>
        pub fn set_remove_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.remove_subnet_arns = input;
            self
        }
        /// <p>Additional options for updating the VPC attachment. </p>
        pub fn options(mut self, input: crate::model::VpcOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Additional options for updating the VPC attachment. </p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::VpcOptions>) -> Self {
            self.options = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateVpcAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateVpcAttachmentInput {
                attachment_id: self.attachment_id,
                add_subnet_arns: self.add_subnet_arns,
                remove_subnet_arns: self.remove_subnet_arns,
                options: self.options,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSiteInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of your site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The site location:</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub location: std::option::Option<crate::model::Location>,
}
impl UpdateSiteInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of your site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The site location:</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
}
impl std::fmt::Debug for UpdateSiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSiteInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("site_id", &self.site_id);
        formatter.field("description", &self.description);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl UpdateSiteInput {
    /// Creates a new builder-style object to manufacture [`UpdateSiteInput`](crate::input::UpdateSiteInput).
    pub fn builder() -> crate::input::update_site_input::Builder {
        crate::input::update_site_input::Builder::default()
    }
}

/// See [`UpdateSiteInput`](crate::input::UpdateSiteInput).
pub mod update_site_input {

    /// A builder for [`UpdateSiteInput`](crate::input::UpdateSiteInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of your site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of your site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The site location:</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The site location:</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSiteInput`](crate::input::UpdateSiteInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSiteInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateSiteInput {
                global_network_id: self.global_network_id,
                site_id: self.site_id,
                description: self.description,
                location: self.location,
            })
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("global_network_id", &self.global_network_id);
            formatter.field("site_id", &self.site_id);
            formatter.field("description", &self.description);
            formatter.field("location", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateNetworkResourceMetadataInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The resource metadata.</p>
    #[doc(hidden)]
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateNetworkResourceMetadataInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The resource metadata.</p>
    pub fn metadata(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.metadata.as_ref()
    }
}
impl UpdateNetworkResourceMetadataInput {
    /// Creates a new builder-style object to manufacture [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput).
    pub fn builder() -> crate::input::update_network_resource_metadata_input::Builder {
        crate::input::update_network_resource_metadata_input::Builder::default()
    }
}

/// See [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput).
pub mod update_network_resource_metadata_input {

    /// A builder for [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Adds a key-value pair to `metadata`.
        ///
        /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
        ///
        /// <p>The resource metadata.</p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        /// <p>The resource metadata.</p>
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateNetworkResourceMetadataInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateNetworkResourceMetadataInput {
                global_network_id: self.global_network_id,
                resource_arn: self.resource_arn,
                metadata: self.metadata,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateLinkInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The upload and download speed in Mbps. </p>
    #[doc(hidden)]
    pub bandwidth: std::option::Option<crate::model::Bandwidth>,
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<std::string::String>,
}
impl UpdateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The upload and download speed in Mbps. </p>
    pub fn bandwidth(&self) -> std::option::Option<&crate::model::Bandwidth> {
        self.bandwidth.as_ref()
    }
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
}
impl UpdateLinkInput {
    /// Creates a new builder-style object to manufacture [`UpdateLinkInput`](crate::input::UpdateLinkInput).
    pub fn builder() -> crate::input::update_link_input::Builder {
        crate::input::update_link_input::Builder::default()
    }
}

/// See [`UpdateLinkInput`](crate::input::UpdateLinkInput).
pub mod update_link_input {

    /// A builder for [`UpdateLinkInput`](crate::input::UpdateLinkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) bandwidth: std::option::Option<crate::model::Bandwidth>,
        pub(crate) provider: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The upload and download speed in Mbps. </p>
        pub fn bandwidth(mut self, input: crate::model::Bandwidth) -> Self {
            self.bandwidth = Some(input);
            self
        }
        /// <p>The upload and download speed in Mbps. </p>
        pub fn set_bandwidth(
            mut self,
            input: std::option::Option<crate::model::Bandwidth>,
        ) -> Self {
            self.bandwidth = input;
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLinkInput`](crate::input::UpdateLinkInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateLinkInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateLinkInput {
                global_network_id: self.global_network_id,
                link_id: self.link_id,
                description: self.description,
                r#type: self.r#type,
                bandwidth: self.bandwidth,
                provider: self.provider,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateGlobalNetworkInput {
    /// <p>The ID of your global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateGlobalNetworkInput {
    /// <p>The ID of your global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateGlobalNetworkInput {
    /// Creates a new builder-style object to manufacture [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput).
    pub fn builder() -> crate::input::update_global_network_input::Builder {
        crate::input::update_global_network_input::Builder::default()
    }
}

/// See [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput).
pub mod update_global_network_input {

    /// A builder for [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of your global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of your global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateGlobalNetworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateGlobalNetworkInput {
                global_network_id: self.global_network_id,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDeviceInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    #[doc(hidden)]
    pub aws_location: std::option::Option<crate::model::AwsLocation>,
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the device.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>Describes a location.</p>
    #[doc(hidden)]
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
}
impl UpdateDeviceInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    pub fn aws_location(&self) -> std::option::Option<&crate::model::AwsLocation> {
        self.aws_location.as_ref()
    }
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the device.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn vendor(&self) -> std::option::Option<&str> {
        self.vendor.as_deref()
    }
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn serial_number(&self) -> std::option::Option<&str> {
        self.serial_number.as_deref()
    }
    /// <p>Describes a location.</p>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
}
impl std::fmt::Debug for UpdateDeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDeviceInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("aws_location", &self.aws_location);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("vendor", &self.vendor);
        formatter.field("model", &self.model);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("site_id", &self.site_id);
        formatter.finish()
    }
}
impl UpdateDeviceInput {
    /// Creates a new builder-style object to manufacture [`UpdateDeviceInput`](crate::input::UpdateDeviceInput).
    pub fn builder() -> crate::input::update_device_input::Builder {
        crate::input::update_device_input::Builder::default()
    }
}

/// See [`UpdateDeviceInput`](crate::input::UpdateDeviceInput).
pub mod update_device_input {

    /// A builder for [`UpdateDeviceInput`](crate::input::UpdateDeviceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) aws_location: std::option::Option<crate::model::AwsLocation>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) site_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn aws_location(mut self, input: crate::model::AwsLocation) -> Self {
            self.aws_location = Some(input);
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn set_aws_location(
            mut self,
            input: std::option::Option<crate::model::AwsLocation>,
        ) -> Self {
            self.aws_location = input;
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the device.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the device.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>Describes a location.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>Describes a location.</p>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDeviceInput`](crate::input::UpdateDeviceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateDeviceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateDeviceInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                aws_location: self.aws_location,
                description: self.description,
                r#type: self.r#type,
                vendor: self.vendor,
                model: self.model,
                serial_number: self.serial_number,
                location: self.location,
                site_id: self.site_id,
            })
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("global_network_id", &self.global_network_id);
            formatter.field("device_id", &self.device_id);
            formatter.field("aws_location", &self.aws_location);
            formatter.field("description", &self.description);
            formatter.field("r#type", &self.r#type);
            formatter.field("vendor", &self.vendor);
            formatter.field("model", &self.model);
            formatter.field("serial_number", &self.serial_number);
            formatter.field("location", &"*** Sensitive Data Redacted ***");
            formatter.field("site_id", &self.site_id);
            formatter.finish()
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The description of the update.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The description of the update.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateCoreNetworkInput {
    /// Creates a new builder-style object to manufacture [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput).
    pub fn builder() -> crate::input::update_core_network_input::Builder {
        crate::input::update_core_network_input::Builder::default()
    }
}

/// See [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput).
pub mod update_core_network_input {

    /// A builder for [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The description of the update.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the update.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateCoreNetworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateCoreNetworkInput {
                core_network_id: self.core_network_id,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateConnectionInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the connection.</p>
    #[doc(hidden)]
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the first device in the connection.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the second device in the connection.</p>
    #[doc(hidden)]
    pub connected_link_id: std::option::Option<std::string::String>,
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateConnectionInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
    /// <p>The ID of the link for the first device in the connection.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>The ID of the link for the second device in the connection.</p>
    pub fn connected_link_id(&self) -> std::option::Option<&str> {
        self.connected_link_id.as_deref()
    }
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateConnectionInput {
    /// Creates a new builder-style object to manufacture [`UpdateConnectionInput`](crate::input::UpdateConnectionInput).
    pub fn builder() -> crate::input::update_connection_input::Builder {
        crate::input::update_connection_input::Builder::default()
    }
}

/// See [`UpdateConnectionInput`](crate::input::UpdateConnectionInput).
pub mod update_connection_input {

    /// A builder for [`UpdateConnectionInput`](crate::input::UpdateConnectionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) connected_link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The ID of the link for the first device in the connection.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the first device in the connection.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>The ID of the link for the second device in the connection.</p>
        pub fn connected_link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the second device in the connection.</p>
        pub fn set_connected_link_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connected_link_id = input;
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateConnectionInput`](crate::input::UpdateConnectionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::UpdateConnectionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::UpdateConnectionInput {
                global_network_id: self.global_network_id,
                connection_id: self.connection_id,
                link_id: self.link_id,
                connected_link_id: self.connected_link_id,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag keys to remove from the specified resource.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag keys to remove from the specified resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys to remove from the specified resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys to remove from the specified resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the specified resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tags to apply to the specified resource.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the specified resource.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the specified resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The source from which traffic originates.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
    /// <p>The destination.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
    /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub include_return_path: bool,
    /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
    #[doc(hidden)]
    pub use_middleboxes: bool,
}
impl StartRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The source from which traffic originates.</p>
    pub fn source(
        &self,
    ) -> std::option::Option<&crate::model::RouteAnalysisEndpointOptionsSpecification> {
        self.source.as_ref()
    }
    /// <p>The destination.</p>
    pub fn destination(
        &self,
    ) -> std::option::Option<&crate::model::RouteAnalysisEndpointOptionsSpecification> {
        self.destination.as_ref()
    }
    /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
    pub fn include_return_path(&self) -> bool {
        self.include_return_path
    }
    /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
    pub fn use_middleboxes(&self) -> bool {
        self.use_middleboxes
    }
}
impl StartRouteAnalysisInput {
    /// Creates a new builder-style object to manufacture [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput).
    pub fn builder() -> crate::input::start_route_analysis_input::Builder {
        crate::input::start_route_analysis_input::Builder::default()
    }
}

/// See [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput).
pub mod start_route_analysis_input {

    /// A builder for [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) source:
            std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        pub(crate) destination:
            std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        pub(crate) include_return_path: std::option::Option<bool>,
        pub(crate) use_middleboxes: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The source from which traffic originates.</p>
        pub fn source(
            mut self,
            input: crate::model::RouteAnalysisEndpointOptionsSpecification,
        ) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source from which traffic originates.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The destination.</p>
        pub fn destination(
            mut self,
            input: crate::model::RouteAnalysisEndpointOptionsSpecification,
        ) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The destination.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
        pub fn include_return_path(mut self, input: bool) -> Self {
            self.include_return_path = Some(input);
            self
        }
        /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
        pub fn set_include_return_path(mut self, input: std::option::Option<bool>) -> Self {
            self.include_return_path = input;
            self
        }
        /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
        pub fn use_middleboxes(mut self, input: bool) -> Self {
            self.use_middleboxes = Some(input);
            self
        }
        /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
        pub fn set_use_middleboxes(mut self, input: std::option::Option<bool>) -> Self {
            self.use_middleboxes = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartRouteAnalysisInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartRouteAnalysisInput {
                global_network_id: self.global_network_id,
                source: self.source,
                destination: self.destination,
                include_return_path: self.include_return_path.unwrap_or_default(),
                use_middleboxes: self.use_middleboxes.unwrap_or_default(),
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartOrganizationServiceAccessUpdateInput {
    /// <p>The action to take for the update request. This can be either <code>ENABLE</code> or <code>DISABLE</code>.</p>
    #[doc(hidden)]
    pub action: std::option::Option<std::string::String>,
}
impl StartOrganizationServiceAccessUpdateInput {
    /// <p>The action to take for the update request. This can be either <code>ENABLE</code> or <code>DISABLE</code>.</p>
    pub fn action(&self) -> std::option::Option<&str> {
        self.action.as_deref()
    }
}
impl StartOrganizationServiceAccessUpdateInput {
    /// Creates a new builder-style object to manufacture [`StartOrganizationServiceAccessUpdateInput`](crate::input::StartOrganizationServiceAccessUpdateInput).
    pub fn builder() -> crate::input::start_organization_service_access_update_input::Builder {
        crate::input::start_organization_service_access_update_input::Builder::default()
    }
}

/// See [`StartOrganizationServiceAccessUpdateInput`](crate::input::StartOrganizationServiceAccessUpdateInput).
pub mod start_organization_service_access_update_input {

    /// A builder for [`StartOrganizationServiceAccessUpdateInput`](crate::input::StartOrganizationServiceAccessUpdateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to take for the update request. This can be either <code>ENABLE</code> or <code>DISABLE</code>.</p>
        pub fn action(mut self, input: impl Into<std::string::String>) -> Self {
            self.action = Some(input.into());
            self
        }
        /// <p>The action to take for the update request. This can be either <code>ENABLE</code> or <code>DISABLE</code>.</p>
        pub fn set_action(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.action = input;
            self
        }
        /// Consumes the builder and constructs a [`StartOrganizationServiceAccessUpdateInput`](crate::input::StartOrganizationServiceAccessUpdateInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::StartOrganizationServiceAccessUpdateInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::StartOrganizationServiceAccessUpdateInput {
                action: self.action,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RestoreCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version to restore.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
}
impl RestoreCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version to restore.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
}
impl RestoreCoreNetworkPolicyVersionInput {
    /// Creates a new builder-style object to manufacture [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput).
    pub fn builder() -> crate::input::restore_core_network_policy_version_input::Builder {
        crate::input::restore_core_network_policy_version_input::Builder::default()
    }
}

/// See [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput).
pub mod restore_core_network_policy_version_input {

    /// A builder for [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version to restore.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version to restore.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::RestoreCoreNetworkPolicyVersionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::RestoreCoreNetworkPolicyVersionInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RejectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl RejectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl RejectAttachmentInput {
    /// Creates a new builder-style object to manufacture [`RejectAttachmentInput`](crate::input::RejectAttachmentInput).
    pub fn builder() -> crate::input::reject_attachment_input::Builder {
        crate::input::reject_attachment_input::Builder::default()
    }
}

/// See [`RejectAttachmentInput`](crate::input::RejectAttachmentInput).
pub mod reject_attachment_input {

    /// A builder for [`RejectAttachmentInput`](crate::input::RejectAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RejectAttachmentInput`](crate::input::RejectAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::RejectAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::RejectAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RegisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    #[doc(hidden)]
    pub transit_gateway_arn: std::option::Option<std::string::String>,
}
impl RegisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_arn.as_deref()
    }
}
impl RegisterTransitGatewayInput {
    /// Creates a new builder-style object to manufacture [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput).
    pub fn builder() -> crate::input::register_transit_gateway_input::Builder {
        crate::input::register_transit_gateway_input::Builder::default()
    }
}

/// See [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput).
pub mod register_transit_gateway_input {

    /// A builder for [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn set_transit_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::RegisterTransitGatewayInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::RegisterTransitGatewayInput {
                global_network_id: self.global_network_id,
                transit_gateway_arn: self.transit_gateway_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutResourcePolicyInput {
    /// <p>The JSON resource policy document.</p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource policy. </p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl PutResourcePolicyInput {
    /// <p>The JSON resource policy document.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>The ARN of the resource policy. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl PutResourcePolicyInput {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput).
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
}

/// See [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput).
pub mod put_resource_policy_input {

    /// A builder for [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The JSON resource policy document.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The JSON resource policy document.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>The ARN of the resource policy. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource policy. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutResourcePolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutResourcePolicyInput {
                policy_document: self.policy_document,
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The policy document.</p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>a core network policy description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of a core network policy. </p>
    #[doc(hidden)]
    pub latest_version_id: std::option::Option<i32>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl PutCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The policy document.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>a core network policy description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of a core network policy. </p>
    pub fn latest_version_id(&self) -> std::option::Option<i32> {
        self.latest_version_id
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl PutCoreNetworkPolicyInput {
    /// Creates a new builder-style object to manufacture [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput).
    pub fn builder() -> crate::input::put_core_network_policy_input::Builder {
        crate::input::put_core_network_policy_input::Builder::default()
    }
}

/// See [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput).
pub mod put_core_network_policy_input {

    /// A builder for [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) latest_version_id: std::option::Option<i32>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The policy document.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The policy document.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>a core network policy description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>a core network policy description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of a core network policy. </p>
        pub fn latest_version_id(mut self, input: i32) -> Self {
            self.latest_version_id = Some(input);
            self
        }
        /// <p>The ID of a core network policy. </p>
        pub fn set_latest_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.latest_version_id = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutCoreNetworkPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutCoreNetworkPolicyInput {
                core_network_id: self.core_network_id,
                policy_document: self.policy_document,
                description: self.description,
                latest_version_id: self.latest_version_id,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListPeeringsInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>Returns a list of a peering requests.</p>
    #[doc(hidden)]
    pub peering_type: std::option::Option<crate::model::PeeringType>,
    /// <p>Returns a list edge locations for the </p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>Returns a list of the peering request states.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::PeeringState>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPeeringsInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>Returns a list of a peering requests.</p>
    pub fn peering_type(&self) -> std::option::Option<&crate::model::PeeringType> {
        self.peering_type.as_ref()
    }
    /// <p>Returns a list edge locations for the </p>
    pub fn edge_location(&self) -> std::option::Option<&str> {
        self.edge_location.as_deref()
    }
    /// <p>Returns a list of the peering request states.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::PeeringState> {
        self.state.as_ref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListPeeringsInput {
    /// Creates a new builder-style object to manufacture [`ListPeeringsInput`](crate::input::ListPeeringsInput).
    pub fn builder() -> crate::input::list_peerings_input::Builder {
        crate::input::list_peerings_input::Builder::default()
    }
}

/// See [`ListPeeringsInput`](crate::input::ListPeeringsInput).
pub mod list_peerings_input {

    /// A builder for [`ListPeeringsInput`](crate::input::ListPeeringsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) peering_type: std::option::Option<crate::model::PeeringType>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::PeeringState>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>Returns a list of a peering requests.</p>
        pub fn peering_type(mut self, input: crate::model::PeeringType) -> Self {
            self.peering_type = Some(input);
            self
        }
        /// <p>Returns a list of a peering requests.</p>
        pub fn set_peering_type(
            mut self,
            input: std::option::Option<crate::model::PeeringType>,
        ) -> Self {
            self.peering_type = input;
            self
        }
        /// <p>Returns a list edge locations for the </p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>Returns a list edge locations for the </p>
        pub fn set_edge_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_location = input;
            self
        }
        /// <p>Returns a list of the peering request states.</p>
        pub fn state(mut self, input: crate::model::PeeringState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Returns a list of the peering request states.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::PeeringState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPeeringsInput`](crate::input::ListPeeringsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListPeeringsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListPeeringsInput {
                core_network_id: self.core_network_id,
                peering_type: self.peering_type,
                edge_location: self.edge_location,
                state: self.state,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListOrganizationServiceAccessStatusInput {
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListOrganizationServiceAccessStatusInput {
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListOrganizationServiceAccessStatusInput {
    /// Creates a new builder-style object to manufacture [`ListOrganizationServiceAccessStatusInput`](crate::input::ListOrganizationServiceAccessStatusInput).
    pub fn builder() -> crate::input::list_organization_service_access_status_input::Builder {
        crate::input::list_organization_service_access_status_input::Builder::default()
    }
}

/// See [`ListOrganizationServiceAccessStatusInput`](crate::input::ListOrganizationServiceAccessStatusInput).
pub mod list_organization_service_access_status_input {

    /// A builder for [`ListOrganizationServiceAccessStatusInput`](crate::input::ListOrganizationServiceAccessStatusInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListOrganizationServiceAccessStatusInput`](crate::input::ListOrganizationServiceAccessStatusInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListOrganizationServiceAccessStatusInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListOrganizationServiceAccessStatusInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCoreNetworksInput {
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCoreNetworksInput {
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListCoreNetworksInput {
    /// Creates a new builder-style object to manufacture [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput).
    pub fn builder() -> crate::input::list_core_networks_input::Builder {
        crate::input::list_core_networks_input::Builder::default()
    }
}

/// See [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput).
pub mod list_core_networks_input {

    /// A builder for [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListCoreNetworksInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListCoreNetworksInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCoreNetworkPolicyVersionsInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCoreNetworkPolicyVersionsInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListCoreNetworkPolicyVersionsInput {
    /// Creates a new builder-style object to manufacture [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput).
    pub fn builder() -> crate::input::list_core_network_policy_versions_input::Builder {
        crate::input::list_core_network_policy_versions_input::Builder::default()
    }
}

/// See [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput).
pub mod list_core_network_policy_versions_input {

    /// A builder for [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListCoreNetworkPolicyVersionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListCoreNetworkPolicyVersionsInput {
                core_network_id: self.core_network_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListConnectPeersInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub connect_attachment_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListConnectPeersInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the attachment.</p>
    pub fn connect_attachment_id(&self) -> std::option::Option<&str> {
        self.connect_attachment_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListConnectPeersInput {
    /// Creates a new builder-style object to manufacture [`ListConnectPeersInput`](crate::input::ListConnectPeersInput).
    pub fn builder() -> crate::input::list_connect_peers_input::Builder {
        crate::input::list_connect_peers_input::Builder::default()
    }
}

/// See [`ListConnectPeersInput`](crate::input::ListConnectPeersInput).
pub mod list_connect_peers_input {

    /// A builder for [`ListConnectPeersInput`](crate::input::ListConnectPeersInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_attachment_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn connect_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_connect_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_attachment_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListConnectPeersInput`](crate::input::ListConnectPeersInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListConnectPeersInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListConnectPeersInput {
                core_network_id: self.core_network_id,
                connect_attachment_id: self.connect_attachment_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListAttachmentsInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The type of attachment.</p>
    #[doc(hidden)]
    pub attachment_type: std::option::Option<crate::model::AttachmentType>,
    /// <p>The Region where the edge is located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The state of the attachment.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AttachmentState>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAttachmentsInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The type of attachment.</p>
    pub fn attachment_type(&self) -> std::option::Option<&crate::model::AttachmentType> {
        self.attachment_type.as_ref()
    }
    /// <p>The Region where the edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<&str> {
        self.edge_location.as_deref()
    }
    /// <p>The state of the attachment.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AttachmentState> {
        self.state.as_ref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListAttachmentsInput {
    /// Creates a new builder-style object to manufacture [`ListAttachmentsInput`](crate::input::ListAttachmentsInput).
    pub fn builder() -> crate::input::list_attachments_input::Builder {
        crate::input::list_attachments_input::Builder::default()
    }
}

/// See [`ListAttachmentsInput`](crate::input::ListAttachmentsInput).
pub mod list_attachments_input {

    /// A builder for [`ListAttachmentsInput`](crate::input::ListAttachmentsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) attachment_type: std::option::Option<crate::model::AttachmentType>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::AttachmentState>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The type of attachment.</p>
        pub fn attachment_type(mut self, input: crate::model::AttachmentType) -> Self {
            self.attachment_type = Some(input);
            self
        }
        /// <p>The type of attachment.</p>
        pub fn set_attachment_type(
            mut self,
            input: std::option::Option<crate::model::AttachmentType>,
        ) -> Self {
            self.attachment_type = input;
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn set_edge_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_location = input;
            self
        }
        /// <p>The state of the attachment.</p>
        pub fn state(mut self, input: crate::model::AttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the attachment.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAttachmentsInput`](crate::input::ListAttachmentsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListAttachmentsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListAttachmentsInput {
                core_network_id: self.core_network_id,
                attachment_type: self.attachment_type,
                edge_location: self.edge_location,
                state: self.state,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl GetVpcAttachmentInput {
    /// Creates a new builder-style object to manufacture [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput).
    pub fn builder() -> crate::input::get_vpc_attachment_input::Builder {
        crate::input::get_vpc_attachment_input::Builder::default()
    }
}

/// See [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput).
pub mod get_vpc_attachment_input {

    /// A builder for [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetVpcAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetVpcAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTransitGatewayRouteTableAttachmentInput {
    /// <p>The ID of the transit gateway route table attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetTransitGatewayRouteTableAttachmentInput {
    /// <p>The ID of the transit gateway route table attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl GetTransitGatewayRouteTableAttachmentInput {
    /// Creates a new builder-style object to manufacture [`GetTransitGatewayRouteTableAttachmentInput`](crate::input::GetTransitGatewayRouteTableAttachmentInput).
    pub fn builder() -> crate::input::get_transit_gateway_route_table_attachment_input::Builder {
        crate::input::get_transit_gateway_route_table_attachment_input::Builder::default()
    }
}

/// See [`GetTransitGatewayRouteTableAttachmentInput`](crate::input::GetTransitGatewayRouteTableAttachmentInput).
pub mod get_transit_gateway_route_table_attachment_input {

    /// A builder for [`GetTransitGatewayRouteTableAttachmentInput`](crate::input::GetTransitGatewayRouteTableAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the transit gateway route table attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the transit gateway route table attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTransitGatewayRouteTableAttachmentInput`](crate::input::GetTransitGatewayRouteTableAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetTransitGatewayRouteTableAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetTransitGatewayRouteTableAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTransitGatewayRegistrationsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
    #[doc(hidden)]
    pub transit_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetTransitGatewayRegistrationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
    pub fn transit_gateway_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.transit_gateway_arns.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetTransitGatewayRegistrationsInput {
    /// Creates a new builder-style object to manufacture [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput).
    pub fn builder() -> crate::input::get_transit_gateway_registrations_input::Builder {
        crate::input::get_transit_gateway_registrations_input::Builder::default()
    }
}

/// See [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput).
pub mod get_transit_gateway_registrations_input {

    /// A builder for [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `transit_gateway_arns`.
        ///
        /// To override the contents of this collection use [`set_transit_gateway_arns`](Self::set_transit_gateway_arns).
        ///
        /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
        pub fn transit_gateway_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.transit_gateway_arns.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
        pub fn set_transit_gateway_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_arns = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetTransitGatewayRegistrationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetTransitGatewayRegistrationsInput {
                global_network_id: self.global_network_id,
                transit_gateway_arns: self.transit_gateway_arns,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTransitGatewayPeeringInput {
    /// <p>The ID of the peering request.</p>
    #[doc(hidden)]
    pub peering_id: std::option::Option<std::string::String>,
}
impl GetTransitGatewayPeeringInput {
    /// <p>The ID of the peering request.</p>
    pub fn peering_id(&self) -> std::option::Option<&str> {
        self.peering_id.as_deref()
    }
}
impl GetTransitGatewayPeeringInput {
    /// Creates a new builder-style object to manufacture [`GetTransitGatewayPeeringInput`](crate::input::GetTransitGatewayPeeringInput).
    pub fn builder() -> crate::input::get_transit_gateway_peering_input::Builder {
        crate::input::get_transit_gateway_peering_input::Builder::default()
    }
}

/// See [`GetTransitGatewayPeeringInput`](crate::input::GetTransitGatewayPeeringInput).
pub mod get_transit_gateway_peering_input {

    /// A builder for [`GetTransitGatewayPeeringInput`](crate::input::GetTransitGatewayPeeringInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) peering_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the peering request.</p>
        pub fn peering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_id = Some(input.into());
            self
        }
        /// <p>The ID of the peering request.</p>
        pub fn set_peering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peering_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTransitGatewayPeeringInput`](crate::input::GetTransitGatewayPeeringInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetTransitGatewayPeeringInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetTransitGatewayPeeringInput {
                peering_id: self.peering_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTransitGatewayConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
    #[doc(hidden)]
    pub transit_gateway_connect_peer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetTransitGatewayConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
    pub fn transit_gateway_connect_peer_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.transit_gateway_connect_peer_arns.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetTransitGatewayConnectPeerAssociationsInput {
    /// Creates a new builder-style object to manufacture [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput).
    pub fn builder() -> crate::input::get_transit_gateway_connect_peer_associations_input::Builder {
        crate::input::get_transit_gateway_connect_peer_associations_input::Builder::default()
    }
}

/// See [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput).
pub mod get_transit_gateway_connect_peer_associations_input {

    /// A builder for [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `transit_gateway_connect_peer_arns`.
        ///
        /// To override the contents of this collection use [`set_transit_gateway_connect_peer_arns`](Self::set_transit_gateway_connect_peer_arns).
        ///
        /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
        pub fn transit_gateway_connect_peer_arns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.transit_gateway_connect_peer_arns.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_connect_peer_arns = Some(v);
            self
        }
        /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
        pub fn set_transit_gateway_connect_peer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_connect_peer_arns = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetTransitGatewayConnectPeerAssociationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::GetTransitGatewayConnectPeerAssociationsInput {
                    global_network_id: self.global_network_id,
                    transit_gateway_connect_peer_arns: self.transit_gateway_connect_peer_arns,
                    max_results: self.max_results,
                    next_token: self.next_token,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSiteToSiteVpnAttachmentInput {
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetSiteToSiteVpnAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl GetSiteToSiteVpnAttachmentInput {
    /// Creates a new builder-style object to manufacture [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput).
    pub fn builder() -> crate::input::get_site_to_site_vpn_attachment_input::Builder {
        crate::input::get_site_to_site_vpn_attachment_input::Builder::default()
    }
}

/// See [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput).
pub mod get_site_to_site_vpn_attachment_input {

    /// A builder for [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetSiteToSiteVpnAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetSiteToSiteVpnAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetSitesInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more site IDs. The maximum is 10.</p>
    #[doc(hidden)]
    pub site_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetSitesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more site IDs. The maximum is 10.</p>
    pub fn site_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.site_ids.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetSitesInput {
    /// Creates a new builder-style object to manufacture [`GetSitesInput`](crate::input::GetSitesInput).
    pub fn builder() -> crate::input::get_sites_input::Builder {
        crate::input::get_sites_input::Builder::default()
    }
}

/// See [`GetSitesInput`](crate::input::GetSitesInput).
pub mod get_sites_input {

    /// A builder for [`GetSitesInput`](crate::input::GetSitesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `site_ids`.
        ///
        /// To override the contents of this collection use [`set_site_ids`](Self::set_site_ids).
        ///
        /// <p>One or more site IDs. The maximum is 10.</p>
        pub fn site_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.site_ids.unwrap_or_default();
            v.push(input.into());
            self.site_ids = Some(v);
            self
        }
        /// <p>One or more site IDs. The maximum is 10.</p>
        pub fn set_site_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.site_ids = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSitesInput`](crate::input::GetSitesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetSitesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetSitesInput {
                global_network_id: self.global_network_id,
                site_ids: self.site_ids,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the route analysis.</p>
    #[doc(hidden)]
    pub route_analysis_id: std::option::Option<std::string::String>,
}
impl GetRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the route analysis.</p>
    pub fn route_analysis_id(&self) -> std::option::Option<&str> {
        self.route_analysis_id.as_deref()
    }
}
impl GetRouteAnalysisInput {
    /// Creates a new builder-style object to manufacture [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput).
    pub fn builder() -> crate::input::get_route_analysis_input::Builder {
        crate::input::get_route_analysis_input::Builder::default()
    }
}

/// See [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput).
pub mod get_route_analysis_input {

    /// A builder for [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) route_analysis_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the route analysis.</p>
        pub fn route_analysis_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_analysis_id = Some(input.into());
            self
        }
        /// <p>The ID of the route analysis.</p>
        pub fn set_route_analysis_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.route_analysis_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetRouteAnalysisInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetRouteAnalysisInput {
                global_network_id: self.global_network_id,
                route_analysis_id: self.route_analysis_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetResourcePolicyInput {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl GetResourcePolicyInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl GetResourcePolicyInput {
    /// Creates a new builder-style object to manufacture [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput).
    pub fn builder() -> crate::input::get_resource_policy_input::Builder {
        crate::input::get_resource_policy_input::Builder::default()
    }
}

/// See [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput).
pub mod get_resource_policy_input {

    /// A builder for [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetResourcePolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetResourcePolicyInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetNetworkTelemetryInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the gateway.</p>
    #[doc(hidden)]
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkTelemetryInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<&str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetNetworkTelemetryInput {
    /// Creates a new builder-style object to manufacture [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput).
    pub fn builder() -> crate::input::get_network_telemetry_input::Builder {
        crate::input::get_network_telemetry_input::Builder::default()
    }
}

/// See [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput).
pub mod get_network_telemetry_input {

    /// A builder for [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_gateway_arn = input;
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetNetworkTelemetryInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetNetworkTelemetryInput {
                global_network_id: self.global_network_id,
                core_network_id: self.core_network_id,
                registered_gateway_arn: self.registered_gateway_arn,
                aws_region: self.aws_region,
                account_id: self.account_id,
                resource_type: self.resource_type,
                resource_arn: self.resource_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetNetworkRoutesInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the route table.</p>
    #[doc(hidden)]
    pub route_table_identifier: std::option::Option<crate::model::RouteTableIdentifier>,
    /// <p>An exact CIDR block.</p>
    #[doc(hidden)]
    pub exact_cidr_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The most specific route that matches the traffic (longest prefix match).</p>
    #[doc(hidden)]
    pub longest_prefix_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The routes with a subnet that match the specified CIDR filter.</p>
    #[doc(hidden)]
    pub subnet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
    #[doc(hidden)]
    pub supernet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IDs of the prefix lists.</p>
    #[doc(hidden)]
    pub prefix_list_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The route states.</p>
    #[doc(hidden)]
    pub states: std::option::Option<std::vec::Vec<crate::model::RouteState>>,
    /// <p>The route types.</p>
    #[doc(hidden)]
    pub types: std::option::Option<std::vec::Vec<crate::model::RouteType>>,
    /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
    #[doc(hidden)]
    pub destination_filters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl GetNetworkRoutesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the route table.</p>
    pub fn route_table_identifier(
        &self,
    ) -> std::option::Option<&crate::model::RouteTableIdentifier> {
        self.route_table_identifier.as_ref()
    }
    /// <p>An exact CIDR block.</p>
    pub fn exact_cidr_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.exact_cidr_matches.as_deref()
    }
    /// <p>The most specific route that matches the traffic (longest prefix match).</p>
    pub fn longest_prefix_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.longest_prefix_matches.as_deref()
    }
    /// <p>The routes with a subnet that match the specified CIDR filter.</p>
    pub fn subnet_of_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_of_matches.as_deref()
    }
    /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
    pub fn supernet_of_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.supernet_of_matches.as_deref()
    }
    /// <p>The IDs of the prefix lists.</p>
    pub fn prefix_list_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.prefix_list_ids.as_deref()
    }
    /// <p>The route states.</p>
    pub fn states(&self) -> std::option::Option<&[crate::model::RouteState]> {
        self.states.as_deref()
    }
    /// <p>The route types.</p>
    pub fn types(&self) -> std::option::Option<&[crate::model::RouteType]> {
        self.types.as_deref()
    }
    /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
    pub fn destination_filters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.destination_filters.as_ref()
    }
}
impl GetNetworkRoutesInput {
    /// Creates a new builder-style object to manufacture [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput).
    pub fn builder() -> crate::input::get_network_routes_input::Builder {
        crate::input::get_network_routes_input::Builder::default()
    }
}

/// See [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput).
pub mod get_network_routes_input {

    /// A builder for [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) route_table_identifier: std::option::Option<crate::model::RouteTableIdentifier>,
        pub(crate) exact_cidr_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) longest_prefix_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supernet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) prefix_list_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) states: std::option::Option<std::vec::Vec<crate::model::RouteState>>,
        pub(crate) types: std::option::Option<std::vec::Vec<crate::model::RouteType>>,
        pub(crate) destination_filters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_identifier(mut self, input: crate::model::RouteTableIdentifier) -> Self {
            self.route_table_identifier = Some(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn set_route_table_identifier(
            mut self,
            input: std::option::Option<crate::model::RouteTableIdentifier>,
        ) -> Self {
            self.route_table_identifier = input;
            self
        }
        /// Appends an item to `exact_cidr_matches`.
        ///
        /// To override the contents of this collection use [`set_exact_cidr_matches`](Self::set_exact_cidr_matches).
        ///
        /// <p>An exact CIDR block.</p>
        pub fn exact_cidr_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exact_cidr_matches.unwrap_or_default();
            v.push(input.into());
            self.exact_cidr_matches = Some(v);
            self
        }
        /// <p>An exact CIDR block.</p>
        pub fn set_exact_cidr_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exact_cidr_matches = input;
            self
        }
        /// Appends an item to `longest_prefix_matches`.
        ///
        /// To override the contents of this collection use [`set_longest_prefix_matches`](Self::set_longest_prefix_matches).
        ///
        /// <p>The most specific route that matches the traffic (longest prefix match).</p>
        pub fn longest_prefix_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.longest_prefix_matches.unwrap_or_default();
            v.push(input.into());
            self.longest_prefix_matches = Some(v);
            self
        }
        /// <p>The most specific route that matches the traffic (longest prefix match).</p>
        pub fn set_longest_prefix_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.longest_prefix_matches = input;
            self
        }
        /// Appends an item to `subnet_of_matches`.
        ///
        /// To override the contents of this collection use [`set_subnet_of_matches`](Self::set_subnet_of_matches).
        ///
        /// <p>The routes with a subnet that match the specified CIDR filter.</p>
        pub fn subnet_of_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_of_matches.unwrap_or_default();
            v.push(input.into());
            self.subnet_of_matches = Some(v);
            self
        }
        /// <p>The routes with a subnet that match the specified CIDR filter.</p>
        pub fn set_subnet_of_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_of_matches = input;
            self
        }
        /// Appends an item to `supernet_of_matches`.
        ///
        /// To override the contents of this collection use [`set_supernet_of_matches`](Self::set_supernet_of_matches).
        ///
        /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
        pub fn supernet_of_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supernet_of_matches.unwrap_or_default();
            v.push(input.into());
            self.supernet_of_matches = Some(v);
            self
        }
        /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
        pub fn set_supernet_of_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supernet_of_matches = input;
            self
        }
        /// Appends an item to `prefix_list_ids`.
        ///
        /// To override the contents of this collection use [`set_prefix_list_ids`](Self::set_prefix_list_ids).
        ///
        /// <p>The IDs of the prefix lists.</p>
        pub fn prefix_list_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.prefix_list_ids.unwrap_or_default();
            v.push(input.into());
            self.prefix_list_ids = Some(v);
            self
        }
        /// <p>The IDs of the prefix lists.</p>
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.prefix_list_ids = input;
            self
        }
        /// Appends an item to `states`.
        ///
        /// To override the contents of this collection use [`set_states`](Self::set_states).
        ///
        /// <p>The route states.</p>
        pub fn states(mut self, input: crate::model::RouteState) -> Self {
            let mut v = self.states.unwrap_or_default();
            v.push(input);
            self.states = Some(v);
            self
        }
        /// <p>The route states.</p>
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RouteState>>,
        ) -> Self {
            self.states = input;
            self
        }
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>The route types.</p>
        pub fn types(mut self, input: crate::model::RouteType) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input);
            self.types = Some(v);
            self
        }
        /// <p>The route types.</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RouteType>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// Adds a key-value pair to `destination_filters`.
        ///
        /// To override the contents of this collection use [`set_destination_filters`](Self::set_destination_filters).
        ///
        /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
        pub fn destination_filters(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.destination_filters.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.destination_filters = Some(hash_map);
            self
        }
        /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
        pub fn set_destination_filters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.destination_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetNetworkRoutesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetNetworkRoutesInput {
                global_network_id: self.global_network_id,
                route_table_identifier: self.route_table_identifier,
                exact_cidr_matches: self.exact_cidr_matches,
                longest_prefix_matches: self.longest_prefix_matches,
                subnet_of_matches: self.subnet_of_matches,
                supernet_of_matches: self.supernet_of_matches,
                prefix_list_ids: self.prefix_list_ids,
                states: self.states,
                types: self.types,
                destination_filters: self.destination_filters,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetNetworkResourcesInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the gateway.</p>
    #[doc(hidden)]
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
    /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
    /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
    /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
    /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkResourcesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<&str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
    /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
    /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
    /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
    /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetNetworkResourcesInput {
    /// Creates a new builder-style object to manufacture [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput).
    pub fn builder() -> crate::input::get_network_resources_input::Builder {
        crate::input::get_network_resources_input::Builder::default()
    }
}

/// See [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput).
pub mod get_network_resources_input {

    /// A builder for [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_gateway_arn = input;
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
        /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
        /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
        /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
        /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
        /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
        /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
        /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
        /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetNetworkResourcesInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetNetworkResourcesInput {
                global_network_id: self.global_network_id,
                core_network_id: self.core_network_id,
                registered_gateway_arn: self.registered_gateway_arn,
                aws_region: self.aws_region,
                account_id: self.account_id,
                resource_type: self.resource_type,
                resource_arn: self.resource_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetNetworkResourceRelationshipsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the registered gateway.</p>
    #[doc(hidden)]
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the gateway.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkResourceRelationshipsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the registered gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<&str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ARN of the gateway.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetNetworkResourceRelationshipsInput {
    /// Creates a new builder-style object to manufacture [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput).
    pub fn builder() -> crate::input::get_network_resource_relationships_input::Builder {
        crate::input::get_network_resource_relationships_input::Builder::default()
    }
}

/// See [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput).
pub mod get_network_resource_relationships_input {

    /// A builder for [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the registered gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the registered gateway.</p>
        pub fn set_registered_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_gateway_arn = input;
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetNetworkResourceRelationshipsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetNetworkResourceRelationshipsInput {
                global_network_id: self.global_network_id,
                core_network_id: self.core_network_id,
                registered_gateway_arn: self.registered_gateway_arn,
                aws_region: self.aws_region,
                account_id: self.account_id,
                resource_type: self.resource_type,
                resource_arn: self.resource_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetNetworkResourceCountsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkResourceCountsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetNetworkResourceCountsInput {
    /// Creates a new builder-style object to manufacture [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput).
    pub fn builder() -> crate::input::get_network_resource_counts_input::Builder {
        crate::input::get_network_resource_counts_input::Builder::default()
    }
}

/// See [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput).
pub mod get_network_resource_counts_input {

    /// A builder for [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetNetworkResourceCountsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetNetworkResourceCountsInput {
                global_network_id: self.global_network_id,
                resource_type: self.resource_type,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLinksInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more link IDs. The maximum is 10.</p>
    #[doc(hidden)]
    pub link_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The link type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The link provider.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetLinksInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more link IDs. The maximum is 10.</p>
    pub fn link_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.link_ids.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The link type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The link provider.</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetLinksInput {
    /// Creates a new builder-style object to manufacture [`GetLinksInput`](crate::input::GetLinksInput).
    pub fn builder() -> crate::input::get_links_input::Builder {
        crate::input::get_links_input::Builder::default()
    }
}

/// See [`GetLinksInput`](crate::input::GetLinksInput).
pub mod get_links_input {

    /// A builder for [`GetLinksInput`](crate::input::GetLinksInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) link_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) provider: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `link_ids`.
        ///
        /// To override the contents of this collection use [`set_link_ids`](Self::set_link_ids).
        ///
        /// <p>One or more link IDs. The maximum is 10.</p>
        pub fn link_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.link_ids.unwrap_or_default();
            v.push(input.into());
            self.link_ids = Some(v);
            self
        }
        /// <p>One or more link IDs. The maximum is 10.</p>
        pub fn set_link_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.link_ids = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The link type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The link type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The link provider.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The link provider.</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLinksInput`](crate::input::GetLinksInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetLinksInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetLinksInput {
                global_network_id: self.global_network_id,
                link_ids: self.link_ids,
                site_id: self.site_id,
                r#type: self.r#type,
                provider: self.provider,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLinkAssociationsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetLinkAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetLinkAssociationsInput {
    /// Creates a new builder-style object to manufacture [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput).
    pub fn builder() -> crate::input::get_link_associations_input::Builder {
        crate::input::get_link_associations_input::Builder::default()
    }
}

/// See [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput).
pub mod get_link_associations_input {

    /// A builder for [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetLinkAssociationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetLinkAssociationsInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDevicesInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more device IDs. The maximum is 10.</p>
    #[doc(hidden)]
    pub device_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetDevicesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more device IDs. The maximum is 10.</p>
    pub fn device_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.device_ids.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetDevicesInput {
    /// Creates a new builder-style object to manufacture [`GetDevicesInput`](crate::input::GetDevicesInput).
    pub fn builder() -> crate::input::get_devices_input::Builder {
        crate::input::get_devices_input::Builder::default()
    }
}

/// See [`GetDevicesInput`](crate::input::GetDevicesInput).
pub mod get_devices_input {

    /// A builder for [`GetDevicesInput`](crate::input::GetDevicesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `device_ids`.
        ///
        /// To override the contents of this collection use [`set_device_ids`](Self::set_device_ids).
        ///
        /// <p>One or more device IDs. The maximum is 10.</p>
        pub fn device_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.device_ids.unwrap_or_default();
            v.push(input.into());
            self.device_ids = Some(v);
            self
        }
        /// <p>One or more device IDs. The maximum is 10.</p>
        pub fn set_device_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.device_ids = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDevicesInput`](crate::input::GetDevicesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetDevicesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetDevicesInput {
                global_network_id: self.global_network_id,
                device_ids: self.device_ids,
                site_id: self.site_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCustomerGatewayAssociationsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
    #[doc(hidden)]
    pub customer_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCustomerGatewayAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
    pub fn customer_gateway_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.customer_gateway_arns.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetCustomerGatewayAssociationsInput {
    /// Creates a new builder-style object to manufacture [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput).
    pub fn builder() -> crate::input::get_customer_gateway_associations_input::Builder {
        crate::input::get_customer_gateway_associations_input::Builder::default()
    }
}

/// See [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput).
pub mod get_customer_gateway_associations_input {

    /// A builder for [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `customer_gateway_arns`.
        ///
        /// To override the contents of this collection use [`set_customer_gateway_arns`](Self::set_customer_gateway_arns).
        ///
        /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
        pub fn customer_gateway_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.customer_gateway_arns.unwrap_or_default();
            v.push(input.into());
            self.customer_gateway_arns = Some(v);
            self
        }
        /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
        pub fn set_customer_gateway_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.customer_gateway_arns = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCustomerGatewayAssociationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCustomerGatewayAssociationsInput {
                global_network_id: self.global_network_id,
                customer_gateway_arns: self.customer_gateway_arns,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network policy version.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
    /// <p>The alias of a core network policy </p>
    #[doc(hidden)]
    pub alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
}
impl GetCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of a core network policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>The alias of a core network policy </p>
    pub fn alias(&self) -> std::option::Option<&crate::model::CoreNetworkPolicyAlias> {
        self.alias.as_ref()
    }
}
impl GetCoreNetworkPolicyInput {
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput).
    pub fn builder() -> crate::input::get_core_network_policy_input::Builder {
        crate::input::get_core_network_policy_input::Builder::default()
    }
}

/// See [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput).
pub mod get_core_network_policy_input {

    /// A builder for [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of a core network policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of a core network policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// <p>The alias of a core network policy </p>
        pub fn alias(mut self, input: crate::model::CoreNetworkPolicyAlias) -> Self {
            self.alias = Some(input);
            self
        }
        /// <p>The alias of a core network policy </p>
        pub fn set_alias(
            mut self,
            input: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
        ) -> Self {
            self.alias = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCoreNetworkPolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCoreNetworkPolicyInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
                alias: self.alias,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetCoreNetworkChangeSetInput {
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput).
    pub fn builder() -> crate::input::get_core_network_change_set_input::Builder {
        crate::input::get_core_network_change_set_input::Builder::default()
    }
}

/// See [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput).
pub mod get_core_network_change_set_input {

    /// A builder for [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCoreNetworkChangeSetInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCoreNetworkChangeSetInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCoreNetworkChangeEventsInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCoreNetworkChangeEventsInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetCoreNetworkChangeEventsInput {
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkChangeEventsInput`](crate::input::GetCoreNetworkChangeEventsInput).
    pub fn builder() -> crate::input::get_core_network_change_events_input::Builder {
        crate::input::get_core_network_change_events_input::Builder::default()
    }
}

/// See [`GetCoreNetworkChangeEventsInput`](crate::input::GetCoreNetworkChangeEventsInput).
pub mod get_core_network_change_events_input {

    /// A builder for [`GetCoreNetworkChangeEventsInput`](crate::input::GetCoreNetworkChangeEventsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkChangeEventsInput`](crate::input::GetCoreNetworkChangeEventsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCoreNetworkChangeEventsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCoreNetworkChangeEventsInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
}
impl GetCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
}
impl GetCoreNetworkInput {
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput).
    pub fn builder() -> crate::input::get_core_network_input::Builder {
        crate::input::get_core_network_input::Builder::default()
    }
}

/// See [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput).
pub mod get_core_network_input {

    /// A builder for [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetCoreNetworkInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetCoreNetworkInput {
                core_network_id: self.core_network_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the Connect peers.</p>
    #[doc(hidden)]
    pub connect_peer_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The IDs of the Connect peers.</p>
    pub fn connect_peer_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.connect_peer_ids.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetConnectPeerAssociationsInput {
    /// Creates a new builder-style object to manufacture [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput).
    pub fn builder() -> crate::input::get_connect_peer_associations_input::Builder {
        crate::input::get_connect_peer_associations_input::Builder::default()
    }
}

/// See [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput).
pub mod get_connect_peer_associations_input {

    /// A builder for [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `connect_peer_ids`.
        ///
        /// To override the contents of this collection use [`set_connect_peer_ids`](Self::set_connect_peer_ids).
        ///
        /// <p>The IDs of the Connect peers.</p>
        pub fn connect_peer_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.connect_peer_ids.unwrap_or_default();
            v.push(input.into());
            self.connect_peer_ids = Some(v);
            self
        }
        /// <p>The IDs of the Connect peers.</p>
        pub fn set_connect_peer_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.connect_peer_ids = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetConnectPeerAssociationsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetConnectPeerAssociationsInput {
                global_network_id: self.global_network_id,
                connect_peer_ids: self.connect_peer_ids,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectPeerInput {
    /// <p>The ID of the Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
}
impl GetConnectPeerInput {
    /// <p>The ID of the Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
}
impl GetConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`GetConnectPeerInput`](crate::input::GetConnectPeerInput).
    pub fn builder() -> crate::input::get_connect_peer_input::Builder {
        crate::input::get_connect_peer_input::Builder::default()
    }
}

/// See [`GetConnectPeerInput`](crate::input::GetConnectPeerInput).
pub mod get_connect_peer_input {

    /// A builder for [`GetConnectPeerInput`](crate::input::GetConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectPeerInput`](crate::input::GetConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetConnectPeerInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetConnectPeerInput {
                connect_peer_id: self.connect_peer_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectionsInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more connection IDs.</p>
    #[doc(hidden)]
    pub connection_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetConnectionsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more connection IDs.</p>
    pub fn connection_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.connection_ids.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetConnectionsInput {
    /// Creates a new builder-style object to manufacture [`GetConnectionsInput`](crate::input::GetConnectionsInput).
    pub fn builder() -> crate::input::get_connections_input::Builder {
        crate::input::get_connections_input::Builder::default()
    }
}

/// See [`GetConnectionsInput`](crate::input::GetConnectionsInput).
pub mod get_connections_input {

    /// A builder for [`GetConnectionsInput`](crate::input::GetConnectionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connection_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `connection_ids`.
        ///
        /// To override the contents of this collection use [`set_connection_ids`](Self::set_connection_ids).
        ///
        /// <p>One or more connection IDs.</p>
        pub fn connection_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.connection_ids.unwrap_or_default();
            v.push(input.into());
            self.connection_ids = Some(v);
            self
        }
        /// <p>One or more connection IDs.</p>
        pub fn set_connection_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.connection_ids = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectionsInput`](crate::input::GetConnectionsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetConnectionsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetConnectionsInput {
                global_network_id: self.global_network_id,
                connection_ids: self.connection_ids,
                device_id: self.device_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetConnectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetConnectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl GetConnectAttachmentInput {
    /// Creates a new builder-style object to manufacture [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput).
    pub fn builder() -> crate::input::get_connect_attachment_input::Builder {
        crate::input::get_connect_attachment_input::Builder::default()
    }
}

/// See [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput).
pub mod get_connect_attachment_input {

    /// A builder for [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetConnectAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetConnectAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExecuteCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
}
impl ExecuteCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
}
impl ExecuteCoreNetworkChangeSetInput {
    /// Creates a new builder-style object to manufacture [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput).
    pub fn builder() -> crate::input::execute_core_network_change_set_input::Builder {
        crate::input::execute_core_network_change_set_input::Builder::default()
    }
}

/// See [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput).
pub mod execute_core_network_change_set_input {

    /// A builder for [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ExecuteCoreNetworkChangeSetInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ExecuteCoreNetworkChangeSetInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    #[doc(hidden)]
    pub transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
}
impl DisassociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    pub fn transit_gateway_connect_peer_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_connect_peer_arn.as_deref()
    }
}
impl DisassociateTransitGatewayConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput).
    pub fn builder() -> crate::input::disassociate_transit_gateway_connect_peer_input::Builder {
        crate::input::disassociate_transit_gateway_connect_peer_input::Builder::default()
    }
}

/// See [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput).
pub mod disassociate_transit_gateway_connect_peer_input {

    /// A builder for [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
        pub fn transit_gateway_connect_peer_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
        pub fn set_transit_gateway_connect_peer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateTransitGatewayConnectPeerInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateTransitGatewayConnectPeerInput {
                global_network_id: self.global_network_id,
                transit_gateway_connect_peer_arn: self.transit_gateway_connect_peer_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateLinkInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
}
impl DisassociateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl DisassociateLinkInput {
    /// Creates a new builder-style object to manufacture [`DisassociateLinkInput`](crate::input::DisassociateLinkInput).
    pub fn builder() -> crate::input::disassociate_link_input::Builder {
        crate::input::disassociate_link_input::Builder::default()
    }
}

/// See [`DisassociateLinkInput`](crate::input::DisassociateLinkInput).
pub mod disassociate_link_input {

    /// A builder for [`DisassociateLinkInput`](crate::input::DisassociateLinkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateLinkInput`](crate::input::DisassociateLinkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateLinkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateLinkInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateCustomerGatewayInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    #[doc(hidden)]
    pub customer_gateway_arn: std::option::Option<std::string::String>,
}
impl DisassociateCustomerGatewayInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub fn customer_gateway_arn(&self) -> std::option::Option<&str> {
        self.customer_gateway_arn.as_deref()
    }
}
impl DisassociateCustomerGatewayInput {
    /// Creates a new builder-style object to manufacture [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput).
    pub fn builder() -> crate::input::disassociate_customer_gateway_input::Builder {
        crate::input::disassociate_customer_gateway_input::Builder::default()
    }
}

/// See [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput).
pub mod disassociate_customer_gateway_input {

    /// A builder for [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn customer_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn set_customer_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateCustomerGatewayInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateCustomerGatewayInput {
                global_network_id: self.global_network_id,
                customer_gateway_arn: self.customer_gateway_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DisassociateConnectPeerInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Connect peer to disassociate from a device.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
}
impl DisassociateConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the Connect peer to disassociate from a device.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
}
impl DisassociateConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput).
    pub fn builder() -> crate::input::disassociate_connect_peer_input::Builder {
        crate::input::disassociate_connect_peer_input::Builder::default()
    }
}

/// See [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput).
pub mod disassociate_connect_peer_input {

    /// A builder for [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the Connect peer to disassociate from a device.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer to disassociate from a device.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DisassociateConnectPeerInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DisassociateConnectPeerInput {
                global_network_id: self.global_network_id,
                connect_peer_id: self.connect_peer_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescribeGlobalNetworksInput {
    /// <p>The IDs of one or more global networks. The maximum is 10.</p>
    #[doc(hidden)]
    pub global_network_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeGlobalNetworksInput {
    /// <p>The IDs of one or more global networks. The maximum is 10.</p>
    pub fn global_network_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.global_network_ids.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl DescribeGlobalNetworksInput {
    /// Creates a new builder-style object to manufacture [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput).
    pub fn builder() -> crate::input::describe_global_networks_input::Builder {
        crate::input::describe_global_networks_input::Builder::default()
    }
}

/// See [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput).
pub mod describe_global_networks_input {

    /// A builder for [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `global_network_ids`.
        ///
        /// To override the contents of this collection use [`set_global_network_ids`](Self::set_global_network_ids).
        ///
        /// <p>The IDs of one or more global networks. The maximum is 10.</p>
        pub fn global_network_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.global_network_ids.unwrap_or_default();
            v.push(input.into());
            self.global_network_ids = Some(v);
            self
        }
        /// <p>The IDs of one or more global networks. The maximum is 10.</p>
        pub fn set_global_network_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.global_network_ids = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DescribeGlobalNetworksInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DescribeGlobalNetworksInput {
                global_network_ids: self.global_network_ids,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeregisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    #[doc(hidden)]
    pub transit_gateway_arn: std::option::Option<std::string::String>,
}
impl DeregisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_arn.as_deref()
    }
}
impl DeregisterTransitGatewayInput {
    /// Creates a new builder-style object to manufacture [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput).
    pub fn builder() -> crate::input::deregister_transit_gateway_input::Builder {
        crate::input::deregister_transit_gateway_input::Builder::default()
    }
}

/// See [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput).
pub mod deregister_transit_gateway_input {

    /// A builder for [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn set_transit_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeregisterTransitGatewayInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeregisterTransitGatewayInput {
                global_network_id: self.global_network_id,
                transit_gateway_arn: self.transit_gateway_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteSiteInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
}
impl DeleteSiteInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
}
impl DeleteSiteInput {
    /// Creates a new builder-style object to manufacture [`DeleteSiteInput`](crate::input::DeleteSiteInput).
    pub fn builder() -> crate::input::delete_site_input::Builder {
        crate::input::delete_site_input::Builder::default()
    }
}

/// See [`DeleteSiteInput`](crate::input::DeleteSiteInput).
pub mod delete_site_input {

    /// A builder for [`DeleteSiteInput`](crate::input::DeleteSiteInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSiteInput`](crate::input::DeleteSiteInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteSiteInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteSiteInput {
                global_network_id: self.global_network_id,
                site_id: self.site_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteResourcePolicyInput {
    /// <p>The ARN of the policy to delete.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
}
impl DeleteResourcePolicyInput {
    /// <p>The ARN of the policy to delete.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl DeleteResourcePolicyInput {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput).
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
}

/// See [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput).
pub mod delete_resource_policy_input {

    /// A builder for [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the policy to delete.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the policy to delete.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteResourcePolicyInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteResourcePolicyInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeletePeeringInput {
    /// <p>The ID of the peering connection to delete.</p>
    #[doc(hidden)]
    pub peering_id: std::option::Option<std::string::String>,
}
impl DeletePeeringInput {
    /// <p>The ID of the peering connection to delete.</p>
    pub fn peering_id(&self) -> std::option::Option<&str> {
        self.peering_id.as_deref()
    }
}
impl DeletePeeringInput {
    /// Creates a new builder-style object to manufacture [`DeletePeeringInput`](crate::input::DeletePeeringInput).
    pub fn builder() -> crate::input::delete_peering_input::Builder {
        crate::input::delete_peering_input::Builder::default()
    }
}

/// See [`DeletePeeringInput`](crate::input::DeletePeeringInput).
pub mod delete_peering_input {

    /// A builder for [`DeletePeeringInput`](crate::input::DeletePeeringInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) peering_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the peering connection to delete.</p>
        pub fn peering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_id = Some(input.into());
            self
        }
        /// <p>The ID of the peering connection to delete.</p>
        pub fn set_peering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peering_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeletePeeringInput`](crate::input::DeletePeeringInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeletePeeringInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeletePeeringInput {
                peering_id: self.peering_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteLinkInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
}
impl DeleteLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl DeleteLinkInput {
    /// Creates a new builder-style object to manufacture [`DeleteLinkInput`](crate::input::DeleteLinkInput).
    pub fn builder() -> crate::input::delete_link_input::Builder {
        crate::input::delete_link_input::Builder::default()
    }
}

/// See [`DeleteLinkInput`](crate::input::DeleteLinkInput).
pub mod delete_link_input {

    /// A builder for [`DeleteLinkInput`](crate::input::DeleteLinkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLinkInput`](crate::input::DeleteLinkInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteLinkInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteLinkInput {
                global_network_id: self.global_network_id,
                link_id: self.link_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteGlobalNetworkInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
}
impl DeleteGlobalNetworkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
}
impl DeleteGlobalNetworkInput {
    /// Creates a new builder-style object to manufacture [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput).
    pub fn builder() -> crate::input::delete_global_network_input::Builder {
        crate::input::delete_global_network_input::Builder::default()
    }
}

/// See [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput).
pub mod delete_global_network_input {

    /// A builder for [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteGlobalNetworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteGlobalNetworkInput {
                global_network_id: self.global_network_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteDeviceInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
}
impl DeleteDeviceInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
}
impl DeleteDeviceInput {
    /// Creates a new builder-style object to manufacture [`DeleteDeviceInput`](crate::input::DeleteDeviceInput).
    pub fn builder() -> crate::input::delete_device_input::Builder {
        crate::input::delete_device_input::Builder::default()
    }
}

/// See [`DeleteDeviceInput`](crate::input::DeleteDeviceInput).
pub mod delete_device_input {

    /// A builder for [`DeleteDeviceInput`](crate::input::DeleteDeviceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDeviceInput`](crate::input::DeleteDeviceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteDeviceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::DeleteDeviceInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network for the deleted policy.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The version ID of the deleted policy.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
}
impl DeleteCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network for the deleted policy.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The version ID of the deleted policy.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
}
impl DeleteCoreNetworkPolicyVersionInput {
    /// Creates a new builder-style object to manufacture [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput).
    pub fn builder() -> crate::input::delete_core_network_policy_version_input::Builder {
        crate::input::delete_core_network_policy_version_input::Builder::default()
    }
}

/// See [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput).
pub mod delete_core_network_policy_version_input {

    /// A builder for [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of a core network for the deleted policy.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network for the deleted policy.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The version ID of the deleted policy.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The version ID of the deleted policy.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteCoreNetworkPolicyVersionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteCoreNetworkPolicyVersionInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteCoreNetworkInput {
    /// <p>The network ID of the deleted core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
}
impl DeleteCoreNetworkInput {
    /// <p>The network ID of the deleted core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
}
impl DeleteCoreNetworkInput {
    /// Creates a new builder-style object to manufacture [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput).
    pub fn builder() -> crate::input::delete_core_network_input::Builder {
        crate::input::delete_core_network_input::Builder::default()
    }
}

/// See [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput).
pub mod delete_core_network_input {

    /// A builder for [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The network ID of the deleted core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The network ID of the deleted core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteCoreNetworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteCoreNetworkInput {
                core_network_id: self.core_network_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteConnectPeerInput {
    /// <p>The ID of the deleted Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
}
impl DeleteConnectPeerInput {
    /// <p>The ID of the deleted Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
}
impl DeleteConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput).
    pub fn builder() -> crate::input::delete_connect_peer_input::Builder {
        crate::input::delete_connect_peer_input::Builder::default()
    }
}

/// See [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput).
pub mod delete_connect_peer_input {

    /// A builder for [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the deleted Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the deleted Connect peer.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteConnectPeerInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteConnectPeerInput {
                connect_peer_id: self.connect_peer_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteConnectionInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the connection.</p>
    #[doc(hidden)]
    pub connection_id: std::option::Option<std::string::String>,
}
impl DeleteConnectionInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
}
impl DeleteConnectionInput {
    /// Creates a new builder-style object to manufacture [`DeleteConnectionInput`](crate::input::DeleteConnectionInput).
    pub fn builder() -> crate::input::delete_connection_input::Builder {
        crate::input::delete_connection_input::Builder::default()
    }
}

/// See [`DeleteConnectionInput`](crate::input::DeleteConnectionInput).
pub mod delete_connection_input {

    /// A builder for [`DeleteConnectionInput`](crate::input::DeleteConnectionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConnectionInput`](crate::input::DeleteConnectionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteConnectionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteConnectionInput {
                global_network_id: self.global_network_id,
                connection_id: self.connection_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeleteAttachmentInput {
    /// <p>The ID of the attachment to delete.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl DeleteAttachmentInput {
    /// <p>The ID of the attachment to delete.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl DeleteAttachmentInput {
    /// Creates a new builder-style object to manufacture [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput).
    pub fn builder() -> crate::input::delete_attachment_input::Builder {
        crate::input::delete_attachment_input::Builder::default()
    }
}

/// See [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput).
pub mod delete_attachment_input {

    /// A builder for [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment to delete.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment to delete.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::DeleteAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::DeleteAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateVpcAttachmentInput {
    /// <p>The ID of a core network for the VPC attachment.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the VPC.</p>
    #[doc(hidden)]
    pub vpc_arn: std::option::Option<std::string::String>,
    /// <p>The subnet ARN of the VPC attachment.</p>
    #[doc(hidden)]
    pub subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Options for the VPC attachment.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::VpcOptions>,
    /// <p>The key-value tags associated with the request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateVpcAttachmentInput {
    /// <p>The ID of a core network for the VPC attachment.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the VPC.</p>
    pub fn vpc_arn(&self) -> std::option::Option<&str> {
        self.vpc_arn.as_deref()
    }
    /// <p>The subnet ARN of the VPC attachment.</p>
    pub fn subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_arns.as_deref()
    }
    /// <p>Options for the VPC attachment.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::VpcOptions> {
        self.options.as_ref()
    }
    /// <p>The key-value tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateVpcAttachmentInput {
    /// Creates a new builder-style object to manufacture [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput).
    pub fn builder() -> crate::input::create_vpc_attachment_input::Builder {
        crate::input::create_vpc_attachment_input::Builder::default()
    }
}

/// See [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput).
pub mod create_vpc_attachment_input {

    /// A builder for [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) vpc_arn: std::option::Option<std::string::String>,
        pub(crate) subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) options: std::option::Option<crate::model::VpcOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network for the VPC attachment.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network for the VPC attachment.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the VPC.</p>
        pub fn vpc_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the VPC.</p>
        pub fn set_vpc_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_arn = input;
            self
        }
        /// Appends an item to `subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_subnet_arns`](Self::set_subnet_arns).
        ///
        /// <p>The subnet ARN of the VPC attachment.</p>
        pub fn subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.subnet_arns = Some(v);
            self
        }
        /// <p>The subnet ARN of the VPC attachment.</p>
        pub fn set_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_arns = input;
            self
        }
        /// <p>Options for the VPC attachment.</p>
        pub fn options(mut self, input: crate::model::VpcOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options for the VPC attachment.</p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::VpcOptions>) -> Self {
            self.options = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The key-value tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The key-value tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateVpcAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateVpcAttachmentInput {
                core_network_id: self.core_network_id,
                vpc_arn: self.vpc_arn,
                subnet_arns: self.subnet_arns,
                options: self.options,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTransitGatewayRouteTableAttachmentInput {
    /// <p>The ID of the peer for the </p>
    #[doc(hidden)]
    pub peering_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the transit gateway route table for the attachment request.</p>
    #[doc(hidden)]
    pub transit_gateway_route_table_arn: std::option::Option<std::string::String>,
    /// <p>The list of key-value tags associated with the request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateTransitGatewayRouteTableAttachmentInput {
    /// <p>The ID of the peer for the </p>
    pub fn peering_id(&self) -> std::option::Option<&str> {
        self.peering_id.as_deref()
    }
    /// <p>The ARN of the transit gateway route table for the attachment request.</p>
    pub fn transit_gateway_route_table_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_route_table_arn.as_deref()
    }
    /// <p>The list of key-value tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateTransitGatewayRouteTableAttachmentInput {
    /// Creates a new builder-style object to manufacture [`CreateTransitGatewayRouteTableAttachmentInput`](crate::input::CreateTransitGatewayRouteTableAttachmentInput).
    pub fn builder() -> crate::input::create_transit_gateway_route_table_attachment_input::Builder {
        crate::input::create_transit_gateway_route_table_attachment_input::Builder::default()
    }
}

/// See [`CreateTransitGatewayRouteTableAttachmentInput`](crate::input::CreateTransitGatewayRouteTableAttachmentInput).
pub mod create_transit_gateway_route_table_attachment_input {

    /// A builder for [`CreateTransitGatewayRouteTableAttachmentInput`](crate::input::CreateTransitGatewayRouteTableAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) peering_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_route_table_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the peer for the </p>
        pub fn peering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_id = Some(input.into());
            self
        }
        /// <p>The ID of the peer for the </p>
        pub fn set_peering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peering_id = input;
            self
        }
        /// <p>The ARN of the transit gateway route table for the attachment request.</p>
        pub fn transit_gateway_route_table_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway route table for the attachment request.</p>
        pub fn set_transit_gateway_route_table_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_route_table_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTransitGatewayRouteTableAttachmentInput`](crate::input::CreateTransitGatewayRouteTableAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateTransitGatewayRouteTableAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(
                crate::input::CreateTransitGatewayRouteTableAttachmentInput {
                    peering_id: self.peering_id,
                    transit_gateway_route_table_arn: self.transit_gateway_route_table_arn,
                    tags: self.tags,
                    client_token: self.client_token,
                },
            )
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTransitGatewayPeeringInput {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the transit gateway for the peering request.</p>
    #[doc(hidden)]
    pub transit_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The list of key-value tags associated with the request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateTransitGatewayPeeringInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the transit gateway for the peering request.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_arn.as_deref()
    }
    /// <p>The list of key-value tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateTransitGatewayPeeringInput {
    /// Creates a new builder-style object to manufacture [`CreateTransitGatewayPeeringInput`](crate::input::CreateTransitGatewayPeeringInput).
    pub fn builder() -> crate::input::create_transit_gateway_peering_input::Builder {
        crate::input::create_transit_gateway_peering_input::Builder::default()
    }
}

/// See [`CreateTransitGatewayPeeringInput`](crate::input::CreateTransitGatewayPeeringInput).
pub mod create_transit_gateway_peering_input {

    /// A builder for [`CreateTransitGatewayPeeringInput`](crate::input::CreateTransitGatewayPeeringInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the transit gateway for the peering request.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway for the peering request.</p>
        pub fn set_transit_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTransitGatewayPeeringInput`](crate::input::CreateTransitGatewayPeeringInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateTransitGatewayPeeringInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateTransitGatewayPeeringInput {
                core_network_id: self.core_network_id,
                transit_gateway_arn: self.transit_gateway_arn,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateSiteToSiteVpnAttachmentInput {
    /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN identifying the VPN attachment.</p>
    #[doc(hidden)]
    pub vpn_connection_arn: std::option::Option<std::string::String>,
    /// <p>The tags associated with the request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateSiteToSiteVpnAttachmentInput {
    /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN identifying the VPN attachment.</p>
    pub fn vpn_connection_arn(&self) -> std::option::Option<&str> {
        self.vpn_connection_arn.as_deref()
    }
    /// <p>The tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateSiteToSiteVpnAttachmentInput {
    /// Creates a new builder-style object to manufacture [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput).
    pub fn builder() -> crate::input::create_site_to_site_vpn_attachment_input::Builder {
        crate::input::create_site_to_site_vpn_attachment_input::Builder::default()
    }
}

/// See [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput).
pub mod create_site_to_site_vpn_attachment_input {

    /// A builder for [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) vpn_connection_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN identifying the VPN attachment.</p>
        pub fn vpn_connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_connection_arn = Some(input.into());
            self
        }
        /// <p>The ARN identifying the VPN attachment.</p>
        pub fn set_vpn_connection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_connection_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateSiteToSiteVpnAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateSiteToSiteVpnAttachmentInput {
                core_network_id: self.core_network_id,
                vpn_connection_arn: self.vpn_connection_arn,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSiteInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The tags to apply to the resource during creation.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateSiteInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateSiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSiteInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("description", &self.description);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
impl CreateSiteInput {
    /// Creates a new builder-style object to manufacture [`CreateSiteInput`](crate::input::CreateSiteInput).
    pub fn builder() -> crate::input::create_site_input::Builder {
        crate::input::create_site_input::Builder::default()
    }
}

/// See [`CreateSiteInput`](crate::input::CreateSiteInput).
pub mod create_site_input {

    /// A builder for [`CreateSiteInput`](crate::input::CreateSiteInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSiteInput`](crate::input::CreateSiteInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateSiteInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateSiteInput {
                global_network_id: self.global_network_id,
                description: self.description,
                location: self.location,
                tags: self.tags,
            })
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("global_network_id", &self.global_network_id);
            formatter.field("description", &self.description);
            formatter.field("location", &"*** Sensitive Data Redacted ***");
            formatter.field("tags", &self.tags);
            formatter.finish()
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateLinkInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p> The upload speed and download speed in Mbps. </p>
    #[doc(hidden)]
    pub bandwidth: std::option::Option<crate::model::Bandwidth>,
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    #[doc(hidden)]
    pub provider: std::option::Option<std::string::String>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p> The upload speed and download speed in Mbps. </p>
    pub fn bandwidth(&self) -> std::option::Option<&crate::model::Bandwidth> {
        self.bandwidth.as_ref()
    }
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateLinkInput {
    /// Creates a new builder-style object to manufacture [`CreateLinkInput`](crate::input::CreateLinkInput).
    pub fn builder() -> crate::input::create_link_input::Builder {
        crate::input::create_link_input::Builder::default()
    }
}

/// See [`CreateLinkInput`](crate::input::CreateLinkInput).
pub mod create_link_input {

    /// A builder for [`CreateLinkInput`](crate::input::CreateLinkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) bandwidth: std::option::Option<crate::model::Bandwidth>,
        pub(crate) provider: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p> The upload speed and download speed in Mbps. </p>
        pub fn bandwidth(mut self, input: crate::model::Bandwidth) -> Self {
            self.bandwidth = Some(input);
            self
        }
        /// <p> The upload speed and download speed in Mbps. </p>
        pub fn set_bandwidth(
            mut self,
            input: std::option::Option<crate::model::Bandwidth>,
        ) -> Self {
            self.bandwidth = input;
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLinkInput`](crate::input::CreateLinkInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateLinkInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateLinkInput {
                global_network_id: self.global_network_id,
                description: self.description,
                r#type: self.r#type,
                bandwidth: self.bandwidth,
                provider: self.provider,
                site_id: self.site_id,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateGlobalNetworkInput {
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateGlobalNetworkInput {
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateGlobalNetworkInput {
    /// Creates a new builder-style object to manufacture [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput).
    pub fn builder() -> crate::input::create_global_network_input::Builder {
        crate::input::create_global_network_input::Builder::default()
    }
}

/// See [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput).
pub mod create_global_network_input {

    /// A builder for [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateGlobalNetworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateGlobalNetworkInput {
                description: self.description,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDeviceInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    #[doc(hidden)]
    pub aws_location: std::option::Option<crate::model::AwsLocation>,
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the device.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The location of the device.</p>
    #[doc(hidden)]
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDeviceInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    pub fn aws_location(&self) -> std::option::Option<&crate::model::AwsLocation> {
        self.aws_location.as_ref()
    }
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the device.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn vendor(&self) -> std::option::Option<&str> {
        self.vendor.as_deref()
    }
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn serial_number(&self) -> std::option::Option<&str> {
        self.serial_number.as_deref()
    }
    /// <p>The location of the device.</p>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDeviceInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("aws_location", &self.aws_location);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("vendor", &self.vendor);
        formatter.field("model", &self.model);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("site_id", &self.site_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
impl CreateDeviceInput {
    /// Creates a new builder-style object to manufacture [`CreateDeviceInput`](crate::input::CreateDeviceInput).
    pub fn builder() -> crate::input::create_device_input::Builder {
        crate::input::create_device_input::Builder::default()
    }
}

/// See [`CreateDeviceInput`](crate::input::CreateDeviceInput).
pub mod create_device_input {

    /// A builder for [`CreateDeviceInput`](crate::input::CreateDeviceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) aws_location: std::option::Option<crate::model::AwsLocation>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn aws_location(mut self, input: crate::model::AwsLocation) -> Self {
            self.aws_location = Some(input);
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn set_aws_location(
            mut self,
            input: std::option::Option<crate::model::AwsLocation>,
        ) -> Self {
            self.aws_location = input;
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the device.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the device.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>The location of the device.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The location of the device.</p>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDeviceInput`](crate::input::CreateDeviceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateDeviceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateDeviceInput {
                global_network_id: self.global_network_id,
                aws_location: self.aws_location,
                description: self.description,
                r#type: self.r#type,
                vendor: self.vendor,
                model: self.model,
                serial_number: self.serial_number,
                location: self.location,
                site_id: self.site_id,
                tags: self.tags,
            })
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("global_network_id", &self.global_network_id);
            formatter.field("aws_location", &self.aws_location);
            formatter.field("description", &self.description);
            formatter.field("r#type", &self.r#type);
            formatter.field("vendor", &self.vendor);
            formatter.field("model", &self.model);
            formatter.field("serial_number", &self.serial_number);
            formatter.field("location", &"*** Sensitive Data Redacted ***");
            formatter.field("site_id", &self.site_id);
            formatter.field("tags", &self.tags);
            formatter.finish()
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCoreNetworkInput {
    /// <p>The ID of the global network that a core network will be a part of. </p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The description of a core network.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Key-value tags associated with a core network request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The policy document for creating a core network.</p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>The client token associated with a core network request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateCoreNetworkInput {
    /// <p>The ID of the global network that a core network will be a part of. </p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The description of a core network.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Key-value tags associated with a core network request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The policy document for creating a core network.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>The client token associated with a core network request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateCoreNetworkInput {
    /// Creates a new builder-style object to manufacture [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput).
    pub fn builder() -> crate::input::create_core_network_input::Builder {
        crate::input::create_core_network_input::Builder::default()
    }
}

/// See [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput).
pub mod create_core_network_input {

    /// A builder for [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network that a core network will be a part of. </p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network that a core network will be a part of. </p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The description of a core network.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a core network.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Key-value tags associated with a core network request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Key-value tags associated with a core network request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The policy document for creating a core network.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The policy document for creating a core network.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>The client token associated with a core network request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with a core network request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateCoreNetworkInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateCoreNetworkInput {
                global_network_id: self.global_network_id,
                description: self.description,
                tags: self.tags,
                policy_document: self.policy_document,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateConnectPeerInput {
    /// <p>The ID of the connection attachment.</p>
    #[doc(hidden)]
    pub connect_attachment_id: std::option::Option<std::string::String>,
    /// <p>A Connect peer core network address.</p>
    #[doc(hidden)]
    pub core_network_address: std::option::Option<std::string::String>,
    /// <p>The Connect peer address.</p>
    #[doc(hidden)]
    pub peer_address: std::option::Option<std::string::String>,
    /// <p>The Connect peer BGP options.</p>
    #[doc(hidden)]
    pub bgp_options: std::option::Option<crate::model::BgpOptions>,
    /// <p>The inside IP addresses used for BGP peering.</p>
    #[doc(hidden)]
    pub inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tags associated with the peer request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateConnectPeerInput {
    /// <p>The ID of the connection attachment.</p>
    pub fn connect_attachment_id(&self) -> std::option::Option<&str> {
        self.connect_attachment_id.as_deref()
    }
    /// <p>A Connect peer core network address.</p>
    pub fn core_network_address(&self) -> std::option::Option<&str> {
        self.core_network_address.as_deref()
    }
    /// <p>The Connect peer address.</p>
    pub fn peer_address(&self) -> std::option::Option<&str> {
        self.peer_address.as_deref()
    }
    /// <p>The Connect peer BGP options.</p>
    pub fn bgp_options(&self) -> std::option::Option<&crate::model::BgpOptions> {
        self.bgp_options.as_ref()
    }
    /// <p>The inside IP addresses used for BGP peering.</p>
    pub fn inside_cidr_blocks(&self) -> std::option::Option<&[std::string::String]> {
        self.inside_cidr_blocks.as_deref()
    }
    /// <p>The tags associated with the peer request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput).
    pub fn builder() -> crate::input::create_connect_peer_input::Builder {
        crate::input::create_connect_peer_input::Builder::default()
    }
}

/// See [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput).
pub mod create_connect_peer_input {

    /// A builder for [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_attachment_id: std::option::Option<std::string::String>,
        pub(crate) core_network_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
        pub(crate) bgp_options: std::option::Option<crate::model::BgpOptions>,
        pub(crate) inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the connection attachment.</p>
        pub fn connect_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection attachment.</p>
        pub fn set_connect_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_attachment_id = input;
            self
        }
        /// <p>A Connect peer core network address.</p>
        pub fn core_network_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_address = Some(input.into());
            self
        }
        /// <p>A Connect peer core network address.</p>
        pub fn set_core_network_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_address = input;
            self
        }
        /// <p>The Connect peer address.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        /// <p>The Connect peer address.</p>
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input;
            self
        }
        /// <p>The Connect peer BGP options.</p>
        pub fn bgp_options(mut self, input: crate::model::BgpOptions) -> Self {
            self.bgp_options = Some(input);
            self
        }
        /// <p>The Connect peer BGP options.</p>
        pub fn set_bgp_options(
            mut self,
            input: std::option::Option<crate::model::BgpOptions>,
        ) -> Self {
            self.bgp_options = input;
            self
        }
        /// Appends an item to `inside_cidr_blocks`.
        ///
        /// To override the contents of this collection use [`set_inside_cidr_blocks`](Self::set_inside_cidr_blocks).
        ///
        /// <p>The inside IP addresses used for BGP peering.</p>
        pub fn inside_cidr_blocks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inside_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.inside_cidr_blocks = Some(v);
            self
        }
        /// <p>The inside IP addresses used for BGP peering.</p>
        pub fn set_inside_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inside_cidr_blocks = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the peer request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags associated with the peer request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateConnectPeerInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateConnectPeerInput {
                connect_attachment_id: self.connect_attachment_id,
                core_network_address: self.core_network_address,
                peer_address: self.peer_address,
                bgp_options: self.bgp_options,
                inside_cidr_blocks: self.inside_cidr_blocks,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateConnectionInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the first device in the connection.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the second device in the connection.</p>
    #[doc(hidden)]
    pub connected_device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the first device.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the second device.</p>
    #[doc(hidden)]
    pub connected_link_id: std::option::Option<std::string::String>,
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateConnectionInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the first device in the connection.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the second device in the connection.</p>
    pub fn connected_device_id(&self) -> std::option::Option<&str> {
        self.connected_device_id.as_deref()
    }
    /// <p>The ID of the link for the first device.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>The ID of the link for the second device.</p>
    pub fn connected_link_id(&self) -> std::option::Option<&str> {
        self.connected_link_id.as_deref()
    }
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateConnectionInput {
    /// Creates a new builder-style object to manufacture [`CreateConnectionInput`](crate::input::CreateConnectionInput).
    pub fn builder() -> crate::input::create_connection_input::Builder {
        crate::input::create_connection_input::Builder::default()
    }
}

/// See [`CreateConnectionInput`](crate::input::CreateConnectionInput).
pub mod create_connection_input {

    /// A builder for [`CreateConnectionInput`](crate::input::CreateConnectionInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) connected_device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) connected_link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the first device in the connection.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the first device in the connection.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the second device in the connection.</p>
        pub fn connected_device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_device_id = Some(input.into());
            self
        }
        /// <p>The ID of the second device in the connection.</p>
        pub fn set_connected_device_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connected_device_id = input;
            self
        }
        /// <p>The ID of the link for the first device.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the first device.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>The ID of the link for the second device.</p>
        pub fn connected_link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the second device.</p>
        pub fn set_connected_link_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connected_link_id = input;
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConnectionInput`](crate::input::CreateConnectionInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateConnectionInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateConnectionInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                connected_device_id: self.connected_device_id,
                link_id: self.link_id,
                connected_link_id: self.connected_link_id,
                description: self.description,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateConnectAttachmentInput {
    /// <p>The ID of a core network where you want to create the attachment. </p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The Region where the edge is located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment between the two connections.</p>
    #[doc(hidden)]
    pub transport_attachment_id: std::option::Option<std::string::String>,
    /// <p>Options for creating an attachment.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::ConnectAttachmentOptions>,
    /// <p>The list of key-value tags associated with the request.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateConnectAttachmentInput {
    /// <p>The ID of a core network where you want to create the attachment. </p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The Region where the edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<&str> {
        self.edge_location.as_deref()
    }
    /// <p>The ID of the attachment between the two connections.</p>
    pub fn transport_attachment_id(&self) -> std::option::Option<&str> {
        self.transport_attachment_id.as_deref()
    }
    /// <p>Options for creating an attachment.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::ConnectAttachmentOptions> {
        self.options.as_ref()
    }
    /// <p>The list of key-value tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateConnectAttachmentInput {
    /// Creates a new builder-style object to manufacture [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput).
    pub fn builder() -> crate::input::create_connect_attachment_input::Builder {
        crate::input::create_connect_attachment_input::Builder::default()
    }
}

/// See [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput).
pub mod create_connect_attachment_input {

    /// A builder for [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) transport_attachment_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<crate::model::ConnectAttachmentOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network where you want to create the attachment. </p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network where you want to create the attachment. </p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn set_edge_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_location = input;
            self
        }
        /// <p>The ID of the attachment between the two connections.</p>
        pub fn transport_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transport_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment between the two connections.</p>
        pub fn set_transport_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transport_attachment_id = input;
            self
        }
        /// <p>Options for creating an attachment.</p>
        pub fn options(mut self, input: crate::model::ConnectAttachmentOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options for creating an attachment.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::ConnectAttachmentOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateConnectAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateConnectAttachmentInput {
                core_network_id: self.core_network_id,
                edge_location: self.edge_location,
                transport_attachment_id: self.transport_attachment_id,
                options: self.options,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
    #[doc(hidden)]
    pub transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
    pub fn transit_gateway_connect_peer_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_connect_peer_arn.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl AssociateTransitGatewayConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput).
    pub fn builder() -> crate::input::associate_transit_gateway_connect_peer_input::Builder {
        crate::input::associate_transit_gateway_connect_peer_input::Builder::default()
    }
}

/// See [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput).
pub mod associate_transit_gateway_connect_peer_input {

    /// A builder for [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
        pub fn transit_gateway_connect_peer_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
        pub fn set_transit_gateway_connect_peer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateTransitGatewayConnectPeerInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateTransitGatewayConnectPeerInput {
                global_network_id: self.global_network_id,
                transit_gateway_connect_peer_arn: self.transit_gateway_connect_peer_arn,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateLinkInput {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl AssociateLinkInput {
    /// Creates a new builder-style object to manufacture [`AssociateLinkInput`](crate::input::AssociateLinkInput).
    pub fn builder() -> crate::input::associate_link_input::Builder {
        crate::input::associate_link_input::Builder::default()
    }
}

/// See [`AssociateLinkInput`](crate::input::AssociateLinkInput).
pub mod associate_link_input {

    /// A builder for [`AssociateLinkInput`](crate::input::AssociateLinkInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateLinkInput`](crate::input::AssociateLinkInput).
        pub fn build(
            self,
        ) -> Result<crate::input::AssociateLinkInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::AssociateLinkInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateCustomerGatewayInput {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    #[doc(hidden)]
    pub customer_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateCustomerGatewayInput {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub fn customer_gateway_arn(&self) -> std::option::Option<&str> {
        self.customer_gateway_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl AssociateCustomerGatewayInput {
    /// Creates a new builder-style object to manufacture [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput).
    pub fn builder() -> crate::input::associate_customer_gateway_input::Builder {
        crate::input::associate_customer_gateway_input::Builder::default()
    }
}

/// See [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput).
pub mod associate_customer_gateway_input {

    /// A builder for [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) customer_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn customer_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn set_customer_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_arn = input;
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateCustomerGatewayInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateCustomerGatewayInput {
                customer_gateway_arn: self.customer_gateway_arn,
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AssociateConnectPeerInput {
    /// <p>The ID of your global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateConnectPeerInput {
    /// <p>The ID of your global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl AssociateConnectPeerInput {
    /// Creates a new builder-style object to manufacture [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput).
    pub fn builder() -> crate::input::associate_connect_peer_input::Builder {
        crate::input::associate_connect_peer_input::Builder::default()
    }
}

/// See [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput).
pub mod associate_connect_peer_input {

    /// A builder for [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of your global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of your global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AssociateConnectPeerInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AssociateConnectPeerInput {
                global_network_id: self.global_network_id,
                connect_peer_id: self.connect_peer_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AcceptAttachmentInput {
    /// <p>The ID of the attachment. </p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
}
impl AcceptAttachmentInput {
    /// <p>The ID of the attachment. </p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl AcceptAttachmentInput {
    /// Creates a new builder-style object to manufacture [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput).
    pub fn builder() -> crate::input::accept_attachment_input::Builder {
        crate::input::accept_attachment_input::Builder::default()
    }
}

/// See [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput).
pub mod accept_attachment_input {

    /// A builder for [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment. </p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment. </p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::AcceptAttachmentInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::AcceptAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
