// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
/// See [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput)
pub mod accept_attachment_input {
    /// A builder for [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment. </p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment. </p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AcceptAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AcceptAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AcceptAttachmentInputOperationOutputAlias = crate::operation::AcceptAttachment;
#[doc(hidden)]
pub type AcceptAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AcceptAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`AcceptAttachment`](crate::operation::AcceptAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AcceptAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AcceptAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_1 = &_input.attachment_id;
            let input_1 =
                input_1
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_1, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/attachments/{AttachmentId}/accept",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AcceptAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AcceptAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AcceptAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AcceptAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AcceptAttachmentInput`](crate::input::AcceptAttachmentInput)
    pub fn builder() -> crate::input::accept_attachment_input::Builder {
        crate::input::accept_attachment_input::Builder::default()
    }
}

/// See [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput)
pub mod associate_connect_peer_input {
    /// A builder for [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of your global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of your global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateConnectPeerInput {
                global_network_id: self.global_network_id,
                connect_peer_id: self.connect_peer_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateConnectPeerInputOperationOutputAlias = crate::operation::AssociateConnectPeer;
#[doc(hidden)]
pub type AssociateConnectPeerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AssociateConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`AssociateConnectPeer`](crate::operation::AssociateConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_2 = &_input.global_network_id;
            let input_2 =
                input_2
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_2, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connect-peer-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_connect_peer(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateConnectPeerInput`](crate::input::AssociateConnectPeerInput)
    pub fn builder() -> crate::input::associate_connect_peer_input::Builder {
        crate::input::associate_connect_peer_input::Builder::default()
    }
}

/// See [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput)
pub mod associate_customer_gateway_input {
    /// A builder for [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) customer_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn customer_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn set_customer_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_arn = input;
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateCustomerGatewayInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateCustomerGatewayInput {
                customer_gateway_arn: self.customer_gateway_arn,
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateCustomerGatewayInputOperationOutputAlias =
    crate::operation::AssociateCustomerGateway;
#[doc(hidden)]
pub type AssociateCustomerGatewayInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AssociateCustomerGatewayInput {
    /// Consumes the builder and constructs an Operation<[`AssociateCustomerGateway`](crate::operation::AssociateCustomerGateway)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateCustomerGateway,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateCustomerGatewayInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_3 = &_input.global_network_id;
            let input_3 =
                input_3
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_3, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/customer-gateway-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateCustomerGatewayInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateCustomerGatewayInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_customer_gateway(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateCustomerGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateCustomerGateway",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateCustomerGatewayInput`](crate::input::AssociateCustomerGatewayInput)
    pub fn builder() -> crate::input::associate_customer_gateway_input::Builder {
        crate::input::associate_customer_gateway_input::Builder::default()
    }
}

/// See [`AssociateLinkInput`](crate::input::AssociateLinkInput)
pub mod associate_link_input {
    /// A builder for [`AssociateLinkInput`](crate::input::AssociateLinkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateLinkInput`](crate::input::AssociateLinkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateLinkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateLinkInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateLinkInputOperationOutputAlias = crate::operation::AssociateLink;
#[doc(hidden)]
pub type AssociateLinkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl AssociateLinkInput {
    /// Consumes the builder and constructs an Operation<[`AssociateLink`](crate::operation::AssociateLink)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateLink,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateLinkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_4 = &_input.global_network_id;
            let input_4 =
                input_4
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_4, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/link-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateLinkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateLinkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_associate_link(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateLink",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateLinkInput`](crate::input::AssociateLinkInput)
    pub fn builder() -> crate::input::associate_link_input::Builder {
        crate::input::associate_link_input::Builder::default()
    }
}

/// See [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput)
pub mod associate_transit_gateway_connect_peer_input {
    /// A builder for [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
        pub fn transit_gateway_connect_peer_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
        pub fn set_transit_gateway_connect_peer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::AssociateTransitGatewayConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::AssociateTransitGatewayConnectPeerInput {
                global_network_id: self.global_network_id,
                transit_gateway_connect_peer_arn: self.transit_gateway_connect_peer_arn,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}
#[doc(hidden)]
pub type AssociateTransitGatewayConnectPeerInputOperationOutputAlias =
    crate::operation::AssociateTransitGatewayConnectPeer;
#[doc(hidden)]
pub type AssociateTransitGatewayConnectPeerInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl AssociateTransitGatewayConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`AssociateTransitGatewayConnectPeer`](crate::operation::AssociateTransitGatewayConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::AssociateTransitGatewayConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::AssociateTransitGatewayConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_5 = &_input.global_network_id;
            let input_5 =
                input_5
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_5, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/transit-gateway-connect-peer-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::AssociateTransitGatewayConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::AssociateTransitGatewayConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_associate_transit_gateway_connect_peer(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::AssociateTransitGatewayConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "AssociateTransitGatewayConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`AssociateTransitGatewayConnectPeerInput`](crate::input::AssociateTransitGatewayConnectPeerInput)
    pub fn builder() -> crate::input::associate_transit_gateway_connect_peer_input::Builder {
        crate::input::associate_transit_gateway_connect_peer_input::Builder::default()
    }
}

/// See [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput)
pub mod create_connect_attachment_input {
    /// A builder for [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) transport_attachment_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<crate::model::ConnectAttachmentOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network where you want to create the attachment. </p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network where you want to create the attachment. </p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn set_edge_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_location = input;
            self
        }
        /// <p>The ID of the attachment between the two connections.</p>
        pub fn transport_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transport_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment between the two connections.</p>
        pub fn set_transport_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transport_attachment_id = input;
            self
        }
        /// <p>Options for creating an attachment.</p>
        pub fn options(mut self, input: crate::model::ConnectAttachmentOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options for creating an attachment.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<crate::model::ConnectAttachmentOptions>,
        ) -> Self {
            self.options = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The list of key-value tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateConnectAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateConnectAttachmentInput {
                core_network_id: self.core_network_id,
                edge_location: self.edge_location,
                transport_attachment_id: self.transport_attachment_id,
                options: self.options,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateConnectAttachmentInputOperationOutputAlias =
    crate::operation::CreateConnectAttachment;
#[doc(hidden)]
pub type CreateConnectAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateConnectAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnectAttachment`](crate::operation::CreateConnectAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateConnectAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateConnectAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/connect-attachments").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateConnectAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateConnectAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_connect_attachment(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateConnectAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateConnectAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateConnectAttachmentInput`](crate::input::CreateConnectAttachmentInput)
    pub fn builder() -> crate::input::create_connect_attachment_input::Builder {
        crate::input::create_connect_attachment_input::Builder::default()
    }
}

/// See [`CreateConnectionInput`](crate::input::CreateConnectionInput)
pub mod create_connection_input {
    /// A builder for [`CreateConnectionInput`](crate::input::CreateConnectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) connected_device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) connected_link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the first device in the connection.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the first device in the connection.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the second device in the connection.</p>
        pub fn connected_device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_device_id = Some(input.into());
            self
        }
        /// <p>The ID of the second device in the connection.</p>
        pub fn set_connected_device_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connected_device_id = input;
            self
        }
        /// <p>The ID of the link for the first device.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the first device.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>The ID of the link for the second device.</p>
        pub fn connected_link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the second device.</p>
        pub fn set_connected_link_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connected_link_id = input;
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConnectionInput`](crate::input::CreateConnectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateConnectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateConnectionInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                connected_device_id: self.connected_device_id,
                link_id: self.link_id,
                connected_link_id: self.connected_link_id,
                description: self.description,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateConnectionInputOperationOutputAlias = crate::operation::CreateConnection;
#[doc(hidden)]
pub type CreateConnectionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateConnectionInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnection`](crate::operation::CreateConnection)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateConnection,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateConnectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_6 = &_input.global_network_id;
            let input_6 =
                input_6
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_6, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connections",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateConnectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateConnectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_connection(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateConnection",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateConnectionInput`](crate::input::CreateConnectionInput)
    pub fn builder() -> crate::input::create_connection_input::Builder {
        crate::input::create_connection_input::Builder::default()
    }
}

/// See [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput)
pub mod create_connect_peer_input {
    /// A builder for [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_attachment_id: std::option::Option<std::string::String>,
        pub(crate) core_network_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
        pub(crate) bgp_options: std::option::Option<crate::model::BgpOptions>,
        pub(crate) inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the connection attachment.</p>
        pub fn connect_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection attachment.</p>
        pub fn set_connect_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_attachment_id = input;
            self
        }
        /// <p>A Connect peer core network address.</p>
        pub fn core_network_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_address = Some(input.into());
            self
        }
        /// <p>A Connect peer core network address.</p>
        pub fn set_core_network_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_address = input;
            self
        }
        /// <p>The Connect peer address.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        /// <p>The Connect peer address.</p>
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input;
            self
        }
        /// <p>The Connect peer BGP options.</p>
        pub fn bgp_options(mut self, input: crate::model::BgpOptions) -> Self {
            self.bgp_options = Some(input);
            self
        }
        /// <p>The Connect peer BGP options.</p>
        pub fn set_bgp_options(
            mut self,
            input: std::option::Option<crate::model::BgpOptions>,
        ) -> Self {
            self.bgp_options = input;
            self
        }
        /// Appends an item to `inside_cidr_blocks`.
        ///
        /// To override the contents of this collection use [`set_inside_cidr_blocks`](Self::set_inside_cidr_blocks).
        ///
        /// <p>The inside IP addresses used for BGP peering.</p>
        pub fn inside_cidr_blocks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inside_cidr_blocks.unwrap_or_default();
            v.push(input.into());
            self.inside_cidr_blocks = Some(v);
            self
        }
        /// <p>The inside IP addresses used for BGP peering.</p>
        pub fn set_inside_cidr_blocks(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inside_cidr_blocks = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the peer request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags associated with the peer request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateConnectPeerInput {
                connect_attachment_id: self.connect_attachment_id,
                core_network_address: self.core_network_address,
                peer_address: self.peer_address,
                bgp_options: self.bgp_options,
                inside_cidr_blocks: self.inside_cidr_blocks,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateConnectPeerInputOperationOutputAlias = crate::operation::CreateConnectPeer;
#[doc(hidden)]
pub type CreateConnectPeerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`CreateConnectPeer`](crate::operation::CreateConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/connect-peers").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_connect_peer(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateConnectPeerInput`](crate::input::CreateConnectPeerInput)
    pub fn builder() -> crate::input::create_connect_peer_input::Builder {
        crate::input::create_connect_peer_input::Builder::default()
    }
}

/// See [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput)
pub mod create_core_network_input {
    /// A builder for [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network that a core network will be a part of. </p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network that a core network will be a part of. </p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The description of a core network.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a core network.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>Key-value tags associated with a core network request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>Key-value tags associated with a core network request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The policy document for creating a core network.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The policy document for creating a core network.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>The client token associated with a core network request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with a core network request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateCoreNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateCoreNetworkInput {
                global_network_id: self.global_network_id,
                description: self.description,
                tags: self.tags,
                policy_document: self.policy_document,
                client_token: self.client_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateCoreNetworkInputOperationOutputAlias = crate::operation::CreateCoreNetwork;
#[doc(hidden)]
pub type CreateCoreNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`CreateCoreNetwork`](crate::operation::CreateCoreNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCoreNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateCoreNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/core-networks").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateCoreNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateCoreNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_core_network(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateCoreNetworkInput`](crate::input::CreateCoreNetworkInput)
    pub fn builder() -> crate::input::create_core_network_input::Builder {
        crate::input::create_core_network_input::Builder::default()
    }
}

/// See [`CreateDeviceInput`](crate::input::CreateDeviceInput)
pub mod create_device_input {
    /// A builder for [`CreateDeviceInput`](crate::input::CreateDeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) aws_location: std::option::Option<crate::model::AwsLocation>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn aws_location(mut self, input: crate::model::AwsLocation) -> Self {
            self.aws_location = Some(input);
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn set_aws_location(
            mut self,
            input: std::option::Option<crate::model::AwsLocation>,
        ) -> Self {
            self.aws_location = input;
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the device.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the device.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>The location of the device.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The location of the device.</p>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDeviceInput`](crate::input::CreateDeviceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateDeviceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateDeviceInput {
                global_network_id: self.global_network_id,
                aws_location: self.aws_location,
                description: self.description,
                r#type: self.r#type,
                vendor: self.vendor,
                model: self.model,
                serial_number: self.serial_number,
                location: self.location,
                site_id: self.site_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateDeviceInputOperationOutputAlias = crate::operation::CreateDevice;
#[doc(hidden)]
pub type CreateDeviceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateDeviceInput {
    /// Consumes the builder and constructs an Operation<[`CreateDevice`](crate::operation::CreateDevice)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDevice,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateDeviceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_7 = &_input.global_network_id;
            let input_7 =
                input_7
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_7, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/devices",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateDeviceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateDeviceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_device(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDevice::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDevice",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateDeviceInput`](crate::input::CreateDeviceInput)
    pub fn builder() -> crate::input::create_device_input::Builder {
        crate::input::create_device_input::Builder::default()
    }
}

/// See [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput)
pub mod create_global_network_input {
    /// A builder for [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateGlobalNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateGlobalNetworkInput {
                description: self.description,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateGlobalNetworkInputOperationOutputAlias = crate::operation::CreateGlobalNetwork;
#[doc(hidden)]
pub type CreateGlobalNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateGlobalNetworkInput {
    /// Consumes the builder and constructs an Operation<[`CreateGlobalNetwork`](crate::operation::CreateGlobalNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateGlobalNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateGlobalNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/global-networks").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateGlobalNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateGlobalNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_global_network(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateGlobalNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateGlobalNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateGlobalNetworkInput`](crate::input::CreateGlobalNetworkInput)
    pub fn builder() -> crate::input::create_global_network_input::Builder {
        crate::input::create_global_network_input::Builder::default()
    }
}

/// See [`CreateLinkInput`](crate::input::CreateLinkInput)
pub mod create_link_input {
    /// A builder for [`CreateLinkInput`](crate::input::CreateLinkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) bandwidth: std::option::Option<crate::model::Bandwidth>,
        pub(crate) provider: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p> The upload speed and download speed in Mbps. </p>
        pub fn bandwidth(mut self, input: crate::model::Bandwidth) -> Self {
            self.bandwidth = Some(input);
            self
        }
        /// <p> The upload speed and download speed in Mbps. </p>
        pub fn set_bandwidth(
            mut self,
            input: std::option::Option<crate::model::Bandwidth>,
        ) -> Self {
            self.bandwidth = input;
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLinkInput`](crate::input::CreateLinkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateLinkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateLinkInput {
                global_network_id: self.global_network_id,
                description: self.description,
                r#type: self.r#type,
                bandwidth: self.bandwidth,
                provider: self.provider,
                site_id: self.site_id,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateLinkInputOperationOutputAlias = crate::operation::CreateLink;
#[doc(hidden)]
pub type CreateLinkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateLinkInput {
    /// Consumes the builder and constructs an Operation<[`CreateLink`](crate::operation::CreateLink)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLink,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateLinkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_8 = &_input.global_network_id;
            let input_8 =
                input_8
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_8, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/links",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateLinkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateLinkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_link(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLink",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateLinkInput`](crate::input::CreateLinkInput)
    pub fn builder() -> crate::input::create_link_input::Builder {
        crate::input::create_link_input::Builder::default()
    }
}

/// See [`CreateSiteInput`](crate::input::CreateSiteInput)
pub mod create_site_input {
    /// A builder for [`CreateSiteInput`](crate::input::CreateSiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the resource during creation.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSiteInput`](crate::input::CreateSiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSiteInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSiteInput {
                global_network_id: self.global_network_id,
                description: self.description,
                location: self.location,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSiteInputOperationOutputAlias = crate::operation::CreateSite;
#[doc(hidden)]
pub type CreateSiteInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateSiteInput {
    /// Consumes the builder and constructs an Operation<[`CreateSite`](crate::operation::CreateSite)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSite,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateSiteInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_9 = &_input.global_network_id;
            let input_9 =
                input_9
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_9, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/sites",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateSiteInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateSiteInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_create_site(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSite::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSite",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateSiteInput`](crate::input::CreateSiteInput)
    pub fn builder() -> crate::input::create_site_input::Builder {
        crate::input::create_site_input::Builder::default()
    }
}

/// See [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput)
pub mod create_site_to_site_vpn_attachment_input {
    /// A builder for [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) vpn_connection_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN identifying the VPN attachment.</p>
        pub fn vpn_connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_connection_arn = Some(input.into());
            self
        }
        /// <p>The ARN identifying the VPN attachment.</p>
        pub fn set_vpn_connection_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpn_connection_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateSiteToSiteVpnAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateSiteToSiteVpnAttachmentInput {
                core_network_id: self.core_network_id,
                vpn_connection_arn: self.vpn_connection_arn,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateSiteToSiteVpnAttachmentInputOperationOutputAlias =
    crate::operation::CreateSiteToSiteVpnAttachment;
#[doc(hidden)]
pub type CreateSiteToSiteVpnAttachmentInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl CreateSiteToSiteVpnAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateSiteToSiteVpnAttachment`](crate::operation::CreateSiteToSiteVpnAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateSiteToSiteVpnAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateSiteToSiteVpnAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/site-to-site-vpn-attachments").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateSiteToSiteVpnAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateSiteToSiteVpnAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_site_to_site_vpn_attachment(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateSiteToSiteVpnAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateSiteToSiteVpnAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateSiteToSiteVpnAttachmentInput`](crate::input::CreateSiteToSiteVpnAttachmentInput)
    pub fn builder() -> crate::input::create_site_to_site_vpn_attachment_input::Builder {
        crate::input::create_site_to_site_vpn_attachment_input::Builder::default()
    }
}

/// See [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput)
pub mod create_vpc_attachment_input {
    /// A builder for [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) vpc_arn: std::option::Option<std::string::String>,
        pub(crate) subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) options: std::option::Option<crate::model::VpcOptions>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network for the VPC attachment.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network for the VPC attachment.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the VPC.</p>
        pub fn vpc_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the VPC.</p>
        pub fn set_vpc_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpc_arn = input;
            self
        }
        /// Appends an item to `subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_subnet_arns`](Self::set_subnet_arns).
        ///
        /// <p>The subnet ARN of the VPC attachment.</p>
        pub fn subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.subnet_arns = Some(v);
            self
        }
        /// <p>The subnet ARN of the VPC attachment.</p>
        pub fn set_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_arns = input;
            self
        }
        /// <p>Options for the VPC attachment.</p>
        pub fn options(mut self, input: crate::model::VpcOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options for the VPC attachment.</p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::VpcOptions>) -> Self {
            self.options = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The key-value tags associated with the request.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The key-value tags associated with the request.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::CreateVpcAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::CreateVpcAttachmentInput {
                core_network_id: self.core_network_id,
                vpc_arn: self.vpc_arn,
                subnet_arns: self.subnet_arns,
                options: self.options,
                tags: self.tags,
                client_token: self.client_token,
            })
        }
    }
}
#[doc(hidden)]
pub type CreateVpcAttachmentInputOperationOutputAlias = crate::operation::CreateVpcAttachment;
#[doc(hidden)]
pub type CreateVpcAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl CreateVpcAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`CreateVpcAttachment`](crate::operation::CreateVpcAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateVpcAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::CreateVpcAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/vpc-attachments").expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::CreateVpcAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::CreateVpcAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_create_vpc_attachment(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateVpcAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateVpcAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`CreateVpcAttachmentInput`](crate::input::CreateVpcAttachmentInput)
    pub fn builder() -> crate::input::create_vpc_attachment_input::Builder {
        crate::input::create_vpc_attachment_input::Builder::default()
    }
}

/// See [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput)
pub mod delete_attachment_input {
    /// A builder for [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment to delete.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment to delete.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteAttachmentInputOperationOutputAlias = crate::operation::DeleteAttachment;
#[doc(hidden)]
pub type DeleteAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`DeleteAttachment`](crate::operation::DeleteAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_10 = &_input.attachment_id;
            let input_10 =
                input_10
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_10, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/attachments/{AttachmentId}",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteAttachmentInput`](crate::input::DeleteAttachmentInput)
    pub fn builder() -> crate::input::delete_attachment_input::Builder {
        crate::input::delete_attachment_input::Builder::default()
    }
}

/// See [`DeleteConnectionInput`](crate::input::DeleteConnectionInput)
pub mod delete_connection_input {
    /// A builder for [`DeleteConnectionInput`](crate::input::DeleteConnectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConnectionInput`](crate::input::DeleteConnectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteConnectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteConnectionInput {
                global_network_id: self.global_network_id,
                connection_id: self.connection_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteConnectionInputOperationOutputAlias = crate::operation::DeleteConnection;
#[doc(hidden)]
pub type DeleteConnectionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteConnectionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteConnection`](crate::operation::DeleteConnection)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteConnection,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteConnectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_11 = &_input.global_network_id;
            let input_11 =
                input_11
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_11, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_12 = &_input.connection_id;
            let input_12 =
                input_12
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "connection_id",
                        details: "cannot be empty or unset",
                    })?;
            let connection_id = aws_smithy_http::label::fmt_string(input_12, false);
            if connection_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "connection_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connections/{ConnectionId}",
                GlobalNetworkId = global_network_id,
                ConnectionId = connection_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteConnectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteConnectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteConnection",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteConnectionInput`](crate::input::DeleteConnectionInput)
    pub fn builder() -> crate::input::delete_connection_input::Builder {
        crate::input::delete_connection_input::Builder::default()
    }
}

/// See [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput)
pub mod delete_connect_peer_input {
    /// A builder for [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the deleted Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the deleted Connect peer.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteConnectPeerInput {
                connect_peer_id: self.connect_peer_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteConnectPeerInputOperationOutputAlias = crate::operation::DeleteConnectPeer;
#[doc(hidden)]
pub type DeleteConnectPeerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`DeleteConnectPeer`](crate::operation::DeleteConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_13 = &_input.connect_peer_id;
            let input_13 =
                input_13
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "connect_peer_id",
                        details: "cannot be empty or unset",
                    })?;
            let connect_peer_id = aws_smithy_http::label::fmt_string(input_13, false);
            if connect_peer_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "connect_peer_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/connect-peers/{ConnectPeerId}",
                ConnectPeerId = connect_peer_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteConnectPeerInput`](crate::input::DeleteConnectPeerInput)
    pub fn builder() -> crate::input::delete_connect_peer_input::Builder {
        crate::input::delete_connect_peer_input::Builder::default()
    }
}

/// See [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput)
pub mod delete_core_network_input {
    /// A builder for [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The network ID of the deleted core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The network ID of the deleted core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCoreNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCoreNetworkInput {
                core_network_id: self.core_network_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCoreNetworkInputOperationOutputAlias = crate::operation::DeleteCoreNetwork;
#[doc(hidden)]
pub type DeleteCoreNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCoreNetwork`](crate::operation::DeleteCoreNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCoreNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteCoreNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_14 = &_input.core_network_id;
            let input_14 =
                input_14
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_14, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}",
                CoreNetworkId = core_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteCoreNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteCoreNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteCoreNetworkInput`](crate::input::DeleteCoreNetworkInput)
    pub fn builder() -> crate::input::delete_core_network_input::Builder {
        crate::input::delete_core_network_input::Builder::default()
    }
}

/// See [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput)
pub mod delete_core_network_policy_version_input {
    /// A builder for [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of a core network for the deleted policy.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network for the deleted policy.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The version ID of the deleted policy.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The version ID of the deleted policy.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteCoreNetworkPolicyVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteCoreNetworkPolicyVersionInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteCoreNetworkPolicyVersionInputOperationOutputAlias =
    crate::operation::DeleteCoreNetworkPolicyVersion;
#[doc(hidden)]
pub type DeleteCoreNetworkPolicyVersionInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DeleteCoreNetworkPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`DeleteCoreNetworkPolicyVersion`](crate::operation::DeleteCoreNetworkPolicyVersion)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteCoreNetworkPolicyVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteCoreNetworkPolicyVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_15 = &_input.core_network_id;
            let input_15 =
                input_15
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_15, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_16 = &_input.policy_version_id;
            let input_16 =
                input_16
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    })?;
            let mut policy_version_id_encoder =
                aws_smithy_types::primitive::Encoder::from(*input_16);
            let policy_version_id = policy_version_id_encoder.encode();
            if policy_version_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "policy_version_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}/core-network-policy-versions/{PolicyVersionId}",
                CoreNetworkId = core_network_id,
                PolicyVersionId = policy_version_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteCoreNetworkPolicyVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteCoreNetworkPolicyVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteCoreNetworkPolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteCoreNetworkPolicyVersion",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteCoreNetworkPolicyVersionInput`](crate::input::DeleteCoreNetworkPolicyVersionInput)
    pub fn builder() -> crate::input::delete_core_network_policy_version_input::Builder {
        crate::input::delete_core_network_policy_version_input::Builder::default()
    }
}

/// See [`DeleteDeviceInput`](crate::input::DeleteDeviceInput)
pub mod delete_device_input {
    /// A builder for [`DeleteDeviceInput`](crate::input::DeleteDeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteDeviceInput`](crate::input::DeleteDeviceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteDeviceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteDeviceInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteDeviceInputOperationOutputAlias = crate::operation::DeleteDevice;
#[doc(hidden)]
pub type DeleteDeviceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteDeviceInput {
    /// Consumes the builder and constructs an Operation<[`DeleteDevice`](crate::operation::DeleteDevice)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteDevice,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteDeviceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_17 = &_input.global_network_id;
            let input_17 =
                input_17
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_17, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_18 = &_input.device_id;
            let input_18 =
                input_18
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "device_id",
                        details: "cannot be empty or unset",
                    })?;
            let device_id = aws_smithy_http::label::fmt_string(input_18, false);
            if device_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "device_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/devices/{DeviceId}",
                GlobalNetworkId = global_network_id,
                DeviceId = device_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteDeviceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteDeviceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteDevice::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteDevice",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteDeviceInput`](crate::input::DeleteDeviceInput)
    pub fn builder() -> crate::input::delete_device_input::Builder {
        crate::input::delete_device_input::Builder::default()
    }
}

/// See [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput)
pub mod delete_global_network_input {
    /// A builder for [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteGlobalNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteGlobalNetworkInput {
                global_network_id: self.global_network_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteGlobalNetworkInputOperationOutputAlias = crate::operation::DeleteGlobalNetwork;
#[doc(hidden)]
pub type DeleteGlobalNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteGlobalNetworkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteGlobalNetwork`](crate::operation::DeleteGlobalNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteGlobalNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteGlobalNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_19 = &_input.global_network_id;
            let input_19 =
                input_19
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_19, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteGlobalNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteGlobalNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteGlobalNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteGlobalNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteGlobalNetworkInput`](crate::input::DeleteGlobalNetworkInput)
    pub fn builder() -> crate::input::delete_global_network_input::Builder {
        crate::input::delete_global_network_input::Builder::default()
    }
}

/// See [`DeleteLinkInput`](crate::input::DeleteLinkInput)
pub mod delete_link_input {
    /// A builder for [`DeleteLinkInput`](crate::input::DeleteLinkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteLinkInput`](crate::input::DeleteLinkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteLinkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteLinkInput {
                global_network_id: self.global_network_id,
                link_id: self.link_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteLinkInputOperationOutputAlias = crate::operation::DeleteLink;
#[doc(hidden)]
pub type DeleteLinkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteLinkInput {
    /// Consumes the builder and constructs an Operation<[`DeleteLink`](crate::operation::DeleteLink)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteLink,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteLinkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_20 = &_input.global_network_id;
            let input_20 =
                input_20
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_20, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_21 = &_input.link_id;
            let input_21 =
                input_21
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "link_id",
                        details: "cannot be empty or unset",
                    })?;
            let link_id = aws_smithy_http::label::fmt_string(input_21, false);
            if link_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "link_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/links/{LinkId}",
                GlobalNetworkId = global_network_id,
                LinkId = link_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteLinkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteLinkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteLink",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteLinkInput`](crate::input::DeleteLinkInput)
    pub fn builder() -> crate::input::delete_link_input::Builder {
        crate::input::delete_link_input::Builder::default()
    }
}

/// See [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
pub mod delete_resource_policy_input {
    /// A builder for [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the policy to delete.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the policy to delete.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteResourcePolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteResourcePolicyInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteResourcePolicyInputOperationOutputAlias = crate::operation::DeleteResourcePolicy;
#[doc(hidden)]
pub type DeleteResourcePolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteResourcePolicy`](crate::operation::DeleteResourcePolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteResourcePolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteResourcePolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_22 = &_input.resource_arn;
            let input_22 =
                input_22
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_22, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/resource-policy/{ResourceArn}",
                ResourceArn = resource_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteResourcePolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteResourcePolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteResourcePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteResourcePolicy",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
}

/// See [`DeleteSiteInput`](crate::input::DeleteSiteInput)
pub mod delete_site_input {
    /// A builder for [`DeleteSiteInput`](crate::input::DeleteSiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSiteInput`](crate::input::DeleteSiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeleteSiteInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeleteSiteInput {
                global_network_id: self.global_network_id,
                site_id: self.site_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DeleteSiteInputOperationOutputAlias = crate::operation::DeleteSite;
#[doc(hidden)]
pub type DeleteSiteInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeleteSiteInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSite`](crate::operation::DeleteSite)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeleteSite,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeleteSiteInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_23 = &_input.global_network_id;
            let input_23 =
                input_23
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_23, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_24 = &_input.site_id;
            let input_24 =
                input_24
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "site_id",
                        details: "cannot be empty or unset",
                    })?;
            let site_id = aws_smithy_http::label::fmt_string(input_24, false);
            if site_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "site_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/sites/{SiteId}",
                GlobalNetworkId = global_network_id,
                SiteId = site_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeleteSiteInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeleteSiteInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeleteSite::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeleteSite",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSiteInput`](crate::input::DeleteSiteInput)
    pub fn builder() -> crate::input::delete_site_input::Builder {
        crate::input::delete_site_input::Builder::default()
    }
}

/// See [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput)
pub mod deregister_transit_gateway_input {
    /// A builder for [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn set_transit_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DeregisterTransitGatewayInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DeregisterTransitGatewayInput {
                global_network_id: self.global_network_id,
                transit_gateway_arn: self.transit_gateway_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DeregisterTransitGatewayInputOperationOutputAlias =
    crate::operation::DeregisterTransitGateway;
#[doc(hidden)]
pub type DeregisterTransitGatewayInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DeregisterTransitGatewayInput {
    /// Consumes the builder and constructs an Operation<[`DeregisterTransitGateway`](crate::operation::DeregisterTransitGateway)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DeregisterTransitGateway,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DeregisterTransitGatewayInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_25 = &_input.global_network_id;
            let input_25 =
                input_25
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_25, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_26 = &_input.transit_gateway_arn;
            let input_26 =
                input_26
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "transit_gateway_arn",
                        details: "cannot be empty or unset",
                    })?;
            let transit_gateway_arn = aws_smithy_http::label::fmt_string(input_26, false);
            if transit_gateway_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "transit_gateway_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/global-networks/{GlobalNetworkId}/transit-gateway-registrations/{TransitGatewayArn}", GlobalNetworkId = global_network_id, TransitGatewayArn = transit_gateway_arn).expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DeregisterTransitGatewayInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DeregisterTransitGatewayInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DeregisterTransitGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DeregisterTransitGateway",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DeregisterTransitGatewayInput`](crate::input::DeregisterTransitGatewayInput)
    pub fn builder() -> crate::input::deregister_transit_gateway_input::Builder {
        crate::input::deregister_transit_gateway_input::Builder::default()
    }
}

/// See [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput)
pub mod describe_global_networks_input {
    /// A builder for [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `global_network_ids`.
        ///
        /// To override the contents of this collection use [`set_global_network_ids`](Self::set_global_network_ids).
        ///
        /// <p>The IDs of one or more global networks. The maximum is 10.</p>
        pub fn global_network_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.global_network_ids.unwrap_or_default();
            v.push(input.into());
            self.global_network_ids = Some(v);
            self
        }
        /// <p>The IDs of one or more global networks. The maximum is 10.</p>
        pub fn set_global_network_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.global_network_ids = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DescribeGlobalNetworksInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DescribeGlobalNetworksInput {
                global_network_ids: self.global_network_ids,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type DescribeGlobalNetworksInputOperationOutputAlias = crate::operation::DescribeGlobalNetworks;
#[doc(hidden)]
pub type DescribeGlobalNetworksInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DescribeGlobalNetworksInput {
    /// Consumes the builder and constructs an Operation<[`DescribeGlobalNetworks`](crate::operation::DescribeGlobalNetworks)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DescribeGlobalNetworks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DescribeGlobalNetworksInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/global-networks").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::DescribeGlobalNetworksInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_27) = &_input.global_network_ids {
                for inner_28 in inner_27 {
                    query.push_kv(
                        "globalNetworkIds",
                        &aws_smithy_http::query::fmt_string(&inner_28),
                    );
                }
            }
            if let Some(inner_29) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_29).encode(),
                );
            }
            if let Some(inner_30) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_30));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DescribeGlobalNetworksInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DescribeGlobalNetworksInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DescribeGlobalNetworks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DescribeGlobalNetworks",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DescribeGlobalNetworksInput`](crate::input::DescribeGlobalNetworksInput)
    pub fn builder() -> crate::input::describe_global_networks_input::Builder {
        crate::input::describe_global_networks_input::Builder::default()
    }
}

/// See [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput)
pub mod disassociate_connect_peer_input {
    /// A builder for [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the Connect peer to disassociate from a device.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer to disassociate from a device.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateConnectPeerInput {
                global_network_id: self.global_network_id,
                connect_peer_id: self.connect_peer_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateConnectPeerInputOperationOutputAlias =
    crate::operation::DisassociateConnectPeer;
#[doc(hidden)]
pub type DisassociateConnectPeerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DisassociateConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateConnectPeer`](crate::operation::DisassociateConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_31 = &_input.global_network_id;
            let input_31 =
                input_31
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_31, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_32 = &_input.connect_peer_id;
            let input_32 =
                input_32
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "connect_peer_id",
                        details: "cannot be empty or unset",
                    })?;
            let connect_peer_id = aws_smithy_http::label::fmt_string(input_32, false);
            if connect_peer_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "connect_peer_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connect-peer-associations/{ConnectPeerId}",
                GlobalNetworkId = global_network_id,
                ConnectPeerId = connect_peer_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateConnectPeerInput`](crate::input::DisassociateConnectPeerInput)
    pub fn builder() -> crate::input::disassociate_connect_peer_input::Builder {
        crate::input::disassociate_connect_peer_input::Builder::default()
    }
}

/// See [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput)
pub mod disassociate_customer_gateway_input {
    /// A builder for [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn customer_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn set_customer_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_gateway_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateCustomerGatewayInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateCustomerGatewayInput {
                global_network_id: self.global_network_id,
                customer_gateway_arn: self.customer_gateway_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateCustomerGatewayInputOperationOutputAlias =
    crate::operation::DisassociateCustomerGateway;
#[doc(hidden)]
pub type DisassociateCustomerGatewayInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DisassociateCustomerGatewayInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateCustomerGateway`](crate::operation::DisassociateCustomerGateway)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateCustomerGateway,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateCustomerGatewayInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_33 = &_input.global_network_id;
            let input_33 =
                input_33
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_33, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_34 = &_input.customer_gateway_arn;
            let input_34 =
                input_34
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "customer_gateway_arn",
                        details: "cannot be empty or unset",
                    })?;
            let customer_gateway_arn = aws_smithy_http::label::fmt_string(input_34, false);
            if customer_gateway_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "customer_gateway_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/global-networks/{GlobalNetworkId}/customer-gateway-associations/{CustomerGatewayArn}", GlobalNetworkId = global_network_id, CustomerGatewayArn = customer_gateway_arn).expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateCustomerGatewayInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateCustomerGatewayInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateCustomerGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateCustomerGateway",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateCustomerGatewayInput`](crate::input::DisassociateCustomerGatewayInput)
    pub fn builder() -> crate::input::disassociate_customer_gateway_input::Builder {
        crate::input::disassociate_customer_gateway_input::Builder::default()
    }
}

/// See [`DisassociateLinkInput`](crate::input::DisassociateLinkInput)
pub mod disassociate_link_input {
    /// A builder for [`DisassociateLinkInput`](crate::input::DisassociateLinkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateLinkInput`](crate::input::DisassociateLinkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateLinkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateLinkInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateLinkInputOperationOutputAlias = crate::operation::DisassociateLink;
#[doc(hidden)]
pub type DisassociateLinkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl DisassociateLinkInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateLink`](crate::operation::DisassociateLink)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateLink,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateLinkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_35 = &_input.global_network_id;
            let input_35 =
                input_35
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_35, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/link-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::DisassociateLinkInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_36) = &_input.device_id {
                query.push_kv("deviceId", &aws_smithy_http::query::fmt_string(&inner_36));
            }
            if let Some(inner_37) = &_input.link_id {
                query.push_kv("linkId", &aws_smithy_http::query::fmt_string(&inner_37));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateLinkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateLinkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateLink",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateLinkInput`](crate::input::DisassociateLinkInput)
    pub fn builder() -> crate::input::disassociate_link_input::Builder {
        crate::input::disassociate_link_input::Builder::default()
    }
}

/// See [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput)
pub mod disassociate_transit_gateway_connect_peer_input {
    /// A builder for [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
        pub fn transit_gateway_connect_peer_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
        pub fn set_transit_gateway_connect_peer_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_connect_peer_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::DisassociateTransitGatewayConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::DisassociateTransitGatewayConnectPeerInput {
                global_network_id: self.global_network_id,
                transit_gateway_connect_peer_arn: self.transit_gateway_connect_peer_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type DisassociateTransitGatewayConnectPeerInputOperationOutputAlias =
    crate::operation::DisassociateTransitGatewayConnectPeer;
#[doc(hidden)]
pub type DisassociateTransitGatewayConnectPeerInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl DisassociateTransitGatewayConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`DisassociateTransitGatewayConnectPeer`](crate::operation::DisassociateTransitGatewayConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::DisassociateTransitGatewayConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::DisassociateTransitGatewayConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_38 = &_input.global_network_id;
            let input_38 =
                input_38
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_38, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_39 = &_input.transit_gateway_connect_peer_arn;
            let input_39 =
                input_39
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "transit_gateway_connect_peer_arn",
                        details: "cannot be empty or unset",
                    })?;
            let transit_gateway_connect_peer_arn =
                aws_smithy_http::label::fmt_string(input_39, false);
            if transit_gateway_connect_peer_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "transit_gateway_connect_peer_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/global-networks/{GlobalNetworkId}/transit-gateway-connect-peer-associations/{TransitGatewayConnectPeerArn}", GlobalNetworkId = global_network_id, TransitGatewayConnectPeerArn = transit_gateway_connect_peer_arn).expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::DisassociateTransitGatewayConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::DisassociateTransitGatewayConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::DisassociateTransitGatewayConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "DisassociateTransitGatewayConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`DisassociateTransitGatewayConnectPeerInput`](crate::input::DisassociateTransitGatewayConnectPeerInput)
    pub fn builder() -> crate::input::disassociate_transit_gateway_connect_peer_input::Builder {
        crate::input::disassociate_transit_gateway_connect_peer_input::Builder::default()
    }
}

/// See [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput)
pub mod execute_core_network_change_set_input {
    /// A builder for [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ExecuteCoreNetworkChangeSetInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ExecuteCoreNetworkChangeSetInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type ExecuteCoreNetworkChangeSetInputOperationOutputAlias =
    crate::operation::ExecuteCoreNetworkChangeSet;
#[doc(hidden)]
pub type ExecuteCoreNetworkChangeSetInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ExecuteCoreNetworkChangeSetInput {
    /// Consumes the builder and constructs an Operation<[`ExecuteCoreNetworkChangeSet`](crate::operation::ExecuteCoreNetworkChangeSet)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ExecuteCoreNetworkChangeSet,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ExecuteCoreNetworkChangeSetInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_40 = &_input.core_network_id;
            let input_40 =
                input_40
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_40, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_41 = &_input.policy_version_id;
            let input_41 =
                input_41
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    })?;
            let mut policy_version_id_encoder =
                aws_smithy_types::primitive::Encoder::from(*input_41);
            let policy_version_id = policy_version_id_encoder.encode();
            if policy_version_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "policy_version_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}/core-network-change-sets/{PolicyVersionId}/execute",
                CoreNetworkId = core_network_id,
                PolicyVersionId = policy_version_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ExecuteCoreNetworkChangeSetInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ExecuteCoreNetworkChangeSetInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ExecuteCoreNetworkChangeSet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ExecuteCoreNetworkChangeSet",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ExecuteCoreNetworkChangeSetInput`](crate::input::ExecuteCoreNetworkChangeSetInput)
    pub fn builder() -> crate::input::execute_core_network_change_set_input::Builder {
        crate::input::execute_core_network_change_set_input::Builder::default()
    }
}

/// See [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput)
pub mod get_connect_attachment_input {
    /// A builder for [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetConnectAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetConnectAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetConnectAttachmentInputOperationOutputAlias = crate::operation::GetConnectAttachment;
#[doc(hidden)]
pub type GetConnectAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetConnectAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectAttachment`](crate::operation::GetConnectAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnectAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetConnectAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_42 = &_input.attachment_id;
            let input_42 =
                input_42
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_42, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/connect-attachments/{AttachmentId}",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetConnectAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetConnectAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnectAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnectAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetConnectAttachmentInput`](crate::input::GetConnectAttachmentInput)
    pub fn builder() -> crate::input::get_connect_attachment_input::Builder {
        crate::input::get_connect_attachment_input::Builder::default()
    }
}

/// See [`GetConnectionsInput`](crate::input::GetConnectionsInput)
pub mod get_connections_input {
    /// A builder for [`GetConnectionsInput`](crate::input::GetConnectionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connection_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `connection_ids`.
        ///
        /// To override the contents of this collection use [`set_connection_ids`](Self::set_connection_ids).
        ///
        /// <p>One or more connection IDs.</p>
        pub fn connection_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.connection_ids.unwrap_or_default();
            v.push(input.into());
            self.connection_ids = Some(v);
            self
        }
        /// <p>One or more connection IDs.</p>
        pub fn set_connection_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.connection_ids = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectionsInput`](crate::input::GetConnectionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetConnectionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetConnectionsInput {
                global_network_id: self.global_network_id,
                connection_ids: self.connection_ids,
                device_id: self.device_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetConnectionsInputOperationOutputAlias = crate::operation::GetConnections;
#[doc(hidden)]
pub type GetConnectionsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetConnectionsInput {
    /// Consumes the builder and constructs an Operation<[`GetConnections`](crate::operation::GetConnections)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnections,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetConnectionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_43 = &_input.global_network_id;
            let input_43 =
                input_43
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_43, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connections",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetConnectionsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_44) = &_input.connection_ids {
                for inner_45 in inner_44 {
                    query.push_kv(
                        "connectionIds",
                        &aws_smithy_http::query::fmt_string(&inner_45),
                    );
                }
            }
            if let Some(inner_46) = &_input.device_id {
                query.push_kv("deviceId", &aws_smithy_http::query::fmt_string(&inner_46));
            }
            if let Some(inner_47) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_47).encode(),
                );
            }
            if let Some(inner_48) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_48));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetConnectionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetConnectionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnections::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnections",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetConnectionsInput`](crate::input::GetConnectionsInput)
    pub fn builder() -> crate::input::get_connections_input::Builder {
        crate::input::get_connections_input::Builder::default()
    }
}

/// See [`GetConnectPeerInput`](crate::input::GetConnectPeerInput)
pub mod get_connect_peer_input {
    /// A builder for [`GetConnectPeerInput`](crate::input::GetConnectPeerInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn set_connect_peer_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_peer_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectPeerInput`](crate::input::GetConnectPeerInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetConnectPeerInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetConnectPeerInput {
                connect_peer_id: self.connect_peer_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetConnectPeerInputOperationOutputAlias = crate::operation::GetConnectPeer;
#[doc(hidden)]
pub type GetConnectPeerInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetConnectPeerInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectPeer`](crate::operation::GetConnectPeer)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnectPeer,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetConnectPeerInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_49 = &_input.connect_peer_id;
            let input_49 =
                input_49
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "connect_peer_id",
                        details: "cannot be empty or unset",
                    })?;
            let connect_peer_id = aws_smithy_http::label::fmt_string(input_49, false);
            if connect_peer_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "connect_peer_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/connect-peers/{ConnectPeerId}",
                ConnectPeerId = connect_peer_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetConnectPeerInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetConnectPeerInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnectPeer::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnectPeer",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetConnectPeerInput`](crate::input::GetConnectPeerInput)
    pub fn builder() -> crate::input::get_connect_peer_input::Builder {
        crate::input::get_connect_peer_input::Builder::default()
    }
}

/// See [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput)
pub mod get_connect_peer_associations_input {
    /// A builder for [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `connect_peer_ids`.
        ///
        /// To override the contents of this collection use [`set_connect_peer_ids`](Self::set_connect_peer_ids).
        ///
        /// <p>The IDs of the Connect peers.</p>
        pub fn connect_peer_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.connect_peer_ids.unwrap_or_default();
            v.push(input.into());
            self.connect_peer_ids = Some(v);
            self
        }
        /// <p>The IDs of the Connect peers.</p>
        pub fn set_connect_peer_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.connect_peer_ids = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetConnectPeerAssociationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetConnectPeerAssociationsInput {
                global_network_id: self.global_network_id,
                connect_peer_ids: self.connect_peer_ids,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetConnectPeerAssociationsInputOperationOutputAlias =
    crate::operation::GetConnectPeerAssociations;
#[doc(hidden)]
pub type GetConnectPeerAssociationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetConnectPeerAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetConnectPeerAssociations`](crate::operation::GetConnectPeerAssociations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetConnectPeerAssociations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetConnectPeerAssociationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_50 = &_input.global_network_id;
            let input_50 =
                input_50
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_50, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connect-peer-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetConnectPeerAssociationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_51) = &_input.connect_peer_ids {
                for inner_52 in inner_51 {
                    query.push_kv(
                        "connectPeerIds",
                        &aws_smithy_http::query::fmt_string(&inner_52),
                    );
                }
            }
            if let Some(inner_53) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_53).encode(),
                );
            }
            if let Some(inner_54) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_54));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetConnectPeerAssociationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetConnectPeerAssociationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetConnectPeerAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetConnectPeerAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetConnectPeerAssociationsInput`](crate::input::GetConnectPeerAssociationsInput)
    pub fn builder() -> crate::input::get_connect_peer_associations_input::Builder {
        crate::input::get_connect_peer_associations_input::Builder::default()
    }
}

/// See [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput)
pub mod get_core_network_input {
    /// A builder for [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCoreNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCoreNetworkInput {
                core_network_id: self.core_network_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCoreNetworkInputOperationOutputAlias = crate::operation::GetCoreNetwork;
#[doc(hidden)]
pub type GetCoreNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetwork`](crate::operation::GetCoreNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCoreNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_55 = &_input.core_network_id;
            let input_55 =
                input_55
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_55, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}",
                CoreNetworkId = core_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCoreNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCoreNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkInput`](crate::input::GetCoreNetworkInput)
    pub fn builder() -> crate::input::get_core_network_input::Builder {
        crate::input::get_core_network_input::Builder::default()
    }
}

/// See [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput)
pub mod get_core_network_change_set_input {
    /// A builder for [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCoreNetworkChangeSetInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCoreNetworkChangeSetInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCoreNetworkChangeSetInputOperationOutputAlias =
    crate::operation::GetCoreNetworkChangeSet;
#[doc(hidden)]
pub type GetCoreNetworkChangeSetInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetCoreNetworkChangeSetInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetworkChangeSet`](crate::operation::GetCoreNetworkChangeSet)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetworkChangeSet,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCoreNetworkChangeSetInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_56 = &_input.core_network_id;
            let input_56 =
                input_56
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_56, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_57 = &_input.policy_version_id;
            let input_57 =
                input_57
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    })?;
            let mut policy_version_id_encoder =
                aws_smithy_types::primitive::Encoder::from(*input_57);
            let policy_version_id = policy_version_id_encoder.encode();
            if policy_version_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "policy_version_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}/core-network-change-sets/{PolicyVersionId}",
                CoreNetworkId = core_network_id,
                PolicyVersionId = policy_version_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetCoreNetworkChangeSetInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_58) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_58).encode(),
                );
            }
            if let Some(inner_59) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_59));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCoreNetworkChangeSetInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCoreNetworkChangeSetInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetworkChangeSet::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetworkChangeSet",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkChangeSetInput`](crate::input::GetCoreNetworkChangeSetInput)
    pub fn builder() -> crate::input::get_core_network_change_set_input::Builder {
        crate::input::get_core_network_change_set_input::Builder::default()
    }
}

/// See [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput)
pub mod get_core_network_policy_input {
    /// A builder for [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of a core network policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of a core network policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// <p>The alias of a core network policy </p>
        pub fn alias(mut self, input: crate::model::CoreNetworkPolicyAlias) -> Self {
            self.alias = Some(input);
            self
        }
        /// <p>The alias of a core network policy </p>
        pub fn set_alias(
            mut self,
            input: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
        ) -> Self {
            self.alias = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCoreNetworkPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCoreNetworkPolicyInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
                alias: self.alias,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCoreNetworkPolicyInputOperationOutputAlias = crate::operation::GetCoreNetworkPolicy;
#[doc(hidden)]
pub type GetCoreNetworkPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetCoreNetworkPolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetCoreNetworkPolicy`](crate::operation::GetCoreNetworkPolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCoreNetworkPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCoreNetworkPolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_60 = &_input.core_network_id;
            let input_60 =
                input_60
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_60, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}/core-network-policy",
                CoreNetworkId = core_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetCoreNetworkPolicyInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_61) = &_input.policy_version_id {
                query.push_kv(
                    "policyVersionId",
                    aws_smithy_types::primitive::Encoder::from(*inner_61).encode(),
                );
            }
            if let Some(inner_62) = &_input.alias {
                query.push_kv("alias", &aws_smithy_http::query::fmt_string(&inner_62));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCoreNetworkPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCoreNetworkPolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCoreNetworkPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCoreNetworkPolicy",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCoreNetworkPolicyInput`](crate::input::GetCoreNetworkPolicyInput)
    pub fn builder() -> crate::input::get_core_network_policy_input::Builder {
        crate::input::get_core_network_policy_input::Builder::default()
    }
}

/// See [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput)
pub mod get_customer_gateway_associations_input {
    /// A builder for [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) customer_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `customer_gateway_arns`.
        ///
        /// To override the contents of this collection use [`set_customer_gateway_arns`](Self::set_customer_gateway_arns).
        ///
        /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
        pub fn customer_gateway_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.customer_gateway_arns.unwrap_or_default();
            v.push(input.into());
            self.customer_gateway_arns = Some(v);
            self
        }
        /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
        pub fn set_customer_gateway_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.customer_gateway_arns = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetCustomerGatewayAssociationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetCustomerGatewayAssociationsInput {
                global_network_id: self.global_network_id,
                customer_gateway_arns: self.customer_gateway_arns,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetCustomerGatewayAssociationsInputOperationOutputAlias =
    crate::operation::GetCustomerGatewayAssociations;
#[doc(hidden)]
pub type GetCustomerGatewayAssociationsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetCustomerGatewayAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetCustomerGatewayAssociations`](crate::operation::GetCustomerGatewayAssociations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCustomerGatewayAssociations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetCustomerGatewayAssociationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_63 = &_input.global_network_id;
            let input_63 =
                input_63
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_63, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/customer-gateway-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetCustomerGatewayAssociationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_64) = &_input.customer_gateway_arns {
                for inner_65 in inner_64 {
                    query.push_kv(
                        "customerGatewayArns",
                        &aws_smithy_http::query::fmt_string(&inner_65),
                    );
                }
            }
            if let Some(inner_66) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_66).encode(),
                );
            }
            if let Some(inner_67) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_67));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetCustomerGatewayAssociationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetCustomerGatewayAssociationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCustomerGatewayAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCustomerGatewayAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetCustomerGatewayAssociationsInput`](crate::input::GetCustomerGatewayAssociationsInput)
    pub fn builder() -> crate::input::get_customer_gateway_associations_input::Builder {
        crate::input::get_customer_gateway_associations_input::Builder::default()
    }
}

/// See [`GetDevicesInput`](crate::input::GetDevicesInput)
pub mod get_devices_input {
    /// A builder for [`GetDevicesInput`](crate::input::GetDevicesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `device_ids`.
        ///
        /// To override the contents of this collection use [`set_device_ids`](Self::set_device_ids).
        ///
        /// <p>One or more device IDs. The maximum is 10.</p>
        pub fn device_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.device_ids.unwrap_or_default();
            v.push(input.into());
            self.device_ids = Some(v);
            self
        }
        /// <p>One or more device IDs. The maximum is 10.</p>
        pub fn set_device_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.device_ids = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDevicesInput`](crate::input::GetDevicesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetDevicesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetDevicesInput {
                global_network_id: self.global_network_id,
                device_ids: self.device_ids,
                site_id: self.site_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetDevicesInputOperationOutputAlias = crate::operation::GetDevices;
#[doc(hidden)]
pub type GetDevicesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetDevicesInput {
    /// Consumes the builder and constructs an Operation<[`GetDevices`](crate::operation::GetDevices)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDevices,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetDevicesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_68 = &_input.global_network_id;
            let input_68 =
                input_68
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_68, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/devices",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetDevicesInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_69) = &_input.device_ids {
                for inner_70 in inner_69 {
                    query.push_kv("deviceIds", &aws_smithy_http::query::fmt_string(&inner_70));
                }
            }
            if let Some(inner_71) = &_input.site_id {
                query.push_kv("siteId", &aws_smithy_http::query::fmt_string(&inner_71));
            }
            if let Some(inner_72) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_72).encode(),
                );
            }
            if let Some(inner_73) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_73));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetDevicesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetDevicesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetDevices::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetDevices",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetDevicesInput`](crate::input::GetDevicesInput)
    pub fn builder() -> crate::input::get_devices_input::Builder {
        crate::input::get_devices_input::Builder::default()
    }
}

/// See [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput)
pub mod get_link_associations_input {
    /// A builder for [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetLinkAssociationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetLinkAssociationsInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                link_id: self.link_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLinkAssociationsInputOperationOutputAlias = crate::operation::GetLinkAssociations;
#[doc(hidden)]
pub type GetLinkAssociationsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLinkAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetLinkAssociations`](crate::operation::GetLinkAssociations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLinkAssociations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLinkAssociationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_74 = &_input.global_network_id;
            let input_74 =
                input_74
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_74, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/link-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetLinkAssociationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_75) = &_input.device_id {
                query.push_kv("deviceId", &aws_smithy_http::query::fmt_string(&inner_75));
            }
            if let Some(inner_76) = &_input.link_id {
                query.push_kv("linkId", &aws_smithy_http::query::fmt_string(&inner_76));
            }
            if let Some(inner_77) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_77).encode(),
                );
            }
            if let Some(inner_78) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_78));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLinkAssociationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLinkAssociationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetLinkAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetLinkAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLinkAssociationsInput`](crate::input::GetLinkAssociationsInput)
    pub fn builder() -> crate::input::get_link_associations_input::Builder {
        crate::input::get_link_associations_input::Builder::default()
    }
}

/// See [`GetLinksInput`](crate::input::GetLinksInput)
pub mod get_links_input {
    /// A builder for [`GetLinksInput`](crate::input::GetLinksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) link_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) provider: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `link_ids`.
        ///
        /// To override the contents of this collection use [`set_link_ids`](Self::set_link_ids).
        ///
        /// <p>One or more link IDs. The maximum is 10.</p>
        pub fn link_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.link_ids.unwrap_or_default();
            v.push(input.into());
            self.link_ids = Some(v);
            self
        }
        /// <p>One or more link IDs. The maximum is 10.</p>
        pub fn set_link_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.link_ids = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>The link type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The link type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The link provider.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The link provider.</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLinksInput`](crate::input::GetLinksInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetLinksInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetLinksInput {
                global_network_id: self.global_network_id,
                link_ids: self.link_ids,
                site_id: self.site_id,
                r#type: self.r#type,
                provider: self.provider,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetLinksInputOperationOutputAlias = crate::operation::GetLinks;
#[doc(hidden)]
pub type GetLinksInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetLinksInput {
    /// Consumes the builder and constructs an Operation<[`GetLinks`](crate::operation::GetLinks)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLinks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetLinksInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_79 = &_input.global_network_id;
            let input_79 =
                input_79
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_79, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/links",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetLinksInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_80) = &_input.link_ids {
                for inner_81 in inner_80 {
                    query.push_kv("linkIds", &aws_smithy_http::query::fmt_string(&inner_81));
                }
            }
            if let Some(inner_82) = &_input.site_id {
                query.push_kv("siteId", &aws_smithy_http::query::fmt_string(&inner_82));
            }
            if let Some(inner_83) = &_input.r#type {
                query.push_kv("type", &aws_smithy_http::query::fmt_string(&inner_83));
            }
            if let Some(inner_84) = &_input.provider {
                query.push_kv("provider", &aws_smithy_http::query::fmt_string(&inner_84));
            }
            if let Some(inner_85) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_85).encode(),
                );
            }
            if let Some(inner_86) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_86));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetLinksInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetLinksInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetLinks::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetLinks",
                    "networkmanager",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetLinksInput`](crate::input::GetLinksInput)
    pub fn builder() -> crate::input::get_links_input::Builder {
        crate::input::get_links_input::Builder::default()
    }
}

/// See [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput)
pub mod get_network_resource_counts_input {
    /// A builder for [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetNetworkResourceCountsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetNetworkResourceCountsInput {
                global_network_id: self.global_network_id,
                resource_type: self.resource_type,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetNetworkResourceCountsInputOperationOutputAlias =
    crate::operation::GetNetworkResourceCounts;
#[doc(hidden)]
pub type GetNetworkResourceCountsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetNetworkResourceCountsInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkResourceCounts`](crate::operation::GetNetworkResourceCounts)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkResourceCounts,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetNetworkResourceCountsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_87 = &_input.global_network_id;
            let input_87 =
                input_87
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_87, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/network-resource-count",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetNetworkResourceCountsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_88) = &_input.resource_type {
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_88),
                );
            }
            if let Some(inner_89) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_89).encode(),
                );
            }
            if let Some(inner_90) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_90));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetNetworkResourceCountsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetNetworkResourceCountsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkResourceCounts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkResourceCounts",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetNetworkResourceCountsInput`](crate::input::GetNetworkResourceCountsInput)
    pub fn builder() -> crate::input::get_network_resource_counts_input::Builder {
        crate::input::get_network_resource_counts_input::Builder::default()
    }
}

/// See [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput)
pub mod get_network_resource_relationships_input {
    /// A builder for [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the registered gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the registered gateway.</p>
        pub fn set_registered_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_gateway_arn = input;
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetNetworkResourceRelationshipsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetNetworkResourceRelationshipsInput {
                global_network_id: self.global_network_id,
                core_network_id: self.core_network_id,
                registered_gateway_arn: self.registered_gateway_arn,
                aws_region: self.aws_region,
                account_id: self.account_id,
                resource_type: self.resource_type,
                resource_arn: self.resource_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetNetworkResourceRelationshipsInputOperationOutputAlias =
    crate::operation::GetNetworkResourceRelationships;
#[doc(hidden)]
pub type GetNetworkResourceRelationshipsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetNetworkResourceRelationshipsInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkResourceRelationships`](crate::operation::GetNetworkResourceRelationships)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkResourceRelationships,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetNetworkResourceRelationshipsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_91 = &_input.global_network_id;
            let input_91 =
                input_91
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_91, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/network-resource-relationships",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetNetworkResourceRelationshipsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_92) = &_input.core_network_id {
                query.push_kv(
                    "coreNetworkId",
                    &aws_smithy_http::query::fmt_string(&inner_92),
                );
            }
            if let Some(inner_93) = &_input.registered_gateway_arn {
                query.push_kv(
                    "registeredGatewayArn",
                    &aws_smithy_http::query::fmt_string(&inner_93),
                );
            }
            if let Some(inner_94) = &_input.aws_region {
                query.push_kv("awsRegion", &aws_smithy_http::query::fmt_string(&inner_94));
            }
            if let Some(inner_95) = &_input.account_id {
                query.push_kv("accountId", &aws_smithy_http::query::fmt_string(&inner_95));
            }
            if let Some(inner_96) = &_input.resource_type {
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_96),
                );
            }
            if let Some(inner_97) = &_input.resource_arn {
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_97),
                );
            }
            if let Some(inner_98) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_98).encode(),
                );
            }
            if let Some(inner_99) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_99));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetNetworkResourceRelationshipsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetNetworkResourceRelationshipsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkResourceRelationships::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkResourceRelationships",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetNetworkResourceRelationshipsInput`](crate::input::GetNetworkResourceRelationshipsInput)
    pub fn builder() -> crate::input::get_network_resource_relationships_input::Builder {
        crate::input::get_network_resource_relationships_input::Builder::default()
    }
}

/// See [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput)
pub mod get_network_resources_input {
    /// A builder for [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_gateway_arn = input;
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
        /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
        /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
        /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
        /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
        /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
        /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
        /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
        /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
        /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetNetworkResourcesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetNetworkResourcesInput {
                global_network_id: self.global_network_id,
                core_network_id: self.core_network_id,
                registered_gateway_arn: self.registered_gateway_arn,
                aws_region: self.aws_region,
                account_id: self.account_id,
                resource_type: self.resource_type,
                resource_arn: self.resource_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetNetworkResourcesInputOperationOutputAlias = crate::operation::GetNetworkResources;
#[doc(hidden)]
pub type GetNetworkResourcesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetNetworkResourcesInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkResources`](crate::operation::GetNetworkResources)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkResources,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetNetworkResourcesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_100 = &_input.global_network_id;
            let input_100 =
                input_100
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_100, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/network-resources",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetNetworkResourcesInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_101) = &_input.core_network_id {
                query.push_kv(
                    "coreNetworkId",
                    &aws_smithy_http::query::fmt_string(&inner_101),
                );
            }
            if let Some(inner_102) = &_input.registered_gateway_arn {
                query.push_kv(
                    "registeredGatewayArn",
                    &aws_smithy_http::query::fmt_string(&inner_102),
                );
            }
            if let Some(inner_103) = &_input.aws_region {
                query.push_kv("awsRegion", &aws_smithy_http::query::fmt_string(&inner_103));
            }
            if let Some(inner_104) = &_input.account_id {
                query.push_kv("accountId", &aws_smithy_http::query::fmt_string(&inner_104));
            }
            if let Some(inner_105) = &_input.resource_type {
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_105),
                );
            }
            if let Some(inner_106) = &_input.resource_arn {
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_106),
                );
            }
            if let Some(inner_107) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_107).encode(),
                );
            }
            if let Some(inner_108) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_108));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetNetworkResourcesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetNetworkResourcesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkResources::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkResources",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetNetworkResourcesInput`](crate::input::GetNetworkResourcesInput)
    pub fn builder() -> crate::input::get_network_resources_input::Builder {
        crate::input::get_network_resources_input::Builder::default()
    }
}

/// See [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput)
pub mod get_network_routes_input {
    /// A builder for [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) route_table_identifier: std::option::Option<crate::model::RouteTableIdentifier>,
        pub(crate) exact_cidr_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) longest_prefix_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) subnet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) supernet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) prefix_list_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) states: std::option::Option<std::vec::Vec<crate::model::RouteState>>,
        pub(crate) types: std::option::Option<std::vec::Vec<crate::model::RouteType>>,
        pub(crate) destination_filters: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn route_table_identifier(mut self, input: crate::model::RouteTableIdentifier) -> Self {
            self.route_table_identifier = Some(input);
            self
        }
        /// <p>The ID of the route table.</p>
        pub fn set_route_table_identifier(
            mut self,
            input: std::option::Option<crate::model::RouteTableIdentifier>,
        ) -> Self {
            self.route_table_identifier = input;
            self
        }
        /// Appends an item to `exact_cidr_matches`.
        ///
        /// To override the contents of this collection use [`set_exact_cidr_matches`](Self::set_exact_cidr_matches).
        ///
        /// <p>An exact CIDR block.</p>
        pub fn exact_cidr_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.exact_cidr_matches.unwrap_or_default();
            v.push(input.into());
            self.exact_cidr_matches = Some(v);
            self
        }
        /// <p>An exact CIDR block.</p>
        pub fn set_exact_cidr_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.exact_cidr_matches = input;
            self
        }
        /// Appends an item to `longest_prefix_matches`.
        ///
        /// To override the contents of this collection use [`set_longest_prefix_matches`](Self::set_longest_prefix_matches).
        ///
        /// <p>The most specific route that matches the traffic (longest prefix match).</p>
        pub fn longest_prefix_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.longest_prefix_matches.unwrap_or_default();
            v.push(input.into());
            self.longest_prefix_matches = Some(v);
            self
        }
        /// <p>The most specific route that matches the traffic (longest prefix match).</p>
        pub fn set_longest_prefix_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.longest_prefix_matches = input;
            self
        }
        /// Appends an item to `subnet_of_matches`.
        ///
        /// To override the contents of this collection use [`set_subnet_of_matches`](Self::set_subnet_of_matches).
        ///
        /// <p>The routes with a subnet that match the specified CIDR filter.</p>
        pub fn subnet_of_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_of_matches.unwrap_or_default();
            v.push(input.into());
            self.subnet_of_matches = Some(v);
            self
        }
        /// <p>The routes with a subnet that match the specified CIDR filter.</p>
        pub fn set_subnet_of_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_of_matches = input;
            self
        }
        /// Appends an item to `supernet_of_matches`.
        ///
        /// To override the contents of this collection use [`set_supernet_of_matches`](Self::set_supernet_of_matches).
        ///
        /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
        pub fn supernet_of_matches(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.supernet_of_matches.unwrap_or_default();
            v.push(input.into());
            self.supernet_of_matches = Some(v);
            self
        }
        /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
        pub fn set_supernet_of_matches(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.supernet_of_matches = input;
            self
        }
        /// Appends an item to `prefix_list_ids`.
        ///
        /// To override the contents of this collection use [`set_prefix_list_ids`](Self::set_prefix_list_ids).
        ///
        /// <p>The IDs of the prefix lists.</p>
        pub fn prefix_list_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.prefix_list_ids.unwrap_or_default();
            v.push(input.into());
            self.prefix_list_ids = Some(v);
            self
        }
        /// <p>The IDs of the prefix lists.</p>
        pub fn set_prefix_list_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.prefix_list_ids = input;
            self
        }
        /// Appends an item to `states`.
        ///
        /// To override the contents of this collection use [`set_states`](Self::set_states).
        ///
        /// <p>The route states.</p>
        pub fn states(mut self, input: crate::model::RouteState) -> Self {
            let mut v = self.states.unwrap_or_default();
            v.push(input);
            self.states = Some(v);
            self
        }
        /// <p>The route states.</p>
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RouteState>>,
        ) -> Self {
            self.states = input;
            self
        }
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        ///
        /// <p>The route types.</p>
        pub fn types(mut self, input: crate::model::RouteType) -> Self {
            let mut v = self.types.unwrap_or_default();
            v.push(input);
            self.types = Some(v);
            self
        }
        /// <p>The route types.</p>
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RouteType>>,
        ) -> Self {
            self.types = input;
            self
        }
        /// Adds a key-value pair to `destination_filters`.
        ///
        /// To override the contents of this collection use [`set_destination_filters`](Self::set_destination_filters).
        ///
        /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
        pub fn destination_filters(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.destination_filters.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.destination_filters = Some(hash_map);
            self
        }
        /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
        pub fn set_destination_filters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.destination_filters = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetNetworkRoutesInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetNetworkRoutesInput {
                global_network_id: self.global_network_id,
                route_table_identifier: self.route_table_identifier,
                exact_cidr_matches: self.exact_cidr_matches,
                longest_prefix_matches: self.longest_prefix_matches,
                subnet_of_matches: self.subnet_of_matches,
                supernet_of_matches: self.supernet_of_matches,
                prefix_list_ids: self.prefix_list_ids,
                states: self.states,
                types: self.types,
                destination_filters: self.destination_filters,
            })
        }
    }
}
#[doc(hidden)]
pub type GetNetworkRoutesInputOperationOutputAlias = crate::operation::GetNetworkRoutes;
#[doc(hidden)]
pub type GetNetworkRoutesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetNetworkRoutesInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkRoutes`](crate::operation::GetNetworkRoutes)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkRoutes,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetNetworkRoutesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_109 = &_input.global_network_id;
            let input_109 =
                input_109
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_109, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/network-routes",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetNetworkRoutesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetNetworkRoutesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_get_network_routes(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkRoutes::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkRoutes",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetNetworkRoutesInput`](crate::input::GetNetworkRoutesInput)
    pub fn builder() -> crate::input::get_network_routes_input::Builder {
        crate::input::get_network_routes_input::Builder::default()
    }
}

/// See [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput)
pub mod get_network_telemetry_input {
    /// A builder for [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registered_gateway_arn = input;
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input;
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input;
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        /// <p>The following are the supported resource types for Direct Connect:</p>
        /// <ul>
        /// <li> <p> <code>dxcon</code> </p> </li>
        /// <li> <p> <code>dx-gateway</code> </p> </li>
        /// <li> <p> <code>dx-vif</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Network Manager:</p>
        /// <ul>
        /// <li> <p> <code>connection</code> </p> </li>
        /// <li> <p> <code>device</code> </p> </li>
        /// <li> <p> <code>link</code> </p> </li>
        /// <li> <p> <code>site</code> </p> </li>
        /// </ul>
        /// <p>The following are the supported resource types for Amazon VPC:</p>
        /// <ul>
        /// <li> <p> <code>customer-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway</code> </p> </li>
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
        /// <li> <p> <code>vpn-connection</code> </p> </li>
        /// </ul>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetNetworkTelemetryInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetNetworkTelemetryInput {
                global_network_id: self.global_network_id,
                core_network_id: self.core_network_id,
                registered_gateway_arn: self.registered_gateway_arn,
                aws_region: self.aws_region,
                account_id: self.account_id,
                resource_type: self.resource_type,
                resource_arn: self.resource_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetNetworkTelemetryInputOperationOutputAlias = crate::operation::GetNetworkTelemetry;
#[doc(hidden)]
pub type GetNetworkTelemetryInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetNetworkTelemetryInput {
    /// Consumes the builder and constructs an Operation<[`GetNetworkTelemetry`](crate::operation::GetNetworkTelemetry)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetNetworkTelemetry,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetNetworkTelemetryInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_110 = &_input.global_network_id;
            let input_110 =
                input_110
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_110, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/network-telemetry",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetNetworkTelemetryInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_111) = &_input.core_network_id {
                query.push_kv(
                    "coreNetworkId",
                    &aws_smithy_http::query::fmt_string(&inner_111),
                );
            }
            if let Some(inner_112) = &_input.registered_gateway_arn {
                query.push_kv(
                    "registeredGatewayArn",
                    &aws_smithy_http::query::fmt_string(&inner_112),
                );
            }
            if let Some(inner_113) = &_input.aws_region {
                query.push_kv("awsRegion", &aws_smithy_http::query::fmt_string(&inner_113));
            }
            if let Some(inner_114) = &_input.account_id {
                query.push_kv("accountId", &aws_smithy_http::query::fmt_string(&inner_114));
            }
            if let Some(inner_115) = &_input.resource_type {
                query.push_kv(
                    "resourceType",
                    &aws_smithy_http::query::fmt_string(&inner_115),
                );
            }
            if let Some(inner_116) = &_input.resource_arn {
                query.push_kv(
                    "resourceArn",
                    &aws_smithy_http::query::fmt_string(&inner_116),
                );
            }
            if let Some(inner_117) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_117).encode(),
                );
            }
            if let Some(inner_118) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_118));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetNetworkTelemetryInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetNetworkTelemetryInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetNetworkTelemetry::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetNetworkTelemetry",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetNetworkTelemetryInput`](crate::input::GetNetworkTelemetryInput)
    pub fn builder() -> crate::input::get_network_telemetry_input::Builder {
        crate::input::get_network_telemetry_input::Builder::default()
    }
}

/// See [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
pub mod get_resource_policy_input {
    /// A builder for [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetResourcePolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetResourcePolicyInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type GetResourcePolicyInputOperationOutputAlias = crate::operation::GetResourcePolicy;
#[doc(hidden)]
pub type GetResourcePolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetResourcePolicy`](crate::operation::GetResourcePolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetResourcePolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetResourcePolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_119 = &_input.resource_arn;
            let input_119 =
                input_119
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_119, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/resource-policy/{ResourceArn}",
                ResourceArn = resource_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetResourcePolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetResourcePolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetResourcePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetResourcePolicy",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
    pub fn builder() -> crate::input::get_resource_policy_input::Builder {
        crate::input::get_resource_policy_input::Builder::default()
    }
}

/// See [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput)
pub mod get_route_analysis_input {
    /// A builder for [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) route_analysis_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the route analysis.</p>
        pub fn route_analysis_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_analysis_id = Some(input.into());
            self
        }
        /// <p>The ID of the route analysis.</p>
        pub fn set_route_analysis_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.route_analysis_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetRouteAnalysisInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetRouteAnalysisInput {
                global_network_id: self.global_network_id,
                route_analysis_id: self.route_analysis_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetRouteAnalysisInputOperationOutputAlias = crate::operation::GetRouteAnalysis;
#[doc(hidden)]
pub type GetRouteAnalysisInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetRouteAnalysisInput {
    /// Consumes the builder and constructs an Operation<[`GetRouteAnalysis`](crate::operation::GetRouteAnalysis)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetRouteAnalysis,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetRouteAnalysisInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_120 = &_input.global_network_id;
            let input_120 =
                input_120
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_120, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_121 = &_input.route_analysis_id;
            let input_121 =
                input_121
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "route_analysis_id",
                        details: "cannot be empty or unset",
                    })?;
            let route_analysis_id = aws_smithy_http::label::fmt_string(input_121, false);
            if route_analysis_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "route_analysis_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/route-analyses/{RouteAnalysisId}",
                GlobalNetworkId = global_network_id,
                RouteAnalysisId = route_analysis_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetRouteAnalysisInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetRouteAnalysisInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetRouteAnalysis::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetRouteAnalysis",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetRouteAnalysisInput`](crate::input::GetRouteAnalysisInput)
    pub fn builder() -> crate::input::get_route_analysis_input::Builder {
        crate::input::get_route_analysis_input::Builder::default()
    }
}

/// See [`GetSitesInput`](crate::input::GetSitesInput)
pub mod get_sites_input {
    /// A builder for [`GetSitesInput`](crate::input::GetSitesInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `site_ids`.
        ///
        /// To override the contents of this collection use [`set_site_ids`](Self::set_site_ids).
        ///
        /// <p>One or more site IDs. The maximum is 10.</p>
        pub fn site_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.site_ids.unwrap_or_default();
            v.push(input.into());
            self.site_ids = Some(v);
            self
        }
        /// <p>One or more site IDs. The maximum is 10.</p>
        pub fn set_site_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.site_ids = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSitesInput`](crate::input::GetSitesInput)
        pub fn build(
            self,
        ) -> std::result::Result<crate::input::GetSitesInput, aws_smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetSitesInput {
                global_network_id: self.global_network_id,
                site_ids: self.site_ids,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSitesInputOperationOutputAlias = crate::operation::GetSites;
#[doc(hidden)]
pub type GetSitesInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetSitesInput {
    /// Consumes the builder and constructs an Operation<[`GetSites`](crate::operation::GetSites)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSites,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetSitesInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_122 = &_input.global_network_id;
            let input_122 =
                input_122
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_122, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/sites",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetSitesInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_123) = &_input.site_ids {
                for inner_124 in inner_123 {
                    query.push_kv("siteIds", &aws_smithy_http::query::fmt_string(&inner_124));
                }
            }
            if let Some(inner_125) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_125).encode(),
                );
            }
            if let Some(inner_126) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_126));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetSitesInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetSitesInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetSites::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetSites",
                    "networkmanager",
                ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSitesInput`](crate::input::GetSitesInput)
    pub fn builder() -> crate::input::get_sites_input::Builder {
        crate::input::get_sites_input::Builder::default()
    }
}

/// See [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput)
pub mod get_site_to_site_vpn_attachment_input {
    /// A builder for [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetSiteToSiteVpnAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetSiteToSiteVpnAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetSiteToSiteVpnAttachmentInputOperationOutputAlias =
    crate::operation::GetSiteToSiteVpnAttachment;
#[doc(hidden)]
pub type GetSiteToSiteVpnAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetSiteToSiteVpnAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetSiteToSiteVpnAttachment`](crate::operation::GetSiteToSiteVpnAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetSiteToSiteVpnAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetSiteToSiteVpnAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_127 = &_input.attachment_id;
            let input_127 =
                input_127
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_127, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/site-to-site-vpn-attachments/{AttachmentId}",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetSiteToSiteVpnAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetSiteToSiteVpnAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetSiteToSiteVpnAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetSiteToSiteVpnAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetSiteToSiteVpnAttachmentInput`](crate::input::GetSiteToSiteVpnAttachmentInput)
    pub fn builder() -> crate::input::get_site_to_site_vpn_attachment_input::Builder {
        crate::input::get_site_to_site_vpn_attachment_input::Builder::default()
    }
}

/// See [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput)
pub mod get_transit_gateway_connect_peer_associations_input {
    /// A builder for [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_connect_peer_arns:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `transit_gateway_connect_peer_arns`.
        ///
        /// To override the contents of this collection use [`set_transit_gateway_connect_peer_arns`](Self::set_transit_gateway_connect_peer_arns).
        ///
        /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
        pub fn transit_gateway_connect_peer_arns(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.transit_gateway_connect_peer_arns.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_connect_peer_arns = Some(v);
            self
        }
        /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
        pub fn set_transit_gateway_connect_peer_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_connect_peer_arns = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetTransitGatewayConnectPeerAssociationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(
                crate::input::GetTransitGatewayConnectPeerAssociationsInput {
                    global_network_id: self.global_network_id,
                    transit_gateway_connect_peer_arns: self.transit_gateway_connect_peer_arns,
                    max_results: self.max_results,
                    next_token: self.next_token,
                },
            )
        }
    }
}
#[doc(hidden)]
pub type GetTransitGatewayConnectPeerAssociationsInputOperationOutputAlias =
    crate::operation::GetTransitGatewayConnectPeerAssociations;
#[doc(hidden)]
pub type GetTransitGatewayConnectPeerAssociationsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetTransitGatewayConnectPeerAssociationsInput {
    /// Consumes the builder and constructs an Operation<[`GetTransitGatewayConnectPeerAssociations`](crate::operation::GetTransitGatewayConnectPeerAssociations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTransitGatewayConnectPeerAssociations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_128 = &_input.global_network_id;
            let input_128 =
                input_128
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_128, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/transit-gateway-connect-peer-associations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_129) = &_input.transit_gateway_connect_peer_arns {
                for inner_130 in inner_129 {
                    query.push_kv(
                        "transitGatewayConnectPeerArns",
                        &aws_smithy_http::query::fmt_string(&inner_130),
                    );
                }
            }
            if let Some(inner_131) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_131).encode(),
                );
            }
            if let Some(inner_132) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_132));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetTransitGatewayConnectPeerAssociationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTransitGatewayConnectPeerAssociations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTransitGatewayConnectPeerAssociations",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetTransitGatewayConnectPeerAssociationsInput`](crate::input::GetTransitGatewayConnectPeerAssociationsInput)
    pub fn builder() -> crate::input::get_transit_gateway_connect_peer_associations_input::Builder {
        crate::input::get_transit_gateway_connect_peer_associations_input::Builder::default()
    }
}

/// See [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput)
pub mod get_transit_gateway_registrations_input {
    /// A builder for [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// Appends an item to `transit_gateway_arns`.
        ///
        /// To override the contents of this collection use [`set_transit_gateway_arns`](Self::set_transit_gateway_arns).
        ///
        /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
        pub fn transit_gateway_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.transit_gateway_arns.unwrap_or_default();
            v.push(input.into());
            self.transit_gateway_arns = Some(v);
            self
        }
        /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
        pub fn set_transit_gateway_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.transit_gateway_arns = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetTransitGatewayRegistrationsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetTransitGatewayRegistrationsInput {
                global_network_id: self.global_network_id,
                transit_gateway_arns: self.transit_gateway_arns,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type GetTransitGatewayRegistrationsInputOperationOutputAlias =
    crate::operation::GetTransitGatewayRegistrations;
#[doc(hidden)]
pub type GetTransitGatewayRegistrationsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl GetTransitGatewayRegistrationsInput {
    /// Consumes the builder and constructs an Operation<[`GetTransitGatewayRegistrations`](crate::operation::GetTransitGatewayRegistrations)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTransitGatewayRegistrations,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetTransitGatewayRegistrationsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_133 = &_input.global_network_id;
            let input_133 =
                input_133
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_133, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/transit-gateway-registrations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::GetTransitGatewayRegistrationsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_134) = &_input.transit_gateway_arns {
                for inner_135 in inner_134 {
                    query.push_kv(
                        "transitGatewayArns",
                        &aws_smithy_http::query::fmt_string(&inner_135),
                    );
                }
            }
            if let Some(inner_136) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_136).encode(),
                );
            }
            if let Some(inner_137) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_137));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetTransitGatewayRegistrationsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetTransitGatewayRegistrationsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTransitGatewayRegistrations::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTransitGatewayRegistrations",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetTransitGatewayRegistrationsInput`](crate::input::GetTransitGatewayRegistrationsInput)
    pub fn builder() -> crate::input::get_transit_gateway_registrations_input::Builder {
        crate::input::get_transit_gateway_registrations_input::Builder::default()
    }
}

/// See [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput)
pub mod get_vpc_attachment_input {
    /// A builder for [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::GetVpcAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::GetVpcAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
#[doc(hidden)]
pub type GetVpcAttachmentInputOperationOutputAlias = crate::operation::GetVpcAttachment;
#[doc(hidden)]
pub type GetVpcAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl GetVpcAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`GetVpcAttachment`](crate::operation::GetVpcAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetVpcAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::GetVpcAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_138 = &_input.attachment_id;
            let input_138 =
                input_138
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_138, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/vpc-attachments/{AttachmentId}",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::GetVpcAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::GetVpcAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetVpcAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetVpcAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`GetVpcAttachmentInput`](crate::input::GetVpcAttachmentInput)
    pub fn builder() -> crate::input::get_vpc_attachment_input::Builder {
        crate::input::get_vpc_attachment_input::Builder::default()
    }
}

/// See [`ListAttachmentsInput`](crate::input::ListAttachmentsInput)
pub mod list_attachments_input {
    /// A builder for [`ListAttachmentsInput`](crate::input::ListAttachmentsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) attachment_type: std::option::Option<crate::model::AttachmentType>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::AttachmentState>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The type of attachment.</p>
        pub fn attachment_type(mut self, input: crate::model::AttachmentType) -> Self {
            self.attachment_type = Some(input);
            self
        }
        /// <p>The type of attachment.</p>
        pub fn set_attachment_type(
            mut self,
            input: std::option::Option<crate::model::AttachmentType>,
        ) -> Self {
            self.attachment_type = input;
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn set_edge_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.edge_location = input;
            self
        }
        /// <p>The state of the attachment.</p>
        pub fn state(mut self, input: crate::model::AttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the attachment.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::AttachmentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListAttachmentsInput`](crate::input::ListAttachmentsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListAttachmentsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListAttachmentsInput {
                core_network_id: self.core_network_id,
                attachment_type: self.attachment_type,
                edge_location: self.edge_location,
                state: self.state,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListAttachmentsInputOperationOutputAlias = crate::operation::ListAttachments;
#[doc(hidden)]
pub type ListAttachmentsInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListAttachmentsInput {
    /// Consumes the builder and constructs an Operation<[`ListAttachments`](crate::operation::ListAttachments)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListAttachments,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListAttachmentsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/attachments").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListAttachmentsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_139) = &_input.core_network_id {
                query.push_kv(
                    "coreNetworkId",
                    &aws_smithy_http::query::fmt_string(&inner_139),
                );
            }
            if let Some(inner_140) = &_input.attachment_type {
                query.push_kv(
                    "attachmentType",
                    &aws_smithy_http::query::fmt_string(&inner_140),
                );
            }
            if let Some(inner_141) = &_input.edge_location {
                query.push_kv(
                    "edgeLocation",
                    &aws_smithy_http::query::fmt_string(&inner_141),
                );
            }
            if let Some(inner_142) = &_input.state {
                query.push_kv("state", &aws_smithy_http::query::fmt_string(&inner_142));
            }
            if let Some(inner_143) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_143).encode(),
                );
            }
            if let Some(inner_144) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_144));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListAttachmentsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListAttachmentsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListAttachments::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListAttachments",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListAttachmentsInput`](crate::input::ListAttachmentsInput)
    pub fn builder() -> crate::input::list_attachments_input::Builder {
        crate::input::list_attachments_input::Builder::default()
    }
}

/// See [`ListConnectPeersInput`](crate::input::ListConnectPeersInput)
pub mod list_connect_peers_input {
    /// A builder for [`ListConnectPeersInput`](crate::input::ListConnectPeersInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_attachment_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn connect_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_connect_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_attachment_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListConnectPeersInput`](crate::input::ListConnectPeersInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListConnectPeersInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListConnectPeersInput {
                core_network_id: self.core_network_id,
                connect_attachment_id: self.connect_attachment_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListConnectPeersInputOperationOutputAlias = crate::operation::ListConnectPeers;
#[doc(hidden)]
pub type ListConnectPeersInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListConnectPeersInput {
    /// Consumes the builder and constructs an Operation<[`ListConnectPeers`](crate::operation::ListConnectPeers)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListConnectPeers,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListConnectPeersInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/connect-peers").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListConnectPeersInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_145) = &_input.core_network_id {
                query.push_kv(
                    "coreNetworkId",
                    &aws_smithy_http::query::fmt_string(&inner_145),
                );
            }
            if let Some(inner_146) = &_input.connect_attachment_id {
                query.push_kv(
                    "connectAttachmentId",
                    &aws_smithy_http::query::fmt_string(&inner_146),
                );
            }
            if let Some(inner_147) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_147).encode(),
                );
            }
            if let Some(inner_148) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_148));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListConnectPeersInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListConnectPeersInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListConnectPeers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListConnectPeers",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListConnectPeersInput`](crate::input::ListConnectPeersInput)
    pub fn builder() -> crate::input::list_connect_peers_input::Builder {
        crate::input::list_connect_peers_input::Builder::default()
    }
}

/// See [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput)
pub mod list_core_network_policy_versions_input {
    /// A builder for [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCoreNetworkPolicyVersionsInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCoreNetworkPolicyVersionsInput {
                core_network_id: self.core_network_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCoreNetworkPolicyVersionsInputOperationOutputAlias =
    crate::operation::ListCoreNetworkPolicyVersions;
#[doc(hidden)]
pub type ListCoreNetworkPolicyVersionsInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl ListCoreNetworkPolicyVersionsInput {
    /// Consumes the builder and constructs an Operation<[`ListCoreNetworkPolicyVersions`](crate::operation::ListCoreNetworkPolicyVersions)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCoreNetworkPolicyVersions,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListCoreNetworkPolicyVersionsInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_149 = &_input.core_network_id;
            let input_149 =
                input_149
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_149, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}/core-network-policy-versions",
                CoreNetworkId = core_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListCoreNetworkPolicyVersionsInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_150) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_150).encode(),
                );
            }
            if let Some(inner_151) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_151));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListCoreNetworkPolicyVersionsInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListCoreNetworkPolicyVersionsInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCoreNetworkPolicyVersions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCoreNetworkPolicyVersions",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListCoreNetworkPolicyVersionsInput`](crate::input::ListCoreNetworkPolicyVersionsInput)
    pub fn builder() -> crate::input::list_core_network_policy_versions_input::Builder {
        crate::input::list_core_network_policy_versions_input::Builder::default()
    }
}

/// See [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput)
pub mod list_core_networks_input {
    /// A builder for [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next page of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListCoreNetworksInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListCoreNetworksInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}
#[doc(hidden)]
pub type ListCoreNetworksInputOperationOutputAlias = crate::operation::ListCoreNetworks;
#[doc(hidden)]
pub type ListCoreNetworksInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListCoreNetworksInput {
    /// Consumes the builder and constructs an Operation<[`ListCoreNetworks`](crate::operation::ListCoreNetworks)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCoreNetworks,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListCoreNetworksInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            write!(output, "/core-networks").expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::ListCoreNetworksInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_152) = &_input.max_results {
                query.push_kv(
                    "maxResults",
                    aws_smithy_types::primitive::Encoder::from(*inner_152).encode(),
                );
            }
            if let Some(inner_153) = &_input.next_token {
                query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_153));
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListCoreNetworksInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListCoreNetworksInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCoreNetworks::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCoreNetworks",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListCoreNetworksInput`](crate::input::ListCoreNetworksInput)
    pub fn builder() -> crate::input::list_core_networks_input::Builder {
        crate::input::list_core_networks_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
pub mod list_tags_for_resource_input {
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput {
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type ListTagsForResourceInputOperationOutputAlias = crate::operation::ListTagsForResource;
#[doc(hidden)]
pub type ListTagsForResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::ListTagsForResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_154 = &_input.resource_arn;
            let input_154 =
                input_154
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_154, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::ListTagsForResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("GET").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::ListTagsForResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput)
pub mod put_core_network_policy_input {
    /// A builder for [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) latest_version_id: std::option::Option<i32>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The policy document.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The policy document.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>a core network policy description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>a core network policy description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of a core network policy. </p>
        pub fn latest_version_id(mut self, input: i32) -> Self {
            self.latest_version_id = Some(input);
            self
        }
        /// <p>The ID of a core network policy. </p>
        pub fn set_latest_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.latest_version_id = input;
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>The client token associated with the request.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutCoreNetworkPolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutCoreNetworkPolicyInput {
                core_network_id: self.core_network_id,
                policy_document: self.policy_document,
                description: self.description,
                latest_version_id: self.latest_version_id,
                client_token: self.client_token,
            })
        }
    }
}
#[doc(hidden)]
pub type PutCoreNetworkPolicyInputOperationOutputAlias = crate::operation::PutCoreNetworkPolicy;
#[doc(hidden)]
pub type PutCoreNetworkPolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl PutCoreNetworkPolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutCoreNetworkPolicy`](crate::operation::PutCoreNetworkPolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutCoreNetworkPolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutCoreNetworkPolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_155 = &_input.core_network_id;
            let input_155 =
                input_155
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_155, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}/core-network-policy",
                CoreNetworkId = core_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutCoreNetworkPolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutCoreNetworkPolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_core_network_policy(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutCoreNetworkPolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutCoreNetworkPolicy",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutCoreNetworkPolicyInput`](crate::input::PutCoreNetworkPolicyInput)
    pub fn builder() -> crate::input::put_core_network_policy_input::Builder {
        crate::input::put_core_network_policy_input::Builder::default()
    }
}

/// See [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
pub mod put_resource_policy_input {
    /// A builder for [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) policy_document: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The JSON resource policy document.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>The JSON resource policy document.</p>
        pub fn set_policy_document(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.policy_document = input;
            self
        }
        /// <p>The ARN of the resource policy. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource policy. </p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::PutResourcePolicyInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::PutResourcePolicyInput {
                policy_document: self.policy_document,
                resource_arn: self.resource_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type PutResourcePolicyInputOperationOutputAlias = crate::operation::PutResourcePolicy;
#[doc(hidden)]
pub type PutResourcePolicyInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl PutResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutResourcePolicy`](crate::operation::PutResourcePolicy)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutResourcePolicy,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::PutResourcePolicyInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_156 = &_input.resource_arn;
            let input_156 =
                input_156
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_156, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/resource-policy/{ResourceArn}",
                ResourceArn = resource_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::PutResourcePolicyInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::PutResourcePolicyInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_put_resource_policy(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutResourcePolicy::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutResourcePolicy",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
}

/// See [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput)
pub mod register_transit_gateway_input {
    /// A builder for [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn set_transit_gateway_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.transit_gateway_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RegisterTransitGatewayInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RegisterTransitGatewayInput {
                global_network_id: self.global_network_id,
                transit_gateway_arn: self.transit_gateway_arn,
            })
        }
    }
}
#[doc(hidden)]
pub type RegisterTransitGatewayInputOperationOutputAlias = crate::operation::RegisterTransitGateway;
#[doc(hidden)]
pub type RegisterTransitGatewayInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RegisterTransitGatewayInput {
    /// Consumes the builder and constructs an Operation<[`RegisterTransitGateway`](crate::operation::RegisterTransitGateway)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RegisterTransitGateway,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RegisterTransitGatewayInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_157 = &_input.global_network_id;
            let input_157 =
                input_157
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_157, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/transit-gateway-registrations",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RegisterTransitGatewayInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RegisterTransitGatewayInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_register_transit_gateway(
                &self,
            )?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RegisterTransitGateway::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RegisterTransitGateway",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RegisterTransitGatewayInput`](crate::input::RegisterTransitGatewayInput)
    pub fn builder() -> crate::input::register_transit_gateway_input::Builder {
        crate::input::register_transit_gateway_input::Builder::default()
    }
}

/// See [`RejectAttachmentInput`](crate::input::RejectAttachmentInput)
pub mod reject_attachment_input {
    /// A builder for [`RejectAttachmentInput`](crate::input::RejectAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RejectAttachmentInput`](crate::input::RejectAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RejectAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RejectAttachmentInput {
                attachment_id: self.attachment_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RejectAttachmentInputOperationOutputAlias = crate::operation::RejectAttachment;
#[doc(hidden)]
pub type RejectAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl RejectAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`RejectAttachment`](crate::operation::RejectAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RejectAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RejectAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_158 = &_input.attachment_id;
            let input_158 =
                input_158
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_158, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/attachments/{AttachmentId}/reject",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RejectAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RejectAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RejectAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RejectAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RejectAttachmentInput`](crate::input::RejectAttachmentInput)
    pub fn builder() -> crate::input::reject_attachment_input::Builder {
        crate::input::reject_attachment_input::Builder::default()
    }
}

/// See [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput)
pub mod restore_core_network_policy_version_input {
    /// A builder for [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The ID of the policy version to restore.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version to restore.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::RestoreCoreNetworkPolicyVersionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::RestoreCoreNetworkPolicyVersionInput {
                core_network_id: self.core_network_id,
                policy_version_id: self.policy_version_id,
            })
        }
    }
}
#[doc(hidden)]
pub type RestoreCoreNetworkPolicyVersionInputOperationOutputAlias =
    crate::operation::RestoreCoreNetworkPolicyVersion;
#[doc(hidden)]
pub type RestoreCoreNetworkPolicyVersionInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl RestoreCoreNetworkPolicyVersionInput {
    /// Consumes the builder and constructs an Operation<[`RestoreCoreNetworkPolicyVersion`](crate::operation::RestoreCoreNetworkPolicyVersion)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::RestoreCoreNetworkPolicyVersion,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::RestoreCoreNetworkPolicyVersionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_159 = &_input.core_network_id;
            let input_159 =
                input_159
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_159, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_160 = &_input.policy_version_id;
            let input_160 =
                input_160
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "policy_version_id",
                        details: "cannot be empty or unset",
                    })?;
            let mut policy_version_id_encoder =
                aws_smithy_types::primitive::Encoder::from(*input_160);
            let policy_version_id = policy_version_id_encoder.encode();
            if policy_version_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "policy_version_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/core-networks/{CoreNetworkId}/core-network-policy-versions/{PolicyVersionId}/restore", CoreNetworkId = core_network_id, PolicyVersionId = policy_version_id).expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::RestoreCoreNetworkPolicyVersionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::RestoreCoreNetworkPolicyVersionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::RestoreCoreNetworkPolicyVersion::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "RestoreCoreNetworkPolicyVersion",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`RestoreCoreNetworkPolicyVersionInput`](crate::input::RestoreCoreNetworkPolicyVersionInput)
    pub fn builder() -> crate::input::restore_core_network_policy_version_input::Builder {
        crate::input::restore_core_network_policy_version_input::Builder::default()
    }
}

/// See [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput)
pub mod start_route_analysis_input {
    /// A builder for [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) source:
            std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        pub(crate) destination:
            std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        pub(crate) include_return_path: std::option::Option<bool>,
        pub(crate) use_middleboxes: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The source from which traffic originates.</p>
        pub fn source(
            mut self,
            input: crate::model::RouteAnalysisEndpointOptionsSpecification,
        ) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source from which traffic originates.</p>
        pub fn set_source(
            mut self,
            input: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        ) -> Self {
            self.source = input;
            self
        }
        /// <p>The destination.</p>
        pub fn destination(
            mut self,
            input: crate::model::RouteAnalysisEndpointOptionsSpecification,
        ) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The destination.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
        pub fn include_return_path(mut self, input: bool) -> Self {
            self.include_return_path = Some(input);
            self
        }
        /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
        pub fn set_include_return_path(mut self, input: std::option::Option<bool>) -> Self {
            self.include_return_path = input;
            self
        }
        /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
        pub fn use_middleboxes(mut self, input: bool) -> Self {
            self.use_middleboxes = Some(input);
            self
        }
        /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
        pub fn set_use_middleboxes(mut self, input: std::option::Option<bool>) -> Self {
            self.use_middleboxes = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::StartRouteAnalysisInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::StartRouteAnalysisInput {
                global_network_id: self.global_network_id,
                source: self.source,
                destination: self.destination,
                include_return_path: self.include_return_path.unwrap_or_default(),
                use_middleboxes: self.use_middleboxes.unwrap_or_default(),
            })
        }
    }
}
#[doc(hidden)]
pub type StartRouteAnalysisInputOperationOutputAlias = crate::operation::StartRouteAnalysis;
#[doc(hidden)]
pub type StartRouteAnalysisInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl StartRouteAnalysisInput {
    /// Consumes the builder and constructs an Operation<[`StartRouteAnalysis`](crate::operation::StartRouteAnalysis)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::StartRouteAnalysis,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::StartRouteAnalysisInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_161 = &_input.global_network_id;
            let input_161 =
                input_161
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_161, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/route-analyses",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::StartRouteAnalysisInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::StartRouteAnalysisInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_start_route_analysis(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::StartRouteAnalysis::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "StartRouteAnalysis",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`StartRouteAnalysisInput`](crate::input::StartRouteAnalysisInput)
    pub fn builder() -> crate::input::start_route_analysis_input::Builder {
        crate::input::start_route_analysis_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags to apply to the specified resource.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags to apply to the specified resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::TagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::TagResourceInput {
                resource_arn: self.resource_arn,
                tags: self.tags,
            })
        }
    }
}
#[doc(hidden)]
pub type TagResourceInputOperationOutputAlias = crate::operation::TagResource;
#[doc(hidden)]
pub type TagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::TagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_162 = &_input.resource_arn;
            let input_162 =
                input_162
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_162, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::TagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("POST").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::TagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>The tag keys to remove from the specified resource.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>The tag keys to remove from the specified resource.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UntagResourceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UntagResourceInput {
                resource_arn: self.resource_arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}
#[doc(hidden)]
pub type UntagResourceInputOperationOutputAlias = crate::operation::UntagResource;
#[doc(hidden)]
pub type UntagResourceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UntagResourceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_163 = &_input.resource_arn;
            let input_163 =
                input_163
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_163, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(output, "/tags/{ResourceArn}", ResourceArn = resource_arn)
                .expect("formatting should succeed");
            Ok(())
        }
        fn uri_query(
            _input: &crate::input::UntagResourceInput,
            mut output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let mut query = aws_smithy_http::query::Writer::new(&mut output);
            if let Some(inner_164) = &_input.tag_keys {
                for inner_165 in inner_164 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_165));
                }
            }
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UntagResourceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            uri_query(input, &mut uri)?;
            Ok(builder.method("DELETE").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UntagResourceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateConnectionInput`](crate::input::UpdateConnectionInput)
pub mod update_connection_input {
    /// A builder for [`UpdateConnectionInput`](crate::input::UpdateConnectionInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) connected_link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn set_connection_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_id = input;
            self
        }
        /// <p>The ID of the link for the first device in the connection.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the first device in the connection.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>The ID of the link for the second device in the connection.</p>
        pub fn connected_link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the second device in the connection.</p>
        pub fn set_connected_link_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connected_link_id = input;
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the connection.</p>
        /// <p>Length Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateConnectionInput`](crate::input::UpdateConnectionInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateConnectionInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateConnectionInput {
                global_network_id: self.global_network_id,
                connection_id: self.connection_id,
                link_id: self.link_id,
                connected_link_id: self.connected_link_id,
                description: self.description,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateConnectionInputOperationOutputAlias = crate::operation::UpdateConnection;
#[doc(hidden)]
pub type UpdateConnectionInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateConnectionInput {
    /// Consumes the builder and constructs an Operation<[`UpdateConnection`](crate::operation::UpdateConnection)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateConnection,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateConnectionInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_166 = &_input.global_network_id;
            let input_166 =
                input_166
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_166, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_167 = &_input.connection_id;
            let input_167 =
                input_167
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "connection_id",
                        details: "cannot be empty or unset",
                    })?;
            let connection_id = aws_smithy_http::label::fmt_string(input_167, false);
            if connection_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "connection_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/connections/{ConnectionId}",
                GlobalNetworkId = global_network_id,
                ConnectionId = connection_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateConnectionInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateConnectionInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_connection(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateConnection::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateConnection",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateConnectionInput`](crate::input::UpdateConnectionInput)
    pub fn builder() -> crate::input::update_connection_input::Builder {
        crate::input::update_connection_input::Builder::default()
    }
}

/// See [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput)
pub mod update_core_network_input {
    /// A builder for [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.core_network_id = input;
            self
        }
        /// <p>The description of the update.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the update.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateCoreNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateCoreNetworkInput {
                core_network_id: self.core_network_id,
                description: self.description,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateCoreNetworkInputOperationOutputAlias = crate::operation::UpdateCoreNetwork;
#[doc(hidden)]
pub type UpdateCoreNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateCoreNetworkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCoreNetwork`](crate::operation::UpdateCoreNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCoreNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateCoreNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_168 = &_input.core_network_id;
            let input_168 =
                input_168
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "core_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let core_network_id = aws_smithy_http::label::fmt_string(input_168, false);
            if core_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "core_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/core-networks/{CoreNetworkId}",
                CoreNetworkId = core_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateCoreNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateCoreNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_core_network(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCoreNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCoreNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateCoreNetworkInput`](crate::input::UpdateCoreNetworkInput)
    pub fn builder() -> crate::input::update_core_network_input::Builder {
        crate::input::update_core_network_input::Builder::default()
    }
}

/// See [`UpdateDeviceInput`](crate::input::UpdateDeviceInput)
pub mod update_device_input {
    /// A builder for [`UpdateDeviceInput`](crate::input::UpdateDeviceInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) aws_location: std::option::Option<crate::model::AwsLocation>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) site_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn aws_location(mut self, input: crate::model::AwsLocation) -> Self {
            self.aws_location = Some(input);
            self
        }
        /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
        pub fn set_aws_location(
            mut self,
            input: std::option::Option<crate::model::AwsLocation>,
        ) -> Self {
            self.aws_location = input;
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the device.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the device.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the device.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The vendor of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input;
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        /// <p>The serial number of the device.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_serial_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.serial_number = input;
            self
        }
        /// <p>Describes a location.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>Describes a location.</p>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateDeviceInput`](crate::input::UpdateDeviceInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateDeviceInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateDeviceInput {
                global_network_id: self.global_network_id,
                device_id: self.device_id,
                aws_location: self.aws_location,
                description: self.description,
                r#type: self.r#type,
                vendor: self.vendor,
                model: self.model,
                serial_number: self.serial_number,
                location: self.location,
                site_id: self.site_id,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateDeviceInputOperationOutputAlias = crate::operation::UpdateDevice;
#[doc(hidden)]
pub type UpdateDeviceInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateDeviceInput {
    /// Consumes the builder and constructs an Operation<[`UpdateDevice`](crate::operation::UpdateDevice)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateDevice,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateDeviceInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_169 = &_input.global_network_id;
            let input_169 =
                input_169
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_169, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_170 = &_input.device_id;
            let input_170 =
                input_170
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "device_id",
                        details: "cannot be empty or unset",
                    })?;
            let device_id = aws_smithy_http::label::fmt_string(input_170, false);
            if device_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "device_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/devices/{DeviceId}",
                GlobalNetworkId = global_network_id,
                DeviceId = device_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateDeviceInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateDeviceInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_device(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateDevice::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateDevice",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateDeviceInput`](crate::input::UpdateDeviceInput)
    pub fn builder() -> crate::input::update_device_input::Builder {
        crate::input::update_device_input::Builder::default()
    }
}

/// See [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput)
pub mod update_global_network_input {
    /// A builder for [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of your global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of your global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the global network.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateGlobalNetworkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateGlobalNetworkInput {
                global_network_id: self.global_network_id,
                description: self.description,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateGlobalNetworkInputOperationOutputAlias = crate::operation::UpdateGlobalNetwork;
#[doc(hidden)]
pub type UpdateGlobalNetworkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateGlobalNetworkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateGlobalNetwork`](crate::operation::UpdateGlobalNetwork)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateGlobalNetwork,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateGlobalNetworkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_171 = &_input.global_network_id;
            let input_171 =
                input_171
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_171, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}",
                GlobalNetworkId = global_network_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateGlobalNetworkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateGlobalNetworkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_global_network(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateGlobalNetwork::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateGlobalNetwork",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateGlobalNetworkInput`](crate::input::UpdateGlobalNetworkInput)
    pub fn builder() -> crate::input::update_global_network_input::Builder {
        crate::input::update_global_network_input::Builder::default()
    }
}

/// See [`UpdateLinkInput`](crate::input::UpdateLinkInput)
pub mod update_link_input {
    /// A builder for [`UpdateLinkInput`](crate::input::UpdateLinkInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) bandwidth: std::option::Option<crate::model::Bandwidth>,
        pub(crate) provider: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input;
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the link.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The upload and download speed in Mbps. </p>
        pub fn bandwidth(mut self, input: crate::model::Bandwidth) -> Self {
            self.bandwidth = Some(input);
            self
        }
        /// <p>The upload and download speed in Mbps. </p>
        pub fn set_bandwidth(
            mut self,
            input: std::option::Option<crate::model::Bandwidth>,
        ) -> Self {
            self.bandwidth = input;
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The provider of the link.</p>
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLinkInput`](crate::input::UpdateLinkInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateLinkInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateLinkInput {
                global_network_id: self.global_network_id,
                link_id: self.link_id,
                description: self.description,
                r#type: self.r#type,
                bandwidth: self.bandwidth,
                provider: self.provider,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateLinkInputOperationOutputAlias = crate::operation::UpdateLink;
#[doc(hidden)]
pub type UpdateLinkInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateLinkInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLink`](crate::operation::UpdateLink)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateLink,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateLinkInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_172 = &_input.global_network_id;
            let input_172 =
                input_172
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_172, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_173 = &_input.link_id;
            let input_173 =
                input_173
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "link_id",
                        details: "cannot be empty or unset",
                    })?;
            let link_id = aws_smithy_http::label::fmt_string(input_173, false);
            if link_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "link_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/links/{LinkId}",
                GlobalNetworkId = global_network_id,
                LinkId = link_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateLinkInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateLinkInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_link(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateLink::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateLink",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateLinkInput`](crate::input::UpdateLinkInput)
    pub fn builder() -> crate::input::update_link_input::Builder {
        crate::input::update_link_input::Builder::default()
    }
}

/// See [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput)
pub mod update_network_resource_metadata_input {
    /// A builder for [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input;
            self
        }
        /// Adds a key-value pair to `metadata`.
        ///
        /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
        ///
        /// <p>The resource metadata.</p>
        pub fn metadata(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metadata = Some(hash_map);
            self
        }
        /// <p>The resource metadata.</p>
        pub fn set_metadata(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metadata = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateNetworkResourceMetadataInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateNetworkResourceMetadataInput {
                global_network_id: self.global_network_id,
                resource_arn: self.resource_arn,
                metadata: self.metadata,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateNetworkResourceMetadataInputOperationOutputAlias =
    crate::operation::UpdateNetworkResourceMetadata;
#[doc(hidden)]
pub type UpdateNetworkResourceMetadataInputOperationRetryAlias =
    aws_http::retry::AwsErrorRetryPolicy;
impl UpdateNetworkResourceMetadataInput {
    /// Consumes the builder and constructs an Operation<[`UpdateNetworkResourceMetadata`](crate::operation::UpdateNetworkResourceMetadata)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateNetworkResourceMetadata,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateNetworkResourceMetadataInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_174 = &_input.global_network_id;
            let input_174 =
                input_174
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_174, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_175 = &_input.resource_arn;
            let input_175 =
                input_175
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "resource_arn",
                        details: "cannot be empty or unset",
                    })?;
            let resource_arn = aws_smithy_http::label::fmt_string(input_175, false);
            if resource_arn.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "resource_arn",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/network-resources/{ResourceArn}/metadata",
                GlobalNetworkId = global_network_id,
                ResourceArn = resource_arn
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateNetworkResourceMetadataInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateNetworkResourceMetadataInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_network_resource_metadata(&self)?
        ;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateNetworkResourceMetadata::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateNetworkResourceMetadata",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateNetworkResourceMetadataInput`](crate::input::UpdateNetworkResourceMetadataInput)
    pub fn builder() -> crate::input::update_network_resource_metadata_input::Builder {
        crate::input::update_network_resource_metadata_input::Builder::default()
    }
}

/// See [`UpdateSiteInput`](crate::input::UpdateSiteInput)
pub mod update_site_input {
    /// A builder for [`UpdateSiteInput`](crate::input::UpdateSiteInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.global_network_id = input;
            self
        }
        /// <p>The ID of your site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of your site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input;
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of your site.</p>
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The site location:</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The site location:</p>
        /// <ul>
        /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
        /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
        /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
        /// </ul>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSiteInput`](crate::input::UpdateSiteInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateSiteInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateSiteInput {
                global_network_id: self.global_network_id,
                site_id: self.site_id,
                description: self.description,
                location: self.location,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateSiteInputOperationOutputAlias = crate::operation::UpdateSite;
#[doc(hidden)]
pub type UpdateSiteInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateSiteInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSite`](crate::operation::UpdateSite)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateSite,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateSiteInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_176 = &_input.global_network_id;
            let input_176 =
                input_176
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "global_network_id",
                        details: "cannot be empty or unset",
                    })?;
            let global_network_id = aws_smithy_http::label::fmt_string(input_176, false);
            if global_network_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "global_network_id",
                    details: "cannot be empty or unset",
                });
            }
            let input_177 = &_input.site_id;
            let input_177 =
                input_177
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "site_id",
                        details: "cannot be empty or unset",
                    })?;
            let site_id = aws_smithy_http::label::fmt_string(input_177, false);
            if site_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "site_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/global-networks/{GlobalNetworkId}/sites/{SiteId}",
                GlobalNetworkId = global_network_id,
                SiteId = site_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateSiteInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateSiteInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body = crate::operation_ser::serialize_operation_crate_operation_update_site(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateSite::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateSite",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSiteInput`](crate::input::UpdateSiteInput)
    pub fn builder() -> crate::input::update_site_input::Builder {
        crate::input::update_site_input::Builder::default()
    }
}

/// See [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput)
pub mod update_vpc_attachment_input {
    /// A builder for [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) add_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) remove_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) options: std::option::Option<crate::model::VpcOptions>,
    }
    impl Builder {
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attachment_id = input;
            self
        }
        /// Appends an item to `add_subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_add_subnet_arns`](Self::set_add_subnet_arns).
        ///
        /// <p>Adds a subnet ARN to the VPC attachment.</p>
        pub fn add_subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.add_subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.add_subnet_arns = Some(v);
            self
        }
        /// <p>Adds a subnet ARN to the VPC attachment.</p>
        pub fn set_add_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.add_subnet_arns = input;
            self
        }
        /// Appends an item to `remove_subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_remove_subnet_arns`](Self::set_remove_subnet_arns).
        ///
        /// <p>Removes a subnet ARN from the attachment.</p>
        pub fn remove_subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.remove_subnet_arns.unwrap_or_default();
            v.push(input.into());
            self.remove_subnet_arns = Some(v);
            self
        }
        /// <p>Removes a subnet ARN from the attachment.</p>
        pub fn set_remove_subnet_arns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.remove_subnet_arns = input;
            self
        }
        /// <p>Additional options for updating the VPC attachment. </p>
        pub fn options(mut self, input: crate::model::VpcOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Additional options for updating the VPC attachment. </p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::VpcOptions>) -> Self {
            self.options = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput)
        pub fn build(
            self,
        ) -> std::result::Result<
            crate::input::UpdateVpcAttachmentInput,
            aws_smithy_http::operation::BuildError,
        > {
            Ok(crate::input::UpdateVpcAttachmentInput {
                attachment_id: self.attachment_id,
                add_subnet_arns: self.add_subnet_arns,
                remove_subnet_arns: self.remove_subnet_arns,
                options: self.options,
            })
        }
    }
}
#[doc(hidden)]
pub type UpdateVpcAttachmentInputOperationOutputAlias = crate::operation::UpdateVpcAttachment;
#[doc(hidden)]
pub type UpdateVpcAttachmentInputOperationRetryAlias = aws_http::retry::AwsErrorRetryPolicy;
impl UpdateVpcAttachmentInput {
    /// Consumes the builder and constructs an Operation<[`UpdateVpcAttachment`](crate::operation::UpdateVpcAttachment)>
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateVpcAttachment,
            aws_http::retry::AwsErrorRetryPolicy,
        >,
        aws_smithy_http::operation::BuildError,
    > {
        fn uri_base(
            _input: &crate::input::UpdateVpcAttachmentInput,
            output: &mut String,
        ) -> Result<(), aws_smithy_http::operation::BuildError> {
            let input_178 = &_input.attachment_id;
            let input_178 =
                input_178
                    .as_ref()
                    .ok_or(aws_smithy_http::operation::BuildError::MissingField {
                        field: "attachment_id",
                        details: "cannot be empty or unset",
                    })?;
            let attachment_id = aws_smithy_http::label::fmt_string(input_178, false);
            if attachment_id.is_empty() {
                return Err(aws_smithy_http::operation::BuildError::MissingField {
                    field: "attachment_id",
                    details: "cannot be empty or unset",
                });
            }
            write!(
                output,
                "/vpc-attachments/{AttachmentId}",
                AttachmentId = attachment_id
            )
            .expect("formatting should succeed");
            Ok(())
        }
        #[allow(clippy::unnecessary_wraps)]
        fn update_http_builder(
            input: &crate::input::UpdateVpcAttachmentInput,
            builder: http::request::Builder,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            let mut uri = String::new();
            uri_base(input, &mut uri)?;
            Ok(builder.method("PATCH").uri(uri))
        }
        #[allow(clippy::unnecessary_wraps)]
        fn request_builder_base(
            input: &crate::input::UpdateVpcAttachmentInput,
        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::BuildError>
        {
            #[allow(unused_mut)]
            let mut builder = update_http_builder(input, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::HeaderName::from_static("content-type"),
                "application/json",
            );
            Ok(builder)
        }
        let properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        let request = request_builder_base(&self)?;
        let body =
            crate::operation_ser::serialize_operation_crate_operation_update_vpc_attachment(&self)?;
        let request = Self::assemble(request, body);
        #[allow(unused_mut)]
        let mut request = aws_smithy_http::operation::Request::from_parts(
            request.map(aws_smithy_http::body::SdkBody::from),
            properties,
        );
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        #[allow(unused_mut)]
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        aws_endpoint::set_endpoint_resolver(
            &mut request.properties_mut(),
            _config.endpoint_resolver.clone(),
        );
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_provider(
            &mut request.properties_mut(),
            _config.credentials_provider.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateVpcAttachment::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateVpcAttachment",
            "networkmanager",
        ));
        let op = op.with_retry_policy(aws_http::retry::AwsErrorRetryPolicy::new());
        Ok(op)
    }
    fn assemble(
        builder: http::request::Builder,
        body: aws_smithy_http::body::SdkBody,
    ) -> http::request::Request<aws_smithy_http::body::SdkBody> {
        let mut builder = builder;
        if let Some(content_length) = body.content_length() {
            builder = aws_smithy_http::header::set_header_if_absent(
                builder,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        builder.body(body).expect("should be valid request")
    }
    /// Creates a new builder-style object to manufacture [`UpdateVpcAttachmentInput`](crate::input::UpdateVpcAttachmentInput)
    pub fn builder() -> crate::input::update_vpc_attachment_input::Builder {
        crate::input::update_vpc_attachment_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>Adds a subnet ARN to the VPC attachment.</p>
    pub add_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Removes a subnet ARN from the attachment.</p>
    pub remove_subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Additional options for updating the VPC attachment. </p>
    pub options: std::option::Option<crate::model::VpcOptions>,
}
impl UpdateVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
    /// <p>Adds a subnet ARN to the VPC attachment.</p>
    pub fn add_subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.add_subnet_arns.as_deref()
    }
    /// <p>Removes a subnet ARN from the attachment.</p>
    pub fn remove_subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.remove_subnet_arns.as_deref()
    }
    /// <p>Additional options for updating the VPC attachment. </p>
    pub fn options(&self) -> std::option::Option<&crate::model::VpcOptions> {
        self.options.as_ref()
    }
}
impl std::fmt::Debug for UpdateVpcAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateVpcAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.field("add_subnet_arns", &self.add_subnet_arns);
        formatter.field("remove_subnet_arns", &self.remove_subnet_arns);
        formatter.field("options", &self.options);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSiteInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of your site.</p>
    pub site_id: std::option::Option<std::string::String>,
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The site location:</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    pub location: std::option::Option<crate::model::Location>,
}
impl UpdateSiteInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of your site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The site location:</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
}
impl std::fmt::Debug for UpdateSiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSiteInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("site_id", &self.site_id);
        formatter.field("description", &self.description);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateNetworkResourceMetadataInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The resource metadata.</p>
    pub metadata:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl UpdateNetworkResourceMetadataInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The resource metadata.</p>
    pub fn metadata(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.metadata.as_ref()
    }
}
impl std::fmt::Debug for UpdateNetworkResourceMetadataInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateNetworkResourceMetadataInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("metadata", &self.metadata);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateLinkInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The upload and download speed in Mbps. </p>
    pub bandwidth: std::option::Option<crate::model::Bandwidth>,
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub provider: std::option::Option<std::string::String>,
}
impl UpdateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The upload and download speed in Mbps. </p>
    pub fn bandwidth(&self) -> std::option::Option<&crate::model::Bandwidth> {
        self.bandwidth.as_ref()
    }
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
}
impl std::fmt::Debug for UpdateLinkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateLinkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("link_id", &self.link_id);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("bandwidth", &self.bandwidth);
        formatter.field("provider", &self.provider);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateGlobalNetworkInput {
    /// <p>The ID of your global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
}
impl UpdateGlobalNetworkInput {
    /// <p>The ID of your global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for UpdateGlobalNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateGlobalNetworkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateDeviceInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    pub aws_location: std::option::Option<crate::model::AwsLocation>,
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the device.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub model: std::option::Option<std::string::String>,
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>Describes a location.</p>
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The ID of the site.</p>
    pub site_id: std::option::Option<std::string::String>,
}
impl UpdateDeviceInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    pub fn aws_location(&self) -> std::option::Option<&crate::model::AwsLocation> {
        self.aws_location.as_ref()
    }
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the device.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn vendor(&self) -> std::option::Option<&str> {
        self.vendor.as_deref()
    }
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn serial_number(&self) -> std::option::Option<&str> {
        self.serial_number.as_deref()
    }
    /// <p>Describes a location.</p>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
}
impl std::fmt::Debug for UpdateDeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateDeviceInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("aws_location", &self.aws_location);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("vendor", &self.vendor);
        formatter.field("model", &self.model);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("site_id", &self.site_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The description of the update.</p>
    pub description: std::option::Option<std::string::String>,
}
impl UpdateCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The description of the update.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for UpdateCoreNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCoreNetworkInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateConnectionInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the connection.</p>
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the first device in the connection.</p>
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the second device in the connection.</p>
    pub connected_link_id: std::option::Option<std::string::String>,
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
}
impl UpdateConnectionInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
    /// <p>The ID of the link for the first device in the connection.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>The ID of the link for the second device in the connection.</p>
    pub fn connected_link_id(&self) -> std::option::Option<&str> {
        self.connected_link_id.as_deref()
    }
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl std::fmt::Debug for UpdateConnectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateConnectionInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("connection_id", &self.connection_id);
        formatter.field("link_id", &self.link_id);
        formatter.field("connected_link_id", &self.connected_link_id);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tag keys to remove from the specified resource.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tag keys to remove from the specified resource.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the specified resource.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The tags to apply to the specified resource.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The source from which traffic originates.</p>
    pub source: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
    /// <p>The destination.</p>
    pub destination: std::option::Option<crate::model::RouteAnalysisEndpointOptionsSpecification>,
    /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
    pub include_return_path: bool,
    /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
    pub use_middleboxes: bool,
}
impl StartRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The source from which traffic originates.</p>
    pub fn source(
        &self,
    ) -> std::option::Option<&crate::model::RouteAnalysisEndpointOptionsSpecification> {
        self.source.as_ref()
    }
    /// <p>The destination.</p>
    pub fn destination(
        &self,
    ) -> std::option::Option<&crate::model::RouteAnalysisEndpointOptionsSpecification> {
        self.destination.as_ref()
    }
    /// <p>Indicates whether to analyze the return path. The default is <code>false</code>.</p>
    pub fn include_return_path(&self) -> bool {
        self.include_return_path
    }
    /// <p>Indicates whether to include the location of middlebox appliances in the route analysis. The default is <code>false</code>.</p>
    pub fn use_middleboxes(&self) -> bool {
        self.use_middleboxes
    }
}
impl std::fmt::Debug for StartRouteAnalysisInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartRouteAnalysisInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("source", &self.source);
        formatter.field("destination", &self.destination);
        formatter.field("include_return_path", &self.include_return_path);
        formatter.field("use_middleboxes", &self.use_middleboxes);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version to restore.</p>
    pub policy_version_id: std::option::Option<i32>,
}
impl RestoreCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version to restore.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
}
impl std::fmt::Debug for RestoreCoreNetworkPolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreCoreNetworkPolicyVersionInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RejectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
}
impl RejectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl std::fmt::Debug for RejectAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RejectAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RegisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub transit_gateway_arn: std::option::Option<std::string::String>,
}
impl RegisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_arn.as_deref()
    }
}
impl std::fmt::Debug for RegisterTransitGatewayInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RegisterTransitGatewayInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("transit_gateway_arn", &self.transit_gateway_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyInput {
    /// <p>The JSON resource policy document.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource policy. </p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl PutResourcePolicyInput {
    /// <p>The JSON resource policy document.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>The ARN of the resource policy. </p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for PutResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyInput");
        formatter.field("policy_document", &self.policy_document);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The policy document.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>a core network policy description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of a core network policy. </p>
    pub latest_version_id: std::option::Option<i32>,
    /// <p>The client token associated with the request.</p>
    pub client_token: std::option::Option<std::string::String>,
}
impl PutCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The policy document.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>a core network policy description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of a core network policy. </p>
    pub fn latest_version_id(&self) -> std::option::Option<i32> {
        self.latest_version_id
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl std::fmt::Debug for PutCoreNetworkPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutCoreNetworkPolicyInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("description", &self.description);
        formatter.field("latest_version_id", &self.latest_version_id);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for ListTagsForResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCoreNetworksInput {
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCoreNetworksInput {
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListCoreNetworksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCoreNetworksInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCoreNetworkPolicyVersionsInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCoreNetworkPolicyVersionsInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListCoreNetworkPolicyVersionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCoreNetworkPolicyVersionsInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListConnectPeersInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment.</p>
    pub connect_attachment_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListConnectPeersInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the attachment.</p>
    pub fn connect_attachment_id(&self) -> std::option::Option<&str> {
        self.connect_attachment_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListConnectPeersInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListConnectPeersInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("connect_attachment_id", &self.connect_attachment_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListAttachmentsInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The type of attachment.</p>
    pub attachment_type: std::option::Option<crate::model::AttachmentType>,
    /// <p>The Region where the edge is located.</p>
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The state of the attachment.</p>
    pub state: std::option::Option<crate::model::AttachmentState>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListAttachmentsInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The type of attachment.</p>
    pub fn attachment_type(&self) -> std::option::Option<&crate::model::AttachmentType> {
        self.attachment_type.as_ref()
    }
    /// <p>The Region where the edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<&str> {
        self.edge_location.as_deref()
    }
    /// <p>The state of the attachment.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::AttachmentState> {
        self.state.as_ref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListAttachmentsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListAttachmentsInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("attachment_type", &self.attachment_type);
        formatter.field("edge_location", &self.edge_location);
        formatter.field("state", &self.state);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetVpcAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl std::fmt::Debug for GetVpcAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetVpcAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTransitGatewayRegistrationsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
    pub transit_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetTransitGatewayRegistrationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is 10.</p>
    pub fn transit_gateway_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.transit_gateway_arns.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetTransitGatewayRegistrationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTransitGatewayRegistrationsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("transit_gateway_arns", &self.transit_gateway_arns);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetTransitGatewayConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
    pub transit_gateway_connect_peer_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetTransitGatewayConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
    pub fn transit_gateway_connect_peer_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.transit_gateway_connect_peer_arns.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetTransitGatewayConnectPeerAssociationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetTransitGatewayConnectPeerAssociationsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field(
            "transit_gateway_connect_peer_arns",
            &self.transit_gateway_connect_peer_arns,
        );
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSiteToSiteVpnAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetSiteToSiteVpnAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl std::fmt::Debug for GetSiteToSiteVpnAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSiteToSiteVpnAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSitesInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more site IDs. The maximum is 10.</p>
    pub site_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetSitesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more site IDs. The maximum is 10.</p>
    pub fn site_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.site_ids.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetSitesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSitesInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("site_ids", &self.site_ids);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the route analysis.</p>
    pub route_analysis_id: std::option::Option<std::string::String>,
}
impl GetRouteAnalysisInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the route analysis.</p>
    pub fn route_analysis_id(&self) -> std::option::Option<&str> {
        self.route_analysis_id.as_deref()
    }
}
impl std::fmt::Debug for GetRouteAnalysisInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRouteAnalysisInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("route_analysis_id", &self.route_analysis_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetResourcePolicyInput {
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl GetResourcePolicyInput {
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for GetResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetResourcePolicyInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNetworkTelemetryInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the gateway.</p>
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkTelemetryInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<&str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetNetworkTelemetryInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetNetworkTelemetryInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("registered_gateway_arn", &self.registered_gateway_arn);
        formatter.field("aws_region", &self.aws_region);
        formatter.field("account_id", &self.account_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNetworkRoutesInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the route table.</p>
    pub route_table_identifier: std::option::Option<crate::model::RouteTableIdentifier>,
    /// <p>An exact CIDR block.</p>
    pub exact_cidr_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The most specific route that matches the traffic (longest prefix match).</p>
    pub longest_prefix_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The routes with a subnet that match the specified CIDR filter.</p>
    pub subnet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
    pub supernet_of_matches: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IDs of the prefix lists.</p>
    pub prefix_list_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The route states.</p>
    pub states: std::option::Option<std::vec::Vec<crate::model::RouteState>>,
    /// <p>The route types.</p>
    pub types: std::option::Option<std::vec::Vec<crate::model::RouteType>>,
    /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
    pub destination_filters: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl GetNetworkRoutesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the route table.</p>
    pub fn route_table_identifier(
        &self,
    ) -> std::option::Option<&crate::model::RouteTableIdentifier> {
        self.route_table_identifier.as_ref()
    }
    /// <p>An exact CIDR block.</p>
    pub fn exact_cidr_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.exact_cidr_matches.as_deref()
    }
    /// <p>The most specific route that matches the traffic (longest prefix match).</p>
    pub fn longest_prefix_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.longest_prefix_matches.as_deref()
    }
    /// <p>The routes with a subnet that match the specified CIDR filter.</p>
    pub fn subnet_of_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_of_matches.as_deref()
    }
    /// <p>The routes with a CIDR that encompasses the CIDR filter. Example: If you specify 10.0.1.0/30, then the result returns 10.0.1.0/29.</p>
    pub fn supernet_of_matches(&self) -> std::option::Option<&[std::string::String]> {
        self.supernet_of_matches.as_deref()
    }
    /// <p>The IDs of the prefix lists.</p>
    pub fn prefix_list_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.prefix_list_ids.as_deref()
    }
    /// <p>The route states.</p>
    pub fn states(&self) -> std::option::Option<&[crate::model::RouteState]> {
        self.states.as_deref()
    }
    /// <p>The route types.</p>
    pub fn types(&self) -> std::option::Option<&[crate::model::RouteType]> {
        self.types.as_deref()
    }
    /// <p>Filter by route table destination. Possible Values: TRANSIT_GATEWAY_ATTACHMENT_ID, RESOURCE_ID, or RESOURCE_TYPE.</p>
    pub fn destination_filters(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.destination_filters.as_ref()
    }
}
impl std::fmt::Debug for GetNetworkRoutesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetNetworkRoutesInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("route_table_identifier", &self.route_table_identifier);
        formatter.field("exact_cidr_matches", &self.exact_cidr_matches);
        formatter.field("longest_prefix_matches", &self.longest_prefix_matches);
        formatter.field("subnet_of_matches", &self.subnet_of_matches);
        formatter.field("supernet_of_matches", &self.supernet_of_matches);
        formatter.field("prefix_list_ids", &self.prefix_list_ids);
        formatter.field("states", &self.states);
        formatter.field("types", &self.types);
        formatter.field("destination_filters", &self.destination_filters);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNetworkResourcesInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the gateway.</p>
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
    /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
    /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
    /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
    /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
    /// </ul>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkResourcesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<&str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>dx-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_DirectConnectGateway.html">DirectConnectGateway</a>.</p> </li>
    /// <li> <p> <code>dx-vif</code> - The definition model is <a href="https://docs.aws.amazon.com/directconnect/latest/APIReference/API_VirtualInterface.html">VirtualInterface</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Connection.html">Connection</a>.</p> </li>
    /// <li> <p> <code>device</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Device.html">Device</a>.</p> </li>
    /// <li> <p> <code>link</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Link.html">Link</a>.</p> </li>
    /// <li> <p> <code>site</code> - The definition model is <a href="https://docs.aws.amazon.com/networkmanager/latest/APIReference/API_Site.html">Site</a>.</p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CustomerGateway.html">CustomerGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGateway.html">TransitGateway</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayAttachment.html">TransitGatewayAttachment</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayConnectPeer.html">TransitGatewayConnectPeer</a>.</p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_TransitGatewayRouteTable.html">TransitGatewayRouteTable</a>.</p> </li>
    /// <li> <p> <code>vpn-connection</code> - The definition model is <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_VpnConnection.html">VpnConnection</a>.</p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetNetworkResourcesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetNetworkResourcesInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("registered_gateway_arn", &self.registered_gateway_arn);
        formatter.field("aws_region", &self.aws_region);
        formatter.field("account_id", &self.account_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNetworkResourceRelationshipsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the registered gateway.</p>
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ARN of the gateway.</p>
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkResourceRelationshipsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the registered gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<&str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<&str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<&str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The ARN of the gateway.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetNetworkResourceRelationshipsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetNetworkResourceRelationshipsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("registered_gateway_arn", &self.registered_gateway_arn);
        formatter.field("aws_region", &self.aws_region);
        formatter.field("account_id", &self.account_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetNetworkResourceCountsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetNetworkResourceCountsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The resource type.</p>
    /// <p>The following are the supported resource types for Direct Connect:</p>
    /// <ul>
    /// <li> <p> <code>dxcon</code> </p> </li>
    /// <li> <p> <code>dx-gateway</code> </p> </li>
    /// <li> <p> <code>dx-vif</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Network Manager:</p>
    /// <ul>
    /// <li> <p> <code>connection</code> </p> </li>
    /// <li> <p> <code>device</code> </p> </li>
    /// <li> <p> <code>link</code> </p> </li>
    /// <li> <p> <code>site</code> </p> </li>
    /// </ul>
    /// <p>The following are the supported resource types for Amazon VPC:</p>
    /// <ul>
    /// <li> <p> <code>customer-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway</code> </p> </li>
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li>
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li>
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li>
    /// <li> <p> <code>vpn-connection</code> </p> </li>
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<&str> {
        self.resource_type.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetNetworkResourceCountsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetNetworkResourceCountsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLinksInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more link IDs. The maximum is 10.</p>
    pub link_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the site.</p>
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The link type.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The link provider.</p>
    pub provider: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetLinksInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more link IDs. The maximum is 10.</p>
    pub fn link_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.link_ids.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The link type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The link provider.</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetLinksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLinksInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("link_ids", &self.link_ids);
        formatter.field("site_id", &self.site_id);
        formatter.field("r#type", &self.r#type);
        formatter.field("provider", &self.provider);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetLinkAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetLinkAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetLinkAssociationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetLinkAssociationsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("link_id", &self.link_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDevicesInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more device IDs. The maximum is 10.</p>
    pub device_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the site.</p>
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetDevicesInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more device IDs. The maximum is 10.</p>
    pub fn device_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.device_ids.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetDevicesInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDevicesInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_ids", &self.device_ids);
        formatter.field("site_id", &self.site_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCustomerGatewayAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
    pub customer_gateway_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCustomerGatewayAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more customer gateway Amazon Resource Names (ARNs). The maximum is 10.</p>
    pub fn customer_gateway_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.customer_gateway_arns.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetCustomerGatewayAssociationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCustomerGatewayAssociationsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("customer_gateway_arns", &self.customer_gateway_arns);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network policy version.</p>
    pub policy_version_id: std::option::Option<i32>,
    /// <p>The alias of a core network policy </p>
    pub alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
}
impl GetCoreNetworkPolicyInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of a core network policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>The alias of a core network policy </p>
    pub fn alias(&self) -> std::option::Option<&crate::model::CoreNetworkPolicyAlias> {
        self.alias.as_ref()
    }
}
impl std::fmt::Debug for GetCoreNetworkPolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCoreNetworkPolicyInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.field("alias", &self.alias);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    pub policy_version_id: std::option::Option<i32>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetCoreNetworkChangeSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCoreNetworkChangeSetInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
}
impl GetCoreNetworkInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
}
impl std::fmt::Debug for GetCoreNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCoreNetworkInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The IDs of the Connect peers.</p>
    pub connect_peer_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetConnectPeerAssociationsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The IDs of the Connect peers.</p>
    pub fn connect_peer_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.connect_peer_ids.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetConnectPeerAssociationsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConnectPeerAssociationsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("connect_peer_ids", &self.connect_peer_ids);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConnectPeerInput {
    /// <p>The ID of the Connect peer.</p>
    pub connect_peer_id: std::option::Option<std::string::String>,
}
impl GetConnectPeerInput {
    /// <p>The ID of the Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
}
impl std::fmt::Debug for GetConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConnectPeerInput");
        formatter.field("connect_peer_id", &self.connect_peer_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConnectionsInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>One or more connection IDs.</p>
    pub connection_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl GetConnectionsInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>One or more connection IDs.</p>
    pub fn connection_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.connection_ids.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for GetConnectionsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConnectionsInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("connection_ids", &self.connection_ids);
        formatter.field("device_id", &self.device_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConnectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub attachment_id: std::option::Option<std::string::String>,
}
impl GetConnectAttachmentInput {
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl std::fmt::Debug for GetConnectAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConnectAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExecuteCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    pub policy_version_id: std::option::Option<i32>,
}
impl ExecuteCoreNetworkChangeSetInput {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
}
impl std::fmt::Debug for ExecuteCoreNetworkChangeSetInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExecuteCoreNetworkChangeSetInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    pub transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
}
impl DisassociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    pub fn transit_gateway_connect_peer_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_connect_peer_arn.as_deref()
    }
}
impl std::fmt::Debug for DisassociateTransitGatewayConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateTransitGatewayConnectPeerInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field(
            "transit_gateway_connect_peer_arn",
            &self.transit_gateway_connect_peer_arn,
        );
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateLinkInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
}
impl DisassociateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl std::fmt::Debug for DisassociateLinkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateLinkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("link_id", &self.link_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateCustomerGatewayInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub customer_gateway_arn: std::option::Option<std::string::String>,
}
impl DisassociateCustomerGatewayInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub fn customer_gateway_arn(&self) -> std::option::Option<&str> {
        self.customer_gateway_arn.as_deref()
    }
}
impl std::fmt::Debug for DisassociateCustomerGatewayInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateCustomerGatewayInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("customer_gateway_arn", &self.customer_gateway_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DisassociateConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Connect peer to disassociate from a device.</p>
    pub connect_peer_id: std::option::Option<std::string::String>,
}
impl DisassociateConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the Connect peer to disassociate from a device.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
}
impl std::fmt::Debug for DisassociateConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DisassociateConnectPeerInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("connect_peer_id", &self.connect_peer_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeGlobalNetworksInput {
    /// <p>The IDs of one or more global networks. The maximum is 10.</p>
    pub global_network_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The maximum number of results to return.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next page of results.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl DescribeGlobalNetworksInput {
    /// <p>The IDs of one or more global networks. The maximum is 10.</p>
    pub fn global_network_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.global_network_ids.as_deref()
    }
    /// <p>The maximum number of results to return.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next page of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for DescribeGlobalNetworksInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeGlobalNetworksInput");
        formatter.field("global_network_ids", &self.global_network_ids);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeregisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub transit_gateway_arn: std::option::Option<std::string::String>,
}
impl DeregisterTransitGatewayInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_arn.as_deref()
    }
}
impl std::fmt::Debug for DeregisterTransitGatewayInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeregisterTransitGatewayInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("transit_gateway_arn", &self.transit_gateway_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSiteInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the site.</p>
    pub site_id: std::option::Option<std::string::String>,
}
impl DeleteSiteInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteSiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSiteInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("site_id", &self.site_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyInput {
    /// <p>The ARN of the policy to delete.</p>
    pub resource_arn: std::option::Option<std::string::String>,
}
impl DeleteResourcePolicyInput {
    /// <p>The ARN of the policy to delete.</p>
    pub fn resource_arn(&self) -> std::option::Option<&str> {
        self.resource_arn.as_deref()
    }
}
impl std::fmt::Debug for DeleteResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyInput");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteLinkInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
}
impl DeleteLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteLinkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteLinkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("link_id", &self.link_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteGlobalNetworkInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
}
impl DeleteGlobalNetworkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteGlobalNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteGlobalNetworkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteDeviceInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
}
impl DeleteDeviceInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteDeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteDeviceInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network for the deleted policy.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The version ID of the deleted policy.</p>
    pub policy_version_id: std::option::Option<i32>,
}
impl DeleteCoreNetworkPolicyVersionInput {
    /// <p>The ID of a core network for the deleted policy.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The version ID of the deleted policy.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
}
impl std::fmt::Debug for DeleteCoreNetworkPolicyVersionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCoreNetworkPolicyVersionInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("policy_version_id", &self.policy_version_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteCoreNetworkInput {
    /// <p>The network ID of the deleted core network.</p>
    pub core_network_id: std::option::Option<std::string::String>,
}
impl DeleteCoreNetworkInput {
    /// <p>The network ID of the deleted core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteCoreNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteCoreNetworkInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteConnectPeerInput {
    /// <p>The ID of the deleted Connect peer.</p>
    pub connect_peer_id: std::option::Option<std::string::String>,
}
impl DeleteConnectPeerInput {
    /// <p>The ID of the deleted Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteConnectPeerInput");
        formatter.field("connect_peer_id", &self.connect_peer_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteConnectionInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the connection.</p>
    pub connection_id: std::option::Option<std::string::String>,
}
impl DeleteConnectionInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<&str> {
        self.connection_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteConnectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteConnectionInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("connection_id", &self.connection_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteAttachmentInput {
    /// <p>The ID of the attachment to delete.</p>
    pub attachment_id: std::option::Option<std::string::String>,
}
impl DeleteAttachmentInput {
    /// <p>The ID of the attachment to delete.</p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl std::fmt::Debug for DeleteAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateVpcAttachmentInput {
    /// <p>The ID of a core network for the VPC attachment.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the VPC.</p>
    pub vpc_arn: std::option::Option<std::string::String>,
    /// <p>The subnet ARN of the VPC attachment.</p>
    pub subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Options for the VPC attachment.</p>
    pub options: std::option::Option<crate::model::VpcOptions>,
    /// <p>The key-value tags associated with the request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateVpcAttachmentInput {
    /// <p>The ID of a core network for the VPC attachment.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of the VPC.</p>
    pub fn vpc_arn(&self) -> std::option::Option<&str> {
        self.vpc_arn.as_deref()
    }
    /// <p>The subnet ARN of the VPC attachment.</p>
    pub fn subnet_arns(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_arns.as_deref()
    }
    /// <p>Options for the VPC attachment.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::VpcOptions> {
        self.options.as_ref()
    }
    /// <p>The key-value tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl std::fmt::Debug for CreateVpcAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateVpcAttachmentInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("vpc_arn", &self.vpc_arn);
        formatter.field("subnet_arns", &self.subnet_arns);
        formatter.field("options", &self.options);
        formatter.field("tags", &self.tags);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSiteToSiteVpnAttachmentInput {
    /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN identifying the VPN attachment.</p>
    pub vpn_connection_arn: std::option::Option<std::string::String>,
    /// <p>The tags associated with the request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateSiteToSiteVpnAttachmentInput {
    /// <p>The ID of a core network where you're creating a site-to-site VPN attachment.</p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN identifying the VPN attachment.</p>
    pub fn vpn_connection_arn(&self) -> std::option::Option<&str> {
        self.vpn_connection_arn.as_deref()
    }
    /// <p>The tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl std::fmt::Debug for CreateSiteToSiteVpnAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSiteToSiteVpnAttachmentInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("vpn_connection_arn", &self.vpn_connection_arn);
        formatter.field("tags", &self.tags);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSiteInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The tags to apply to the resource during creation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateSiteInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>A description of your site.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
    /// <ul>
    /// <li> <p> <code>Address</code>: The physical address of the site.</p> </li>
    /// <li> <p> <code>Latitude</code>: The latitude of the site. </p> </li>
    /// <li> <p> <code>Longitude</code>: The longitude of the site.</p> </li>
    /// </ul>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateSiteInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSiteInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("description", &self.description);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateLinkInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p> The upload speed and download speed in Mbps. </p>
    pub bandwidth: std::option::Option<crate::model::Bandwidth>,
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    pub provider: std::option::Option<std::string::String>,
    /// <p>The ID of the site.</p>
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>A description of the link.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p> The upload speed and download speed in Mbps. </p>
    pub fn bandwidth(&self) -> std::option::Option<&crate::model::Bandwidth> {
        self.bandwidth.as_ref()
    }
    /// <p>The provider of the link.</p>
    /// <p>Constraints: Maximum length of 128 characters. Cannot include the following characters: | \ ^</p>
    pub fn provider(&self) -> std::option::Option<&str> {
        self.provider.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateLinkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateLinkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("bandwidth", &self.bandwidth);
        formatter.field("provider", &self.provider);
        formatter.field("site_id", &self.site_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateGlobalNetworkInput {
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateGlobalNetworkInput {
    /// <p>A description of the global network.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateGlobalNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateGlobalNetworkInput");
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDeviceInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    pub aws_location: std::option::Option<crate::model::AwsLocation>,
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the device.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub model: std::option::Option<std::string::String>,
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The location of the device.</p>
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The ID of the site.</p>
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateDeviceInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Web Services location of the device, if applicable. For an on-premises device, you can omit this parameter.</p>
    pub fn aws_location(&self) -> std::option::Option<&crate::model::AwsLocation> {
        self.aws_location.as_ref()
    }
    /// <p>A description of the device.</p>
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the device.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The vendor of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn vendor(&self) -> std::option::Option<&str> {
        self.vendor.as_deref()
    }
    /// <p>The model of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The serial number of the device.</p>
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn serial_number(&self) -> std::option::Option<&str> {
        self.serial_number.as_deref()
    }
    /// <p>The location of the device.</p>
    pub fn location(&self) -> std::option::Option<&crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<&str> {
        self.site_id.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateDeviceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDeviceInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("aws_location", &self.aws_location);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("vendor", &self.vendor);
        formatter.field("model", &self.model);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("site_id", &self.site_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCoreNetworkInput {
    /// <p>The ID of the global network that a core network will be a part of. </p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The description of a core network.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Key-value tags associated with a core network request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The policy document for creating a core network.</p>
    pub policy_document: std::option::Option<std::string::String>,
    /// <p>The client token associated with a core network request.</p>
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateCoreNetworkInput {
    /// <p>The ID of the global network that a core network will be a part of. </p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The description of a core network.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Key-value tags associated with a core network request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The policy document for creating a core network.</p>
    pub fn policy_document(&self) -> std::option::Option<&str> {
        self.policy_document.as_deref()
    }
    /// <p>The client token associated with a core network request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl std::fmt::Debug for CreateCoreNetworkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCoreNetworkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.field("policy_document", &self.policy_document);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateConnectPeerInput {
    /// <p>The ID of the connection attachment.</p>
    pub connect_attachment_id: std::option::Option<std::string::String>,
    /// <p>A Connect peer core network address.</p>
    pub core_network_address: std::option::Option<std::string::String>,
    /// <p>The Connect peer address.</p>
    pub peer_address: std::option::Option<std::string::String>,
    /// <p>The Connect peer BGP options.</p>
    pub bgp_options: std::option::Option<crate::model::BgpOptions>,
    /// <p>The inside IP addresses used for BGP peering.</p>
    pub inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The tags associated with the peer request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateConnectPeerInput {
    /// <p>The ID of the connection attachment.</p>
    pub fn connect_attachment_id(&self) -> std::option::Option<&str> {
        self.connect_attachment_id.as_deref()
    }
    /// <p>A Connect peer core network address.</p>
    pub fn core_network_address(&self) -> std::option::Option<&str> {
        self.core_network_address.as_deref()
    }
    /// <p>The Connect peer address.</p>
    pub fn peer_address(&self) -> std::option::Option<&str> {
        self.peer_address.as_deref()
    }
    /// <p>The Connect peer BGP options.</p>
    pub fn bgp_options(&self) -> std::option::Option<&crate::model::BgpOptions> {
        self.bgp_options.as_ref()
    }
    /// <p>The inside IP addresses used for BGP peering.</p>
    pub fn inside_cidr_blocks(&self) -> std::option::Option<&[std::string::String]> {
        self.inside_cidr_blocks.as_deref()
    }
    /// <p>The tags associated with the peer request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl std::fmt::Debug for CreateConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateConnectPeerInput");
        formatter.field("connect_attachment_id", &self.connect_attachment_id);
        formatter.field("core_network_address", &self.core_network_address);
        formatter.field("peer_address", &self.peer_address);
        formatter.field("bgp_options", &self.bgp_options);
        formatter.field("inside_cidr_blocks", &self.inside_cidr_blocks);
        formatter.field("tags", &self.tags);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateConnectionInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the first device in the connection.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the second device in the connection.</p>
    pub connected_device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the first device.</p>
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the second device.</p>
    pub connected_link_id: std::option::Option<std::string::String>,
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The tags to apply to the resource during creation.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CreateConnectionInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the first device in the connection.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the second device in the connection.</p>
    pub fn connected_device_id(&self) -> std::option::Option<&str> {
        self.connected_device_id.as_deref()
    }
    /// <p>The ID of the link for the first device.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
    /// <p>The ID of the link for the second device.</p>
    pub fn connected_link_id(&self) -> std::option::Option<&str> {
        self.connected_link_id.as_deref()
    }
    /// <p>A description of the connection.</p>
    /// <p>Length Constraints: Maximum length of 256 characters.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The tags to apply to the resource during creation.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl std::fmt::Debug for CreateConnectionInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateConnectionInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("connected_device_id", &self.connected_device_id);
        formatter.field("link_id", &self.link_id);
        formatter.field("connected_link_id", &self.connected_link_id);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateConnectAttachmentInput {
    /// <p>The ID of a core network where you want to create the attachment. </p>
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The Region where the edge is located.</p>
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment between the two connections.</p>
    pub transport_attachment_id: std::option::Option<std::string::String>,
    /// <p>Options for creating an attachment.</p>
    pub options: std::option::Option<crate::model::ConnectAttachmentOptions>,
    /// <p>The list of key-value tags associated with the request.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The client token associated with the request.</p>
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateConnectAttachmentInput {
    /// <p>The ID of a core network where you want to create the attachment. </p>
    pub fn core_network_id(&self) -> std::option::Option<&str> {
        self.core_network_id.as_deref()
    }
    /// <p>The Region where the edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<&str> {
        self.edge_location.as_deref()
    }
    /// <p>The ID of the attachment between the two connections.</p>
    pub fn transport_attachment_id(&self) -> std::option::Option<&str> {
        self.transport_attachment_id.as_deref()
    }
    /// <p>Options for creating an attachment.</p>
    pub fn options(&self) -> std::option::Option<&crate::model::ConnectAttachmentOptions> {
        self.options.as_ref()
    }
    /// <p>The list of key-value tags associated with the request.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The client token associated with the request.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl std::fmt::Debug for CreateConnectAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateConnectAttachmentInput");
        formatter.field("core_network_id", &self.core_network_id);
        formatter.field("edge_location", &self.edge_location);
        formatter.field("transport_attachment_id", &self.transport_attachment_id);
        formatter.field("options", &self.options);
        formatter.field("tags", &self.tags);
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
    pub transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateTransitGatewayConnectPeerInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
    pub fn transit_gateway_connect_peer_arn(&self) -> std::option::Option<&str> {
        self.transit_gateway_connect_peer_arn.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl std::fmt::Debug for AssociateTransitGatewayConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateTransitGatewayConnectPeerInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field(
            "transit_gateway_connect_peer_arn",
            &self.transit_gateway_connect_peer_arn,
        );
        formatter.field("device_id", &self.device_id);
        formatter.field("link_id", &self.link_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateLinkInput {
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateLinkInput {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl std::fmt::Debug for AssociateLinkInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateLinkInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("link_id", &self.link_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateCustomerGatewayInput {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub customer_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateCustomerGatewayInput {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub fn customer_gateway_arn(&self) -> std::option::Option<&str> {
        self.customer_gateway_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl std::fmt::Debug for AssociateCustomerGatewayInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateCustomerGatewayInput");
        formatter.field("customer_gateway_arn", &self.customer_gateway_arn);
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("link_id", &self.link_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AssociateConnectPeerInput {
    /// <p>The ID of your global network.</p>
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Connect peer.</p>
    pub connect_peer_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    pub link_id: std::option::Option<std::string::String>,
}
impl AssociateConnectPeerInput {
    /// <p>The ID of your global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<&str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<&str> {
        self.connect_peer_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<&str> {
        self.link_id.as_deref()
    }
}
impl std::fmt::Debug for AssociateConnectPeerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AssociateConnectPeerInput");
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("connect_peer_id", &self.connect_peer_id);
        formatter.field("device_id", &self.device_id);
        formatter.field("link_id", &self.link_id);
        formatter.finish()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AcceptAttachmentInput {
    /// <p>The ID of the attachment. </p>
    pub attachment_id: std::option::Option<std::string::String>,
}
impl AcceptAttachmentInput {
    /// <p>The ID of the attachment. </p>
    pub fn attachment_id(&self) -> std::option::Option<&str> {
        self.attachment_id.as_deref()
    }
}
impl std::fmt::Debug for AcceptAttachmentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AcceptAttachmentInput");
        formatter.field("attachment_id", &self.attachment_id);
        formatter.finish()
    }
}
