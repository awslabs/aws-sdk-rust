// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a validation exception for a field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationExceptionField  {
    /// <p>The name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The message for the field.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationExceptionField {
    /// <p>The name of the field.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The message for the field.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {
    
    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The message for the field.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the field.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        pub fn build(self) -> crate::model::ValidationExceptionField {
            crate::model::ValidationExceptionField {
                name: self.name
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

/// When writing a match expression against `ValidationExceptionReason`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let validationexceptionreason = unimplemented!();
/// match validationexceptionreason {
///     ValidationExceptionReason::CannotParse => { /* ... */ },
///     ValidationExceptionReason::FieldValidationFailed => { /* ... */ },
///     ValidationExceptionReason::Other => { /* ... */ },
///     ValidationExceptionReason::UnknownOperation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `validationexceptionreason` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ValidationExceptionReason::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ValidationExceptionReason::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ValidationExceptionReason::NewFeature` is defined.
/// Specifically, when `validationexceptionreason` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ValidationExceptionReason::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ValidationExceptionReason {
    #[allow(missing_docs)] // documentation missing in model
    CannotParse,
    #[allow(missing_docs)] // documentation missing in model
    FieldValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Other,
    #[allow(missing_docs)] // documentation missing in model
    UnknownOperation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ValidationExceptionReason {
    fn from(s: &str) -> Self {
        match s {
            "CannotParse" => ValidationExceptionReason::CannotParse,
            "FieldValidationFailed" => ValidationExceptionReason::FieldValidationFailed,
            "Other" => ValidationExceptionReason::Other,
            "UnknownOperation" => ValidationExceptionReason::UnknownOperation,
            other => ValidationExceptionReason::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ValidationExceptionReason {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ValidationExceptionReason::from(s))
                }
            }
impl ValidationExceptionReason {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ValidationExceptionReason::CannotParse => "CannotParse",
            ValidationExceptionReason::FieldValidationFailed => "FieldValidationFailed",
            ValidationExceptionReason::Other => "Other",
            ValidationExceptionReason::UnknownOperation => "UnknownOperation",
            ValidationExceptionReason::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CannotParse", "FieldValidationFailed", "Other", "UnknownOperation"
        ]
    }
}
impl AsRef<str> for ValidationExceptionReason {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a VPC attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcAttachment  {
    /// <p>Provides details about the VPC attachment.</p>
    #[doc(hidden)]
    pub attachment: std::option::Option<crate::model::Attachment>,
    /// <p>The subnet ARNs.</p>
    #[doc(hidden)]
    pub subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Provides details about the VPC attachment.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::VpcOptions>,
}
impl VpcAttachment {
    /// <p>Provides details about the VPC attachment.</p>
    pub fn attachment(&self) -> std::option::Option<& crate::model::Attachment> {
        self.attachment.as_ref()
    }
    /// <p>The subnet ARNs.</p>
    pub fn subnet_arns(&self) -> std::option::Option<& [std::string::String]> {
        self.subnet_arns.as_deref()
    }
    /// <p>Provides details about the VPC attachment.</p>
    pub fn options(&self) -> std::option::Option<& crate::model::VpcOptions> {
        self.options.as_ref()
    }
}
/// See [`VpcAttachment`](crate::model::VpcAttachment).
pub mod vpc_attachment {
    
    /// A builder for [`VpcAttachment`](crate::model::VpcAttachment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment: std::option::Option<crate::model::Attachment>,
        pub(crate) subnet_arns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) options: std::option::Option<crate::model::VpcOptions>,
    }
    impl Builder {
        /// <p>Provides details about the VPC attachment.</p>
        pub fn attachment(mut self, input: crate::model::Attachment) -> Self {
            self.attachment = Some(input);
            self
        }
        /// <p>Provides details about the VPC attachment.</p>
        pub fn set_attachment(mut self, input: std::option::Option<crate::model::Attachment>) -> Self {
            self.attachment = input; self
        }
        /// Appends an item to `subnet_arns`.
        ///
        /// To override the contents of this collection use [`set_subnet_arns`](Self::set_subnet_arns).
        ///
        /// <p>The subnet ARNs.</p>
        pub fn subnet_arns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_arns.unwrap_or_default();
                            v.push(input.into());
                            self.subnet_arns = Some(v);
                            self
        }
        /// <p>The subnet ARNs.</p>
        pub fn set_subnet_arns(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.subnet_arns = input; self
        }
        /// <p>Provides details about the VPC attachment.</p>
        pub fn options(mut self, input: crate::model::VpcOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Provides details about the VPC attachment.</p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::VpcOptions>) -> Self {
            self.options = input; self
        }
        /// Consumes the builder and constructs a [`VpcAttachment`](crate::model::VpcAttachment).
        pub fn build(self) -> crate::model::VpcAttachment {
            crate::model::VpcAttachment {
                attachment: self.attachment
                ,
                subnet_arns: self.subnet_arns
                ,
                options: self.options
                ,
            }
        }
    }
    
    
}
impl VpcAttachment {
    /// Creates a new builder-style object to manufacture [`VpcAttachment`](crate::model::VpcAttachment).
    pub fn builder() -> crate::model::vpc_attachment::Builder {
        crate::model::vpc_attachment::Builder::default()
    }
}

/// <p>Describes the VPC options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VpcOptions  {
    /// <p>Indicates whether IPv6 is supported.</p>
    #[doc(hidden)]
    pub ipv6_support: bool,
    /// <p>Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is <code>false</code>.</p>
    #[doc(hidden)]
    pub appliance_mode_support: bool,
}
impl VpcOptions {
    /// <p>Indicates whether IPv6 is supported.</p>
    pub fn ipv6_support(&self) -> bool {
        self.ipv6_support
    }
    /// <p>Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is <code>false</code>.</p>
    pub fn appliance_mode_support(&self) -> bool {
        self.appliance_mode_support
    }
}
/// See [`VpcOptions`](crate::model::VpcOptions).
pub mod vpc_options {
    
    /// A builder for [`VpcOptions`](crate::model::VpcOptions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ipv6_support: std::option::Option<bool>,
        pub(crate) appliance_mode_support: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether IPv6 is supported.</p>
        pub fn ipv6_support(mut self, input: bool) -> Self {
            self.ipv6_support = Some(input);
            self
        }
        /// <p>Indicates whether IPv6 is supported.</p>
        pub fn set_ipv6_support(mut self, input: std::option::Option<bool>) -> Self {
            self.ipv6_support = input; self
        }
        /// <p>Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is <code>false</code>.</p>
        pub fn appliance_mode_support(mut self, input: bool) -> Self {
            self.appliance_mode_support = Some(input);
            self
        }
        /// <p>Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow. The default value is <code>false</code>.</p>
        pub fn set_appliance_mode_support(mut self, input: std::option::Option<bool>) -> Self {
            self.appliance_mode_support = input; self
        }
        /// Consumes the builder and constructs a [`VpcOptions`](crate::model::VpcOptions).
        pub fn build(self) -> crate::model::VpcOptions {
            crate::model::VpcOptions {
                ipv6_support: self.ipv6_support
                    .unwrap_or_default()
                ,
                appliance_mode_support: self.appliance_mode_support
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl VpcOptions {
    /// Creates a new builder-style object to manufacture [`VpcOptions`](crate::model::VpcOptions).
    pub fn builder() -> crate::model::vpc_options::Builder {
        crate::model::vpc_options::Builder::default()
    }
}

/// <p>Describes a core network attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Attachment  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a core network.</p>
    #[doc(hidden)]
    pub core_network_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment.</p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment account owner.</p>
    #[doc(hidden)]
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>The type of attachment.</p>
    #[doc(hidden)]
    pub attachment_type: std::option::Option<crate::model::AttachmentType>,
    /// <p>The state of the attachment.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::AttachmentState>,
    /// <p>The Region where the edge is located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The attachment resource ARN.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The policy rule number associated with the attachment.</p>
    #[doc(hidden)]
    pub attachment_policy_rule_number: std::option::Option<i32>,
    /// <p>The name of the segment attachment.</p>
    #[doc(hidden)]
    pub segment_name: std::option::Option<std::string::String>,
    /// <p>The tags associated with the attachment.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The attachment to move from one segment to another.</p>
    #[doc(hidden)]
    pub proposed_segment_change: std::option::Option<crate::model::ProposedSegmentChange>,
    /// <p>The timestamp when the attachment was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when the attachment was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Attachment {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of a core network.</p>
    pub fn core_network_arn(&self) -> std::option::Option<& str> {
        self.core_network_arn.as_deref()
    }
    /// <p>The ID of the attachment.</p>
    pub fn attachment_id(&self) -> std::option::Option<& str> {
        self.attachment_id.as_deref()
    }
    /// <p>The ID of the attachment account owner.</p>
    pub fn owner_account_id(&self) -> std::option::Option<& str> {
        self.owner_account_id.as_deref()
    }
    /// <p>The type of attachment.</p>
    pub fn attachment_type(&self) -> std::option::Option<& crate::model::AttachmentType> {
        self.attachment_type.as_ref()
    }
    /// <p>The state of the attachment.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::AttachmentState> {
        self.state.as_ref()
    }
    /// <p>The Region where the edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The attachment resource ARN.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>The policy rule number associated with the attachment.</p>
    pub fn attachment_policy_rule_number(&self) -> std::option::Option<i32> {
        self.attachment_policy_rule_number
    }
    /// <p>The name of the segment attachment.</p>
    pub fn segment_name(&self) -> std::option::Option<& str> {
        self.segment_name.as_deref()
    }
    /// <p>The tags associated with the attachment.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The attachment to move from one segment to another.</p>
    pub fn proposed_segment_change(&self) -> std::option::Option<& crate::model::ProposedSegmentChange> {
        self.proposed_segment_change.as_ref()
    }
    /// <p>The timestamp when the attachment was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The timestamp when the attachment was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
/// See [`Attachment`](crate::model::Attachment).
pub mod attachment {
    
    /// A builder for [`Attachment`](crate::model::Attachment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_arn: std::option::Option<std::string::String>,
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) attachment_type: std::option::Option<crate::model::AttachmentType>,
        pub(crate) state: std::option::Option<crate::model::AttachmentState>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) attachment_policy_rule_number: std::option::Option<i32>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) proposed_segment_change: std::option::Option<crate::model::ProposedSegmentChange>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ARN of a core network.</p>
        pub fn core_network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a core network.</p>
        pub fn set_core_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_arn = input; self
        }
        /// <p>The ID of the attachment.</p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment.</p>
        pub fn set_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attachment_id = input; self
        }
        /// <p>The ID of the attachment account owner.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment account owner.</p>
        pub fn set_owner_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_account_id = input; self
        }
        /// <p>The type of attachment.</p>
        pub fn attachment_type(mut self, input: crate::model::AttachmentType) -> Self {
            self.attachment_type = Some(input);
            self
        }
        /// <p>The type of attachment.</p>
        pub fn set_attachment_type(mut self, input: std::option::Option<crate::model::AttachmentType>) -> Self {
            self.attachment_type = input; self
        }
        /// <p>The state of the attachment.</p>
        pub fn state(mut self, input: crate::model::AttachmentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the attachment.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::AttachmentState>) -> Self {
            self.state = input; self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The attachment resource ARN.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The attachment resource ARN.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// <p>The policy rule number associated with the attachment.</p>
        pub fn attachment_policy_rule_number(mut self, input: i32) -> Self {
            self.attachment_policy_rule_number = Some(input);
            self
        }
        /// <p>The policy rule number associated with the attachment.</p>
        pub fn set_attachment_policy_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.attachment_policy_rule_number = input; self
        }
        /// <p>The name of the segment attachment.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The name of the segment attachment.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the attachment.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags associated with the attachment.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// <p>The attachment to move from one segment to another.</p>
        pub fn proposed_segment_change(mut self, input: crate::model::ProposedSegmentChange) -> Self {
            self.proposed_segment_change = Some(input);
            self
        }
        /// <p>The attachment to move from one segment to another.</p>
        pub fn set_proposed_segment_change(mut self, input: std::option::Option<crate::model::ProposedSegmentChange>) -> Self {
            self.proposed_segment_change = input; self
        }
        /// <p>The timestamp when the attachment was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when the attachment was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The timestamp when the attachment was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The timestamp when the attachment was last updated.</p>
        pub fn set_updated_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.updated_at = input; self
        }
        /// Consumes the builder and constructs a [`Attachment`](crate::model::Attachment).
        pub fn build(self) -> crate::model::Attachment {
            crate::model::Attachment {
                core_network_id: self.core_network_id
                ,
                core_network_arn: self.core_network_arn
                ,
                attachment_id: self.attachment_id
                ,
                owner_account_id: self.owner_account_id
                ,
                attachment_type: self.attachment_type
                ,
                state: self.state
                ,
                edge_location: self.edge_location
                ,
                resource_arn: self.resource_arn
                ,
                attachment_policy_rule_number: self.attachment_policy_rule_number
                ,
                segment_name: self.segment_name
                ,
                tags: self.tags
                ,
                proposed_segment_change: self.proposed_segment_change
                ,
                created_at: self.created_at
                ,
                updated_at: self.updated_at
                ,
            }
        }
    }
    
    
}
impl Attachment {
    /// Creates a new builder-style object to manufacture [`Attachment`](crate::model::Attachment).
    pub fn builder() -> crate::model::attachment::Builder {
        crate::model::attachment::Builder::default()
    }
}

/// <p>Describes a proposed segment change. In some cases, the segment change must first be evaluated and accepted. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProposedSegmentChange  {
    /// <p>The list of key-value tags that changed for the segment.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The rule number in the policy document that applies to this change.</p>
    #[doc(hidden)]
    pub attachment_policy_rule_number: std::option::Option<i32>,
    /// <p>The name of the segment to change.</p>
    #[doc(hidden)]
    pub segment_name: std::option::Option<std::string::String>,
}
impl ProposedSegmentChange {
    /// <p>The list of key-value tags that changed for the segment.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The rule number in the policy document that applies to this change.</p>
    pub fn attachment_policy_rule_number(&self) -> std::option::Option<i32> {
        self.attachment_policy_rule_number
    }
    /// <p>The name of the segment to change.</p>
    pub fn segment_name(&self) -> std::option::Option<& str> {
        self.segment_name.as_deref()
    }
}
/// See [`ProposedSegmentChange`](crate::model::ProposedSegmentChange).
pub mod proposed_segment_change {
    
    /// A builder for [`ProposedSegmentChange`](crate::model::ProposedSegmentChange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) attachment_policy_rule_number: std::option::Option<i32>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags that changed for the segment.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The list of key-value tags that changed for the segment.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// <p>The rule number in the policy document that applies to this change.</p>
        pub fn attachment_policy_rule_number(mut self, input: i32) -> Self {
            self.attachment_policy_rule_number = Some(input);
            self
        }
        /// <p>The rule number in the policy document that applies to this change.</p>
        pub fn set_attachment_policy_rule_number(mut self, input: std::option::Option<i32>) -> Self {
            self.attachment_policy_rule_number = input; self
        }
        /// <p>The name of the segment to change.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The name of the segment to change.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input; self
        }
        /// Consumes the builder and constructs a [`ProposedSegmentChange`](crate::model::ProposedSegmentChange).
        pub fn build(self) -> crate::model::ProposedSegmentChange {
            crate::model::ProposedSegmentChange {
                tags: self.tags
                ,
                attachment_policy_rule_number: self.attachment_policy_rule_number
                ,
                segment_name: self.segment_name
                ,
            }
        }
    }
    
    
}
impl ProposedSegmentChange {
    /// Creates a new builder-style object to manufacture [`ProposedSegmentChange`](crate::model::ProposedSegmentChange).
    pub fn builder() -> crate::model::proposed_segment_change::Builder {
        crate::model::proposed_segment_change::Builder::default()
    }
}

/// <p>Describes a tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag  {
    /// <p>The tag key.</p> 
    /// <p>Constraints: Maximum length of 128 characters.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p> 
    /// <p>Constraints: Maximum length of 256 characters.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag key.</p> 
    /// <p>Constraints: Maximum length of 128 characters.</p>
    pub fn key(&self) -> std::option::Option<& str> {
        self.key.as_deref()
    }
    /// <p>The tag value.</p> 
    /// <p>Constraints: Maximum length of 256 characters.</p>
    pub fn value(&self) -> std::option::Option<& str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {
    
    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag key.</p> 
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag key.</p> 
        /// <p>Constraints: Maximum length of 128 characters.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input; self
        }
        /// <p>The tag value.</p> 
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag value.</p> 
        /// <p>Constraints: Maximum length of 256 characters.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input; self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key
                ,
                value: self.value
                ,
            }
        }
    }
    
    
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// When writing a match expression against `AttachmentState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let attachmentstate = unimplemented!();
/// match attachmentstate {
///     AttachmentState::Available => { /* ... */ },
///     AttachmentState::Creating => { /* ... */ },
///     AttachmentState::Deleting => { /* ... */ },
///     AttachmentState::Failed => { /* ... */ },
///     AttachmentState::PendingAttachmentAcceptance => { /* ... */ },
///     AttachmentState::PendingNetworkUpdate => { /* ... */ },
///     AttachmentState::PendingTagAcceptance => { /* ... */ },
///     AttachmentState::Rejected => { /* ... */ },
///     AttachmentState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `attachmentstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AttachmentState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AttachmentState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AttachmentState::NewFeature` is defined.
/// Specifically, when `attachmentstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AttachmentState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum AttachmentState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    PendingAttachmentAcceptance,
    #[allow(missing_docs)] // documentation missing in model
    PendingNetworkUpdate,
    #[allow(missing_docs)] // documentation missing in model
    PendingTagAcceptance,
    #[allow(missing_docs)] // documentation missing in model
    Rejected,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for AttachmentState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => AttachmentState::Available,
            "CREATING" => AttachmentState::Creating,
            "DELETING" => AttachmentState::Deleting,
            "FAILED" => AttachmentState::Failed,
            "PENDING_ATTACHMENT_ACCEPTANCE" => AttachmentState::PendingAttachmentAcceptance,
            "PENDING_NETWORK_UPDATE" => AttachmentState::PendingNetworkUpdate,
            "PENDING_TAG_ACCEPTANCE" => AttachmentState::PendingTagAcceptance,
            "REJECTED" => AttachmentState::Rejected,
            "UPDATING" => AttachmentState::Updating,
            other => AttachmentState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for AttachmentState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(AttachmentState::from(s))
                }
            }
impl AttachmentState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AttachmentState::Available => "AVAILABLE",
            AttachmentState::Creating => "CREATING",
            AttachmentState::Deleting => "DELETING",
            AttachmentState::Failed => "FAILED",
            AttachmentState::PendingAttachmentAcceptance => "PENDING_ATTACHMENT_ACCEPTANCE",
            AttachmentState::PendingNetworkUpdate => "PENDING_NETWORK_UPDATE",
            AttachmentState::PendingTagAcceptance => "PENDING_TAG_ACCEPTANCE",
            AttachmentState::Rejected => "REJECTED",
            AttachmentState::Updating => "UPDATING",
            AttachmentState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "CREATING", "DELETING", "FAILED", "PENDING_ATTACHMENT_ACCEPTANCE", "PENDING_NETWORK_UPDATE", "PENDING_TAG_ACCEPTANCE", "REJECTED", "UPDATING"
        ]
    }
}
impl AsRef<str> for AttachmentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AttachmentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let attachmenttype = unimplemented!();
/// match attachmenttype {
///     AttachmentType::Connect => { /* ... */ },
///     AttachmentType::SiteToSiteVpn => { /* ... */ },
///     AttachmentType::TransitGatewayRouteTable => { /* ... */ },
///     AttachmentType::Vpc => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `attachmenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AttachmentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AttachmentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AttachmentType::NewFeature` is defined.
/// Specifically, when `attachmenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AttachmentType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum AttachmentType {
    #[allow(missing_docs)] // documentation missing in model
    Connect,
    #[allow(missing_docs)] // documentation missing in model
    SiteToSiteVpn,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayRouteTable,
    #[allow(missing_docs)] // documentation missing in model
    Vpc,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for AttachmentType {
    fn from(s: &str) -> Self {
        match s {
            "CONNECT" => AttachmentType::Connect,
            "SITE_TO_SITE_VPN" => AttachmentType::SiteToSiteVpn,
            "TRANSIT_GATEWAY_ROUTE_TABLE" => AttachmentType::TransitGatewayRouteTable,
            "VPC" => AttachmentType::Vpc,
            other => AttachmentType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for AttachmentType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(AttachmentType::from(s))
                }
            }
impl AttachmentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AttachmentType::Connect => "CONNECT",
            AttachmentType::SiteToSiteVpn => "SITE_TO_SITE_VPN",
            AttachmentType::TransitGatewayRouteTable => "TRANSIT_GATEWAY_ROUTE_TABLE",
            AttachmentType::Vpc => "VPC",
            AttachmentType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONNECT", "SITE_TO_SITE_VPN", "TRANSIT_GATEWAY_ROUTE_TABLE", "VPC"
        ]
    }
}
impl AsRef<str> for AttachmentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a site.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Site  {
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    #[doc(hidden)]
    pub site_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The description of the site.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The location of the site.</p>
    #[doc(hidden)]
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The date and time that the site was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the site.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::SiteState>,
    /// <p>The tags for the site.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Site {
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<& str> {
        self.site_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    pub fn site_arn(&self) -> std::option::Option<& str> {
        self.site_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The description of the site.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The location of the site.</p>
    pub fn location(&self) -> std::option::Option<& crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The date and time that the site was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The state of the site.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::SiteState> {
        self.state.as_ref()
    }
    /// <p>The tags for the site.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl  std::fmt::Debug for Site  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Site");
        formatter.field("site_id", &self.site_id);
        formatter.field("site_arn", &self.site_arn);
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("description", &self.description);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("created_at", &self.created_at);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Site`](crate::model::Site).
pub mod site {
    
    /// A builder for [`Site`](crate::model::Site).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) site_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::SiteState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the site.</p>
        pub fn site_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the site.</p>
        pub fn set_site_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_arn = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The description of the site.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the site.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The location of the site.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The location of the site.</p>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input; self
        }
        /// <p>The date and time that the site was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time that the site was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The state of the site.</p>
        pub fn state(mut self, input: crate::model::SiteState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the site.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::SiteState>) -> Self {
            self.state = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the site.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags for the site.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`Site`](crate::model::Site).
        pub fn build(self) -> crate::model::Site {
            crate::model::Site {
                site_id: self.site_id
                ,
                site_arn: self.site_arn
                ,
                global_network_id: self.global_network_id
                ,
                description: self.description
                ,
                location: self.location
                ,
                created_at: self.created_at
                ,
                state: self.state
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("site_id", &self.site_id);
            formatter.field("site_arn", &self.site_arn);
            formatter.field("global_network_id", &self.global_network_id);
            formatter.field("description", &self.description);
            formatter.field("location", &"*** Sensitive Data Redacted ***");
            formatter.field("created_at", &self.created_at);
            formatter.field("state", &self.state);
            formatter.field("tags", &self.tags);
            formatter.finish()
        }
    }
    
    
}
impl Site {
    /// Creates a new builder-style object to manufacture [`Site`](crate::model::Site).
    pub fn builder() -> crate::model::site::Builder {
        crate::model::site::Builder::default()
    }
}

/// When writing a match expression against `SiteState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let sitestate = unimplemented!();
/// match sitestate {
///     SiteState::Available => { /* ... */ },
///     SiteState::Deleting => { /* ... */ },
///     SiteState::Pending => { /* ... */ },
///     SiteState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sitestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SiteState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SiteState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SiteState::NewFeature` is defined.
/// Specifically, when `sitestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SiteState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum SiteState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for SiteState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => SiteState::Available,
            "DELETING" => SiteState::Deleting,
            "PENDING" => SiteState::Pending,
            "UPDATING" => SiteState::Updating,
            other => SiteState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for SiteState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(SiteState::from(s))
                }
            }
impl SiteState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SiteState::Available => "AVAILABLE",
            SiteState::Deleting => "DELETING",
            SiteState::Pending => "PENDING",
            SiteState::Updating => "UPDATING",
            SiteState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETING", "PENDING", "UPDATING"
        ]
    }
}
impl AsRef<str> for SiteState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Location  {
    /// <p>The physical address.</p>
    #[doc(hidden)]
    pub address: std::option::Option<std::string::String>,
    /// <p>The latitude.</p>
    #[doc(hidden)]
    pub latitude: std::option::Option<std::string::String>,
    /// <p>The longitude.</p>
    #[doc(hidden)]
    pub longitude: std::option::Option<std::string::String>,
}
impl Location {
    /// <p>The physical address.</p>
    pub fn address(&self) -> std::option::Option<& str> {
        self.address.as_deref()
    }
    /// <p>The latitude.</p>
    pub fn latitude(&self) -> std::option::Option<& str> {
        self.latitude.as_deref()
    }
    /// <p>The longitude.</p>
    pub fn longitude(&self) -> std::option::Option<& str> {
        self.longitude.as_deref()
    }
}
impl  std::fmt::Debug for Location  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Location");
        formatter.field("address", &"*** Sensitive Data Redacted ***");
        formatter.field("latitude", &"*** Sensitive Data Redacted ***");
        formatter.field("longitude", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Location`](crate::model::Location).
pub mod location {
    
    /// A builder for [`Location`](crate::model::Location).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) latitude: std::option::Option<std::string::String>,
        pub(crate) longitude: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The physical address.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The physical address.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input; self
        }
        /// <p>The latitude.</p>
        pub fn latitude(mut self, input: impl Into<std::string::String>) -> Self {
            self.latitude = Some(input.into());
            self
        }
        /// <p>The latitude.</p>
        pub fn set_latitude(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.latitude = input; self
        }
        /// <p>The longitude.</p>
        pub fn longitude(mut self, input: impl Into<std::string::String>) -> Self {
            self.longitude = Some(input.into());
            self
        }
        /// <p>The longitude.</p>
        pub fn set_longitude(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.longitude = input; self
        }
        /// Consumes the builder and constructs a [`Location`](crate::model::Location).
        pub fn build(self) -> crate::model::Location {
            crate::model::Location {
                address: self.address
                ,
                latitude: self.latitude
                ,
                longitude: self.longitude
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("address", &"*** Sensitive Data Redacted ***");
            formatter.field("latitude", &"*** Sensitive Data Redacted ***");
            formatter.field("longitude", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
    
    
}
impl Location {
    /// Creates a new builder-style object to manufacture [`Location`](crate::model::Location).
    pub fn builder() -> crate::model::location::Builder {
        crate::model::location::Builder::default()
    }
}

/// <p>Describes a link.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Link  {
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the link.</p>
    #[doc(hidden)]
    pub link_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the site.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The description of the link.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the link.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The bandwidth for the link.</p>
    #[doc(hidden)]
    pub bandwidth: std::option::Option<crate::model::Bandwidth>,
    /// <p>The provider of the link.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<std::string::String>,
    /// <p>The date and time that the link was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the link.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::LinkState>,
    /// <p>The tags for the link.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Link {
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<& str> {
        self.link_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the link.</p>
    pub fn link_arn(&self) -> std::option::Option<& str> {
        self.link_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the site.</p>
    pub fn site_id(&self) -> std::option::Option<& str> {
        self.site_id.as_deref()
    }
    /// <p>The description of the link.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The type of the link.</p>
    pub fn r#type(&self) -> std::option::Option<& str> {
        self.r#type.as_deref()
    }
    /// <p>The bandwidth for the link.</p>
    pub fn bandwidth(&self) -> std::option::Option<& crate::model::Bandwidth> {
        self.bandwidth.as_ref()
    }
    /// <p>The provider of the link.</p>
    pub fn provider(&self) -> std::option::Option<& str> {
        self.provider.as_deref()
    }
    /// <p>The date and time that the link was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The state of the link.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::LinkState> {
        self.state.as_ref()
    }
    /// <p>The tags for the link.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`Link`](crate::model::Link).
pub mod link {
    
    /// A builder for [`Link`](crate::model::Link).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) link_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) bandwidth: std::option::Option<crate::model::Bandwidth>,
        pub(crate) provider: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::LinkState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the link.</p>
        pub fn link_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the link.</p>
        pub fn set_link_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_arn = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the site.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The ID of the site.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input; self
        }
        /// <p>The description of the link.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the link.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The type of the link.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of the link.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input; self
        }
        /// <p>The bandwidth for the link.</p>
        pub fn bandwidth(mut self, input: crate::model::Bandwidth) -> Self {
            self.bandwidth = Some(input);
            self
        }
        /// <p>The bandwidth for the link.</p>
        pub fn set_bandwidth(mut self, input: std::option::Option<crate::model::Bandwidth>) -> Self {
            self.bandwidth = input; self
        }
        /// <p>The provider of the link.</p>
        pub fn provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.provider = Some(input.into());
            self
        }
        /// <p>The provider of the link.</p>
        pub fn set_provider(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.provider = input; self
        }
        /// <p>The date and time that the link was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time that the link was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The state of the link.</p>
        pub fn state(mut self, input: crate::model::LinkState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the link.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::LinkState>) -> Self {
            self.state = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the link.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags for the link.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`Link`](crate::model::Link).
        pub fn build(self) -> crate::model::Link {
            crate::model::Link {
                link_id: self.link_id
                ,
                link_arn: self.link_arn
                ,
                global_network_id: self.global_network_id
                ,
                site_id: self.site_id
                ,
                description: self.description
                ,
                r#type: self.r#type
                ,
                bandwidth: self.bandwidth
                ,
                provider: self.provider
                ,
                created_at: self.created_at
                ,
                state: self.state
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl Link {
    /// Creates a new builder-style object to manufacture [`Link`](crate::model::Link).
    pub fn builder() -> crate::model::link::Builder {
        crate::model::link::Builder::default()
    }
}

/// When writing a match expression against `LinkState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let linkstate = unimplemented!();
/// match linkstate {
///     LinkState::Available => { /* ... */ },
///     LinkState::Deleting => { /* ... */ },
///     LinkState::Pending => { /* ... */ },
///     LinkState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `linkstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LinkState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LinkState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LinkState::NewFeature` is defined.
/// Specifically, when `linkstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LinkState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LinkState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LinkState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => LinkState::Available,
            "DELETING" => LinkState::Deleting,
            "PENDING" => LinkState::Pending,
            "UPDATING" => LinkState::Updating,
            other => LinkState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LinkState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LinkState::from(s))
                }
            }
impl LinkState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LinkState::Available => "AVAILABLE",
            LinkState::Deleting => "DELETING",
            LinkState::Pending => "PENDING",
            LinkState::Updating => "UPDATING",
            LinkState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETING", "PENDING", "UPDATING"
        ]
    }
}
impl AsRef<str> for LinkState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes bandwidth information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Bandwidth  {
    /// <p>Upload speed in Mbps.</p>
    #[doc(hidden)]
    pub upload_speed: std::option::Option<i32>,
    /// <p>Download speed in Mbps.</p>
    #[doc(hidden)]
    pub download_speed: std::option::Option<i32>,
}
impl Bandwidth {
    /// <p>Upload speed in Mbps.</p>
    pub fn upload_speed(&self) -> std::option::Option<i32> {
        self.upload_speed
    }
    /// <p>Download speed in Mbps.</p>
    pub fn download_speed(&self) -> std::option::Option<i32> {
        self.download_speed
    }
}
/// See [`Bandwidth`](crate::model::Bandwidth).
pub mod bandwidth {
    
    /// A builder for [`Bandwidth`](crate::model::Bandwidth).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) upload_speed: std::option::Option<i32>,
        pub(crate) download_speed: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Upload speed in Mbps.</p>
        pub fn upload_speed(mut self, input: i32) -> Self {
            self.upload_speed = Some(input);
            self
        }
        /// <p>Upload speed in Mbps.</p>
        pub fn set_upload_speed(mut self, input: std::option::Option<i32>) -> Self {
            self.upload_speed = input; self
        }
        /// <p>Download speed in Mbps.</p>
        pub fn download_speed(mut self, input: i32) -> Self {
            self.download_speed = Some(input);
            self
        }
        /// <p>Download speed in Mbps.</p>
        pub fn set_download_speed(mut self, input: std::option::Option<i32>) -> Self {
            self.download_speed = input; self
        }
        /// Consumes the builder and constructs a [`Bandwidth`](crate::model::Bandwidth).
        pub fn build(self) -> crate::model::Bandwidth {
            crate::model::Bandwidth {
                upload_speed: self.upload_speed
                ,
                download_speed: self.download_speed
                ,
            }
        }
    }
    
    
}
impl Bandwidth {
    /// Creates a new builder-style object to manufacture [`Bandwidth`](crate::model::Bandwidth).
    pub fn builder() -> crate::model::bandwidth::Builder {
        crate::model::bandwidth::Builder::default()
    }
}

/// <p>Describes a global network. This is a single private network acting as a high-level container for your network objects, including an Amazon Web Services-managed Core Network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlobalNetwork  {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the global network.</p>
    #[doc(hidden)]
    pub global_network_arn: std::option::Option<std::string::String>,
    /// <p>The description of the global network.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time that the global network was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the global network.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::GlobalNetworkState>,
    /// <p>The tags for the global network.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl GlobalNetwork {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the global network.</p>
    pub fn global_network_arn(&self) -> std::option::Option<& str> {
        self.global_network_arn.as_deref()
    }
    /// <p>The description of the global network.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The date and time that the global network was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The state of the global network.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::GlobalNetworkState> {
        self.state.as_ref()
    }
    /// <p>The tags for the global network.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`GlobalNetwork`](crate::model::GlobalNetwork).
pub mod global_network {
    
    /// A builder for [`GlobalNetwork`](crate::model::GlobalNetwork).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) global_network_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::GlobalNetworkState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the global network.</p>
        pub fn global_network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the global network.</p>
        pub fn set_global_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_arn = input; self
        }
        /// <p>The description of the global network.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the global network.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The date and time that the global network was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time that the global network was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The state of the global network.</p>
        pub fn state(mut self, input: crate::model::GlobalNetworkState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the global network.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::GlobalNetworkState>) -> Self {
            self.state = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the global network.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags for the global network.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`GlobalNetwork`](crate::model::GlobalNetwork).
        pub fn build(self) -> crate::model::GlobalNetwork {
            crate::model::GlobalNetwork {
                global_network_id: self.global_network_id
                ,
                global_network_arn: self.global_network_arn
                ,
                description: self.description
                ,
                created_at: self.created_at
                ,
                state: self.state
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl GlobalNetwork {
    /// Creates a new builder-style object to manufacture [`GlobalNetwork`](crate::model::GlobalNetwork).
    pub fn builder() -> crate::model::global_network::Builder {
        crate::model::global_network::Builder::default()
    }
}

/// When writing a match expression against `GlobalNetworkState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let globalnetworkstate = unimplemented!();
/// match globalnetworkstate {
///     GlobalNetworkState::Available => { /* ... */ },
///     GlobalNetworkState::Deleting => { /* ... */ },
///     GlobalNetworkState::Pending => { /* ... */ },
///     GlobalNetworkState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `globalnetworkstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `GlobalNetworkState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `GlobalNetworkState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `GlobalNetworkState::NewFeature` is defined.
/// Specifically, when `globalnetworkstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `GlobalNetworkState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum GlobalNetworkState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for GlobalNetworkState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => GlobalNetworkState::Available,
            "DELETING" => GlobalNetworkState::Deleting,
            "PENDING" => GlobalNetworkState::Pending,
            "UPDATING" => GlobalNetworkState::Updating,
            other => GlobalNetworkState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for GlobalNetworkState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(GlobalNetworkState::from(s))
                }
            }
impl GlobalNetworkState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            GlobalNetworkState::Available => "AVAILABLE",
            GlobalNetworkState::Deleting => "DELETING",
            GlobalNetworkState::Pending => "PENDING",
            GlobalNetworkState::Updating => "UPDATING",
            GlobalNetworkState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETING", "PENDING", "UPDATING"
        ]
    }
}
impl AsRef<str> for GlobalNetworkState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Device  {
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the device.</p>
    #[doc(hidden)]
    pub device_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services location of the device.</p>
    #[doc(hidden)]
    pub aws_location: std::option::Option<crate::model::AwsLocation>,
    /// <p>The description of the device.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The device type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The device vendor.</p>
    #[doc(hidden)]
    pub vendor: std::option::Option<std::string::String>,
    /// <p>The device model.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The device serial number.</p>
    #[doc(hidden)]
    pub serial_number: std::option::Option<std::string::String>,
    /// <p>The site location.</p>
    #[doc(hidden)]
    pub location: std::option::Option<crate::model::Location>,
    /// <p>The site ID.</p>
    #[doc(hidden)]
    pub site_id: std::option::Option<std::string::String>,
    /// <p>The date and time that the site was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The device state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::DeviceState>,
    /// <p>The tags for the device.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Device {
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<& str> {
        self.device_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the device.</p>
    pub fn device_arn(&self) -> std::option::Option<& str> {
        self.device_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Web Services location of the device.</p>
    pub fn aws_location(&self) -> std::option::Option<& crate::model::AwsLocation> {
        self.aws_location.as_ref()
    }
    /// <p>The description of the device.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The device type.</p>
    pub fn r#type(&self) -> std::option::Option<& str> {
        self.r#type.as_deref()
    }
    /// <p>The device vendor.</p>
    pub fn vendor(&self) -> std::option::Option<& str> {
        self.vendor.as_deref()
    }
    /// <p>The device model.</p>
    pub fn model(&self) -> std::option::Option<& str> {
        self.model.as_deref()
    }
    /// <p>The device serial number.</p>
    pub fn serial_number(&self) -> std::option::Option<& str> {
        self.serial_number.as_deref()
    }
    /// <p>The site location.</p>
    pub fn location(&self) -> std::option::Option<& crate::model::Location> {
        self.location.as_ref()
    }
    /// <p>The site ID.</p>
    pub fn site_id(&self) -> std::option::Option<& str> {
        self.site_id.as_deref()
    }
    /// <p>The date and time that the site was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The device state.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::DeviceState> {
        self.state.as_ref()
    }
    /// <p>The tags for the device.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl  std::fmt::Debug for Device  {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Device");
        formatter.field("device_id", &self.device_id);
        formatter.field("device_arn", &self.device_arn);
        formatter.field("global_network_id", &self.global_network_id);
        formatter.field("aws_location", &self.aws_location);
        formatter.field("description", &self.description);
        formatter.field("r#type", &self.r#type);
        formatter.field("vendor", &self.vendor);
        formatter.field("model", &self.model);
        formatter.field("serial_number", &self.serial_number);
        formatter.field("location", &"*** Sensitive Data Redacted ***");
        formatter.field("site_id", &self.site_id);
        formatter.field("created_at", &self.created_at);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`Device`](crate::model::Device).
pub mod device {
    
    /// A builder for [`Device`](crate::model::Device).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) device_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) aws_location: std::option::Option<crate::model::AwsLocation>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) vendor: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) serial_number: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::Location>,
        pub(crate) site_id: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::DeviceState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the device.</p>
        pub fn device_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the device.</p>
        pub fn set_device_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_arn = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The Amazon Web Services location of the device.</p>
        pub fn aws_location(mut self, input: crate::model::AwsLocation) -> Self {
            self.aws_location = Some(input);
            self
        }
        /// <p>The Amazon Web Services location of the device.</p>
        pub fn set_aws_location(mut self, input: std::option::Option<crate::model::AwsLocation>) -> Self {
            self.aws_location = input; self
        }
        /// <p>The description of the device.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the device.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The device type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The device type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input; self
        }
        /// <p>The device vendor.</p>
        pub fn vendor(mut self, input: impl Into<std::string::String>) -> Self {
            self.vendor = Some(input.into());
            self
        }
        /// <p>The device vendor.</p>
        pub fn set_vendor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vendor = input; self
        }
        /// <p>The device model.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The device model.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input; self
        }
        /// <p>The device serial number.</p>
        pub fn serial_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.serial_number = Some(input.into());
            self
        }
        /// <p>The device serial number.</p>
        pub fn set_serial_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.serial_number = input; self
        }
        /// <p>The site location.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The site location.</p>
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.location = input; self
        }
        /// <p>The site ID.</p>
        pub fn site_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.site_id = Some(input.into());
            self
        }
        /// <p>The site ID.</p>
        pub fn set_site_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.site_id = input; self
        }
        /// <p>The date and time that the site was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time that the site was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The device state.</p>
        pub fn state(mut self, input: crate::model::DeviceState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The device state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::DeviceState>) -> Self {
            self.state = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the device.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags for the device.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`Device`](crate::model::Device).
        pub fn build(self) -> crate::model::Device {
            crate::model::Device {
                device_id: self.device_id
                ,
                device_arn: self.device_arn
                ,
                global_network_id: self.global_network_id
                ,
                aws_location: self.aws_location
                ,
                description: self.description
                ,
                r#type: self.r#type
                ,
                vendor: self.vendor
                ,
                model: self.model
                ,
                serial_number: self.serial_number
                ,
                location: self.location
                ,
                site_id: self.site_id
                ,
                created_at: self.created_at
                ,
                state: self.state
                ,
                tags: self.tags
                ,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("device_id", &self.device_id);
            formatter.field("device_arn", &self.device_arn);
            formatter.field("global_network_id", &self.global_network_id);
            formatter.field("aws_location", &self.aws_location);
            formatter.field("description", &self.description);
            formatter.field("r#type", &self.r#type);
            formatter.field("vendor", &self.vendor);
            formatter.field("model", &self.model);
            formatter.field("serial_number", &self.serial_number);
            formatter.field("location", &"*** Sensitive Data Redacted ***");
            formatter.field("site_id", &self.site_id);
            formatter.field("created_at", &self.created_at);
            formatter.field("state", &self.state);
            formatter.field("tags", &self.tags);
            formatter.finish()
        }
    }
    
    
}
impl Device {
    /// Creates a new builder-style object to manufacture [`Device`](crate::model::Device).
    pub fn builder() -> crate::model::device::Builder {
        crate::model::device::Builder::default()
    }
}

/// When writing a match expression against `DeviceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let devicestate = unimplemented!();
/// match devicestate {
///     DeviceState::Available => { /* ... */ },
///     DeviceState::Deleting => { /* ... */ },
///     DeviceState::Pending => { /* ... */ },
///     DeviceState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `devicestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeviceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeviceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeviceState::NewFeature` is defined.
/// Specifically, when `devicestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeviceState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum DeviceState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for DeviceState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => DeviceState::Available,
            "DELETING" => DeviceState::Deleting,
            "PENDING" => DeviceState::Pending,
            "UPDATING" => DeviceState::Updating,
            other => DeviceState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for DeviceState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(DeviceState::from(s))
                }
            }
impl DeviceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeviceState::Available => "AVAILABLE",
            DeviceState::Deleting => "DELETING",
            DeviceState::Pending => "PENDING",
            DeviceState::Updating => "UPDATING",
            DeviceState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETING", "PENDING", "UPDATING"
        ]
    }
}
impl AsRef<str> for DeviceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies a location in Amazon Web Services.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsLocation  {
    /// <p>The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.</p>
    #[doc(hidden)]
    pub zone: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the subnet that the device is located in.</p>
    #[doc(hidden)]
    pub subnet_arn: std::option::Option<std::string::String>,
}
impl AwsLocation {
    /// <p>The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.</p>
    pub fn zone(&self) -> std::option::Option<& str> {
        self.zone.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the subnet that the device is located in.</p>
    pub fn subnet_arn(&self) -> std::option::Option<& str> {
        self.subnet_arn.as_deref()
    }
}
/// See [`AwsLocation`](crate::model::AwsLocation).
pub mod aws_location {
    
    /// A builder for [`AwsLocation`](crate::model::AwsLocation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) zone: std::option::Option<std::string::String>,
        pub(crate) subnet_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.</p>
        pub fn zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.zone = Some(input.into());
            self
        }
        /// <p>The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.</p>
        pub fn set_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zone = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the subnet that the device is located in.</p>
        pub fn subnet_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the subnet that the device is located in.</p>
        pub fn set_subnet_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_arn = input; self
        }
        /// Consumes the builder and constructs a [`AwsLocation`](crate::model::AwsLocation).
        pub fn build(self) -> crate::model::AwsLocation {
            crate::model::AwsLocation {
                zone: self.zone
                ,
                subnet_arn: self.subnet_arn
                ,
            }
        }
    }
    
    
}
impl AwsLocation {
    /// Creates a new builder-style object to manufacture [`AwsLocation`](crate::model::AwsLocation).
    pub fn builder() -> crate::model::aws_location::Builder {
        crate::model::aws_location::Builder::default()
    }
}

/// <p>Describes a core network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetwork  {
    /// <p>The ID of the global network that your core network is a part of. </p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a core network.</p>
    #[doc(hidden)]
    pub core_network_arn: std::option::Option<std::string::String>,
    /// <p>The description of a core network.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp when a core network was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The current state of a core network.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CoreNetworkState>,
    /// <p>The segments within a core network.</p>
    #[doc(hidden)]
    pub segments: std::option::Option<std::vec::Vec<crate::model::CoreNetworkSegment>>,
    /// <p>The edges within a core network.</p>
    #[doc(hidden)]
    pub edges: std::option::Option<std::vec::Vec<crate::model::CoreNetworkEdge>>,
    /// <p>The list of key-value tags associated with a core network.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CoreNetwork {
    /// <p>The ID of the global network that your core network is a part of. </p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of a core network.</p>
    pub fn core_network_arn(&self) -> std::option::Option<& str> {
        self.core_network_arn.as_deref()
    }
    /// <p>The description of a core network.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The timestamp when a core network was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The current state of a core network.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::CoreNetworkState> {
        self.state.as_ref()
    }
    /// <p>The segments within a core network.</p>
    pub fn segments(&self) -> std::option::Option<& [crate::model::CoreNetworkSegment]> {
        self.segments.as_deref()
    }
    /// <p>The edges within a core network.</p>
    pub fn edges(&self) -> std::option::Option<& [crate::model::CoreNetworkEdge]> {
        self.edges.as_deref()
    }
    /// <p>The list of key-value tags associated with a core network.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`CoreNetwork`](crate::model::CoreNetwork).
pub mod core_network {
    
    /// A builder for [`CoreNetwork`](crate::model::CoreNetwork).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::CoreNetworkState>,
        pub(crate) segments: std::option::Option<std::vec::Vec<crate::model::CoreNetworkSegment>>,
        pub(crate) edges: std::option::Option<std::vec::Vec<crate::model::CoreNetworkEdge>>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the global network that your core network is a part of. </p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network that your core network is a part of. </p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ARN of a core network.</p>
        pub fn core_network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a core network.</p>
        pub fn set_core_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_arn = input; self
        }
        /// <p>The description of a core network.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a core network.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The timestamp when a core network was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when a core network was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The current state of a core network.</p>
        pub fn state(mut self, input: crate::model::CoreNetworkState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of a core network.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::CoreNetworkState>) -> Self {
            self.state = input; self
        }
        /// Appends an item to `segments`.
        ///
        /// To override the contents of this collection use [`set_segments`](Self::set_segments).
        ///
        /// <p>The segments within a core network.</p>
        pub fn segments(mut self, input: crate::model::CoreNetworkSegment) -> Self {
            let mut v = self.segments.unwrap_or_default();
                            v.push(input);
                            self.segments = Some(v);
                            self
        }
        /// <p>The segments within a core network.</p>
        pub fn set_segments(mut self, input: std::option::Option<std::vec::Vec<crate::model::CoreNetworkSegment>>) -> Self {
            self.segments = input; self
        }
        /// Appends an item to `edges`.
        ///
        /// To override the contents of this collection use [`set_edges`](Self::set_edges).
        ///
        /// <p>The edges within a core network.</p>
        pub fn edges(mut self, input: crate::model::CoreNetworkEdge) -> Self {
            let mut v = self.edges.unwrap_or_default();
                            v.push(input);
                            self.edges = Some(v);
                            self
        }
        /// <p>The edges within a core network.</p>
        pub fn set_edges(mut self, input: std::option::Option<std::vec::Vec<crate::model::CoreNetworkEdge>>) -> Self {
            self.edges = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with a core network.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The list of key-value tags associated with a core network.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetwork`](crate::model::CoreNetwork).
        pub fn build(self) -> crate::model::CoreNetwork {
            crate::model::CoreNetwork {
                global_network_id: self.global_network_id
                ,
                core_network_id: self.core_network_id
                ,
                core_network_arn: self.core_network_arn
                ,
                description: self.description
                ,
                created_at: self.created_at
                ,
                state: self.state
                ,
                segments: self.segments
                ,
                edges: self.edges
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl CoreNetwork {
    /// Creates a new builder-style object to manufacture [`CoreNetwork`](crate::model::CoreNetwork).
    pub fn builder() -> crate::model::core_network::Builder {
        crate::model::core_network::Builder::default()
    }
}

/// <p>Describes a core network edge.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkEdge  {
    /// <p>The Region where a core network edge is located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The ASN of a core network edge.</p>
    #[doc(hidden)]
    pub asn: std::option::Option<i64>,
    /// <p>The inside IP addresses used for core network edges.</p>
    #[doc(hidden)]
    pub inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CoreNetworkEdge {
    /// <p>The Region where a core network edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The ASN of a core network edge.</p>
    pub fn asn(&self) -> std::option::Option<i64> {
        self.asn
    }
    /// <p>The inside IP addresses used for core network edges.</p>
    pub fn inside_cidr_blocks(&self) -> std::option::Option<& [std::string::String]> {
        self.inside_cidr_blocks.as_deref()
    }
}
/// See [`CoreNetworkEdge`](crate::model::CoreNetworkEdge).
pub mod core_network_edge {
    
    /// A builder for [`CoreNetworkEdge`](crate::model::CoreNetworkEdge).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) asn: std::option::Option<i64>,
        pub(crate) inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Region where a core network edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where a core network edge is located.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The ASN of a core network edge.</p>
        pub fn asn(mut self, input: i64) -> Self {
            self.asn = Some(input);
            self
        }
        /// <p>The ASN of a core network edge.</p>
        pub fn set_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.asn = input; self
        }
        /// Appends an item to `inside_cidr_blocks`.
        ///
        /// To override the contents of this collection use [`set_inside_cidr_blocks`](Self::set_inside_cidr_blocks).
        ///
        /// <p>The inside IP addresses used for core network edges.</p>
        pub fn inside_cidr_blocks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inside_cidr_blocks.unwrap_or_default();
                            v.push(input.into());
                            self.inside_cidr_blocks = Some(v);
                            self
        }
        /// <p>The inside IP addresses used for core network edges.</p>
        pub fn set_inside_cidr_blocks(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.inside_cidr_blocks = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkEdge`](crate::model::CoreNetworkEdge).
        pub fn build(self) -> crate::model::CoreNetworkEdge {
            crate::model::CoreNetworkEdge {
                edge_location: self.edge_location
                ,
                asn: self.asn
                ,
                inside_cidr_blocks: self.inside_cidr_blocks
                ,
            }
        }
    }
    
    
}
impl CoreNetworkEdge {
    /// Creates a new builder-style object to manufacture [`CoreNetworkEdge`](crate::model::CoreNetworkEdge).
    pub fn builder() -> crate::model::core_network_edge::Builder {
        crate::model::core_network_edge::Builder::default()
    }
}

/// <p>Describes a core network segment, which are dedicated routes. Only attachments within this segment can communicate with each other.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkSegment  {
    /// <p>The name of a core network segment.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Regions where the edges are located.</p>
    #[doc(hidden)]
    pub edge_locations: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The shared segments of a core network.</p>
    #[doc(hidden)]
    pub shared_segments: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CoreNetworkSegment {
    /// <p>The name of a core network segment.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The Regions where the edges are located.</p>
    pub fn edge_locations(&self) -> std::option::Option<& [std::string::String]> {
        self.edge_locations.as_deref()
    }
    /// <p>The shared segments of a core network.</p>
    pub fn shared_segments(&self) -> std::option::Option<& [std::string::String]> {
        self.shared_segments.as_deref()
    }
}
/// See [`CoreNetworkSegment`](crate::model::CoreNetworkSegment).
pub mod core_network_segment {
    
    /// A builder for [`CoreNetworkSegment`](crate::model::CoreNetworkSegment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) edge_locations: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) shared_segments: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of a core network segment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a core network segment.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Appends an item to `edge_locations`.
        ///
        /// To override the contents of this collection use [`set_edge_locations`](Self::set_edge_locations).
        ///
        /// <p>The Regions where the edges are located.</p>
        pub fn edge_locations(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.edge_locations.unwrap_or_default();
                            v.push(input.into());
                            self.edge_locations = Some(v);
                            self
        }
        /// <p>The Regions where the edges are located.</p>
        pub fn set_edge_locations(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.edge_locations = input; self
        }
        /// Appends an item to `shared_segments`.
        ///
        /// To override the contents of this collection use [`set_shared_segments`](Self::set_shared_segments).
        ///
        /// <p>The shared segments of a core network.</p>
        pub fn shared_segments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.shared_segments.unwrap_or_default();
                            v.push(input.into());
                            self.shared_segments = Some(v);
                            self
        }
        /// <p>The shared segments of a core network.</p>
        pub fn set_shared_segments(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.shared_segments = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkSegment`](crate::model::CoreNetworkSegment).
        pub fn build(self) -> crate::model::CoreNetworkSegment {
            crate::model::CoreNetworkSegment {
                name: self.name
                ,
                edge_locations: self.edge_locations
                ,
                shared_segments: self.shared_segments
                ,
            }
        }
    }
    
    
}
impl CoreNetworkSegment {
    /// Creates a new builder-style object to manufacture [`CoreNetworkSegment`](crate::model::CoreNetworkSegment).
    pub fn builder() -> crate::model::core_network_segment::Builder {
        crate::model::core_network_segment::Builder::default()
    }
}

/// When writing a match expression against `CoreNetworkState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let corenetworkstate = unimplemented!();
/// match corenetworkstate {
///     CoreNetworkState::Available => { /* ... */ },
///     CoreNetworkState::Creating => { /* ... */ },
///     CoreNetworkState::Deleting => { /* ... */ },
///     CoreNetworkState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `corenetworkstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CoreNetworkState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CoreNetworkState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CoreNetworkState::NewFeature` is defined.
/// Specifically, when `corenetworkstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CoreNetworkState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum CoreNetworkState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for CoreNetworkState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => CoreNetworkState::Available,
            "CREATING" => CoreNetworkState::Creating,
            "DELETING" => CoreNetworkState::Deleting,
            "UPDATING" => CoreNetworkState::Updating,
            other => CoreNetworkState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for CoreNetworkState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(CoreNetworkState::from(s))
                }
            }
impl CoreNetworkState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CoreNetworkState::Available => "AVAILABLE",
            CoreNetworkState::Creating => "CREATING",
            CoreNetworkState::Deleting => "DELETING",
            CoreNetworkState::Updating => "UPDATING",
            CoreNetworkState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "CREATING", "DELETING", "UPDATING"
        ]
    }
}
impl AsRef<str> for CoreNetworkState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Connection  {
    /// <p>The ID of the connection.</p>
    #[doc(hidden)]
    pub connection_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the connection.</p>
    #[doc(hidden)]
    pub connection_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the first device in the connection.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the second device in the connection.</p>
    #[doc(hidden)]
    pub connected_device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the first device in the connection.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link for the second device in the connection.</p>
    #[doc(hidden)]
    pub connected_link_id: std::option::Option<std::string::String>,
    /// <p>The description of the connection.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date and time that the connection was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the connection.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ConnectionState>,
    /// <p>The tags for the connection.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl Connection {
    /// <p>The ID of the connection.</p>
    pub fn connection_id(&self) -> std::option::Option<& str> {
        self.connection_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the connection.</p>
    pub fn connection_arn(&self) -> std::option::Option<& str> {
        self.connection_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the first device in the connection.</p>
    pub fn device_id(&self) -> std::option::Option<& str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the second device in the connection.</p>
    pub fn connected_device_id(&self) -> std::option::Option<& str> {
        self.connected_device_id.as_deref()
    }
    /// <p>The ID of the link for the first device in the connection.</p>
    pub fn link_id(&self) -> std::option::Option<& str> {
        self.link_id.as_deref()
    }
    /// <p>The ID of the link for the second device in the connection.</p>
    pub fn connected_link_id(&self) -> std::option::Option<& str> {
        self.connected_link_id.as_deref()
    }
    /// <p>The description of the connection.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The date and time that the connection was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The state of the connection.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::ConnectionState> {
        self.state.as_ref()
    }
    /// <p>The tags for the connection.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`Connection`](crate::model::Connection).
pub mod connection {
    
    /// A builder for [`Connection`](crate::model::Connection).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_id: std::option::Option<std::string::String>,
        pub(crate) connection_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) connected_device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) connected_link_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::ConnectionState>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of the connection.</p>
        pub fn connection_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_id = Some(input.into());
            self
        }
        /// <p>The ID of the connection.</p>
        pub fn set_connection_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connection_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the connection.</p>
        pub fn connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the connection.</p>
        pub fn set_connection_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connection_arn = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the first device in the connection.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the first device in the connection.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input; self
        }
        /// <p>The ID of the second device in the connection.</p>
        pub fn connected_device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_device_id = Some(input.into());
            self
        }
        /// <p>The ID of the second device in the connection.</p>
        pub fn set_connected_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connected_device_id = input; self
        }
        /// <p>The ID of the link for the first device in the connection.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the first device in the connection.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input; self
        }
        /// <p>The ID of the link for the second device in the connection.</p>
        pub fn connected_link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connected_link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link for the second device in the connection.</p>
        pub fn set_connected_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connected_link_id = input; self
        }
        /// <p>The description of the connection.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the connection.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The date and time that the connection was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time that the connection was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The state of the connection.</p>
        pub fn state(mut self, input: crate::model::ConnectionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the connection.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::ConnectionState>) -> Self {
            self.state = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the connection.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags for the connection.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`Connection`](crate::model::Connection).
        pub fn build(self) -> crate::model::Connection {
            crate::model::Connection {
                connection_id: self.connection_id
                ,
                connection_arn: self.connection_arn
                ,
                global_network_id: self.global_network_id
                ,
                device_id: self.device_id
                ,
                connected_device_id: self.connected_device_id
                ,
                link_id: self.link_id
                ,
                connected_link_id: self.connected_link_id
                ,
                description: self.description
                ,
                created_at: self.created_at
                ,
                state: self.state
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl Connection {
    /// Creates a new builder-style object to manufacture [`Connection`](crate::model::Connection).
    pub fn builder() -> crate::model::connection::Builder {
        crate::model::connection::Builder::default()
    }
}

/// When writing a match expression against `ConnectionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let connectionstate = unimplemented!();
/// match connectionstate {
///     ConnectionState::Available => { /* ... */ },
///     ConnectionState::Deleting => { /* ... */ },
///     ConnectionState::Pending => { /* ... */ },
///     ConnectionState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionState::NewFeature` is defined.
/// Specifically, when `connectionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ConnectionState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ConnectionState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => ConnectionState::Available,
            "DELETING" => ConnectionState::Deleting,
            "PENDING" => ConnectionState::Pending,
            "UPDATING" => ConnectionState::Updating,
            other => ConnectionState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ConnectionState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ConnectionState::from(s))
                }
            }
impl ConnectionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionState::Available => "AVAILABLE",
            ConnectionState::Deleting => "DELETING",
            ConnectionState::Pending => "PENDING",
            ConnectionState::Updating => "UPDATING",
            ConnectionState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETING", "PENDING", "UPDATING"
        ]
    }
}
impl AsRef<str> for ConnectionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a route analysis.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RouteAnalysis  {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the AWS account that created the route analysis.</p>
    #[doc(hidden)]
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>The ID of the route analysis.</p>
    #[doc(hidden)]
    pub route_analysis_id: std::option::Option<std::string::String>,
    /// <p>The time that the analysis started.</p>
    #[doc(hidden)]
    pub start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the route analysis.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::RouteAnalysisStatus>,
    /// <p>The source.</p>
    #[doc(hidden)]
    pub source: std::option::Option<crate::model::RouteAnalysisEndpointOptions>,
    /// <p>The destination.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::RouteAnalysisEndpointOptions>,
    /// <p>Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.</p>
    #[doc(hidden)]
    pub include_return_path: bool,
    /// <p>Indicates whether to include the location of middlebox appliances in the route analysis.</p>
    #[doc(hidden)]
    pub use_middleboxes: bool,
    /// <p>The forward path.</p>
    #[doc(hidden)]
    pub forward_path: std::option::Option<crate::model::RouteAnalysisPath>,
    /// <p>The return path.</p>
    #[doc(hidden)]
    pub return_path: std::option::Option<crate::model::RouteAnalysisPath>,
}
impl RouteAnalysis {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the AWS account that created the route analysis.</p>
    pub fn owner_account_id(&self) -> std::option::Option<& str> {
        self.owner_account_id.as_deref()
    }
    /// <p>The ID of the route analysis.</p>
    pub fn route_analysis_id(&self) -> std::option::Option<& str> {
        self.route_analysis_id.as_deref()
    }
    /// <p>The time that the analysis started.</p>
    pub fn start_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.start_timestamp.as_ref()
    }
    /// <p>The status of the route analysis.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::RouteAnalysisStatus> {
        self.status.as_ref()
    }
    /// <p>The source.</p>
    pub fn source(&self) -> std::option::Option<& crate::model::RouteAnalysisEndpointOptions> {
        self.source.as_ref()
    }
    /// <p>The destination.</p>
    pub fn destination(&self) -> std::option::Option<& crate::model::RouteAnalysisEndpointOptions> {
        self.destination.as_ref()
    }
    /// <p>Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.</p>
    pub fn include_return_path(&self) -> bool {
        self.include_return_path
    }
    /// <p>Indicates whether to include the location of middlebox appliances in the route analysis.</p>
    pub fn use_middleboxes(&self) -> bool {
        self.use_middleboxes
    }
    /// <p>The forward path.</p>
    pub fn forward_path(&self) -> std::option::Option<& crate::model::RouteAnalysisPath> {
        self.forward_path.as_ref()
    }
    /// <p>The return path.</p>
    pub fn return_path(&self) -> std::option::Option<& crate::model::RouteAnalysisPath> {
        self.return_path.as_ref()
    }
}
/// See [`RouteAnalysis`](crate::model::RouteAnalysis).
pub mod route_analysis {
    
    /// A builder for [`RouteAnalysis`](crate::model::RouteAnalysis).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) route_analysis_id: std::option::Option<std::string::String>,
        pub(crate) start_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::RouteAnalysisStatus>,
        pub(crate) source: std::option::Option<crate::model::RouteAnalysisEndpointOptions>,
        pub(crate) destination: std::option::Option<crate::model::RouteAnalysisEndpointOptions>,
        pub(crate) include_return_path: std::option::Option<bool>,
        pub(crate) use_middleboxes: std::option::Option<bool>,
        pub(crate) forward_path: std::option::Option<crate::model::RouteAnalysisPath>,
        pub(crate) return_path: std::option::Option<crate::model::RouteAnalysisPath>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the AWS account that created the route analysis.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The ID of the AWS account that created the route analysis.</p>
        pub fn set_owner_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_account_id = input; self
        }
        /// <p>The ID of the route analysis.</p>
        pub fn route_analysis_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.route_analysis_id = Some(input.into());
            self
        }
        /// <p>The ID of the route analysis.</p>
        pub fn set_route_analysis_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.route_analysis_id = input; self
        }
        /// <p>The time that the analysis started.</p>
        pub fn start_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_timestamp = Some(input);
            self
        }
        /// <p>The time that the analysis started.</p>
        pub fn set_start_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.start_timestamp = input; self
        }
        /// <p>The status of the route analysis.</p>
        pub fn status(mut self, input: crate::model::RouteAnalysisStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the route analysis.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::RouteAnalysisStatus>) -> Self {
            self.status = input; self
        }
        /// <p>The source.</p>
        pub fn source(mut self, input: crate::model::RouteAnalysisEndpointOptions) -> Self {
            self.source = Some(input);
            self
        }
        /// <p>The source.</p>
        pub fn set_source(mut self, input: std::option::Option<crate::model::RouteAnalysisEndpointOptions>) -> Self {
            self.source = input; self
        }
        /// <p>The destination.</p>
        pub fn destination(mut self, input: crate::model::RouteAnalysisEndpointOptions) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>The destination.</p>
        pub fn set_destination(mut self, input: std::option::Option<crate::model::RouteAnalysisEndpointOptions>) -> Self {
            self.destination = input; self
        }
        /// <p>Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.</p>
        pub fn include_return_path(mut self, input: bool) -> Self {
            self.include_return_path = Some(input);
            self
        }
        /// <p>Indicates whether to analyze the return path. The return path is not analyzed if the forward path analysis does not succeed.</p>
        pub fn set_include_return_path(mut self, input: std::option::Option<bool>) -> Self {
            self.include_return_path = input; self
        }
        /// <p>Indicates whether to include the location of middlebox appliances in the route analysis.</p>
        pub fn use_middleboxes(mut self, input: bool) -> Self {
            self.use_middleboxes = Some(input);
            self
        }
        /// <p>Indicates whether to include the location of middlebox appliances in the route analysis.</p>
        pub fn set_use_middleboxes(mut self, input: std::option::Option<bool>) -> Self {
            self.use_middleboxes = input; self
        }
        /// <p>The forward path.</p>
        pub fn forward_path(mut self, input: crate::model::RouteAnalysisPath) -> Self {
            self.forward_path = Some(input);
            self
        }
        /// <p>The forward path.</p>
        pub fn set_forward_path(mut self, input: std::option::Option<crate::model::RouteAnalysisPath>) -> Self {
            self.forward_path = input; self
        }
        /// <p>The return path.</p>
        pub fn return_path(mut self, input: crate::model::RouteAnalysisPath) -> Self {
            self.return_path = Some(input);
            self
        }
        /// <p>The return path.</p>
        pub fn set_return_path(mut self, input: std::option::Option<crate::model::RouteAnalysisPath>) -> Self {
            self.return_path = input; self
        }
        /// Consumes the builder and constructs a [`RouteAnalysis`](crate::model::RouteAnalysis).
        pub fn build(self) -> crate::model::RouteAnalysis {
            crate::model::RouteAnalysis {
                global_network_id: self.global_network_id
                ,
                owner_account_id: self.owner_account_id
                ,
                route_analysis_id: self.route_analysis_id
                ,
                start_timestamp: self.start_timestamp
                ,
                status: self.status
                ,
                source: self.source
                ,
                destination: self.destination
                ,
                include_return_path: self.include_return_path
                    .unwrap_or_default()
                ,
                use_middleboxes: self.use_middleboxes
                    .unwrap_or_default()
                ,
                forward_path: self.forward_path
                ,
                return_path: self.return_path
                ,
            }
        }
    }
    
    
}
impl RouteAnalysis {
    /// Creates a new builder-style object to manufacture [`RouteAnalysis`](crate::model::RouteAnalysis).
    pub fn builder() -> crate::model::route_analysis::Builder {
        crate::model::route_analysis::Builder::default()
    }
}

/// <p>Describes a route analysis path.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RouteAnalysisPath  {
    /// <p>The status of the analysis at completion.</p>
    #[doc(hidden)]
    pub completion_status: std::option::Option<crate::model::RouteAnalysisCompletion>,
    /// <p>The route analysis path.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
}
impl RouteAnalysisPath {
    /// <p>The status of the analysis at completion.</p>
    pub fn completion_status(&self) -> std::option::Option<& crate::model::RouteAnalysisCompletion> {
        self.completion_status.as_ref()
    }
    /// <p>The route analysis path.</p>
    pub fn path(&self) -> std::option::Option<& [crate::model::PathComponent]> {
        self.path.as_deref()
    }
}
/// See [`RouteAnalysisPath`](crate::model::RouteAnalysisPath).
pub mod route_analysis_path {
    
    /// A builder for [`RouteAnalysisPath`](crate::model::RouteAnalysisPath).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) completion_status: std::option::Option<crate::model::RouteAnalysisCompletion>,
        pub(crate) path: std::option::Option<std::vec::Vec<crate::model::PathComponent>>,
    }
    impl Builder {
        /// <p>The status of the analysis at completion.</p>
        pub fn completion_status(mut self, input: crate::model::RouteAnalysisCompletion) -> Self {
            self.completion_status = Some(input);
            self
        }
        /// <p>The status of the analysis at completion.</p>
        pub fn set_completion_status(mut self, input: std::option::Option<crate::model::RouteAnalysisCompletion>) -> Self {
            self.completion_status = input; self
        }
        /// Appends an item to `path`.
        ///
        /// To override the contents of this collection use [`set_path`](Self::set_path).
        ///
        /// <p>The route analysis path.</p>
        pub fn path(mut self, input: crate::model::PathComponent) -> Self {
            let mut v = self.path.unwrap_or_default();
                            v.push(input);
                            self.path = Some(v);
                            self
        }
        /// <p>The route analysis path.</p>
        pub fn set_path(mut self, input: std::option::Option<std::vec::Vec<crate::model::PathComponent>>) -> Self {
            self.path = input; self
        }
        /// Consumes the builder and constructs a [`RouteAnalysisPath`](crate::model::RouteAnalysisPath).
        pub fn build(self) -> crate::model::RouteAnalysisPath {
            crate::model::RouteAnalysisPath {
                completion_status: self.completion_status
                ,
                path: self.path
                ,
            }
        }
    }
    
    
}
impl RouteAnalysisPath {
    /// Creates a new builder-style object to manufacture [`RouteAnalysisPath`](crate::model::RouteAnalysisPath).
    pub fn builder() -> crate::model::route_analysis_path::Builder {
        crate::model::route_analysis_path::Builder::default()
    }
}

/// <p>Describes a path component.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PathComponent  {
    /// <p>The sequence number in the path. The destination is 0.</p>
    #[doc(hidden)]
    pub sequence: std::option::Option<i32>,
    /// <p>The resource.</p>
    #[doc(hidden)]
    pub resource: std::option::Option<crate::model::NetworkResourceSummary>,
    /// <p>The destination CIDR block in the route table.</p>
    #[doc(hidden)]
    pub destination_cidr_block: std::option::Option<std::string::String>,
}
impl PathComponent {
    /// <p>The sequence number in the path. The destination is 0.</p>
    pub fn sequence(&self) -> std::option::Option<i32> {
        self.sequence
    }
    /// <p>The resource.</p>
    pub fn resource(&self) -> std::option::Option<& crate::model::NetworkResourceSummary> {
        self.resource.as_ref()
    }
    /// <p>The destination CIDR block in the route table.</p>
    pub fn destination_cidr_block(&self) -> std::option::Option<& str> {
        self.destination_cidr_block.as_deref()
    }
}
/// See [`PathComponent`](crate::model::PathComponent).
pub mod path_component {
    
    /// A builder for [`PathComponent`](crate::model::PathComponent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sequence: std::option::Option<i32>,
        pub(crate) resource: std::option::Option<crate::model::NetworkResourceSummary>,
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The sequence number in the path. The destination is 0.</p>
        pub fn sequence(mut self, input: i32) -> Self {
            self.sequence = Some(input);
            self
        }
        /// <p>The sequence number in the path. The destination is 0.</p>
        pub fn set_sequence(mut self, input: std::option::Option<i32>) -> Self {
            self.sequence = input; self
        }
        /// <p>The resource.</p>
        pub fn resource(mut self, input: crate::model::NetworkResourceSummary) -> Self {
            self.resource = Some(input);
            self
        }
        /// <p>The resource.</p>
        pub fn set_resource(mut self, input: std::option::Option<crate::model::NetworkResourceSummary>) -> Self {
            self.resource = input; self
        }
        /// <p>The destination CIDR block in the route table.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        /// <p>The destination CIDR block in the route table.</p>
        pub fn set_destination_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_cidr_block = input; self
        }
        /// Consumes the builder and constructs a [`PathComponent`](crate::model::PathComponent).
        pub fn build(self) -> crate::model::PathComponent {
            crate::model::PathComponent {
                sequence: self.sequence
                ,
                resource: self.resource
                ,
                destination_cidr_block: self.destination_cidr_block
                ,
            }
        }
    }
    
    
}
impl PathComponent {
    /// Creates a new builder-style object to manufacture [`PathComponent`](crate::model::PathComponent).
    pub fn builder() -> crate::model::path_component::Builder {
        crate::model::path_component::Builder::default()
    }
}

/// <p>Describes a network resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkResourceSummary  {
    /// <p>The ARN of the gateway.</p>
    #[doc(hidden)]
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<std::string::String>,
    /// <p>The value for the Name tag.</p>
    #[doc(hidden)]
    pub name_tag: std::option::Option<std::string::String>,
    /// <p>Indicates whether this is a middlebox appliance.</p>
    #[doc(hidden)]
    pub is_middlebox: bool,
}
impl NetworkResourceSummary {
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<& str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<& str> {
        self.resource_type.as_deref()
    }
    /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
    pub fn definition(&self) -> std::option::Option<& str> {
        self.definition.as_deref()
    }
    /// <p>The value for the Name tag.</p>
    pub fn name_tag(&self) -> std::option::Option<& str> {
        self.name_tag.as_deref()
    }
    /// <p>Indicates whether this is a middlebox appliance.</p>
    pub fn is_middlebox(&self) -> bool {
        self.is_middlebox
    }
}
/// See [`NetworkResourceSummary`](crate::model::NetworkResourceSummary).
pub mod network_resource_summary {
    
    /// A builder for [`NetworkResourceSummary`](crate::model::NetworkResourceSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) definition: std::option::Option<std::string::String>,
        pub(crate) name_tag: std::option::Option<std::string::String>,
        pub(crate) is_middlebox: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registered_gateway_arn = input; self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_type = input; self
        }
        /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
        pub fn definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.definition = Some(input.into());
            self
        }
        /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
        pub fn set_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.definition = input; self
        }
        /// <p>The value for the Name tag.</p>
        pub fn name_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.name_tag = Some(input.into());
            self
        }
        /// <p>The value for the Name tag.</p>
        pub fn set_name_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name_tag = input; self
        }
        /// <p>Indicates whether this is a middlebox appliance.</p>
        pub fn is_middlebox(mut self, input: bool) -> Self {
            self.is_middlebox = Some(input);
            self
        }
        /// <p>Indicates whether this is a middlebox appliance.</p>
        pub fn set_is_middlebox(mut self, input: std::option::Option<bool>) -> Self {
            self.is_middlebox = input; self
        }
        /// Consumes the builder and constructs a [`NetworkResourceSummary`](crate::model::NetworkResourceSummary).
        pub fn build(self) -> crate::model::NetworkResourceSummary {
            crate::model::NetworkResourceSummary {
                registered_gateway_arn: self.registered_gateway_arn
                ,
                resource_arn: self.resource_arn
                ,
                resource_type: self.resource_type
                ,
                definition: self.definition
                ,
                name_tag: self.name_tag
                ,
                is_middlebox: self.is_middlebox
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl NetworkResourceSummary {
    /// Creates a new builder-style object to manufacture [`NetworkResourceSummary`](crate::model::NetworkResourceSummary).
    pub fn builder() -> crate::model::network_resource_summary::Builder {
        crate::model::network_resource_summary::Builder::default()
    }
}

/// <p>Describes the status of an analysis at completion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RouteAnalysisCompletion  {
    /// <p>The result of the analysis. If the status is <code>NOT_CONNECTED</code>, check the reason code.</p>
    #[doc(hidden)]
    pub result_code: std::option::Option<crate::model::RouteAnalysisCompletionResultCode>,
    /// <p>The reason code. Available only if a connection is not found.</p> 
    /// <ul> 
    /// <li> <p> <code>BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND</code> - Found a black hole route with the destination CIDR block.</p> </li> 
    /// <li> <p> <code>CYCLIC_PATH_DETECTED</code> - Found the same resource multiple times while traversing the path.</p> </li> 
    /// <li> <p> <code>INACTIVE_ROUTE_FOR_DESTINATION_FOUND</code> - Found an inactive route with the destination CIDR block.</p> </li> 
    /// <li> <p> <code>MAX_HOPS_EXCEEDED</code> - Analysis exceeded 64 hops without finding the destination.</p> </li> 
    /// <li> <p> <code>ROUTE_NOT_FOUND</code> - Cannot find a route table with the destination CIDR block.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_ARN_NO_MATCH</code> - Found an attachment, but not with the correct destination ARN.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_NOT_FOUND</code> - Cannot find an attachment.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_NOT_IN_TGW</code> - Found an attachment, but not to the correct transit gateway.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND</code> - The state of the route table association is not associated.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub reason_code: std::option::Option<crate::model::RouteAnalysisCompletionReasonCode>,
    /// <p>Additional information about the path. Available only if a connection is not found.</p>
    #[doc(hidden)]
    pub reason_context: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl RouteAnalysisCompletion {
    /// <p>The result of the analysis. If the status is <code>NOT_CONNECTED</code>, check the reason code.</p>
    pub fn result_code(&self) -> std::option::Option<& crate::model::RouteAnalysisCompletionResultCode> {
        self.result_code.as_ref()
    }
    /// <p>The reason code. Available only if a connection is not found.</p> 
    /// <ul> 
    /// <li> <p> <code>BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND</code> - Found a black hole route with the destination CIDR block.</p> </li> 
    /// <li> <p> <code>CYCLIC_PATH_DETECTED</code> - Found the same resource multiple times while traversing the path.</p> </li> 
    /// <li> <p> <code>INACTIVE_ROUTE_FOR_DESTINATION_FOUND</code> - Found an inactive route with the destination CIDR block.</p> </li> 
    /// <li> <p> <code>MAX_HOPS_EXCEEDED</code> - Analysis exceeded 64 hops without finding the destination.</p> </li> 
    /// <li> <p> <code>ROUTE_NOT_FOUND</code> - Cannot find a route table with the destination CIDR block.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_ARN_NO_MATCH</code> - Found an attachment, but not with the correct destination ARN.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_NOT_FOUND</code> - Cannot find an attachment.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_NOT_IN_TGW</code> - Found an attachment, but not to the correct transit gateway.</p> </li> 
    /// <li> <p> <code>TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND</code> - The state of the route table association is not associated.</p> </li> 
    /// </ul>
    pub fn reason_code(&self) -> std::option::Option<& crate::model::RouteAnalysisCompletionReasonCode> {
        self.reason_code.as_ref()
    }
    /// <p>Additional information about the path. Available only if a connection is not found.</p>
    pub fn reason_context(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.reason_context.as_ref()
    }
}
/// See [`RouteAnalysisCompletion`](crate::model::RouteAnalysisCompletion).
pub mod route_analysis_completion {
    
    /// A builder for [`RouteAnalysisCompletion`](crate::model::RouteAnalysisCompletion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) result_code: std::option::Option<crate::model::RouteAnalysisCompletionResultCode>,
        pub(crate) reason_code: std::option::Option<crate::model::RouteAnalysisCompletionReasonCode>,
        pub(crate) reason_context: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The result of the analysis. If the status is <code>NOT_CONNECTED</code>, check the reason code.</p>
        pub fn result_code(mut self, input: crate::model::RouteAnalysisCompletionResultCode) -> Self {
            self.result_code = Some(input);
            self
        }
        /// <p>The result of the analysis. If the status is <code>NOT_CONNECTED</code>, check the reason code.</p>
        pub fn set_result_code(mut self, input: std::option::Option<crate::model::RouteAnalysisCompletionResultCode>) -> Self {
            self.result_code = input; self
        }
        /// <p>The reason code. Available only if a connection is not found.</p> 
        /// <ul> 
        /// <li> <p> <code>BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND</code> - Found a black hole route with the destination CIDR block.</p> </li> 
        /// <li> <p> <code>CYCLIC_PATH_DETECTED</code> - Found the same resource multiple times while traversing the path.</p> </li> 
        /// <li> <p> <code>INACTIVE_ROUTE_FOR_DESTINATION_FOUND</code> - Found an inactive route with the destination CIDR block.</p> </li> 
        /// <li> <p> <code>MAX_HOPS_EXCEEDED</code> - Analysis exceeded 64 hops without finding the destination.</p> </li> 
        /// <li> <p> <code>ROUTE_NOT_FOUND</code> - Cannot find a route table with the destination CIDR block.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_ARN_NO_MATCH</code> - Found an attachment, but not with the correct destination ARN.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_NOT_FOUND</code> - Cannot find an attachment.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_NOT_IN_TGW</code> - Found an attachment, but not to the correct transit gateway.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND</code> - The state of the route table association is not associated.</p> </li> 
        /// </ul>
        pub fn reason_code(mut self, input: crate::model::RouteAnalysisCompletionReasonCode) -> Self {
            self.reason_code = Some(input);
            self
        }
        /// <p>The reason code. Available only if a connection is not found.</p> 
        /// <ul> 
        /// <li> <p> <code>BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND</code> - Found a black hole route with the destination CIDR block.</p> </li> 
        /// <li> <p> <code>CYCLIC_PATH_DETECTED</code> - Found the same resource multiple times while traversing the path.</p> </li> 
        /// <li> <p> <code>INACTIVE_ROUTE_FOR_DESTINATION_FOUND</code> - Found an inactive route with the destination CIDR block.</p> </li> 
        /// <li> <p> <code>MAX_HOPS_EXCEEDED</code> - Analysis exceeded 64 hops without finding the destination.</p> </li> 
        /// <li> <p> <code>ROUTE_NOT_FOUND</code> - Cannot find a route table with the destination CIDR block.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_ARN_NO_MATCH</code> - Found an attachment, but not with the correct destination ARN.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_NOT_FOUND</code> - Cannot find an attachment.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_NOT_IN_TGW</code> - Found an attachment, but not to the correct transit gateway.</p> </li> 
        /// <li> <p> <code>TGW_ATTACH_STABLE_ROUTE_TABLE_NOT_FOUND</code> - The state of the route table association is not associated.</p> </li> 
        /// </ul>
        pub fn set_reason_code(mut self, input: std::option::Option<crate::model::RouteAnalysisCompletionReasonCode>) -> Self {
            self.reason_code = input; self
        }
        /// Adds a key-value pair to `reason_context`.
        ///
        /// To override the contents of this collection use [`set_reason_context`](Self::set_reason_context).
        ///
        /// <p>Additional information about the path. Available only if a connection is not found.</p>
        pub fn reason_context(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.reason_context.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.reason_context = Some(hash_map);
                            self
        }
        /// <p>Additional information about the path. Available only if a connection is not found.</p>
        pub fn set_reason_context(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.reason_context = input; self
        }
        /// Consumes the builder and constructs a [`RouteAnalysisCompletion`](crate::model::RouteAnalysisCompletion).
        pub fn build(self) -> crate::model::RouteAnalysisCompletion {
            crate::model::RouteAnalysisCompletion {
                result_code: self.result_code
                ,
                reason_code: self.reason_code
                ,
                reason_context: self.reason_context
                ,
            }
        }
    }
    
    
}
impl RouteAnalysisCompletion {
    /// Creates a new builder-style object to manufacture [`RouteAnalysisCompletion`](crate::model::RouteAnalysisCompletion).
    pub fn builder() -> crate::model::route_analysis_completion::Builder {
        crate::model::route_analysis_completion::Builder::default()
    }
}

/// When writing a match expression against `RouteAnalysisCompletionReasonCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let routeanalysiscompletionreasoncode = unimplemented!();
/// match routeanalysiscompletionreasoncode {
///     RouteAnalysisCompletionReasonCode::BlackholeRouteForDestinationFound => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::CyclicPathDetected => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::InactiveRouteForDestinationFound => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::MaxHopsExceeded => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::NoDestinationArnProvided => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::PossibleMiddlebox => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::RouteNotFound => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::TransitGatewayAttachment => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentNotFound => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentNotInTransitGateway => { /* ... */ },
///     RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentStableRouteTableNotFound => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `routeanalysiscompletionreasoncode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RouteAnalysisCompletionReasonCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RouteAnalysisCompletionReasonCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RouteAnalysisCompletionReasonCode::NewFeature` is defined.
/// Specifically, when `routeanalysiscompletionreasoncode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RouteAnalysisCompletionReasonCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RouteAnalysisCompletionReasonCode {
    #[allow(missing_docs)] // documentation missing in model
    BlackholeRouteForDestinationFound,
    #[allow(missing_docs)] // documentation missing in model
    CyclicPathDetected,
    #[allow(missing_docs)] // documentation missing in model
    InactiveRouteForDestinationFound,
    #[allow(missing_docs)] // documentation missing in model
    MaxHopsExceeded,
    #[allow(missing_docs)] // documentation missing in model
    NoDestinationArnProvided,
    #[allow(missing_docs)] // documentation missing in model
    PossibleMiddlebox,
    #[allow(missing_docs)] // documentation missing in model
    RouteNotFound,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayAttachment,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayAttachmentNotFound,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayAttachmentNotInTransitGateway,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayAttachmentStableRouteTableNotFound,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RouteAnalysisCompletionReasonCode {
    fn from(s: &str) -> Self {
        match s {
            "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND" => RouteAnalysisCompletionReasonCode::BlackholeRouteForDestinationFound,
            "CYCLIC_PATH_DETECTED" => RouteAnalysisCompletionReasonCode::CyclicPathDetected,
            "INACTIVE_ROUTE_FOR_DESTINATION_FOUND" => RouteAnalysisCompletionReasonCode::InactiveRouteForDestinationFound,
            "MAX_HOPS_EXCEEDED" => RouteAnalysisCompletionReasonCode::MaxHopsExceeded,
            "NO_DESTINATION_ARN_PROVIDED" => RouteAnalysisCompletionReasonCode::NoDestinationArnProvided,
            "POSSIBLE_MIDDLEBOX" => RouteAnalysisCompletionReasonCode::PossibleMiddlebox,
            "ROUTE_NOT_FOUND" => RouteAnalysisCompletionReasonCode::RouteNotFound,
            "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH" => RouteAnalysisCompletionReasonCode::TransitGatewayAttachment,
            "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND" => RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentNotFound,
            "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY" => RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentNotInTransitGateway,
            "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND" => RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentStableRouteTableNotFound,
            other => RouteAnalysisCompletionReasonCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RouteAnalysisCompletionReasonCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RouteAnalysisCompletionReasonCode::from(s))
                }
            }
impl RouteAnalysisCompletionReasonCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RouteAnalysisCompletionReasonCode::BlackholeRouteForDestinationFound => "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND",
            RouteAnalysisCompletionReasonCode::CyclicPathDetected => "CYCLIC_PATH_DETECTED",
            RouteAnalysisCompletionReasonCode::InactiveRouteForDestinationFound => "INACTIVE_ROUTE_FOR_DESTINATION_FOUND",
            RouteAnalysisCompletionReasonCode::MaxHopsExceeded => "MAX_HOPS_EXCEEDED",
            RouteAnalysisCompletionReasonCode::NoDestinationArnProvided => "NO_DESTINATION_ARN_PROVIDED",
            RouteAnalysisCompletionReasonCode::PossibleMiddlebox => "POSSIBLE_MIDDLEBOX",
            RouteAnalysisCompletionReasonCode::RouteNotFound => "ROUTE_NOT_FOUND",
            RouteAnalysisCompletionReasonCode::TransitGatewayAttachment => "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH",
            RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentNotFound => "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND",
            RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentNotInTransitGateway => "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY",
            RouteAnalysisCompletionReasonCode::TransitGatewayAttachmentStableRouteTableNotFound => "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND",
            RouteAnalysisCompletionReasonCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BLACKHOLE_ROUTE_FOR_DESTINATION_FOUND", "CYCLIC_PATH_DETECTED", "INACTIVE_ROUTE_FOR_DESTINATION_FOUND", "MAX_HOPS_EXCEEDED", "NO_DESTINATION_ARN_PROVIDED", "POSSIBLE_MIDDLEBOX", "ROUTE_NOT_FOUND", "TRANSIT_GATEWAY_ATTACHMENT_ATTACH_ARN_NO_MATCH", "TRANSIT_GATEWAY_ATTACHMENT_NOT_FOUND", "TRANSIT_GATEWAY_ATTACHMENT_NOT_IN_TRANSIT_GATEWAY", "TRANSIT_GATEWAY_ATTACHMENT_STABLE_ROUTE_TABLE_NOT_FOUND"
        ]
    }
}
impl AsRef<str> for RouteAnalysisCompletionReasonCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RouteAnalysisCompletionResultCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let routeanalysiscompletionresultcode = unimplemented!();
/// match routeanalysiscompletionresultcode {
///     RouteAnalysisCompletionResultCode::Connected => { /* ... */ },
///     RouteAnalysisCompletionResultCode::NotConnected => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `routeanalysiscompletionresultcode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RouteAnalysisCompletionResultCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RouteAnalysisCompletionResultCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RouteAnalysisCompletionResultCode::NewFeature` is defined.
/// Specifically, when `routeanalysiscompletionresultcode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RouteAnalysisCompletionResultCode::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RouteAnalysisCompletionResultCode {
    #[allow(missing_docs)] // documentation missing in model
    Connected,
    #[allow(missing_docs)] // documentation missing in model
    NotConnected,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RouteAnalysisCompletionResultCode {
    fn from(s: &str) -> Self {
        match s {
            "CONNECTED" => RouteAnalysisCompletionResultCode::Connected,
            "NOT_CONNECTED" => RouteAnalysisCompletionResultCode::NotConnected,
            other => RouteAnalysisCompletionResultCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RouteAnalysisCompletionResultCode {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RouteAnalysisCompletionResultCode::from(s))
                }
            }
impl RouteAnalysisCompletionResultCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RouteAnalysisCompletionResultCode::Connected => "CONNECTED",
            RouteAnalysisCompletionResultCode::NotConnected => "NOT_CONNECTED",
            RouteAnalysisCompletionResultCode::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CONNECTED", "NOT_CONNECTED"
        ]
    }
}
impl AsRef<str> for RouteAnalysisCompletionResultCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a source or a destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RouteAnalysisEndpointOptions  {
    /// <p>The ARN of the transit gateway attachment.</p>
    #[doc(hidden)]
    pub transit_gateway_attachment_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the transit gateway.</p>
    #[doc(hidden)]
    pub transit_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The IP address.</p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
}
impl RouteAnalysisEndpointOptions {
    /// <p>The ARN of the transit gateway attachment.</p>
    pub fn transit_gateway_attachment_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_attachment_arn.as_deref()
    }
    /// <p>The ARN of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_arn.as_deref()
    }
    /// <p>The IP address.</p>
    pub fn ip_address(&self) -> std::option::Option<& str> {
        self.ip_address.as_deref()
    }
}
/// See [`RouteAnalysisEndpointOptions`](crate::model::RouteAnalysisEndpointOptions).
pub mod route_analysis_endpoint_options {
    
    /// A builder for [`RouteAnalysisEndpointOptions`](crate::model::RouteAnalysisEndpointOptions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_arn: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_attachment_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway attachment.</p>
        pub fn set_transit_gateway_attachment_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_attachment_arn = input; self
        }
        /// <p>The ARN of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway.</p>
        pub fn set_transit_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_arn = input; self
        }
        /// <p>The IP address.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p>The IP address.</p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input; self
        }
        /// Consumes the builder and constructs a [`RouteAnalysisEndpointOptions`](crate::model::RouteAnalysisEndpointOptions).
        pub fn build(self) -> crate::model::RouteAnalysisEndpointOptions {
            crate::model::RouteAnalysisEndpointOptions {
                transit_gateway_attachment_arn: self.transit_gateway_attachment_arn
                ,
                transit_gateway_arn: self.transit_gateway_arn
                ,
                ip_address: self.ip_address
                ,
            }
        }
    }
    
    
}
impl RouteAnalysisEndpointOptions {
    /// Creates a new builder-style object to manufacture [`RouteAnalysisEndpointOptions`](crate::model::RouteAnalysisEndpointOptions).
    pub fn builder() -> crate::model::route_analysis_endpoint_options::Builder {
        crate::model::route_analysis_endpoint_options::Builder::default()
    }
}

/// When writing a match expression against `RouteAnalysisStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let routeanalysisstatus = unimplemented!();
/// match routeanalysisstatus {
///     RouteAnalysisStatus::Completed => { /* ... */ },
///     RouteAnalysisStatus::Failed => { /* ... */ },
///     RouteAnalysisStatus::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `routeanalysisstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RouteAnalysisStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RouteAnalysisStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RouteAnalysisStatus::NewFeature` is defined.
/// Specifically, when `routeanalysisstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RouteAnalysisStatus::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RouteAnalysisStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RouteAnalysisStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => RouteAnalysisStatus::Completed,
            "FAILED" => RouteAnalysisStatus::Failed,
            "RUNNING" => RouteAnalysisStatus::Running,
            other => RouteAnalysisStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RouteAnalysisStatus {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RouteAnalysisStatus::from(s))
                }
            }
impl RouteAnalysisStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RouteAnalysisStatus::Completed => "COMPLETED",
            RouteAnalysisStatus::Failed => "FAILED",
            RouteAnalysisStatus::Running => "RUNNING",
            RouteAnalysisStatus::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED", "FAILED", "RUNNING"
        ]
    }
}
impl AsRef<str> for RouteAnalysisStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a source or a destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RouteAnalysisEndpointOptionsSpecification  {
    /// <p>The ARN of the transit gateway attachment.</p>
    #[doc(hidden)]
    pub transit_gateway_attachment_arn: std::option::Option<std::string::String>,
    /// <p>The IP address.</p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
}
impl RouteAnalysisEndpointOptionsSpecification {
    /// <p>The ARN of the transit gateway attachment.</p>
    pub fn transit_gateway_attachment_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_attachment_arn.as_deref()
    }
    /// <p>The IP address.</p>
    pub fn ip_address(&self) -> std::option::Option<& str> {
        self.ip_address.as_deref()
    }
}
/// See [`RouteAnalysisEndpointOptionsSpecification`](crate::model::RouteAnalysisEndpointOptionsSpecification).
pub mod route_analysis_endpoint_options_specification {
    
    /// A builder for [`RouteAnalysisEndpointOptionsSpecification`](crate::model::RouteAnalysisEndpointOptionsSpecification).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_attachment_arn: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_attachment_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway attachment.</p>
        pub fn set_transit_gateway_attachment_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_attachment_arn = input; self
        }
        /// <p>The IP address.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p>The IP address.</p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input; self
        }
        /// Consumes the builder and constructs a [`RouteAnalysisEndpointOptionsSpecification`](crate::model::RouteAnalysisEndpointOptionsSpecification).
        pub fn build(self) -> crate::model::RouteAnalysisEndpointOptionsSpecification {
            crate::model::RouteAnalysisEndpointOptionsSpecification {
                transit_gateway_attachment_arn: self.transit_gateway_attachment_arn
                ,
                ip_address: self.ip_address
                ,
            }
        }
    }
    
    
}
impl RouteAnalysisEndpointOptionsSpecification {
    /// Creates a new builder-style object to manufacture [`RouteAnalysisEndpointOptionsSpecification`](crate::model::RouteAnalysisEndpointOptionsSpecification).
    pub fn builder() -> crate::model::route_analysis_endpoint_options_specification::Builder {
        crate::model::route_analysis_endpoint_options_specification::Builder::default()
    }
}

/// <p>The status of an Amazon Web Services Organization and the accounts within that organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationStatus  {
    /// <p>The ID of an Amazon Web Services Organization.</p>
    #[doc(hidden)]
    pub organization_id: std::option::Option<std::string::String>,
    /// <p>The status of the organization's AWS service access. This will be <code>ENABLED</code> or <code>DISABLED</code>.</p>
    #[doc(hidden)]
    pub organization_aws_service_access_status: std::option::Option<std::string::String>,
    /// <p>The status of the SLR deployment for the account. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
    #[doc(hidden)]
    pub slr_deployment_status: std::option::Option<std::string::String>,
    /// <p>The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
    #[doc(hidden)]
    pub account_status_list: std::option::Option<std::vec::Vec<crate::model::AccountStatus>>,
}
impl OrganizationStatus {
    /// <p>The ID of an Amazon Web Services Organization.</p>
    pub fn organization_id(&self) -> std::option::Option<& str> {
        self.organization_id.as_deref()
    }
    /// <p>The status of the organization's AWS service access. This will be <code>ENABLED</code> or <code>DISABLED</code>.</p>
    pub fn organization_aws_service_access_status(&self) -> std::option::Option<& str> {
        self.organization_aws_service_access_status.as_deref()
    }
    /// <p>The status of the SLR deployment for the account. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
    pub fn slr_deployment_status(&self) -> std::option::Option<& str> {
        self.slr_deployment_status.as_deref()
    }
    /// <p>The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
    pub fn account_status_list(&self) -> std::option::Option<& [crate::model::AccountStatus]> {
        self.account_status_list.as_deref()
    }
}
/// See [`OrganizationStatus`](crate::model::OrganizationStatus).
pub mod organization_status {
    
    /// A builder for [`OrganizationStatus`](crate::model::OrganizationStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_id: std::option::Option<std::string::String>,
        pub(crate) organization_aws_service_access_status: std::option::Option<std::string::String>,
        pub(crate) slr_deployment_status: std::option::Option<std::string::String>,
        pub(crate) account_status_list: std::option::Option<std::vec::Vec<crate::model::AccountStatus>>,
    }
    impl Builder {
        /// <p>The ID of an Amazon Web Services Organization.</p>
        pub fn organization_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_id = Some(input.into());
            self
        }
        /// <p>The ID of an Amazon Web Services Organization.</p>
        pub fn set_organization_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.organization_id = input; self
        }
        /// <p>The status of the organization's AWS service access. This will be <code>ENABLED</code> or <code>DISABLED</code>.</p>
        pub fn organization_aws_service_access_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_aws_service_access_status = Some(input.into());
            self
        }
        /// <p>The status of the organization's AWS service access. This will be <code>ENABLED</code> or <code>DISABLED</code>.</p>
        pub fn set_organization_aws_service_access_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.organization_aws_service_access_status = input; self
        }
        /// <p>The status of the SLR deployment for the account. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
        pub fn slr_deployment_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.slr_deployment_status = Some(input.into());
            self
        }
        /// <p>The status of the SLR deployment for the account. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
        pub fn set_slr_deployment_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slr_deployment_status = input; self
        }
        /// Appends an item to `account_status_list`.
        ///
        /// To override the contents of this collection use [`set_account_status_list`](Self::set_account_status_list).
        ///
        /// <p>The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
        pub fn account_status_list(mut self, input: crate::model::AccountStatus) -> Self {
            let mut v = self.account_status_list.unwrap_or_default();
                            v.push(input);
                            self.account_status_list = Some(v);
                            self
        }
        /// <p>The current service-linked role (SLR) deployment status for an Amazon Web Services Organization's accounts. This will be either <code>SUCCEEDED</code> or <code>IN_PROGRESS</code>.</p>
        pub fn set_account_status_list(mut self, input: std::option::Option<std::vec::Vec<crate::model::AccountStatus>>) -> Self {
            self.account_status_list = input; self
        }
        /// Consumes the builder and constructs a [`OrganizationStatus`](crate::model::OrganizationStatus).
        pub fn build(self) -> crate::model::OrganizationStatus {
            crate::model::OrganizationStatus {
                organization_id: self.organization_id
                ,
                organization_aws_service_access_status: self.organization_aws_service_access_status
                ,
                slr_deployment_status: self.slr_deployment_status
                ,
                account_status_list: self.account_status_list
                ,
            }
        }
    }
    
    
}
impl OrganizationStatus {
    /// Creates a new builder-style object to manufacture [`OrganizationStatus`](crate::model::OrganizationStatus).
    pub fn builder() -> crate::model::organization_status::Builder {
        crate::model::organization_status::Builder::default()
    }
}

/// <p>Describes the current status of an account within an Amazon Web Services Organization, including service-linked roles (SLRs).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountStatus  {
    /// <p>The ID of an account within the Amazon Web Services Organization.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The status of SLR deployment for the account.</p>
    #[doc(hidden)]
    pub slr_deployment_status: std::option::Option<std::string::String>,
}
impl AccountStatus {
    /// <p>The ID of an account within the Amazon Web Services Organization.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The status of SLR deployment for the account.</p>
    pub fn slr_deployment_status(&self) -> std::option::Option<& str> {
        self.slr_deployment_status.as_deref()
    }
}
/// See [`AccountStatus`](crate::model::AccountStatus).
pub mod account_status {
    
    /// A builder for [`AccountStatus`](crate::model::AccountStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) slr_deployment_status: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of an account within the Amazon Web Services Organization.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The ID of an account within the Amazon Web Services Organization.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The status of SLR deployment for the account.</p>
        pub fn slr_deployment_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.slr_deployment_status = Some(input.into());
            self
        }
        /// <p>The status of SLR deployment for the account.</p>
        pub fn set_slr_deployment_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.slr_deployment_status = input; self
        }
        /// Consumes the builder and constructs a [`AccountStatus`](crate::model::AccountStatus).
        pub fn build(self) -> crate::model::AccountStatus {
            crate::model::AccountStatus {
                account_id: self.account_id
                ,
                slr_deployment_status: self.slr_deployment_status
                ,
            }
        }
    }
    
    
}
impl AccountStatus {
    /// Creates a new builder-style object to manufacture [`AccountStatus`](crate::model::AccountStatus).
    pub fn builder() -> crate::model::account_status::Builder {
        crate::model::account_status::Builder::default()
    }
}

/// <p>Describes a core network policy. You can have only one LIVE Core Policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkPolicy  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
    /// <p>Whether a core network policy is the current LIVE policy or the most recently submitted policy.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
    /// <p>The description of a core network policy.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp when a core network policy was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of a core network policy.</p>
    #[doc(hidden)]
    pub change_set_state: std::option::Option<crate::model::ChangeSetState>,
    /// <p>Describes any errors in a core network policy.</p>
    #[doc(hidden)]
    pub policy_errors: std::option::Option<std::vec::Vec<crate::model::CoreNetworkPolicyError>>,
    /// <p>Describes a core network policy.</p>
    #[doc(hidden)]
    pub policy_document: std::option::Option<std::string::String>,
}
impl CoreNetworkPolicy {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>Whether a core network policy is the current LIVE policy or the most recently submitted policy.</p>
    pub fn alias(&self) -> std::option::Option<& crate::model::CoreNetworkPolicyAlias> {
        self.alias.as_ref()
    }
    /// <p>The description of a core network policy.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The timestamp when a core network policy was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The state of a core network policy.</p>
    pub fn change_set_state(&self) -> std::option::Option<& crate::model::ChangeSetState> {
        self.change_set_state.as_ref()
    }
    /// <p>Describes any errors in a core network policy.</p>
    pub fn policy_errors(&self) -> std::option::Option<& [crate::model::CoreNetworkPolicyError]> {
        self.policy_errors.as_deref()
    }
    /// <p>Describes a core network policy.</p>
    pub fn policy_document(&self) -> std::option::Option<& str> {
        self.policy_document.as_deref()
    }
}
/// See [`CoreNetworkPolicy`](crate::model::CoreNetworkPolicy).
pub mod core_network_policy {
    
    /// A builder for [`CoreNetworkPolicy`](crate::model::CoreNetworkPolicy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) change_set_state: std::option::Option<crate::model::ChangeSetState>,
        pub(crate) policy_errors: std::option::Option<std::vec::Vec<crate::model::CoreNetworkPolicyError>>,
        pub(crate) policy_document: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input; self
        }
        /// <p>Whether a core network policy is the current LIVE policy or the most recently submitted policy.</p>
        pub fn alias(mut self, input: crate::model::CoreNetworkPolicyAlias) -> Self {
            self.alias = Some(input);
            self
        }
        /// <p>Whether a core network policy is the current LIVE policy or the most recently submitted policy.</p>
        pub fn set_alias(mut self, input: std::option::Option<crate::model::CoreNetworkPolicyAlias>) -> Self {
            self.alias = input; self
        }
        /// <p>The description of a core network policy.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a core network policy.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The timestamp when a core network policy was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when a core network policy was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The state of a core network policy.</p>
        pub fn change_set_state(mut self, input: crate::model::ChangeSetState) -> Self {
            self.change_set_state = Some(input);
            self
        }
        /// <p>The state of a core network policy.</p>
        pub fn set_change_set_state(mut self, input: std::option::Option<crate::model::ChangeSetState>) -> Self {
            self.change_set_state = input; self
        }
        /// Appends an item to `policy_errors`.
        ///
        /// To override the contents of this collection use [`set_policy_errors`](Self::set_policy_errors).
        ///
        /// <p>Describes any errors in a core network policy.</p>
        pub fn policy_errors(mut self, input: crate::model::CoreNetworkPolicyError) -> Self {
            let mut v = self.policy_errors.unwrap_or_default();
                            v.push(input);
                            self.policy_errors = Some(v);
                            self
        }
        /// <p>Describes any errors in a core network policy.</p>
        pub fn set_policy_errors(mut self, input: std::option::Option<std::vec::Vec<crate::model::CoreNetworkPolicyError>>) -> Self {
            self.policy_errors = input; self
        }
        /// <p>Describes a core network policy.</p>
        pub fn policy_document(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_document = Some(input.into());
            self
        }
        /// <p>Describes a core network policy.</p>
        pub fn set_policy_document(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_document = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkPolicy`](crate::model::CoreNetworkPolicy).
        pub fn build(self) -> crate::model::CoreNetworkPolicy {
            crate::model::CoreNetworkPolicy {
                core_network_id: self.core_network_id
                ,
                policy_version_id: self.policy_version_id
                ,
                alias: self.alias
                ,
                description: self.description
                ,
                created_at: self.created_at
                ,
                change_set_state: self.change_set_state
                ,
                policy_errors: self.policy_errors
                ,
                policy_document: self.policy_document
                ,
            }
        }
    }
    
    
}
impl CoreNetworkPolicy {
    /// Creates a new builder-style object to manufacture [`CoreNetworkPolicy`](crate::model::CoreNetworkPolicy).
    pub fn builder() -> crate::model::core_network_policy::Builder {
        crate::model::core_network_policy::Builder::default()
    }
}

/// <p>Provides details about an error in a core network policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkPolicyError  {
    /// <p>The error code associated with a core network policy error.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The message associated with a core network policy error code.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>The JSON path where the error was discovered in the policy document.</p>
    #[doc(hidden)]
    pub path: std::option::Option<std::string::String>,
}
impl CoreNetworkPolicyError {
    /// <p>The error code associated with a core network policy error.</p>
    pub fn error_code(&self) -> std::option::Option<& str> {
        self.error_code.as_deref()
    }
    /// <p>The message associated with a core network policy error code.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
    /// <p>The JSON path where the error was discovered in the policy document.</p>
    pub fn path(&self) -> std::option::Option<& str> {
        self.path.as_deref()
    }
}
/// See [`CoreNetworkPolicyError`](crate::model::CoreNetworkPolicyError).
pub mod core_network_policy_error {
    
    /// A builder for [`CoreNetworkPolicyError`](crate::model::CoreNetworkPolicyError).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error code associated with a core network policy error.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code associated with a core network policy error.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input; self
        }
        /// <p>The message associated with a core network policy error code.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message associated with a core network policy error code.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>The JSON path where the error was discovered in the policy document.</p>
        pub fn path(mut self, input: impl Into<std::string::String>) -> Self {
            self.path = Some(input.into());
            self
        }
        /// <p>The JSON path where the error was discovered in the policy document.</p>
        pub fn set_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.path = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkPolicyError`](crate::model::CoreNetworkPolicyError).
        pub fn build(self) -> crate::model::CoreNetworkPolicyError {
            crate::model::CoreNetworkPolicyError {
                error_code: self.error_code
                ,
                message: self.message
                ,
                path: self.path
                ,
            }
        }
    }
    
    
}
impl CoreNetworkPolicyError {
    /// Creates a new builder-style object to manufacture [`CoreNetworkPolicyError`](crate::model::CoreNetworkPolicyError).
    pub fn builder() -> crate::model::core_network_policy_error::Builder {
        crate::model::core_network_policy_error::Builder::default()
    }
}

/// When writing a match expression against `ChangeSetState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let changesetstate = unimplemented!();
/// match changesetstate {
///     ChangeSetState::Executing => { /* ... */ },
///     ChangeSetState::ExecutionSucceeded => { /* ... */ },
///     ChangeSetState::FailedGeneration => { /* ... */ },
///     ChangeSetState::OutOfDate => { /* ... */ },
///     ChangeSetState::PendingGeneration => { /* ... */ },
///     ChangeSetState::ReadyToExecute => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `changesetstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChangeSetState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChangeSetState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChangeSetState::NewFeature` is defined.
/// Specifically, when `changesetstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChangeSetState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ChangeSetState {
    #[allow(missing_docs)] // documentation missing in model
    Executing,
    #[allow(missing_docs)] // documentation missing in model
    ExecutionSucceeded,
    #[allow(missing_docs)] // documentation missing in model
    FailedGeneration,
    #[allow(missing_docs)] // documentation missing in model
    OutOfDate,
    #[allow(missing_docs)] // documentation missing in model
    PendingGeneration,
    #[allow(missing_docs)] // documentation missing in model
    ReadyToExecute,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ChangeSetState {
    fn from(s: &str) -> Self {
        match s {
            "EXECUTING" => ChangeSetState::Executing,
            "EXECUTION_SUCCEEDED" => ChangeSetState::ExecutionSucceeded,
            "FAILED_GENERATION" => ChangeSetState::FailedGeneration,
            "OUT_OF_DATE" => ChangeSetState::OutOfDate,
            "PENDING_GENERATION" => ChangeSetState::PendingGeneration,
            "READY_TO_EXECUTE" => ChangeSetState::ReadyToExecute,
            other => ChangeSetState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ChangeSetState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ChangeSetState::from(s))
                }
            }
impl ChangeSetState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChangeSetState::Executing => "EXECUTING",
            ChangeSetState::ExecutionSucceeded => "EXECUTION_SUCCEEDED",
            ChangeSetState::FailedGeneration => "FAILED_GENERATION",
            ChangeSetState::OutOfDate => "OUT_OF_DATE",
            ChangeSetState::PendingGeneration => "PENDING_GENERATION",
            ChangeSetState::ReadyToExecute => "READY_TO_EXECUTE",
            ChangeSetState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "EXECUTING", "EXECUTION_SUCCEEDED", "FAILED_GENERATION", "OUT_OF_DATE", "PENDING_GENERATION", "READY_TO_EXECUTE"
        ]
    }
}
impl AsRef<str> for ChangeSetState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `CoreNetworkPolicyAlias`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let corenetworkpolicyalias = unimplemented!();
/// match corenetworkpolicyalias {
///     CoreNetworkPolicyAlias::Latest => { /* ... */ },
///     CoreNetworkPolicyAlias::Live => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `corenetworkpolicyalias` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CoreNetworkPolicyAlias::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CoreNetworkPolicyAlias::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CoreNetworkPolicyAlias::NewFeature` is defined.
/// Specifically, when `corenetworkpolicyalias` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CoreNetworkPolicyAlias::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum CoreNetworkPolicyAlias {
    #[allow(missing_docs)] // documentation missing in model
    Latest,
    #[allow(missing_docs)] // documentation missing in model
    Live,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for CoreNetworkPolicyAlias {
    fn from(s: &str) -> Self {
        match s {
            "LATEST" => CoreNetworkPolicyAlias::Latest,
            "LIVE" => CoreNetworkPolicyAlias::Live,
            other => CoreNetworkPolicyAlias::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for CoreNetworkPolicyAlias {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(CoreNetworkPolicyAlias::from(s))
                }
            }
impl CoreNetworkPolicyAlias {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CoreNetworkPolicyAlias::Latest => "LATEST",
            CoreNetworkPolicyAlias::Live => "LIVE",
            CoreNetworkPolicyAlias::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "LATEST", "LIVE"
        ]
    }
}
impl AsRef<str> for CoreNetworkPolicyAlias {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the registration of a transit gateway to a global network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransitGatewayRegistration  {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    #[doc(hidden)]
    pub transit_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The state of the transit gateway registration.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::TransitGatewayRegistrationStateReason>,
}
impl TransitGatewayRegistration {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_arn.as_deref()
    }
    /// <p>The state of the transit gateway registration.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::TransitGatewayRegistrationStateReason> {
        self.state.as_ref()
    }
}
/// See [`TransitGatewayRegistration`](crate::model::TransitGatewayRegistration).
pub mod transit_gateway_registration {
    
    /// A builder for [`TransitGatewayRegistration`](crate::model::TransitGatewayRegistration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayRegistrationStateReason>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
        pub fn set_transit_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_arn = input; self
        }
        /// <p>The state of the transit gateway registration.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayRegistrationStateReason) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the transit gateway registration.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::TransitGatewayRegistrationStateReason>) -> Self {
            self.state = input; self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRegistration`](crate::model::TransitGatewayRegistration).
        pub fn build(self) -> crate::model::TransitGatewayRegistration {
            crate::model::TransitGatewayRegistration {
                global_network_id: self.global_network_id
                ,
                transit_gateway_arn: self.transit_gateway_arn
                ,
                state: self.state
                ,
            }
        }
    }
    
    
}
impl TransitGatewayRegistration {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRegistration`](crate::model::TransitGatewayRegistration).
    pub fn builder() -> crate::model::transit_gateway_registration::Builder {
        crate::model::transit_gateway_registration::Builder::default()
    }
}

/// <p>Describes the status of a transit gateway registration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransitGatewayRegistrationStateReason  {
    /// <p>The code for the state reason.</p>
    #[doc(hidden)]
    pub code: std::option::Option<crate::model::TransitGatewayRegistrationState>,
    /// <p>The message for the state reason.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl TransitGatewayRegistrationStateReason {
    /// <p>The code for the state reason.</p>
    pub fn code(&self) -> std::option::Option<& crate::model::TransitGatewayRegistrationState> {
        self.code.as_ref()
    }
    /// <p>The message for the state reason.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
}
/// See [`TransitGatewayRegistrationStateReason`](crate::model::TransitGatewayRegistrationStateReason).
pub mod transit_gateway_registration_state_reason {
    
    /// A builder for [`TransitGatewayRegistrationStateReason`](crate::model::TransitGatewayRegistrationStateReason).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) code: std::option::Option<crate::model::TransitGatewayRegistrationState>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The code for the state reason.</p>
        pub fn code(mut self, input: crate::model::TransitGatewayRegistrationState) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The code for the state reason.</p>
        pub fn set_code(mut self, input: std::option::Option<crate::model::TransitGatewayRegistrationState>) -> Self {
            self.code = input; self
        }
        /// <p>The message for the state reason.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message for the state reason.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRegistrationStateReason`](crate::model::TransitGatewayRegistrationStateReason).
        pub fn build(self) -> crate::model::TransitGatewayRegistrationStateReason {
            crate::model::TransitGatewayRegistrationStateReason {
                code: self.code
                ,
                message: self.message
                ,
            }
        }
    }
    
    
}
impl TransitGatewayRegistrationStateReason {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRegistrationStateReason`](crate::model::TransitGatewayRegistrationStateReason).
    pub fn builder() -> crate::model::transit_gateway_registration_state_reason::Builder {
        crate::model::transit_gateway_registration_state_reason::Builder::default()
    }
}

/// When writing a match expression against `TransitGatewayRegistrationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let transitgatewayregistrationstate = unimplemented!();
/// match transitgatewayregistrationstate {
///     TransitGatewayRegistrationState::Available => { /* ... */ },
///     TransitGatewayRegistrationState::Deleted => { /* ... */ },
///     TransitGatewayRegistrationState::Deleting => { /* ... */ },
///     TransitGatewayRegistrationState::Failed => { /* ... */ },
///     TransitGatewayRegistrationState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transitgatewayregistrationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransitGatewayRegistrationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransitGatewayRegistrationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransitGatewayRegistrationState::NewFeature` is defined.
/// Specifically, when `transitgatewayregistrationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransitGatewayRegistrationState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum TransitGatewayRegistrationState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for TransitGatewayRegistrationState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => TransitGatewayRegistrationState::Available,
            "DELETED" => TransitGatewayRegistrationState::Deleted,
            "DELETING" => TransitGatewayRegistrationState::Deleting,
            "FAILED" => TransitGatewayRegistrationState::Failed,
            "PENDING" => TransitGatewayRegistrationState::Pending,
            other => TransitGatewayRegistrationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for TransitGatewayRegistrationState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(TransitGatewayRegistrationState::from(s))
                }
            }
impl TransitGatewayRegistrationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayRegistrationState::Available => "AVAILABLE",
            TransitGatewayRegistrationState::Deleted => "DELETED",
            TransitGatewayRegistrationState::Deleting => "DELETING",
            TransitGatewayRegistrationState::Failed => "FAILED",
            TransitGatewayRegistrationState::Pending => "PENDING",
            TransitGatewayRegistrationState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETED", "DELETING", "FAILED", "PENDING"
        ]
    }
}
impl AsRef<str> for TransitGatewayRegistrationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a peering connection.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Peering  {
    /// <p>The ID of the core network for the peering request.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ARN of a core network.</p>
    #[doc(hidden)]
    pub core_network_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the peering attachment. </p>
    #[doc(hidden)]
    pub peering_id: std::option::Option<std::string::String>,
    /// <p>The ID of the account owner.</p>
    #[doc(hidden)]
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>The type of peering. This will be <code>TRANSIT_GATEWAY</code>.</p>
    #[doc(hidden)]
    pub peering_type: std::option::Option<crate::model::PeeringType>,
    /// <p>The current state of the peering connection. </p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::PeeringState>,
    /// <p>The edge location for the peer.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The resource ARN of the peer.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The list of key-value tags associated with the peering.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The timestamp when the attachment peer was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Peering {
    /// <p>The ID of the core network for the peering request.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ARN of a core network.</p>
    pub fn core_network_arn(&self) -> std::option::Option<& str> {
        self.core_network_arn.as_deref()
    }
    /// <p>The ID of the peering attachment. </p>
    pub fn peering_id(&self) -> std::option::Option<& str> {
        self.peering_id.as_deref()
    }
    /// <p>The ID of the account owner.</p>
    pub fn owner_account_id(&self) -> std::option::Option<& str> {
        self.owner_account_id.as_deref()
    }
    /// <p>The type of peering. This will be <code>TRANSIT_GATEWAY</code>.</p>
    pub fn peering_type(&self) -> std::option::Option<& crate::model::PeeringType> {
        self.peering_type.as_ref()
    }
    /// <p>The current state of the peering connection. </p>
    pub fn state(&self) -> std::option::Option<& crate::model::PeeringState> {
        self.state.as_ref()
    }
    /// <p>The edge location for the peer.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The resource ARN of the peer.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>The list of key-value tags associated with the peering.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The timestamp when the attachment peer was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
}
/// See [`Peering`](crate::model::Peering).
pub mod peering {
    
    /// A builder for [`Peering`](crate::model::Peering).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_arn: std::option::Option<std::string::String>,
        pub(crate) peering_id: std::option::Option<std::string::String>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) peering_type: std::option::Option<crate::model::PeeringType>,
        pub(crate) state: std::option::Option<crate::model::PeeringState>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the core network for the peering request.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the core network for the peering request.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ARN of a core network.</p>
        pub fn core_network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_arn = Some(input.into());
            self
        }
        /// <p>The ARN of a core network.</p>
        pub fn set_core_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_arn = input; self
        }
        /// <p>The ID of the peering attachment. </p>
        pub fn peering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_id = Some(input.into());
            self
        }
        /// <p>The ID of the peering attachment. </p>
        pub fn set_peering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peering_id = input; self
        }
        /// <p>The ID of the account owner.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The ID of the account owner.</p>
        pub fn set_owner_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_account_id = input; self
        }
        /// <p>The type of peering. This will be <code>TRANSIT_GATEWAY</code>.</p>
        pub fn peering_type(mut self, input: crate::model::PeeringType) -> Self {
            self.peering_type = Some(input);
            self
        }
        /// <p>The type of peering. This will be <code>TRANSIT_GATEWAY</code>.</p>
        pub fn set_peering_type(mut self, input: std::option::Option<crate::model::PeeringType>) -> Self {
            self.peering_type = input; self
        }
        /// <p>The current state of the peering connection. </p>
        pub fn state(mut self, input: crate::model::PeeringState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the peering connection. </p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::PeeringState>) -> Self {
            self.state = input; self
        }
        /// <p>The edge location for the peer.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The edge location for the peer.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The resource ARN of the peer.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The resource ARN of the peer.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the peering.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The list of key-value tags associated with the peering.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// <p>The timestamp when the attachment peer was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when the attachment peer was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// Consumes the builder and constructs a [`Peering`](crate::model::Peering).
        pub fn build(self) -> crate::model::Peering {
            crate::model::Peering {
                core_network_id: self.core_network_id
                ,
                core_network_arn: self.core_network_arn
                ,
                peering_id: self.peering_id
                ,
                owner_account_id: self.owner_account_id
                ,
                peering_type: self.peering_type
                ,
                state: self.state
                ,
                edge_location: self.edge_location
                ,
                resource_arn: self.resource_arn
                ,
                tags: self.tags
                ,
                created_at: self.created_at
                ,
            }
        }
    }
    
    
}
impl Peering {
    /// Creates a new builder-style object to manufacture [`Peering`](crate::model::Peering).
    pub fn builder() -> crate::model::peering::Builder {
        crate::model::peering::Builder::default()
    }
}

/// When writing a match expression against `PeeringState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let peeringstate = unimplemented!();
/// match peeringstate {
///     PeeringState::Available => { /* ... */ },
///     PeeringState::Creating => { /* ... */ },
///     PeeringState::Deleting => { /* ... */ },
///     PeeringState::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `peeringstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PeeringState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PeeringState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PeeringState::NewFeature` is defined.
/// Specifically, when `peeringstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PeeringState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PeeringState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PeeringState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => PeeringState::Available,
            "CREATING" => PeeringState::Creating,
            "DELETING" => PeeringState::Deleting,
            "FAILED" => PeeringState::Failed,
            other => PeeringState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PeeringState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PeeringState::from(s))
                }
            }
impl PeeringState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PeeringState::Available => "AVAILABLE",
            PeeringState::Creating => "CREATING",
            PeeringState::Deleting => "DELETING",
            PeeringState::Failed => "FAILED",
            PeeringState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "CREATING", "DELETING", "FAILED"
        ]
    }
}
impl AsRef<str> for PeeringState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PeeringType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let peeringtype = unimplemented!();
/// match peeringtype {
///     PeeringType::TransitGateway => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `peeringtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PeeringType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PeeringType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PeeringType::NewFeature` is defined.
/// Specifically, when `peeringtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PeeringType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum PeeringType {
    #[allow(missing_docs)] // documentation missing in model
    TransitGateway,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for PeeringType {
    fn from(s: &str) -> Self {
        match s {
            "TRANSIT_GATEWAY" => PeeringType::TransitGateway,
            other => PeeringType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for PeeringType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(PeeringType::from(s))
                }
            }
impl PeeringType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PeeringType::TransitGateway => "TRANSIT_GATEWAY",
            PeeringType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "TRANSIT_GATEWAY"
        ]
    }
}
impl AsRef<str> for PeeringType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns summary information about a core network.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkSummary  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>a core network ARN.</p>
    #[doc(hidden)]
    pub core_network_arn: std::option::Option<std::string::String>,
    /// <p>The global network ID.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the account owner.</p>
    #[doc(hidden)]
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>The state of a core network.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CoreNetworkState>,
    /// <p>The description of a core network.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The key-value tags associated with a core network summary.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl CoreNetworkSummary {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>a core network ARN.</p>
    pub fn core_network_arn(&self) -> std::option::Option<& str> {
        self.core_network_arn.as_deref()
    }
    /// <p>The global network ID.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the account owner.</p>
    pub fn owner_account_id(&self) -> std::option::Option<& str> {
        self.owner_account_id.as_deref()
    }
    /// <p>The state of a core network.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::CoreNetworkState> {
        self.state.as_ref()
    }
    /// <p>The description of a core network.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The key-value tags associated with a core network summary.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`CoreNetworkSummary`](crate::model::CoreNetworkSummary).
pub mod core_network_summary {
    
    /// A builder for [`CoreNetworkSummary`](crate::model::CoreNetworkSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) core_network_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::CoreNetworkState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>a core network ARN.</p>
        pub fn core_network_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_arn = Some(input.into());
            self
        }
        /// <p>a core network ARN.</p>
        pub fn set_core_network_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_arn = input; self
        }
        /// <p>The global network ID.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The global network ID.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the account owner.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The ID of the account owner.</p>
        pub fn set_owner_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner_account_id = input; self
        }
        /// <p>The state of a core network.</p>
        pub fn state(mut self, input: crate::model::CoreNetworkState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of a core network.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::CoreNetworkState>) -> Self {
            self.state = input; self
        }
        /// <p>The description of a core network.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a core network.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The key-value tags associated with a core network summary.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The key-value tags associated with a core network summary.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkSummary`](crate::model::CoreNetworkSummary).
        pub fn build(self) -> crate::model::CoreNetworkSummary {
            crate::model::CoreNetworkSummary {
                core_network_id: self.core_network_id
                ,
                core_network_arn: self.core_network_arn
                ,
                global_network_id: self.global_network_id
                ,
                owner_account_id: self.owner_account_id
                ,
                state: self.state
                ,
                description: self.description
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl CoreNetworkSummary {
    /// Creates a new builder-style object to manufacture [`CoreNetworkSummary`](crate::model::CoreNetworkSummary).
    pub fn builder() -> crate::model::core_network_summary::Builder {
        crate::model::core_network_summary::Builder::default()
    }
}

/// <p>Describes a core network policy version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkPolicyVersion  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the policy version.</p>
    #[doc(hidden)]
    pub policy_version_id: std::option::Option<i32>,
    /// <p>Whether a core network policy is the current policy or the most recently submitted policy.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
    /// <p>The description of a core network policy version.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp when a core network policy version was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the policy version change set.</p>
    #[doc(hidden)]
    pub change_set_state: std::option::Option<crate::model::ChangeSetState>,
}
impl CoreNetworkPolicyVersion {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the policy version.</p>
    pub fn policy_version_id(&self) -> std::option::Option<i32> {
        self.policy_version_id
    }
    /// <p>Whether a core network policy is the current policy or the most recently submitted policy.</p>
    pub fn alias(&self) -> std::option::Option<& crate::model::CoreNetworkPolicyAlias> {
        self.alias.as_ref()
    }
    /// <p>The description of a core network policy version.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The timestamp when a core network policy version was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The status of the policy version change set.</p>
    pub fn change_set_state(&self) -> std::option::Option<& crate::model::ChangeSetState> {
        self.change_set_state.as_ref()
    }
}
/// See [`CoreNetworkPolicyVersion`](crate::model::CoreNetworkPolicyVersion).
pub mod core_network_policy_version {
    
    /// A builder for [`CoreNetworkPolicyVersion`](crate::model::CoreNetworkPolicyVersion).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) policy_version_id: std::option::Option<i32>,
        pub(crate) alias: std::option::Option<crate::model::CoreNetworkPolicyAlias>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) change_set_state: std::option::Option<crate::model::ChangeSetState>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ID of the policy version.</p>
        pub fn policy_version_id(mut self, input: i32) -> Self {
            self.policy_version_id = Some(input);
            self
        }
        /// <p>The ID of the policy version.</p>
        pub fn set_policy_version_id(mut self, input: std::option::Option<i32>) -> Self {
            self.policy_version_id = input; self
        }
        /// <p>Whether a core network policy is the current policy or the most recently submitted policy.</p>
        pub fn alias(mut self, input: crate::model::CoreNetworkPolicyAlias) -> Self {
            self.alias = Some(input);
            self
        }
        /// <p>Whether a core network policy is the current policy or the most recently submitted policy.</p>
        pub fn set_alias(mut self, input: std::option::Option<crate::model::CoreNetworkPolicyAlias>) -> Self {
            self.alias = input; self
        }
        /// <p>The description of a core network policy version.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a core network policy version.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>The timestamp when a core network policy version was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when a core network policy version was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The status of the policy version change set.</p>
        pub fn change_set_state(mut self, input: crate::model::ChangeSetState) -> Self {
            self.change_set_state = Some(input);
            self
        }
        /// <p>The status of the policy version change set.</p>
        pub fn set_change_set_state(mut self, input: std::option::Option<crate::model::ChangeSetState>) -> Self {
            self.change_set_state = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkPolicyVersion`](crate::model::CoreNetworkPolicyVersion).
        pub fn build(self) -> crate::model::CoreNetworkPolicyVersion {
            crate::model::CoreNetworkPolicyVersion {
                core_network_id: self.core_network_id
                ,
                policy_version_id: self.policy_version_id
                ,
                alias: self.alias
                ,
                description: self.description
                ,
                created_at: self.created_at
                ,
                change_set_state: self.change_set_state
                ,
            }
        }
    }
    
    
}
impl CoreNetworkPolicyVersion {
    /// Creates a new builder-style object to manufacture [`CoreNetworkPolicyVersion`](crate::model::CoreNetworkPolicyVersion).
    pub fn builder() -> crate::model::core_network_policy_version::Builder {
        crate::model::core_network_policy_version::Builder::default()
    }
}

/// <p>Summary description of a Connect peer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectPeerSummary  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of a Connect peer attachment.</p>
    #[doc(hidden)]
    pub connect_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of a Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
    /// <p>The Region where the edge is located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The state of a Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_state: std::option::Option<crate::model::ConnectPeerState>,
    /// <p>The timestamp when a Connect peer was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The list of key-value tags associated with the Connect peer summary.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ConnectPeerSummary {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of a Connect peer attachment.</p>
    pub fn connect_attachment_id(&self) -> std::option::Option<& str> {
        self.connect_attachment_id.as_deref()
    }
    /// <p>The ID of a Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<& str> {
        self.connect_peer_id.as_deref()
    }
    /// <p>The Region where the edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The state of a Connect peer.</p>
    pub fn connect_peer_state(&self) -> std::option::Option<& crate::model::ConnectPeerState> {
        self.connect_peer_state.as_ref()
    }
    /// <p>The timestamp when a Connect peer was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The list of key-value tags associated with the Connect peer summary.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`ConnectPeerSummary`](crate::model::ConnectPeerSummary).
pub mod connect_peer_summary {
    
    /// A builder for [`ConnectPeerSummary`](crate::model::ConnectPeerSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_attachment_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) connect_peer_state: std::option::Option<crate::model::ConnectPeerState>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ID of a Connect peer attachment.</p>
        pub fn connect_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of a Connect peer attachment.</p>
        pub fn set_connect_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connect_attachment_id = input; self
        }
        /// <p>The ID of a Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of a Connect peer.</p>
        pub fn set_connect_peer_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connect_peer_id = input; self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the edge is located.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The state of a Connect peer.</p>
        pub fn connect_peer_state(mut self, input: crate::model::ConnectPeerState) -> Self {
            self.connect_peer_state = Some(input);
            self
        }
        /// <p>The state of a Connect peer.</p>
        pub fn set_connect_peer_state(mut self, input: std::option::Option<crate::model::ConnectPeerState>) -> Self {
            self.connect_peer_state = input; self
        }
        /// <p>The timestamp when a Connect peer was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when a Connect peer was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the Connect peer summary.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The list of key-value tags associated with the Connect peer summary.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`ConnectPeerSummary`](crate::model::ConnectPeerSummary).
        pub fn build(self) -> crate::model::ConnectPeerSummary {
            crate::model::ConnectPeerSummary {
                core_network_id: self.core_network_id
                ,
                connect_attachment_id: self.connect_attachment_id
                ,
                connect_peer_id: self.connect_peer_id
                ,
                edge_location: self.edge_location
                ,
                connect_peer_state: self.connect_peer_state
                ,
                created_at: self.created_at
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl ConnectPeerSummary {
    /// Creates a new builder-style object to manufacture [`ConnectPeerSummary`](crate::model::ConnectPeerSummary).
    pub fn builder() -> crate::model::connect_peer_summary::Builder {
        crate::model::connect_peer_summary::Builder::default()
    }
}

/// When writing a match expression against `ConnectPeerState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let connectpeerstate = unimplemented!();
/// match connectpeerstate {
///     ConnectPeerState::Available => { /* ... */ },
///     ConnectPeerState::Creating => { /* ... */ },
///     ConnectPeerState::Deleting => { /* ... */ },
///     ConnectPeerState::Failed => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectpeerstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectPeerState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectPeerState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectPeerState::NewFeature` is defined.
/// Specifically, when `connectpeerstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectPeerState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ConnectPeerState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ConnectPeerState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => ConnectPeerState::Available,
            "CREATING" => ConnectPeerState::Creating,
            "DELETING" => ConnectPeerState::Deleting,
            "FAILED" => ConnectPeerState::Failed,
            other => ConnectPeerState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ConnectPeerState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ConnectPeerState::from(s))
                }
            }
impl ConnectPeerState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectPeerState::Available => "AVAILABLE",
            ConnectPeerState::Creating => "CREATING",
            ConnectPeerState::Deleting => "DELETING",
            ConnectPeerState::Failed => "FAILED",
            ConnectPeerState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "CREATING", "DELETING", "FAILED"
        ]
    }
}
impl AsRef<str> for ConnectPeerState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a transit gateway route table attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransitGatewayRouteTableAttachment  {
    /// <p>Describes a core network attachment.</p>
    #[doc(hidden)]
    pub attachment: std::option::Option<crate::model::Attachment>,
    /// <p>The ID of the peering attachment.</p>
    #[doc(hidden)]
    pub peering_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the transit gateway attachment route table.</p>
    #[doc(hidden)]
    pub transit_gateway_route_table_arn: std::option::Option<std::string::String>,
}
impl TransitGatewayRouteTableAttachment {
    /// <p>Describes a core network attachment.</p>
    pub fn attachment(&self) -> std::option::Option<& crate::model::Attachment> {
        self.attachment.as_ref()
    }
    /// <p>The ID of the peering attachment.</p>
    pub fn peering_id(&self) -> std::option::Option<& str> {
        self.peering_id.as_deref()
    }
    /// <p>The ARN of the transit gateway attachment route table.</p>
    pub fn transit_gateway_route_table_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_route_table_arn.as_deref()
    }
}
/// See [`TransitGatewayRouteTableAttachment`](crate::model::TransitGatewayRouteTableAttachment).
pub mod transit_gateway_route_table_attachment {
    
    /// A builder for [`TransitGatewayRouteTableAttachment`](crate::model::TransitGatewayRouteTableAttachment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment: std::option::Option<crate::model::Attachment>,
        pub(crate) peering_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_route_table_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Describes a core network attachment.</p>
        pub fn attachment(mut self, input: crate::model::Attachment) -> Self {
            self.attachment = Some(input);
            self
        }
        /// <p>Describes a core network attachment.</p>
        pub fn set_attachment(mut self, input: std::option::Option<crate::model::Attachment>) -> Self {
            self.attachment = input; self
        }
        /// <p>The ID of the peering attachment.</p>
        pub fn peering_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.peering_id = Some(input.into());
            self
        }
        /// <p>The ID of the peering attachment.</p>
        pub fn set_peering_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peering_id = input; self
        }
        /// <p>The ARN of the transit gateway attachment route table.</p>
        pub fn transit_gateway_route_table_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_route_table_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway attachment route table.</p>
        pub fn set_transit_gateway_route_table_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_route_table_arn = input; self
        }
        /// Consumes the builder and constructs a [`TransitGatewayRouteTableAttachment`](crate::model::TransitGatewayRouteTableAttachment).
        pub fn build(self) -> crate::model::TransitGatewayRouteTableAttachment {
            crate::model::TransitGatewayRouteTableAttachment {
                attachment: self.attachment
                ,
                peering_id: self.peering_id
                ,
                transit_gateway_route_table_arn: self.transit_gateway_route_table_arn
                ,
            }
        }
    }
    
    
}
impl TransitGatewayRouteTableAttachment {
    /// Creates a new builder-style object to manufacture [`TransitGatewayRouteTableAttachment`](crate::model::TransitGatewayRouteTableAttachment).
    pub fn builder() -> crate::model::transit_gateway_route_table_attachment::Builder {
        crate::model::transit_gateway_route_table_attachment::Builder::default()
    }
}

/// <p>Describes a transit gateway peering attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransitGatewayPeering  {
    /// <p>Describes a transit gateway peer connection.</p>
    #[doc(hidden)]
    pub peering: std::option::Option<crate::model::Peering>,
    /// <p>The ARN of the transit gateway.</p>
    #[doc(hidden)]
    pub transit_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway peering attachment.</p>
    #[doc(hidden)]
    pub transit_gateway_peering_attachment_id: std::option::Option<std::string::String>,
}
impl TransitGatewayPeering {
    /// <p>Describes a transit gateway peer connection.</p>
    pub fn peering(&self) -> std::option::Option<& crate::model::Peering> {
        self.peering.as_ref()
    }
    /// <p>The ARN of the transit gateway.</p>
    pub fn transit_gateway_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_arn.as_deref()
    }
    /// <p>The ID of the transit gateway peering attachment.</p>
    pub fn transit_gateway_peering_attachment_id(&self) -> std::option::Option<& str> {
        self.transit_gateway_peering_attachment_id.as_deref()
    }
}
/// See [`TransitGatewayPeering`](crate::model::TransitGatewayPeering).
pub mod transit_gateway_peering {
    
    /// A builder for [`TransitGatewayPeering`](crate::model::TransitGatewayPeering).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) peering: std::option::Option<crate::model::Peering>,
        pub(crate) transit_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_peering_attachment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Describes a transit gateway peer connection.</p>
        pub fn peering(mut self, input: crate::model::Peering) -> Self {
            self.peering = Some(input);
            self
        }
        /// <p>Describes a transit gateway peer connection.</p>
        pub fn set_peering(mut self, input: std::option::Option<crate::model::Peering>) -> Self {
            self.peering = input; self
        }
        /// <p>The ARN of the transit gateway.</p>
        pub fn transit_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway.</p>
        pub fn set_transit_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_arn = input; self
        }
        /// <p>The ID of the transit gateway peering attachment.</p>
        pub fn transit_gateway_peering_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_peering_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the transit gateway peering attachment.</p>
        pub fn set_transit_gateway_peering_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_peering_attachment_id = input; self
        }
        /// Consumes the builder and constructs a [`TransitGatewayPeering`](crate::model::TransitGatewayPeering).
        pub fn build(self) -> crate::model::TransitGatewayPeering {
            crate::model::TransitGatewayPeering {
                peering: self.peering
                ,
                transit_gateway_arn: self.transit_gateway_arn
                ,
                transit_gateway_peering_attachment_id: self.transit_gateway_peering_attachment_id
                ,
            }
        }
    }
    
    
}
impl TransitGatewayPeering {
    /// Creates a new builder-style object to manufacture [`TransitGatewayPeering`](crate::model::TransitGatewayPeering).
    pub fn builder() -> crate::model::transit_gateway_peering::Builder {
        crate::model::transit_gateway_peering::Builder::default()
    }
}

/// <p>Describes a transit gateway Connect peer association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TransitGatewayConnectPeerAssociation  {
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    #[doc(hidden)]
    pub transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The state of the association.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::TransitGatewayConnectPeerAssociationState>,
}
impl TransitGatewayConnectPeerAssociation {
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    pub fn transit_gateway_connect_peer_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_connect_peer_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<& str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<& str> {
        self.link_id.as_deref()
    }
    /// <p>The state of the association.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::TransitGatewayConnectPeerAssociationState> {
        self.state.as_ref()
    }
}
/// See [`TransitGatewayConnectPeerAssociation`](crate::model::TransitGatewayConnectPeerAssociation).
pub mod transit_gateway_connect_peer_association {
    
    /// A builder for [`TransitGatewayConnectPeerAssociation`](crate::model::TransitGatewayConnectPeerAssociation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_connect_peer_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::TransitGatewayConnectPeerAssociationState>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
        pub fn transit_gateway_connect_peer_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_connect_peer_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
        pub fn set_transit_gateway_connect_peer_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_connect_peer_arn = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input; self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input; self
        }
        /// <p>The state of the association.</p>
        pub fn state(mut self, input: crate::model::TransitGatewayConnectPeerAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the association.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::TransitGatewayConnectPeerAssociationState>) -> Self {
            self.state = input; self
        }
        /// Consumes the builder and constructs a [`TransitGatewayConnectPeerAssociation`](crate::model::TransitGatewayConnectPeerAssociation).
        pub fn build(self) -> crate::model::TransitGatewayConnectPeerAssociation {
            crate::model::TransitGatewayConnectPeerAssociation {
                transit_gateway_connect_peer_arn: self.transit_gateway_connect_peer_arn
                ,
                global_network_id: self.global_network_id
                ,
                device_id: self.device_id
                ,
                link_id: self.link_id
                ,
                state: self.state
                ,
            }
        }
    }
    
    
}
impl TransitGatewayConnectPeerAssociation {
    /// Creates a new builder-style object to manufacture [`TransitGatewayConnectPeerAssociation`](crate::model::TransitGatewayConnectPeerAssociation).
    pub fn builder() -> crate::model::transit_gateway_connect_peer_association::Builder {
        crate::model::transit_gateway_connect_peer_association::Builder::default()
    }
}

/// When writing a match expression against `TransitGatewayConnectPeerAssociationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let transitgatewayconnectpeerassociationstate = unimplemented!();
/// match transitgatewayconnectpeerassociationstate {
///     TransitGatewayConnectPeerAssociationState::Available => { /* ... */ },
///     TransitGatewayConnectPeerAssociationState::Deleted => { /* ... */ },
///     TransitGatewayConnectPeerAssociationState::Deleting => { /* ... */ },
///     TransitGatewayConnectPeerAssociationState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `transitgatewayconnectpeerassociationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TransitGatewayConnectPeerAssociationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TransitGatewayConnectPeerAssociationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TransitGatewayConnectPeerAssociationState::NewFeature` is defined.
/// Specifically, when `transitgatewayconnectpeerassociationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TransitGatewayConnectPeerAssociationState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum TransitGatewayConnectPeerAssociationState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for TransitGatewayConnectPeerAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => TransitGatewayConnectPeerAssociationState::Available,
            "DELETED" => TransitGatewayConnectPeerAssociationState::Deleted,
            "DELETING" => TransitGatewayConnectPeerAssociationState::Deleting,
            "PENDING" => TransitGatewayConnectPeerAssociationState::Pending,
            other => TransitGatewayConnectPeerAssociationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for TransitGatewayConnectPeerAssociationState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(TransitGatewayConnectPeerAssociationState::from(s))
                }
            }
impl TransitGatewayConnectPeerAssociationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TransitGatewayConnectPeerAssociationState::Available => "AVAILABLE",
            TransitGatewayConnectPeerAssociationState::Deleted => "DELETED",
            TransitGatewayConnectPeerAssociationState::Deleting => "DELETING",
            TransitGatewayConnectPeerAssociationState::Pending => "PENDING",
            TransitGatewayConnectPeerAssociationState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETED", "DELETING", "PENDING"
        ]
    }
}
impl AsRef<str> for TransitGatewayConnectPeerAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Creates a site-to-site VPN attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SiteToSiteVpnAttachment  {
    /// <p>Provides details about a site-to-site VPN attachment.</p>
    #[doc(hidden)]
    pub attachment: std::option::Option<crate::model::Attachment>,
    /// <p>The ARN of the site-to-site VPN attachment. </p>
    #[doc(hidden)]
    pub vpn_connection_arn: std::option::Option<std::string::String>,
}
impl SiteToSiteVpnAttachment {
    /// <p>Provides details about a site-to-site VPN attachment.</p>
    pub fn attachment(&self) -> std::option::Option<& crate::model::Attachment> {
        self.attachment.as_ref()
    }
    /// <p>The ARN of the site-to-site VPN attachment. </p>
    pub fn vpn_connection_arn(&self) -> std::option::Option<& str> {
        self.vpn_connection_arn.as_deref()
    }
}
/// See [`SiteToSiteVpnAttachment`](crate::model::SiteToSiteVpnAttachment).
pub mod site_to_site_vpn_attachment {
    
    /// A builder for [`SiteToSiteVpnAttachment`](crate::model::SiteToSiteVpnAttachment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment: std::option::Option<crate::model::Attachment>,
        pub(crate) vpn_connection_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Provides details about a site-to-site VPN attachment.</p>
        pub fn attachment(mut self, input: crate::model::Attachment) -> Self {
            self.attachment = Some(input);
            self
        }
        /// <p>Provides details about a site-to-site VPN attachment.</p>
        pub fn set_attachment(mut self, input: std::option::Option<crate::model::Attachment>) -> Self {
            self.attachment = input; self
        }
        /// <p>The ARN of the site-to-site VPN attachment. </p>
        pub fn vpn_connection_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpn_connection_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the site-to-site VPN attachment. </p>
        pub fn set_vpn_connection_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.vpn_connection_arn = input; self
        }
        /// Consumes the builder and constructs a [`SiteToSiteVpnAttachment`](crate::model::SiteToSiteVpnAttachment).
        pub fn build(self) -> crate::model::SiteToSiteVpnAttachment {
            crate::model::SiteToSiteVpnAttachment {
                attachment: self.attachment
                ,
                vpn_connection_arn: self.vpn_connection_arn
                ,
            }
        }
    }
    
    
}
impl SiteToSiteVpnAttachment {
    /// Creates a new builder-style object to manufacture [`SiteToSiteVpnAttachment`](crate::model::SiteToSiteVpnAttachment).
    pub fn builder() -> crate::model::site_to_site_vpn_attachment::Builder {
        crate::model::site_to_site_vpn_attachment::Builder::default()
    }
}

/// <p>Describes the telemetry information for a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkTelemetry  {
    /// <p>The ARN of the gateway.</p>
    #[doc(hidden)]
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>The address.</p>
    #[doc(hidden)]
    pub address: std::option::Option<std::string::String>,
    /// <p>The connection health.</p>
    #[doc(hidden)]
    pub health: std::option::Option<crate::model::ConnectionHealth>,
}
impl NetworkTelemetry {
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<& str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<& str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<& str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the resource.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>The address.</p>
    pub fn address(&self) -> std::option::Option<& str> {
        self.address.as_deref()
    }
    /// <p>The connection health.</p>
    pub fn health(&self) -> std::option::Option<& crate::model::ConnectionHealth> {
        self.health.as_ref()
    }
}
/// See [`NetworkTelemetry`](crate::model::NetworkTelemetry).
pub mod network_telemetry {
    
    /// A builder for [`NetworkTelemetry`](crate::model::NetworkTelemetry).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) health: std::option::Option<crate::model::ConnectionHealth>,
    }
    impl Builder {
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registered_gateway_arn = input; self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input; self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// <p>The address.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The address.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input; self
        }
        /// <p>The connection health.</p>
        pub fn health(mut self, input: crate::model::ConnectionHealth) -> Self {
            self.health = Some(input);
            self
        }
        /// <p>The connection health.</p>
        pub fn set_health(mut self, input: std::option::Option<crate::model::ConnectionHealth>) -> Self {
            self.health = input; self
        }
        /// Consumes the builder and constructs a [`NetworkTelemetry`](crate::model::NetworkTelemetry).
        pub fn build(self) -> crate::model::NetworkTelemetry {
            crate::model::NetworkTelemetry {
                registered_gateway_arn: self.registered_gateway_arn
                ,
                core_network_id: self.core_network_id
                ,
                aws_region: self.aws_region
                ,
                account_id: self.account_id
                ,
                resource_type: self.resource_type
                ,
                resource_id: self.resource_id
                ,
                resource_arn: self.resource_arn
                ,
                address: self.address
                ,
                health: self.health
                ,
            }
        }
    }
    
    
}
impl NetworkTelemetry {
    /// Creates a new builder-style object to manufacture [`NetworkTelemetry`](crate::model::NetworkTelemetry).
    pub fn builder() -> crate::model::network_telemetry::Builder {
        crate::model::network_telemetry::Builder::default()
    }
}

/// <p>Describes connection health.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionHealth  {
    /// <p>The connection type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ConnectionType>,
    /// <p>The connection status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ConnectionStatus>,
    /// <p>The time the status was last updated.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl ConnectionHealth {
    /// <p>The connection type.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::ConnectionType> {
        self.r#type.as_ref()
    }
    /// <p>The connection status.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::ConnectionStatus> {
        self.status.as_ref()
    }
    /// <p>The time the status was last updated.</p>
    pub fn timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
}
/// See [`ConnectionHealth`](crate::model::ConnectionHealth).
pub mod connection_health {
    
    /// A builder for [`ConnectionHealth`](crate::model::ConnectionHealth).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ConnectionType>,
        pub(crate) status: std::option::Option<crate::model::ConnectionStatus>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The connection type.</p>
        pub fn r#type(mut self, input: crate::model::ConnectionType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The connection type.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ConnectionType>) -> Self {
            self.r#type = input; self
        }
        /// <p>The connection status.</p>
        pub fn status(mut self, input: crate::model::ConnectionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The connection status.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ConnectionStatus>) -> Self {
            self.status = input; self
        }
        /// <p>The time the status was last updated.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The time the status was last updated.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.timestamp = input; self
        }
        /// Consumes the builder and constructs a [`ConnectionHealth`](crate::model::ConnectionHealth).
        pub fn build(self) -> crate::model::ConnectionHealth {
            crate::model::ConnectionHealth {
                r#type: self.r#type
                ,
                status: self.status
                ,
                timestamp: self.timestamp
                ,
            }
        }
    }
    
    
}
impl ConnectionHealth {
    /// Creates a new builder-style object to manufacture [`ConnectionHealth`](crate::model::ConnectionHealth).
    pub fn builder() -> crate::model::connection_health::Builder {
        crate::model::connection_health::Builder::default()
    }
}

/// When writing a match expression against `ConnectionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let connectionstatus = unimplemented!();
/// match connectionstatus {
///     ConnectionStatus::Down => { /* ... */ },
///     ConnectionStatus::Up => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionStatus::NewFeature` is defined.
/// Specifically, when `connectionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionStatus::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ConnectionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Down,
    #[allow(missing_docs)] // documentation missing in model
    Up,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ConnectionStatus {
    fn from(s: &str) -> Self {
        match s {
            "DOWN" => ConnectionStatus::Down,
            "UP" => ConnectionStatus::Up,
            other => ConnectionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ConnectionStatus {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ConnectionStatus::from(s))
                }
            }
impl ConnectionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionStatus::Down => "DOWN",
            ConnectionStatus::Up => "UP",
            ConnectionStatus::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DOWN", "UP"
        ]
    }
}
impl AsRef<str> for ConnectionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConnectionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let connectiontype = unimplemented!();
/// match connectiontype {
///     ConnectionType::Bgp => { /* ... */ },
///     ConnectionType::Ipsec => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionType::NewFeature` is defined.
/// Specifically, when `connectiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ConnectionType {
    #[allow(missing_docs)] // documentation missing in model
    Bgp,
    #[allow(missing_docs)] // documentation missing in model
    Ipsec,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ConnectionType {
    fn from(s: &str) -> Self {
        match s {
            "BGP" => ConnectionType::Bgp,
            "IPSEC" => ConnectionType::Ipsec,
            other => ConnectionType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ConnectionType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ConnectionType::from(s))
                }
            }
impl ConnectionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionType::Bgp => "BGP",
            ConnectionType::Ipsec => "IPSEC",
            ConnectionType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BGP", "IPSEC"
        ]
    }
}
impl AsRef<str> for ConnectionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a network route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkRoute  {
    /// <p>A unique identifier for the route, such as a CIDR block.</p>
    #[doc(hidden)]
    pub destination_cidr_block: std::option::Option<std::string::String>,
    /// <p>The destinations.</p>
    #[doc(hidden)]
    pub destinations: std::option::Option<std::vec::Vec<crate::model::NetworkRouteDestination>>,
    /// <p>The ID of the prefix list.</p>
    #[doc(hidden)]
    pub prefix_list_id: std::option::Option<std::string::String>,
    /// <p>The route state. The possible values are <code>active</code> and <code>blackhole</code>.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::RouteState>,
    /// <p>The route type. The possible values are <code>propagated</code> and <code>static</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::RouteType>,
}
impl NetworkRoute {
    /// <p>A unique identifier for the route, such as a CIDR block.</p>
    pub fn destination_cidr_block(&self) -> std::option::Option<& str> {
        self.destination_cidr_block.as_deref()
    }
    /// <p>The destinations.</p>
    pub fn destinations(&self) -> std::option::Option<& [crate::model::NetworkRouteDestination]> {
        self.destinations.as_deref()
    }
    /// <p>The ID of the prefix list.</p>
    pub fn prefix_list_id(&self) -> std::option::Option<& str> {
        self.prefix_list_id.as_deref()
    }
    /// <p>The route state. The possible values are <code>active</code> and <code>blackhole</code>.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::RouteState> {
        self.state.as_ref()
    }
    /// <p>The route type. The possible values are <code>propagated</code> and <code>static</code>.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::RouteType> {
        self.r#type.as_ref()
    }
}
/// See [`NetworkRoute`](crate::model::NetworkRoute).
pub mod network_route {
    
    /// A builder for [`NetworkRoute`](crate::model::NetworkRoute).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_cidr_block: std::option::Option<std::string::String>,
        pub(crate) destinations: std::option::Option<std::vec::Vec<crate::model::NetworkRouteDestination>>,
        pub(crate) prefix_list_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::RouteState>,
        pub(crate) r#type: std::option::Option<crate::model::RouteType>,
    }
    impl Builder {
        /// <p>A unique identifier for the route, such as a CIDR block.</p>
        pub fn destination_cidr_block(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_cidr_block = Some(input.into());
            self
        }
        /// <p>A unique identifier for the route, such as a CIDR block.</p>
        pub fn set_destination_cidr_block(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_cidr_block = input; self
        }
        /// Appends an item to `destinations`.
        ///
        /// To override the contents of this collection use [`set_destinations`](Self::set_destinations).
        ///
        /// <p>The destinations.</p>
        pub fn destinations(mut self, input: crate::model::NetworkRouteDestination) -> Self {
            let mut v = self.destinations.unwrap_or_default();
                            v.push(input);
                            self.destinations = Some(v);
                            self
        }
        /// <p>The destinations.</p>
        pub fn set_destinations(mut self, input: std::option::Option<std::vec::Vec<crate::model::NetworkRouteDestination>>) -> Self {
            self.destinations = input; self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn prefix_list_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.prefix_list_id = Some(input.into());
            self
        }
        /// <p>The ID of the prefix list.</p>
        pub fn set_prefix_list_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.prefix_list_id = input; self
        }
        /// <p>The route state. The possible values are <code>active</code> and <code>blackhole</code>.</p>
        pub fn state(mut self, input: crate::model::RouteState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The route state. The possible values are <code>active</code> and <code>blackhole</code>.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::RouteState>) -> Self {
            self.state = input; self
        }
        /// <p>The route type. The possible values are <code>propagated</code> and <code>static</code>.</p>
        pub fn r#type(mut self, input: crate::model::RouteType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The route type. The possible values are <code>propagated</code> and <code>static</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::RouteType>) -> Self {
            self.r#type = input; self
        }
        /// Consumes the builder and constructs a [`NetworkRoute`](crate::model::NetworkRoute).
        pub fn build(self) -> crate::model::NetworkRoute {
            crate::model::NetworkRoute {
                destination_cidr_block: self.destination_cidr_block
                ,
                destinations: self.destinations
                ,
                prefix_list_id: self.prefix_list_id
                ,
                state: self.state
                ,
                r#type: self.r#type
                ,
            }
        }
    }
    
    
}
impl NetworkRoute {
    /// Creates a new builder-style object to manufacture [`NetworkRoute`](crate::model::NetworkRoute).
    pub fn builder() -> crate::model::network_route::Builder {
        crate::model::network_route::Builder::default()
    }
}

/// When writing a match expression against `RouteType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let routetype = unimplemented!();
/// match routetype {
///     RouteType::Propagated => { /* ... */ },
///     RouteType::Static => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `routetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RouteType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RouteType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RouteType::NewFeature` is defined.
/// Specifically, when `routetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RouteType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RouteType {
    #[allow(missing_docs)] // documentation missing in model
    Propagated,
    #[allow(missing_docs)] // documentation missing in model
    Static,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RouteType {
    fn from(s: &str) -> Self {
        match s {
            "PROPAGATED" => RouteType::Propagated,
            "STATIC" => RouteType::Static,
            other => RouteType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RouteType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RouteType::from(s))
                }
            }
impl RouteType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RouteType::Propagated => "PROPAGATED",
            RouteType::Static => "STATIC",
            RouteType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "PROPAGATED", "STATIC"
        ]
    }
}
impl AsRef<str> for RouteType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RouteState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let routestate = unimplemented!();
/// match routestate {
///     RouteState::Active => { /* ... */ },
///     RouteState::Blackhole => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `routestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RouteState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RouteState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RouteState::NewFeature` is defined.
/// Specifically, when `routestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RouteState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RouteState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Blackhole,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RouteState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => RouteState::Active,
            "BLACKHOLE" => RouteState::Blackhole,
            other => RouteState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RouteState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RouteState::from(s))
                }
            }
impl RouteState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RouteState::Active => "ACTIVE",
            RouteState::Blackhole => "BLACKHOLE",
            RouteState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE", "BLACKHOLE"
        ]
    }
}
impl AsRef<str> for RouteState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the destination of a network route.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkRouteDestination  {
    /// <p>The ID of a core network attachment.</p>
    #[doc(hidden)]
    pub core_network_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the transit gateway attachment.</p>
    #[doc(hidden)]
    pub transit_gateway_attachment_id: std::option::Option<std::string::String>,
    /// <p>The name of the segment.</p>
    #[doc(hidden)]
    pub segment_name: std::option::Option<std::string::String>,
    /// <p>The edge location for the network destination.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
}
impl NetworkRouteDestination {
    /// <p>The ID of a core network attachment.</p>
    pub fn core_network_attachment_id(&self) -> std::option::Option<& str> {
        self.core_network_attachment_id.as_deref()
    }
    /// <p>The ID of the transit gateway attachment.</p>
    pub fn transit_gateway_attachment_id(&self) -> std::option::Option<& str> {
        self.transit_gateway_attachment_id.as_deref()
    }
    /// <p>The name of the segment.</p>
    pub fn segment_name(&self) -> std::option::Option<& str> {
        self.segment_name.as_deref()
    }
    /// <p>The edge location for the network destination.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<& str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the resource.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
}
/// See [`NetworkRouteDestination`](crate::model::NetworkRouteDestination).
pub mod network_route_destination {
    
    /// A builder for [`NetworkRouteDestination`](crate::model::NetworkRouteDestination).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_attachment_id: std::option::Option<std::string::String>,
        pub(crate) transit_gateway_attachment_id: std::option::Option<std::string::String>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network attachment.</p>
        pub fn core_network_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network attachment.</p>
        pub fn set_core_network_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_attachment_id = input; self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn transit_gateway_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the transit gateway attachment.</p>
        pub fn set_transit_gateway_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_attachment_id = input; self
        }
        /// <p>The name of the segment.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The name of the segment.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input; self
        }
        /// <p>The edge location for the network destination.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The edge location for the network destination.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// Consumes the builder and constructs a [`NetworkRouteDestination`](crate::model::NetworkRouteDestination).
        pub fn build(self) -> crate::model::NetworkRouteDestination {
            crate::model::NetworkRouteDestination {
                core_network_attachment_id: self.core_network_attachment_id
                ,
                transit_gateway_attachment_id: self.transit_gateway_attachment_id
                ,
                segment_name: self.segment_name
                ,
                edge_location: self.edge_location
                ,
                resource_type: self.resource_type
                ,
                resource_id: self.resource_id
                ,
            }
        }
    }
    
    
}
impl NetworkRouteDestination {
    /// Creates a new builder-style object to manufacture [`NetworkRouteDestination`](crate::model::NetworkRouteDestination).
    pub fn builder() -> crate::model::network_route_destination::Builder {
        crate::model::network_route_destination::Builder::default()
    }
}

/// When writing a match expression against `RouteTableType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let routetabletype = unimplemented!();
/// match routetabletype {
///     RouteTableType::CoreNetworkSegment => { /* ... */ },
///     RouteTableType::TransitGatewayRouteTable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `routetabletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RouteTableType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RouteTableType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RouteTableType::NewFeature` is defined.
/// Specifically, when `routetabletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RouteTableType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum RouteTableType {
    #[allow(missing_docs)] // documentation missing in model
    CoreNetworkSegment,
    #[allow(missing_docs)] // documentation missing in model
    TransitGatewayRouteTable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for RouteTableType {
    fn from(s: &str) -> Self {
        match s {
            "CORE_NETWORK_SEGMENT" => RouteTableType::CoreNetworkSegment,
            "TRANSIT_GATEWAY_ROUTE_TABLE" => RouteTableType::TransitGatewayRouteTable,
            other => RouteTableType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for RouteTableType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(RouteTableType::from(s))
                }
            }
impl RouteTableType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RouteTableType::CoreNetworkSegment => "CORE_NETWORK_SEGMENT",
            RouteTableType::TransitGatewayRouteTable => "TRANSIT_GATEWAY_ROUTE_TABLE",
            RouteTableType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CORE_NETWORK_SEGMENT", "TRANSIT_GATEWAY_ROUTE_TABLE"
        ]
    }
}
impl AsRef<str> for RouteTableType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns details about a core network edge.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkSegmentEdgeIdentifier  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The name of the segment edge.</p>
    #[doc(hidden)]
    pub segment_name: std::option::Option<std::string::String>,
    /// <p>The Region where the segment edge is located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
}
impl CoreNetworkSegmentEdgeIdentifier {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The name of the segment edge.</p>
    pub fn segment_name(&self) -> std::option::Option<& str> {
        self.segment_name.as_deref()
    }
    /// <p>The Region where the segment edge is located.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
}
/// See [`CoreNetworkSegmentEdgeIdentifier`](crate::model::CoreNetworkSegmentEdgeIdentifier).
pub mod core_network_segment_edge_identifier {
    
    /// A builder for [`CoreNetworkSegmentEdgeIdentifier`](crate::model::CoreNetworkSegmentEdgeIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The name of the segment edge.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The name of the segment edge.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input; self
        }
        /// <p>The Region where the segment edge is located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Region where the segment edge is located.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkSegmentEdgeIdentifier`](crate::model::CoreNetworkSegmentEdgeIdentifier).
        pub fn build(self) -> crate::model::CoreNetworkSegmentEdgeIdentifier {
            crate::model::CoreNetworkSegmentEdgeIdentifier {
                core_network_id: self.core_network_id
                ,
                segment_name: self.segment_name
                ,
                edge_location: self.edge_location
                ,
            }
        }
    }
    
    
}
impl CoreNetworkSegmentEdgeIdentifier {
    /// Creates a new builder-style object to manufacture [`CoreNetworkSegmentEdgeIdentifier`](crate::model::CoreNetworkSegmentEdgeIdentifier).
    pub fn builder() -> crate::model::core_network_segment_edge_identifier::Builder {
        crate::model::core_network_segment_edge_identifier::Builder::default()
    }
}

/// <p>Describes a route table.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RouteTableIdentifier  {
    /// <p>The ARN of the transit gateway route table.</p>
    #[doc(hidden)]
    pub transit_gateway_route_table_arn: std::option::Option<std::string::String>,
    /// <p>The segment edge in a core network.</p>
    #[doc(hidden)]
    pub core_network_segment_edge: std::option::Option<crate::model::CoreNetworkSegmentEdgeIdentifier>,
}
impl RouteTableIdentifier {
    /// <p>The ARN of the transit gateway route table.</p>
    pub fn transit_gateway_route_table_arn(&self) -> std::option::Option<& str> {
        self.transit_gateway_route_table_arn.as_deref()
    }
    /// <p>The segment edge in a core network.</p>
    pub fn core_network_segment_edge(&self) -> std::option::Option<& crate::model::CoreNetworkSegmentEdgeIdentifier> {
        self.core_network_segment_edge.as_ref()
    }
}
/// See [`RouteTableIdentifier`](crate::model::RouteTableIdentifier).
pub mod route_table_identifier {
    
    /// A builder for [`RouteTableIdentifier`](crate::model::RouteTableIdentifier).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) transit_gateway_route_table_arn: std::option::Option<std::string::String>,
        pub(crate) core_network_segment_edge: std::option::Option<crate::model::CoreNetworkSegmentEdgeIdentifier>,
    }
    impl Builder {
        /// <p>The ARN of the transit gateway route table.</p>
        pub fn transit_gateway_route_table_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.transit_gateway_route_table_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the transit gateway route table.</p>
        pub fn set_transit_gateway_route_table_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transit_gateway_route_table_arn = input; self
        }
        /// <p>The segment edge in a core network.</p>
        pub fn core_network_segment_edge(mut self, input: crate::model::CoreNetworkSegmentEdgeIdentifier) -> Self {
            self.core_network_segment_edge = Some(input);
            self
        }
        /// <p>The segment edge in a core network.</p>
        pub fn set_core_network_segment_edge(mut self, input: std::option::Option<crate::model::CoreNetworkSegmentEdgeIdentifier>) -> Self {
            self.core_network_segment_edge = input; self
        }
        /// Consumes the builder and constructs a [`RouteTableIdentifier`](crate::model::RouteTableIdentifier).
        pub fn build(self) -> crate::model::RouteTableIdentifier {
            crate::model::RouteTableIdentifier {
                transit_gateway_route_table_arn: self.transit_gateway_route_table_arn
                ,
                core_network_segment_edge: self.core_network_segment_edge
                ,
            }
        }
    }
    
    
}
impl RouteTableIdentifier {
    /// Creates a new builder-style object to manufacture [`RouteTableIdentifier`](crate::model::RouteTableIdentifier).
    pub fn builder() -> crate::model::route_table_identifier::Builder {
        crate::model::route_table_identifier::Builder::default()
    }
}

/// <p>Describes a network resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkResource  {
    /// <p>The ARN of the gateway.</p>
    #[doc(hidden)]
    pub registered_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region.</p>
    #[doc(hidden)]
    pub aws_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services account ID.</p>
    #[doc(hidden)]
    pub account_id: std::option::Option<std::string::String>,
    /// <p>The resource type.</p> 
    /// <p>The following are the supported resource types for Direct Connect:</p> 
    /// <ul> 
    /// <li> <p> <code>dxcon</code> </p> </li> 
    /// <li> <p> <code>dx-gateway</code> </p> </li> 
    /// <li> <p> <code>dx-vif</code> </p> </li> 
    /// </ul> 
    /// <p>The following are the supported resource types for Network Manager:</p> 
    /// <ul> 
    /// <li> <p> <code>connection</code> </p> </li> 
    /// <li> <p> <code>device</code> </p> </li> 
    /// <li> <p> <code>link</code> </p> </li> 
    /// <li> <p> <code>site</code> </p> </li> 
    /// </ul> 
    /// <p>The following are the supported resource types for Amazon VPC:</p> 
    /// <ul> 
    /// <li> <p> <code>customer-gateway</code> </p> </li> 
    /// <li> <p> <code>transit-gateway</code> </p> </li> 
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li> 
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li> 
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li> 
    /// <li> <p> <code>vpn-connection</code> </p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The ID of the resource.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub resource_arn: std::option::Option<std::string::String>,
    /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
    #[doc(hidden)]
    pub definition: std::option::Option<std::string::String>,
    /// <p>The time that the resource definition was retrieved.</p>
    #[doc(hidden)]
    pub definition_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The resource metadata.</p>
    #[doc(hidden)]
    pub metadata: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl NetworkResource {
    /// <p>The ARN of the gateway.</p>
    pub fn registered_gateway_arn(&self) -> std::option::Option<& str> {
        self.registered_gateway_arn.as_deref()
    }
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The Amazon Web Services Region.</p>
    pub fn aws_region(&self) -> std::option::Option<& str> {
        self.aws_region.as_deref()
    }
    /// <p>The Amazon Web Services account ID.</p>
    pub fn account_id(&self) -> std::option::Option<& str> {
        self.account_id.as_deref()
    }
    /// <p>The resource type.</p> 
    /// <p>The following are the supported resource types for Direct Connect:</p> 
    /// <ul> 
    /// <li> <p> <code>dxcon</code> </p> </li> 
    /// <li> <p> <code>dx-gateway</code> </p> </li> 
    /// <li> <p> <code>dx-vif</code> </p> </li> 
    /// </ul> 
    /// <p>The following are the supported resource types for Network Manager:</p> 
    /// <ul> 
    /// <li> <p> <code>connection</code> </p> </li> 
    /// <li> <p> <code>device</code> </p> </li> 
    /// <li> <p> <code>link</code> </p> </li> 
    /// <li> <p> <code>site</code> </p> </li> 
    /// </ul> 
    /// <p>The following are the supported resource types for Amazon VPC:</p> 
    /// <ul> 
    /// <li> <p> <code>customer-gateway</code> </p> </li> 
    /// <li> <p> <code>transit-gateway</code> </p> </li> 
    /// <li> <p> <code>transit-gateway-attachment</code> </p> </li> 
    /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li> 
    /// <li> <p> <code>transit-gateway-route-table</code> </p> </li> 
    /// <li> <p> <code>vpn-connection</code> </p> </li> 
    /// </ul>
    pub fn resource_type(&self) -> std::option::Option<& str> {
        self.resource_type.as_deref()
    }
    /// <p>The ID of the resource.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn resource_arn(&self) -> std::option::Option<& str> {
        self.resource_arn.as_deref()
    }
    /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
    pub fn definition(&self) -> std::option::Option<& str> {
        self.definition.as_deref()
    }
    /// <p>The time that the resource definition was retrieved.</p>
    pub fn definition_timestamp(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.definition_timestamp.as_ref()
    }
    /// <p>The tags.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
    /// <p>The resource metadata.</p>
    pub fn metadata(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.metadata.as_ref()
    }
}
/// See [`NetworkResource`](crate::model::NetworkResource).
pub mod network_resource {
    
    /// A builder for [`NetworkResource`](crate::model::NetworkResource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registered_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) aws_region: std::option::Option<std::string::String>,
        pub(crate) account_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_arn: std::option::Option<std::string::String>,
        pub(crate) definition: std::option::Option<std::string::String>,
        pub(crate) definition_timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        pub(crate) metadata: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The ARN of the gateway.</p>
        pub fn registered_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.registered_gateway_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the gateway.</p>
        pub fn set_registered_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registered_gateway_arn = input; self
        }
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn aws_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.aws_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region.</p>
        pub fn set_aws_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.aws_region = input; self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.account_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services account ID.</p>
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.account_id = input; self
        }
        /// <p>The resource type.</p> 
        /// <p>The following are the supported resource types for Direct Connect:</p> 
        /// <ul> 
        /// <li> <p> <code>dxcon</code> </p> </li> 
        /// <li> <p> <code>dx-gateway</code> </p> </li> 
        /// <li> <p> <code>dx-vif</code> </p> </li> 
        /// </ul> 
        /// <p>The following are the supported resource types for Network Manager:</p> 
        /// <ul> 
        /// <li> <p> <code>connection</code> </p> </li> 
        /// <li> <p> <code>device</code> </p> </li> 
        /// <li> <p> <code>link</code> </p> </li> 
        /// <li> <p> <code>site</code> </p> </li> 
        /// </ul> 
        /// <p>The following are the supported resource types for Amazon VPC:</p> 
        /// <ul> 
        /// <li> <p> <code>customer-gateway</code> </p> </li> 
        /// <li> <p> <code>transit-gateway</code> </p> </li> 
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li> 
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li> 
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li> 
        /// <li> <p> <code>vpn-connection</code> </p> </li> 
        /// </ul>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p> 
        /// <p>The following are the supported resource types for Direct Connect:</p> 
        /// <ul> 
        /// <li> <p> <code>dxcon</code> </p> </li> 
        /// <li> <p> <code>dx-gateway</code> </p> </li> 
        /// <li> <p> <code>dx-vif</code> </p> </li> 
        /// </ul> 
        /// <p>The following are the supported resource types for Network Manager:</p> 
        /// <ul> 
        /// <li> <p> <code>connection</code> </p> </li> 
        /// <li> <p> <code>device</code> </p> </li> 
        /// <li> <p> <code>link</code> </p> </li> 
        /// <li> <p> <code>site</code> </p> </li> 
        /// </ul> 
        /// <p>The following are the supported resource types for Amazon VPC:</p> 
        /// <ul> 
        /// <li> <p> <code>customer-gateway</code> </p> </li> 
        /// <li> <p> <code>transit-gateway</code> </p> </li> 
        /// <li> <p> <code>transit-gateway-attachment</code> </p> </li> 
        /// <li> <p> <code>transit-gateway-connect-peer</code> </p> </li> 
        /// <li> <p> <code>transit-gateway-route-table</code> </p> </li> 
        /// <li> <p> <code>vpn-connection</code> </p> </li> 
        /// </ul>
        pub fn set_resource_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The ID of the resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The ID of the resource.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>The ARN of the resource.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_arn = input; self
        }
        /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
        pub fn definition(mut self, input: impl Into<std::string::String>) -> Self {
            self.definition = Some(input.into());
            self
        }
        /// <p>Information about the resource, in JSON format. Network Manager gets this information by describing the resource using its Describe API call.</p>
        pub fn set_definition(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.definition = input; self
        }
        /// <p>The time that the resource definition was retrieved.</p>
        pub fn definition_timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.definition_timestamp = Some(input);
            self
        }
        /// <p>The time that the resource definition was retrieved.</p>
        pub fn set_definition_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.definition_timestamp = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The tags.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Adds a key-value pair to `metadata`.
        ///
        /// To override the contents of this collection use [`set_metadata`](Self::set_metadata).
        ///
        /// <p>The resource metadata.</p>
        pub fn metadata(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.metadata.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.metadata = Some(hash_map);
                            self
        }
        /// <p>The resource metadata.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.metadata = input; self
        }
        /// Consumes the builder and constructs a [`NetworkResource`](crate::model::NetworkResource).
        pub fn build(self) -> crate::model::NetworkResource {
            crate::model::NetworkResource {
                registered_gateway_arn: self.registered_gateway_arn
                ,
                core_network_id: self.core_network_id
                ,
                aws_region: self.aws_region
                ,
                account_id: self.account_id
                ,
                resource_type: self.resource_type
                ,
                resource_id: self.resource_id
                ,
                resource_arn: self.resource_arn
                ,
                definition: self.definition
                ,
                definition_timestamp: self.definition_timestamp
                ,
                tags: self.tags
                ,
                metadata: self.metadata
                ,
            }
        }
    }
    
    
}
impl NetworkResource {
    /// Creates a new builder-style object to manufacture [`NetworkResource`](crate::model::NetworkResource).
    pub fn builder() -> crate::model::network_resource::Builder {
        crate::model::network_resource::Builder::default()
    }
}

/// <p>Describes a resource relationship.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Relationship  {
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub from: std::option::Option<std::string::String>,
    /// <p>The ARN of the resource.</p>
    #[doc(hidden)]
    pub to: std::option::Option<std::string::String>,
}
impl Relationship {
    /// <p>The ARN of the resource.</p>
    pub fn from(&self) -> std::option::Option<& str> {
        self.from.as_deref()
    }
    /// <p>The ARN of the resource.</p>
    pub fn to(&self) -> std::option::Option<& str> {
        self.to.as_deref()
    }
}
/// See [`Relationship`](crate::model::Relationship).
pub mod relationship {
    
    /// A builder for [`Relationship`](crate::model::Relationship).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from: std::option::Option<std::string::String>,
        pub(crate) to: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn from(mut self, input: impl Into<std::string::String>) -> Self {
            self.from = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_from(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from = input; self
        }
        /// <p>The ARN of the resource.</p>
        pub fn to(mut self, input: impl Into<std::string::String>) -> Self {
            self.to = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_to(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.to = input; self
        }
        /// Consumes the builder and constructs a [`Relationship`](crate::model::Relationship).
        pub fn build(self) -> crate::model::Relationship {
            crate::model::Relationship {
                from: self.from
                ,
                to: self.to
                ,
            }
        }
    }
    
    
}
impl Relationship {
    /// Creates a new builder-style object to manufacture [`Relationship`](crate::model::Relationship).
    pub fn builder() -> crate::model::relationship::Builder {
        crate::model::relationship::Builder::default()
    }
}

/// <p>Describes a resource count.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkResourceCount  {
    /// <p>The resource type.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The resource count.</p>
    #[doc(hidden)]
    pub count: std::option::Option<i32>,
}
impl NetworkResourceCount {
    /// <p>The resource type.</p>
    pub fn resource_type(&self) -> std::option::Option<& str> {
        self.resource_type.as_deref()
    }
    /// <p>The resource count.</p>
    pub fn count(&self) -> std::option::Option<i32> {
        self.count
    }
}
/// See [`NetworkResourceCount`](crate::model::NetworkResourceCount).
pub mod network_resource_count {
    
    /// A builder for [`NetworkResourceCount`](crate::model::NetworkResourceCount).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The resource type.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>The resource type.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_type = input; self
        }
        /// <p>The resource count.</p>
        pub fn count(mut self, input: i32) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The resource count.</p>
        pub fn set_count(mut self, input: std::option::Option<i32>) -> Self {
            self.count = input; self
        }
        /// Consumes the builder and constructs a [`NetworkResourceCount`](crate::model::NetworkResourceCount).
        pub fn build(self) -> crate::model::NetworkResourceCount {
            crate::model::NetworkResourceCount {
                resource_type: self.resource_type
                ,
                count: self.count
                ,
            }
        }
    }
    
    
}
impl NetworkResourceCount {
    /// Creates a new builder-style object to manufacture [`NetworkResourceCount`](crate::model::NetworkResourceCount).
    pub fn builder() -> crate::model::network_resource_count::Builder {
        crate::model::network_resource_count::Builder::default()
    }
}

/// <p>Describes the association between a device and a link.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LinkAssociation  {
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The device ID for the link association.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The state of the association.</p>
    #[doc(hidden)]
    pub link_association_state: std::option::Option<crate::model::LinkAssociationState>,
}
impl LinkAssociation {
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The device ID for the link association.</p>
    pub fn device_id(&self) -> std::option::Option<& str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<& str> {
        self.link_id.as_deref()
    }
    /// <p>The state of the association.</p>
    pub fn link_association_state(&self) -> std::option::Option<& crate::model::LinkAssociationState> {
        self.link_association_state.as_ref()
    }
}
/// See [`LinkAssociation`](crate::model::LinkAssociation).
pub mod link_association {
    
    /// A builder for [`LinkAssociation`](crate::model::LinkAssociation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) link_association_state: std::option::Option<crate::model::LinkAssociationState>,
    }
    impl Builder {
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The device ID for the link association.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The device ID for the link association.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input; self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input; self
        }
        /// <p>The state of the association.</p>
        pub fn link_association_state(mut self, input: crate::model::LinkAssociationState) -> Self {
            self.link_association_state = Some(input);
            self
        }
        /// <p>The state of the association.</p>
        pub fn set_link_association_state(mut self, input: std::option::Option<crate::model::LinkAssociationState>) -> Self {
            self.link_association_state = input; self
        }
        /// Consumes the builder and constructs a [`LinkAssociation`](crate::model::LinkAssociation).
        pub fn build(self) -> crate::model::LinkAssociation {
            crate::model::LinkAssociation {
                global_network_id: self.global_network_id
                ,
                device_id: self.device_id
                ,
                link_id: self.link_id
                ,
                link_association_state: self.link_association_state
                ,
            }
        }
    }
    
    
}
impl LinkAssociation {
    /// Creates a new builder-style object to manufacture [`LinkAssociation`](crate::model::LinkAssociation).
    pub fn builder() -> crate::model::link_association::Builder {
        crate::model::link_association::Builder::default()
    }
}

/// When writing a match expression against `LinkAssociationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let linkassociationstate = unimplemented!();
/// match linkassociationstate {
///     LinkAssociationState::Available => { /* ... */ },
///     LinkAssociationState::Deleted => { /* ... */ },
///     LinkAssociationState::Deleting => { /* ... */ },
///     LinkAssociationState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `linkassociationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LinkAssociationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LinkAssociationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LinkAssociationState::NewFeature` is defined.
/// Specifically, when `linkassociationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LinkAssociationState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum LinkAssociationState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for LinkAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => LinkAssociationState::Available,
            "DELETED" => LinkAssociationState::Deleted,
            "DELETING" => LinkAssociationState::Deleting,
            "PENDING" => LinkAssociationState::Pending,
            other => LinkAssociationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for LinkAssociationState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(LinkAssociationState::from(s))
                }
            }
impl LinkAssociationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LinkAssociationState::Available => "AVAILABLE",
            LinkAssociationState::Deleted => "DELETED",
            LinkAssociationState::Deleting => "DELETING",
            LinkAssociationState::Pending => "PENDING",
            LinkAssociationState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETED", "DELETING", "PENDING"
        ]
    }
}
impl AsRef<str> for LinkAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the association between a customer gateway, a device, and a link.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomerGatewayAssociation  {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    #[doc(hidden)]
    pub customer_gateway_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The association state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::CustomerGatewayAssociationState>,
}
impl CustomerGatewayAssociation {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    pub fn customer_gateway_arn(&self) -> std::option::Option<& str> {
        self.customer_gateway_arn.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device.</p>
    pub fn device_id(&self) -> std::option::Option<& str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<& str> {
        self.link_id.as_deref()
    }
    /// <p>The association state.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::CustomerGatewayAssociationState> {
        self.state.as_ref()
    }
}
/// See [`CustomerGatewayAssociation`](crate::model::CustomerGatewayAssociation).
pub mod customer_gateway_association {
    
    /// A builder for [`CustomerGatewayAssociation`](crate::model::CustomerGatewayAssociation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) customer_gateway_arn: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::CustomerGatewayAssociationState>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn customer_gateway_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_gateway_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
        pub fn set_customer_gateway_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.customer_gateway_arn = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the device.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input; self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input; self
        }
        /// <p>The association state.</p>
        pub fn state(mut self, input: crate::model::CustomerGatewayAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The association state.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::CustomerGatewayAssociationState>) -> Self {
            self.state = input; self
        }
        /// Consumes the builder and constructs a [`CustomerGatewayAssociation`](crate::model::CustomerGatewayAssociation).
        pub fn build(self) -> crate::model::CustomerGatewayAssociation {
            crate::model::CustomerGatewayAssociation {
                customer_gateway_arn: self.customer_gateway_arn
                ,
                global_network_id: self.global_network_id
                ,
                device_id: self.device_id
                ,
                link_id: self.link_id
                ,
                state: self.state
                ,
            }
        }
    }
    
    
}
impl CustomerGatewayAssociation {
    /// Creates a new builder-style object to manufacture [`CustomerGatewayAssociation`](crate::model::CustomerGatewayAssociation).
    pub fn builder() -> crate::model::customer_gateway_association::Builder {
        crate::model::customer_gateway_association::Builder::default()
    }
}

/// When writing a match expression against `CustomerGatewayAssociationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let customergatewayassociationstate = unimplemented!();
/// match customergatewayassociationstate {
///     CustomerGatewayAssociationState::Available => { /* ... */ },
///     CustomerGatewayAssociationState::Deleted => { /* ... */ },
///     CustomerGatewayAssociationState::Deleting => { /* ... */ },
///     CustomerGatewayAssociationState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `customergatewayassociationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CustomerGatewayAssociationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CustomerGatewayAssociationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CustomerGatewayAssociationState::NewFeature` is defined.
/// Specifically, when `customergatewayassociationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CustomerGatewayAssociationState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum CustomerGatewayAssociationState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for CustomerGatewayAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => CustomerGatewayAssociationState::Available,
            "DELETED" => CustomerGatewayAssociationState::Deleted,
            "DELETING" => CustomerGatewayAssociationState::Deleting,
            "PENDING" => CustomerGatewayAssociationState::Pending,
            other => CustomerGatewayAssociationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for CustomerGatewayAssociationState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(CustomerGatewayAssociationState::from(s))
                }
            }
impl CustomerGatewayAssociationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CustomerGatewayAssociationState::Available => "AVAILABLE",
            CustomerGatewayAssociationState::Deleted => "DELETED",
            CustomerGatewayAssociationState::Deleting => "DELETING",
            CustomerGatewayAssociationState::Pending => "PENDING",
            CustomerGatewayAssociationState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETED", "DELETING", "PENDING"
        ]
    }
}
impl AsRef<str> for CustomerGatewayAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Details describing a core network change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkChange  {
    /// <p>The type of change.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ChangeType>,
    /// <p>The action to take for a core network.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::ChangeAction>,
    /// <p>The resource identifier.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The previous values for a core network.</p>
    #[doc(hidden)]
    pub previous_values: std::option::Option<crate::model::CoreNetworkChangeValues>,
    /// <p>The new value for a core network</p>
    #[doc(hidden)]
    pub new_values: std::option::Option<crate::model::CoreNetworkChangeValues>,
    /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
    #[doc(hidden)]
    pub identifier_path: std::option::Option<std::string::String>,
}
impl CoreNetworkChange {
    /// <p>The type of change.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::ChangeType> {
        self.r#type.as_ref()
    }
    /// <p>The action to take for a core network.</p>
    pub fn action(&self) -> std::option::Option<& crate::model::ChangeAction> {
        self.action.as_ref()
    }
    /// <p>The resource identifier.</p>
    pub fn identifier(&self) -> std::option::Option<& str> {
        self.identifier.as_deref()
    }
    /// <p>The previous values for a core network.</p>
    pub fn previous_values(&self) -> std::option::Option<& crate::model::CoreNetworkChangeValues> {
        self.previous_values.as_ref()
    }
    /// <p>The new value for a core network</p>
    pub fn new_values(&self) -> std::option::Option<& crate::model::CoreNetworkChangeValues> {
        self.new_values.as_ref()
    }
    /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
    pub fn identifier_path(&self) -> std::option::Option<& str> {
        self.identifier_path.as_deref()
    }
}
/// See [`CoreNetworkChange`](crate::model::CoreNetworkChange).
pub mod core_network_change {
    
    /// A builder for [`CoreNetworkChange`](crate::model::CoreNetworkChange).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ChangeType>,
        pub(crate) action: std::option::Option<crate::model::ChangeAction>,
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) previous_values: std::option::Option<crate::model::CoreNetworkChangeValues>,
        pub(crate) new_values: std::option::Option<crate::model::CoreNetworkChangeValues>,
        pub(crate) identifier_path: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of change.</p>
        pub fn r#type(mut self, input: crate::model::ChangeType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of change.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ChangeType>) -> Self {
            self.r#type = input; self
        }
        /// <p>The action to take for a core network.</p>
        pub fn action(mut self, input: crate::model::ChangeAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to take for a core network.</p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::ChangeAction>) -> Self {
            self.action = input; self
        }
        /// <p>The resource identifier.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The resource identifier.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input; self
        }
        /// <p>The previous values for a core network.</p>
        pub fn previous_values(mut self, input: crate::model::CoreNetworkChangeValues) -> Self {
            self.previous_values = Some(input);
            self
        }
        /// <p>The previous values for a core network.</p>
        pub fn set_previous_values(mut self, input: std::option::Option<crate::model::CoreNetworkChangeValues>) -> Self {
            self.previous_values = input; self
        }
        /// <p>The new value for a core network</p>
        pub fn new_values(mut self, input: crate::model::CoreNetworkChangeValues) -> Self {
            self.new_values = Some(input);
            self
        }
        /// <p>The new value for a core network</p>
        pub fn set_new_values(mut self, input: std::option::Option<crate::model::CoreNetworkChangeValues>) -> Self {
            self.new_values = input; self
        }
        /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
        pub fn identifier_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier_path = Some(input.into());
            self
        }
        /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
        pub fn set_identifier_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier_path = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkChange`](crate::model::CoreNetworkChange).
        pub fn build(self) -> crate::model::CoreNetworkChange {
            crate::model::CoreNetworkChange {
                r#type: self.r#type
                ,
                action: self.action
                ,
                identifier: self.identifier
                ,
                previous_values: self.previous_values
                ,
                new_values: self.new_values
                ,
                identifier_path: self.identifier_path
                ,
            }
        }
    }
    
    
}
impl CoreNetworkChange {
    /// Creates a new builder-style object to manufacture [`CoreNetworkChange`](crate::model::CoreNetworkChange).
    pub fn builder() -> crate::model::core_network_change::Builder {
        crate::model::core_network_change::Builder::default()
    }
}

/// <p>Describes a core network change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkChangeValues  {
    /// <p>The names of the segments in a core network.</p>
    #[doc(hidden)]
    pub segment_name: std::option::Option<std::string::String>,
    /// <p>The Regions where edges are located in a core network. </p>
    #[doc(hidden)]
    pub edge_locations: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ASN of a core network.</p>
    #[doc(hidden)]
    pub asn: std::option::Option<i64>,
    /// <p>The IP addresses used for a core network.</p>
    #[doc(hidden)]
    pub cidr: std::option::Option<std::string::String>,
    /// <p>The ID of the destination.</p>
    #[doc(hidden)]
    pub destination_identifier: std::option::Option<std::string::String>,
    /// <p>The inside IP addresses used for core network change values.</p>
    #[doc(hidden)]
    pub inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The shared segments for a core network change value. </p>
    #[doc(hidden)]
    pub shared_segments: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl CoreNetworkChangeValues {
    /// <p>The names of the segments in a core network.</p>
    pub fn segment_name(&self) -> std::option::Option<& str> {
        self.segment_name.as_deref()
    }
    /// <p>The Regions where edges are located in a core network. </p>
    pub fn edge_locations(&self) -> std::option::Option<& [std::string::String]> {
        self.edge_locations.as_deref()
    }
    /// <p>The ASN of a core network.</p>
    pub fn asn(&self) -> std::option::Option<i64> {
        self.asn
    }
    /// <p>The IP addresses used for a core network.</p>
    pub fn cidr(&self) -> std::option::Option<& str> {
        self.cidr.as_deref()
    }
    /// <p>The ID of the destination.</p>
    pub fn destination_identifier(&self) -> std::option::Option<& str> {
        self.destination_identifier.as_deref()
    }
    /// <p>The inside IP addresses used for core network change values.</p>
    pub fn inside_cidr_blocks(&self) -> std::option::Option<& [std::string::String]> {
        self.inside_cidr_blocks.as_deref()
    }
    /// <p>The shared segments for a core network change value. </p>
    pub fn shared_segments(&self) -> std::option::Option<& [std::string::String]> {
        self.shared_segments.as_deref()
    }
}
/// See [`CoreNetworkChangeValues`](crate::model::CoreNetworkChangeValues).
pub mod core_network_change_values {
    
    /// A builder for [`CoreNetworkChangeValues`](crate::model::CoreNetworkChangeValues).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) segment_name: std::option::Option<std::string::String>,
        pub(crate) edge_locations: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) asn: std::option::Option<i64>,
        pub(crate) cidr: std::option::Option<std::string::String>,
        pub(crate) destination_identifier: std::option::Option<std::string::String>,
        pub(crate) inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) shared_segments: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The names of the segments in a core network.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The names of the segments in a core network.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input; self
        }
        /// Appends an item to `edge_locations`.
        ///
        /// To override the contents of this collection use [`set_edge_locations`](Self::set_edge_locations).
        ///
        /// <p>The Regions where edges are located in a core network. </p>
        pub fn edge_locations(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.edge_locations.unwrap_or_default();
                            v.push(input.into());
                            self.edge_locations = Some(v);
                            self
        }
        /// <p>The Regions where edges are located in a core network. </p>
        pub fn set_edge_locations(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.edge_locations = input; self
        }
        /// <p>The ASN of a core network.</p>
        pub fn asn(mut self, input: i64) -> Self {
            self.asn = Some(input);
            self
        }
        /// <p>The ASN of a core network.</p>
        pub fn set_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.asn = input; self
        }
        /// <p>The IP addresses used for a core network.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        /// <p>The IP addresses used for a core network.</p>
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input; self
        }
        /// <p>The ID of the destination.</p>
        pub fn destination_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_identifier = Some(input.into());
            self
        }
        /// <p>The ID of the destination.</p>
        pub fn set_destination_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination_identifier = input; self
        }
        /// Appends an item to `inside_cidr_blocks`.
        ///
        /// To override the contents of this collection use [`set_inside_cidr_blocks`](Self::set_inside_cidr_blocks).
        ///
        /// <p>The inside IP addresses used for core network change values.</p>
        pub fn inside_cidr_blocks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inside_cidr_blocks.unwrap_or_default();
                            v.push(input.into());
                            self.inside_cidr_blocks = Some(v);
                            self
        }
        /// <p>The inside IP addresses used for core network change values.</p>
        pub fn set_inside_cidr_blocks(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.inside_cidr_blocks = input; self
        }
        /// Appends an item to `shared_segments`.
        ///
        /// To override the contents of this collection use [`set_shared_segments`](Self::set_shared_segments).
        ///
        /// <p>The shared segments for a core network change value. </p>
        pub fn shared_segments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.shared_segments.unwrap_or_default();
                            v.push(input.into());
                            self.shared_segments = Some(v);
                            self
        }
        /// <p>The shared segments for a core network change value. </p>
        pub fn set_shared_segments(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.shared_segments = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkChangeValues`](crate::model::CoreNetworkChangeValues).
        pub fn build(self) -> crate::model::CoreNetworkChangeValues {
            crate::model::CoreNetworkChangeValues {
                segment_name: self.segment_name
                ,
                edge_locations: self.edge_locations
                ,
                asn: self.asn
                ,
                cidr: self.cidr
                ,
                destination_identifier: self.destination_identifier
                ,
                inside_cidr_blocks: self.inside_cidr_blocks
                ,
                shared_segments: self.shared_segments
                ,
            }
        }
    }
    
    
}
impl CoreNetworkChangeValues {
    /// Creates a new builder-style object to manufacture [`CoreNetworkChangeValues`](crate::model::CoreNetworkChangeValues).
    pub fn builder() -> crate::model::core_network_change_values::Builder {
        crate::model::core_network_change_values::Builder::default()
    }
}

/// When writing a match expression against `ChangeAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let changeaction = unimplemented!();
/// match changeaction {
///     ChangeAction::Add => { /* ... */ },
///     ChangeAction::Modify => { /* ... */ },
///     ChangeAction::Remove => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `changeaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChangeAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChangeAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChangeAction::NewFeature` is defined.
/// Specifically, when `changeaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChangeAction::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ChangeAction {
    #[allow(missing_docs)] // documentation missing in model
    Add,
    #[allow(missing_docs)] // documentation missing in model
    Modify,
    #[allow(missing_docs)] // documentation missing in model
    Remove,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ChangeAction {
    fn from(s: &str) -> Self {
        match s {
            "ADD" => ChangeAction::Add,
            "MODIFY" => ChangeAction::Modify,
            "REMOVE" => ChangeAction::Remove,
            other => ChangeAction::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ChangeAction {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ChangeAction::from(s))
                }
            }
impl ChangeAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChangeAction::Add => "ADD",
            ChangeAction::Modify => "MODIFY",
            ChangeAction::Remove => "REMOVE",
            ChangeAction::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADD", "MODIFY", "REMOVE"
        ]
    }
}
impl AsRef<str> for ChangeAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ChangeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let changetype = unimplemented!();
/// match changetype {
///     ChangeType::AttachmentMapping => { /* ... */ },
///     ChangeType::AttachmentPoliciesConfiguration => { /* ... */ },
///     ChangeType::AttachmentRoutePropagation => { /* ... */ },
///     ChangeType::AttachmentRouteStatic => { /* ... */ },
///     ChangeType::CoreNetworkConfiguration => { /* ... */ },
///     ChangeType::CoreNetworkEdge => { /* ... */ },
///     ChangeType::CoreNetworkSegment => { /* ... */ },
///     ChangeType::SegmentsConfiguration => { /* ... */ },
///     ChangeType::SegmentActionsConfiguration => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `changetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChangeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChangeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChangeType::NewFeature` is defined.
/// Specifically, when `changetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChangeType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ChangeType {
    #[allow(missing_docs)] // documentation missing in model
    AttachmentMapping,
    #[allow(missing_docs)] // documentation missing in model
    AttachmentPoliciesConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    AttachmentRoutePropagation,
    #[allow(missing_docs)] // documentation missing in model
    AttachmentRouteStatic,
    #[allow(missing_docs)] // documentation missing in model
    CoreNetworkConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    CoreNetworkEdge,
    #[allow(missing_docs)] // documentation missing in model
    CoreNetworkSegment,
    #[allow(missing_docs)] // documentation missing in model
    SegmentsConfiguration,
    #[allow(missing_docs)] // documentation missing in model
    SegmentActionsConfiguration,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ChangeType {
    fn from(s: &str) -> Self {
        match s {
            "ATTACHMENT_MAPPING" => ChangeType::AttachmentMapping,
            "ATTACHMENT_POLICIES_CONFIGURATION" => ChangeType::AttachmentPoliciesConfiguration,
            "ATTACHMENT_ROUTE_PROPAGATION" => ChangeType::AttachmentRoutePropagation,
            "ATTACHMENT_ROUTE_STATIC" => ChangeType::AttachmentRouteStatic,
            "CORE_NETWORK_CONFIGURATION" => ChangeType::CoreNetworkConfiguration,
            "CORE_NETWORK_EDGE" => ChangeType::CoreNetworkEdge,
            "CORE_NETWORK_SEGMENT" => ChangeType::CoreNetworkSegment,
            "SEGMENTS_CONFIGURATION" => ChangeType::SegmentsConfiguration,
            "SEGMENT_ACTIONS_CONFIGURATION" => ChangeType::SegmentActionsConfiguration,
            other => ChangeType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ChangeType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ChangeType::from(s))
                }
            }
impl ChangeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChangeType::AttachmentMapping => "ATTACHMENT_MAPPING",
            ChangeType::AttachmentPoliciesConfiguration => "ATTACHMENT_POLICIES_CONFIGURATION",
            ChangeType::AttachmentRoutePropagation => "ATTACHMENT_ROUTE_PROPAGATION",
            ChangeType::AttachmentRouteStatic => "ATTACHMENT_ROUTE_STATIC",
            ChangeType::CoreNetworkConfiguration => "CORE_NETWORK_CONFIGURATION",
            ChangeType::CoreNetworkEdge => "CORE_NETWORK_EDGE",
            ChangeType::CoreNetworkSegment => "CORE_NETWORK_SEGMENT",
            ChangeType::SegmentsConfiguration => "SEGMENTS_CONFIGURATION",
            ChangeType::SegmentActionsConfiguration => "SEGMENT_ACTIONS_CONFIGURATION",
            ChangeType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ATTACHMENT_MAPPING", "ATTACHMENT_POLICIES_CONFIGURATION", "ATTACHMENT_ROUTE_PROPAGATION", "ATTACHMENT_ROUTE_STATIC", "CORE_NETWORK_CONFIGURATION", "CORE_NETWORK_EDGE", "CORE_NETWORK_SEGMENT", "SEGMENTS_CONFIGURATION", "SEGMENT_ACTIONS_CONFIGURATION"
        ]
    }
}
impl AsRef<str> for ChangeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a core network change event. This can be a change to a segment, attachment, route, etc.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkChangeEvent  {
    /// <p>Describes the type of change event. </p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ChangeType>,
    /// <p>The action taken for the change event.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::ChangeAction>,
    /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
    #[doc(hidden)]
    pub identifier_path: std::option::Option<std::string::String>,
    /// <p>The timestamp for an event change in status.</p>
    #[doc(hidden)]
    pub event_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The status of the core network change event.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::ChangeStatus>,
    /// <p>Details of the change event.</p>
    #[doc(hidden)]
    pub values: std::option::Option<crate::model::CoreNetworkChangeEventValues>,
}
impl CoreNetworkChangeEvent {
    /// <p>Describes the type of change event. </p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::ChangeType> {
        self.r#type.as_ref()
    }
    /// <p>The action taken for the change event.</p>
    pub fn action(&self) -> std::option::Option<& crate::model::ChangeAction> {
        self.action.as_ref()
    }
    /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
    pub fn identifier_path(&self) -> std::option::Option<& str> {
        self.identifier_path.as_deref()
    }
    /// <p>The timestamp for an event change in status.</p>
    pub fn event_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.event_time.as_ref()
    }
    /// <p>The status of the core network change event.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::ChangeStatus> {
        self.status.as_ref()
    }
    /// <p>Details of the change event.</p>
    pub fn values(&self) -> std::option::Option<& crate::model::CoreNetworkChangeEventValues> {
        self.values.as_ref()
    }
}
/// See [`CoreNetworkChangeEvent`](crate::model::CoreNetworkChangeEvent).
pub mod core_network_change_event {
    
    /// A builder for [`CoreNetworkChangeEvent`](crate::model::CoreNetworkChangeEvent).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ChangeType>,
        pub(crate) action: std::option::Option<crate::model::ChangeAction>,
        pub(crate) identifier_path: std::option::Option<std::string::String>,
        pub(crate) event_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) status: std::option::Option<crate::model::ChangeStatus>,
        pub(crate) values: std::option::Option<crate::model::CoreNetworkChangeEventValues>,
    }
    impl Builder {
        /// <p>Describes the type of change event. </p>
        pub fn r#type(mut self, input: crate::model::ChangeType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Describes the type of change event. </p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ChangeType>) -> Self {
            self.r#type = input; self
        }
        /// <p>The action taken for the change event.</p>
        pub fn action(mut self, input: crate::model::ChangeAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action taken for the change event.</p>
        pub fn set_action(mut self, input: std::option::Option<crate::model::ChangeAction>) -> Self {
            self.action = input; self
        }
        /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
        pub fn identifier_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier_path = Some(input.into());
            self
        }
        /// <p>Uniquely identifies the path for a change within the changeset. For example, the <code>IdentifierPath</code> for a core network segment change might be <code>"CORE_NETWORK_SEGMENT/us-east-1/devsegment"</code>.</p>
        pub fn set_identifier_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier_path = input; self
        }
        /// <p>The timestamp for an event change in status.</p>
        pub fn event_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.event_time = Some(input);
            self
        }
        /// <p>The timestamp for an event change in status.</p>
        pub fn set_event_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.event_time = input; self
        }
        /// <p>The status of the core network change event.</p>
        pub fn status(mut self, input: crate::model::ChangeStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the core network change event.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::ChangeStatus>) -> Self {
            self.status = input; self
        }
        /// <p>Details of the change event.</p>
        pub fn values(mut self, input: crate::model::CoreNetworkChangeEventValues) -> Self {
            self.values = Some(input);
            self
        }
        /// <p>Details of the change event.</p>
        pub fn set_values(mut self, input: std::option::Option<crate::model::CoreNetworkChangeEventValues>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkChangeEvent`](crate::model::CoreNetworkChangeEvent).
        pub fn build(self) -> crate::model::CoreNetworkChangeEvent {
            crate::model::CoreNetworkChangeEvent {
                r#type: self.r#type
                ,
                action: self.action
                ,
                identifier_path: self.identifier_path
                ,
                event_time: self.event_time
                ,
                status: self.status
                ,
                values: self.values
                ,
            }
        }
    }
    
    
}
impl CoreNetworkChangeEvent {
    /// Creates a new builder-style object to manufacture [`CoreNetworkChangeEvent`](crate::model::CoreNetworkChangeEvent).
    pub fn builder() -> crate::model::core_network_change_event::Builder {
        crate::model::core_network_change_event::Builder::default()
    }
}

/// <p>Describes a core network change event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CoreNetworkChangeEventValues  {
    /// <p>The edge location for the core network change event.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The segment name if the change event is associated with a segment.</p>
    #[doc(hidden)]
    pub segment_name: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment if the change event is associated with an attachment. </p>
    #[doc(hidden)]
    pub attachment_id: std::option::Option<std::string::String>,
    /// <p>For a <code>STATIC_ROUTE</code> event, this is the IP address.</p>
    #[doc(hidden)]
    pub cidr: std::option::Option<std::string::String>,
}
impl CoreNetworkChangeEventValues {
    /// <p>The edge location for the core network change event.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The segment name if the change event is associated with a segment.</p>
    pub fn segment_name(&self) -> std::option::Option<& str> {
        self.segment_name.as_deref()
    }
    /// <p>The ID of the attachment if the change event is associated with an attachment. </p>
    pub fn attachment_id(&self) -> std::option::Option<& str> {
        self.attachment_id.as_deref()
    }
    /// <p>For a <code>STATIC_ROUTE</code> event, this is the IP address.</p>
    pub fn cidr(&self) -> std::option::Option<& str> {
        self.cidr.as_deref()
    }
}
/// See [`CoreNetworkChangeEventValues`](crate::model::CoreNetworkChangeEventValues).
pub mod core_network_change_event_values {
    
    /// A builder for [`CoreNetworkChangeEventValues`](crate::model::CoreNetworkChangeEventValues).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
        pub(crate) attachment_id: std::option::Option<std::string::String>,
        pub(crate) cidr: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The edge location for the core network change event.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The edge location for the core network change event.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The segment name if the change event is associated with a segment.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The segment name if the change event is associated with a segment.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input; self
        }
        /// <p>The ID of the attachment if the change event is associated with an attachment. </p>
        pub fn attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment if the change event is associated with an attachment. </p>
        pub fn set_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.attachment_id = input; self
        }
        /// <p>For a <code>STATIC_ROUTE</code> event, this is the IP address.</p>
        pub fn cidr(mut self, input: impl Into<std::string::String>) -> Self {
            self.cidr = Some(input.into());
            self
        }
        /// <p>For a <code>STATIC_ROUTE</code> event, this is the IP address.</p>
        pub fn set_cidr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cidr = input; self
        }
        /// Consumes the builder and constructs a [`CoreNetworkChangeEventValues`](crate::model::CoreNetworkChangeEventValues).
        pub fn build(self) -> crate::model::CoreNetworkChangeEventValues {
            crate::model::CoreNetworkChangeEventValues {
                edge_location: self.edge_location
                ,
                segment_name: self.segment_name
                ,
                attachment_id: self.attachment_id
                ,
                cidr: self.cidr
                ,
            }
        }
    }
    
    
}
impl CoreNetworkChangeEventValues {
    /// Creates a new builder-style object to manufacture [`CoreNetworkChangeEventValues`](crate::model::CoreNetworkChangeEventValues).
    pub fn builder() -> crate::model::core_network_change_event_values::Builder {
        crate::model::core_network_change_event_values::Builder::default()
    }
}

/// When writing a match expression against `ChangeStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let changestatus = unimplemented!();
/// match changestatus {
///     ChangeStatus::Complete => { /* ... */ },
///     ChangeStatus::Failed => { /* ... */ },
///     ChangeStatus::InProgress => { /* ... */ },
///     ChangeStatus::NotStarted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `changestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChangeStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChangeStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChangeStatus::NewFeature` is defined.
/// Specifically, when `changestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChangeStatus::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ChangeStatus {
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    NotStarted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ChangeStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => ChangeStatus::Complete,
            "FAILED" => ChangeStatus::Failed,
            "IN_PROGRESS" => ChangeStatus::InProgress,
            "NOT_STARTED" => ChangeStatus::NotStarted,
            other => ChangeStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ChangeStatus {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ChangeStatus::from(s))
                }
            }
impl ChangeStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChangeStatus::Complete => "COMPLETE",
            ChangeStatus::Failed => "FAILED",
            ChangeStatus::InProgress => "IN_PROGRESS",
            ChangeStatus::NotStarted => "NOT_STARTED",
            ChangeStatus::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETE", "FAILED", "IN_PROGRESS", "NOT_STARTED"
        ]
    }
}
impl AsRef<str> for ChangeStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a core network Connect peer association.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectPeerAssociation  {
    /// <p>The ID of the Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
    /// <p>The ID of the global network.</p>
    #[doc(hidden)]
    pub global_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the device to connect to.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The ID of the link.</p>
    #[doc(hidden)]
    pub link_id: std::option::Option<std::string::String>,
    /// <p>The state of the Connect peer association.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ConnectPeerAssociationState>,
}
impl ConnectPeerAssociation {
    /// <p>The ID of the Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<& str> {
        self.connect_peer_id.as_deref()
    }
    /// <p>The ID of the global network.</p>
    pub fn global_network_id(&self) -> std::option::Option<& str> {
        self.global_network_id.as_deref()
    }
    /// <p>The ID of the device to connect to.</p>
    pub fn device_id(&self) -> std::option::Option<& str> {
        self.device_id.as_deref()
    }
    /// <p>The ID of the link.</p>
    pub fn link_id(&self) -> std::option::Option<& str> {
        self.link_id.as_deref()
    }
    /// <p>The state of the Connect peer association.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::ConnectPeerAssociationState> {
        self.state.as_ref()
    }
}
/// See [`ConnectPeerAssociation`](crate::model::ConnectPeerAssociation).
pub mod connect_peer_association {
    
    /// A builder for [`ConnectPeerAssociation`](crate::model::ConnectPeerAssociation).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
        pub(crate) global_network_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) link_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ConnectPeerAssociationState>,
    }
    impl Builder {
        /// <p>The ID of the Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn set_connect_peer_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connect_peer_id = input; self
        }
        /// <p>The ID of the global network.</p>
        pub fn global_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.global_network_id = Some(input.into());
            self
        }
        /// <p>The ID of the global network.</p>
        pub fn set_global_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.global_network_id = input; self
        }
        /// <p>The ID of the device to connect to.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The ID of the device to connect to.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input; self
        }
        /// <p>The ID of the link.</p>
        pub fn link_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.link_id = Some(input.into());
            self
        }
        /// <p>The ID of the link.</p>
        pub fn set_link_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link_id = input; self
        }
        /// <p>The state of the Connect peer association.</p>
        pub fn state(mut self, input: crate::model::ConnectPeerAssociationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the Connect peer association.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::ConnectPeerAssociationState>) -> Self {
            self.state = input; self
        }
        /// Consumes the builder and constructs a [`ConnectPeerAssociation`](crate::model::ConnectPeerAssociation).
        pub fn build(self) -> crate::model::ConnectPeerAssociation {
            crate::model::ConnectPeerAssociation {
                connect_peer_id: self.connect_peer_id
                ,
                global_network_id: self.global_network_id
                ,
                device_id: self.device_id
                ,
                link_id: self.link_id
                ,
                state: self.state
                ,
            }
        }
    }
    
    
}
impl ConnectPeerAssociation {
    /// Creates a new builder-style object to manufacture [`ConnectPeerAssociation`](crate::model::ConnectPeerAssociation).
    pub fn builder() -> crate::model::connect_peer_association::Builder {
        crate::model::connect_peer_association::Builder::default()
    }
}

/// When writing a match expression against `ConnectPeerAssociationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let connectpeerassociationstate = unimplemented!();
/// match connectpeerassociationstate {
///     ConnectPeerAssociationState::Available => { /* ... */ },
///     ConnectPeerAssociationState::Deleted => { /* ... */ },
///     ConnectPeerAssociationState::Deleting => { /* ... */ },
///     ConnectPeerAssociationState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectpeerassociationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectPeerAssociationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectPeerAssociationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectPeerAssociationState::NewFeature` is defined.
/// Specifically, when `connectpeerassociationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectPeerAssociationState::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ConnectPeerAssociationState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ConnectPeerAssociationState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => ConnectPeerAssociationState::Available,
            "DELETED" => ConnectPeerAssociationState::Deleted,
            "DELETING" => ConnectPeerAssociationState::Deleting,
            "PENDING" => ConnectPeerAssociationState::Pending,
            other => ConnectPeerAssociationState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ConnectPeerAssociationState {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ConnectPeerAssociationState::from(s))
                }
            }
impl ConnectPeerAssociationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectPeerAssociationState::Available => "AVAILABLE",
            ConnectPeerAssociationState::Deleted => "DELETED",
            ConnectPeerAssociationState::Deleting => "DELETING",
            ConnectPeerAssociationState::Pending => "PENDING",
            ConnectPeerAssociationState::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AVAILABLE", "DELETED", "DELETING", "PENDING"
        ]
    }
}
impl AsRef<str> for ConnectPeerAssociationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a core network Connect peer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectPeer  {
    /// <p>The ID of a core network.</p>
    #[doc(hidden)]
    pub core_network_id: std::option::Option<std::string::String>,
    /// <p>The ID of the attachment to connect.</p>
    #[doc(hidden)]
    pub connect_attachment_id: std::option::Option<std::string::String>,
    /// <p>The ID of the Connect peer.</p>
    #[doc(hidden)]
    pub connect_peer_id: std::option::Option<std::string::String>,
    /// <p>The Connect peer Regions where edges are located.</p>
    #[doc(hidden)]
    pub edge_location: std::option::Option<std::string::String>,
    /// <p>The state of the Connect peer.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ConnectPeerState>,
    /// <p>The timestamp when the Connect peer was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The configuration of the Connect peer.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::ConnectPeerConfiguration>,
    /// <p>The list of key-value tags associated with the Connect peer.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl ConnectPeer {
    /// <p>The ID of a core network.</p>
    pub fn core_network_id(&self) -> std::option::Option<& str> {
        self.core_network_id.as_deref()
    }
    /// <p>The ID of the attachment to connect.</p>
    pub fn connect_attachment_id(&self) -> std::option::Option<& str> {
        self.connect_attachment_id.as_deref()
    }
    /// <p>The ID of the Connect peer.</p>
    pub fn connect_peer_id(&self) -> std::option::Option<& str> {
        self.connect_peer_id.as_deref()
    }
    /// <p>The Connect peer Regions where edges are located.</p>
    pub fn edge_location(&self) -> std::option::Option<& str> {
        self.edge_location.as_deref()
    }
    /// <p>The state of the Connect peer.</p>
    pub fn state(&self) -> std::option::Option<& crate::model::ConnectPeerState> {
        self.state.as_ref()
    }
    /// <p>The timestamp when the Connect peer was created.</p>
    pub fn created_at(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The configuration of the Connect peer.</p>
    pub fn configuration(&self) -> std::option::Option<& crate::model::ConnectPeerConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The list of key-value tags associated with the Connect peer.</p>
    pub fn tags(&self) -> std::option::Option<& [crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`ConnectPeer`](crate::model::ConnectPeer).
pub mod connect_peer {
    
    /// A builder for [`ConnectPeer`](crate::model::ConnectPeer).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_id: std::option::Option<std::string::String>,
        pub(crate) connect_attachment_id: std::option::Option<std::string::String>,
        pub(crate) connect_peer_id: std::option::Option<std::string::String>,
        pub(crate) edge_location: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ConnectPeerState>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) configuration: std::option::Option<crate::model::ConnectPeerConfiguration>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The ID of a core network.</p>
        pub fn core_network_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_id = Some(input.into());
            self
        }
        /// <p>The ID of a core network.</p>
        pub fn set_core_network_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_id = input; self
        }
        /// <p>The ID of the attachment to connect.</p>
        pub fn connect_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the attachment to connect.</p>
        pub fn set_connect_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connect_attachment_id = input; self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn connect_peer_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_peer_id = Some(input.into());
            self
        }
        /// <p>The ID of the Connect peer.</p>
        pub fn set_connect_peer_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.connect_peer_id = input; self
        }
        /// <p>The Connect peer Regions where edges are located.</p>
        pub fn edge_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.edge_location = Some(input.into());
            self
        }
        /// <p>The Connect peer Regions where edges are located.</p>
        pub fn set_edge_location(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.edge_location = input; self
        }
        /// <p>The state of the Connect peer.</p>
        pub fn state(mut self, input: crate::model::ConnectPeerState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the Connect peer.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::ConnectPeerState>) -> Self {
            self.state = input; self
        }
        /// <p>The timestamp when the Connect peer was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The timestamp when the Connect peer was created.</p>
        pub fn set_created_at(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
            self.created_at = input; self
        }
        /// <p>The configuration of the Connect peer.</p>
        pub fn configuration(mut self, input: crate::model::ConnectPeerConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration of the Connect peer.</p>
        pub fn set_configuration(mut self, input: std::option::Option<crate::model::ConnectPeerConfiguration>) -> Self {
            self.configuration = input; self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of key-value tags associated with the Connect peer.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
                            v.push(input);
                            self.tags = Some(v);
                            self
        }
        /// <p>The list of key-value tags associated with the Connect peer.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::vec::Vec<crate::model::Tag>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`ConnectPeer`](crate::model::ConnectPeer).
        pub fn build(self) -> crate::model::ConnectPeer {
            crate::model::ConnectPeer {
                core_network_id: self.core_network_id
                ,
                connect_attachment_id: self.connect_attachment_id
                ,
                connect_peer_id: self.connect_peer_id
                ,
                edge_location: self.edge_location
                ,
                state: self.state
                ,
                created_at: self.created_at
                ,
                configuration: self.configuration
                ,
                tags: self.tags
                ,
            }
        }
    }
    
    
}
impl ConnectPeer {
    /// Creates a new builder-style object to manufacture [`ConnectPeer`](crate::model::ConnectPeer).
    pub fn builder() -> crate::model::connect_peer::Builder {
        crate::model::connect_peer::Builder::default()
    }
}

/// <p>Describes a core network Connect peer configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectPeerConfiguration  {
    /// <p>The IP address of a core network.</p>
    #[doc(hidden)]
    pub core_network_address: std::option::Option<std::string::String>,
    /// <p>The IP address of the Connect peer.</p>
    #[doc(hidden)]
    pub peer_address: std::option::Option<std::string::String>,
    /// <p>The inside IP addresses used for a Connect peer configuration.</p>
    #[doc(hidden)]
    pub inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The protocol used for a Connect peer configuration.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::model::TunnelProtocol>,
    /// <p>The Connect peer BGP configurations.</p>
    #[doc(hidden)]
    pub bgp_configurations: std::option::Option<std::vec::Vec<crate::model::ConnectPeerBgpConfiguration>>,
}
impl ConnectPeerConfiguration {
    /// <p>The IP address of a core network.</p>
    pub fn core_network_address(&self) -> std::option::Option<& str> {
        self.core_network_address.as_deref()
    }
    /// <p>The IP address of the Connect peer.</p>
    pub fn peer_address(&self) -> std::option::Option<& str> {
        self.peer_address.as_deref()
    }
    /// <p>The inside IP addresses used for a Connect peer configuration.</p>
    pub fn inside_cidr_blocks(&self) -> std::option::Option<& [std::string::String]> {
        self.inside_cidr_blocks.as_deref()
    }
    /// <p>The protocol used for a Connect peer configuration.</p>
    pub fn protocol(&self) -> std::option::Option<& crate::model::TunnelProtocol> {
        self.protocol.as_ref()
    }
    /// <p>The Connect peer BGP configurations.</p>
    pub fn bgp_configurations(&self) -> std::option::Option<& [crate::model::ConnectPeerBgpConfiguration]> {
        self.bgp_configurations.as_deref()
    }
}
/// See [`ConnectPeerConfiguration`](crate::model::ConnectPeerConfiguration).
pub mod connect_peer_configuration {
    
    /// A builder for [`ConnectPeerConfiguration`](crate::model::ConnectPeerConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
        pub(crate) inside_cidr_blocks: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) protocol: std::option::Option<crate::model::TunnelProtocol>,
        pub(crate) bgp_configurations: std::option::Option<std::vec::Vec<crate::model::ConnectPeerBgpConfiguration>>,
    }
    impl Builder {
        /// <p>The IP address of a core network.</p>
        pub fn core_network_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_address = Some(input.into());
            self
        }
        /// <p>The IP address of a core network.</p>
        pub fn set_core_network_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_address = input; self
        }
        /// <p>The IP address of the Connect peer.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        /// <p>The IP address of the Connect peer.</p>
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input; self
        }
        /// Appends an item to `inside_cidr_blocks`.
        ///
        /// To override the contents of this collection use [`set_inside_cidr_blocks`](Self::set_inside_cidr_blocks).
        ///
        /// <p>The inside IP addresses used for a Connect peer configuration.</p>
        pub fn inside_cidr_blocks(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.inside_cidr_blocks.unwrap_or_default();
                            v.push(input.into());
                            self.inside_cidr_blocks = Some(v);
                            self
        }
        /// <p>The inside IP addresses used for a Connect peer configuration.</p>
        pub fn set_inside_cidr_blocks(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.inside_cidr_blocks = input; self
        }
        /// <p>The protocol used for a Connect peer configuration.</p>
        pub fn protocol(mut self, input: crate::model::TunnelProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol used for a Connect peer configuration.</p>
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::TunnelProtocol>) -> Self {
            self.protocol = input; self
        }
        /// Appends an item to `bgp_configurations`.
        ///
        /// To override the contents of this collection use [`set_bgp_configurations`](Self::set_bgp_configurations).
        ///
        /// <p>The Connect peer BGP configurations.</p>
        pub fn bgp_configurations(mut self, input: crate::model::ConnectPeerBgpConfiguration) -> Self {
            let mut v = self.bgp_configurations.unwrap_or_default();
                            v.push(input);
                            self.bgp_configurations = Some(v);
                            self
        }
        /// <p>The Connect peer BGP configurations.</p>
        pub fn set_bgp_configurations(mut self, input: std::option::Option<std::vec::Vec<crate::model::ConnectPeerBgpConfiguration>>) -> Self {
            self.bgp_configurations = input; self
        }
        /// Consumes the builder and constructs a [`ConnectPeerConfiguration`](crate::model::ConnectPeerConfiguration).
        pub fn build(self) -> crate::model::ConnectPeerConfiguration {
            crate::model::ConnectPeerConfiguration {
                core_network_address: self.core_network_address
                ,
                peer_address: self.peer_address
                ,
                inside_cidr_blocks: self.inside_cidr_blocks
                ,
                protocol: self.protocol
                ,
                bgp_configurations: self.bgp_configurations
                ,
            }
        }
    }
    
    
}
impl ConnectPeerConfiguration {
    /// Creates a new builder-style object to manufacture [`ConnectPeerConfiguration`](crate::model::ConnectPeerConfiguration).
    pub fn builder() -> crate::model::connect_peer_configuration::Builder {
        crate::model::connect_peer_configuration::Builder::default()
    }
}

/// <p>Describes a core network BGP configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectPeerBgpConfiguration  {
    /// <p>The ASN of the Coret Network.</p>
    #[doc(hidden)]
    pub core_network_asn: std::option::Option<i64>,
    /// <p>The ASN of the Connect peer.</p>
    #[doc(hidden)]
    pub peer_asn: std::option::Option<i64>,
    /// <p>The address of a core network.</p>
    #[doc(hidden)]
    pub core_network_address: std::option::Option<std::string::String>,
    /// <p>The address of a core network Connect peer.</p>
    #[doc(hidden)]
    pub peer_address: std::option::Option<std::string::String>,
}
impl ConnectPeerBgpConfiguration {
    /// <p>The ASN of the Coret Network.</p>
    pub fn core_network_asn(&self) -> std::option::Option<i64> {
        self.core_network_asn
    }
    /// <p>The ASN of the Connect peer.</p>
    pub fn peer_asn(&self) -> std::option::Option<i64> {
        self.peer_asn
    }
    /// <p>The address of a core network.</p>
    pub fn core_network_address(&self) -> std::option::Option<& str> {
        self.core_network_address.as_deref()
    }
    /// <p>The address of a core network Connect peer.</p>
    pub fn peer_address(&self) -> std::option::Option<& str> {
        self.peer_address.as_deref()
    }
}
/// See [`ConnectPeerBgpConfiguration`](crate::model::ConnectPeerBgpConfiguration).
pub mod connect_peer_bgp_configuration {
    
    /// A builder for [`ConnectPeerBgpConfiguration`](crate::model::ConnectPeerBgpConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) core_network_asn: std::option::Option<i64>,
        pub(crate) peer_asn: std::option::Option<i64>,
        pub(crate) core_network_address: std::option::Option<std::string::String>,
        pub(crate) peer_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ASN of the Coret Network.</p>
        pub fn core_network_asn(mut self, input: i64) -> Self {
            self.core_network_asn = Some(input);
            self
        }
        /// <p>The ASN of the Coret Network.</p>
        pub fn set_core_network_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.core_network_asn = input; self
        }
        /// <p>The ASN of the Connect peer.</p>
        pub fn peer_asn(mut self, input: i64) -> Self {
            self.peer_asn = Some(input);
            self
        }
        /// <p>The ASN of the Connect peer.</p>
        pub fn set_peer_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.peer_asn = input; self
        }
        /// <p>The address of a core network.</p>
        pub fn core_network_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.core_network_address = Some(input.into());
            self
        }
        /// <p>The address of a core network.</p>
        pub fn set_core_network_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.core_network_address = input; self
        }
        /// <p>The address of a core network Connect peer.</p>
        pub fn peer_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.peer_address = Some(input.into());
            self
        }
        /// <p>The address of a core network Connect peer.</p>
        pub fn set_peer_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.peer_address = input; self
        }
        /// Consumes the builder and constructs a [`ConnectPeerBgpConfiguration`](crate::model::ConnectPeerBgpConfiguration).
        pub fn build(self) -> crate::model::ConnectPeerBgpConfiguration {
            crate::model::ConnectPeerBgpConfiguration {
                core_network_asn: self.core_network_asn
                ,
                peer_asn: self.peer_asn
                ,
                core_network_address: self.core_network_address
                ,
                peer_address: self.peer_address
                ,
            }
        }
    }
    
    
}
impl ConnectPeerBgpConfiguration {
    /// Creates a new builder-style object to manufacture [`ConnectPeerBgpConfiguration`](crate::model::ConnectPeerBgpConfiguration).
    pub fn builder() -> crate::model::connect_peer_bgp_configuration::Builder {
        crate::model::connect_peer_bgp_configuration::Builder::default()
    }
}

/// When writing a match expression against `TunnelProtocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let tunnelprotocol = unimplemented!();
/// match tunnelprotocol {
///     TunnelProtocol::Gre => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tunnelprotocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TunnelProtocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TunnelProtocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TunnelProtocol::NewFeature` is defined.
/// Specifically, when `tunnelprotocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TunnelProtocol::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum TunnelProtocol {
    #[allow(missing_docs)] // documentation missing in model
    Gre,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for TunnelProtocol {
    fn from(s: &str) -> Self {
        match s {
            "GRE" => TunnelProtocol::Gre,
            other => TunnelProtocol::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for TunnelProtocol {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(TunnelProtocol::from(s))
                }
            }
impl TunnelProtocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TunnelProtocol::Gre => "GRE",
            TunnelProtocol::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "GRE"
        ]
    }
}
impl AsRef<str> for TunnelProtocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a core network Connect attachment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectAttachment  {
    /// <p>The attachment details.</p>
    #[doc(hidden)]
    pub attachment: std::option::Option<crate::model::Attachment>,
    /// <p>The ID of the transport attachment.</p>
    #[doc(hidden)]
    pub transport_attachment_id: std::option::Option<std::string::String>,
    /// <p>Options for connecting an attachment.</p>
    #[doc(hidden)]
    pub options: std::option::Option<crate::model::ConnectAttachmentOptions>,
}
impl ConnectAttachment {
    /// <p>The attachment details.</p>
    pub fn attachment(&self) -> std::option::Option<& crate::model::Attachment> {
        self.attachment.as_ref()
    }
    /// <p>The ID of the transport attachment.</p>
    pub fn transport_attachment_id(&self) -> std::option::Option<& str> {
        self.transport_attachment_id.as_deref()
    }
    /// <p>Options for connecting an attachment.</p>
    pub fn options(&self) -> std::option::Option<& crate::model::ConnectAttachmentOptions> {
        self.options.as_ref()
    }
}
/// See [`ConnectAttachment`](crate::model::ConnectAttachment).
pub mod connect_attachment {
    
    /// A builder for [`ConnectAttachment`](crate::model::ConnectAttachment).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attachment: std::option::Option<crate::model::Attachment>,
        pub(crate) transport_attachment_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<crate::model::ConnectAttachmentOptions>,
    }
    impl Builder {
        /// <p>The attachment details.</p>
        pub fn attachment(mut self, input: crate::model::Attachment) -> Self {
            self.attachment = Some(input);
            self
        }
        /// <p>The attachment details.</p>
        pub fn set_attachment(mut self, input: std::option::Option<crate::model::Attachment>) -> Self {
            self.attachment = input; self
        }
        /// <p>The ID of the transport attachment.</p>
        pub fn transport_attachment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.transport_attachment_id = Some(input.into());
            self
        }
        /// <p>The ID of the transport attachment.</p>
        pub fn set_transport_attachment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.transport_attachment_id = input; self
        }
        /// <p>Options for connecting an attachment.</p>
        pub fn options(mut self, input: crate::model::ConnectAttachmentOptions) -> Self {
            self.options = Some(input);
            self
        }
        /// <p>Options for connecting an attachment.</p>
        pub fn set_options(mut self, input: std::option::Option<crate::model::ConnectAttachmentOptions>) -> Self {
            self.options = input; self
        }
        /// Consumes the builder and constructs a [`ConnectAttachment`](crate::model::ConnectAttachment).
        pub fn build(self) -> crate::model::ConnectAttachment {
            crate::model::ConnectAttachment {
                attachment: self.attachment
                ,
                transport_attachment_id: self.transport_attachment_id
                ,
                options: self.options
                ,
            }
        }
    }
    
    
}
impl ConnectAttachment {
    /// Creates a new builder-style object to manufacture [`ConnectAttachment`](crate::model::ConnectAttachment).
    pub fn builder() -> crate::model::connect_attachment::Builder {
        crate::model::connect_attachment::Builder::default()
    }
}

/// <p>Describes a core network Connect attachment options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectAttachmentOptions  {
    /// <p>The protocol used for the attachment connection.</p>
    #[doc(hidden)]
    pub protocol: std::option::Option<crate::model::TunnelProtocol>,
}
impl ConnectAttachmentOptions {
    /// <p>The protocol used for the attachment connection.</p>
    pub fn protocol(&self) -> std::option::Option<& crate::model::TunnelProtocol> {
        self.protocol.as_ref()
    }
}
/// See [`ConnectAttachmentOptions`](crate::model::ConnectAttachmentOptions).
pub mod connect_attachment_options {
    
    /// A builder for [`ConnectAttachmentOptions`](crate::model::ConnectAttachmentOptions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) protocol: std::option::Option<crate::model::TunnelProtocol>,
    }
    impl Builder {
        /// <p>The protocol used for the attachment connection.</p>
        pub fn protocol(mut self, input: crate::model::TunnelProtocol) -> Self {
            self.protocol = Some(input);
            self
        }
        /// <p>The protocol used for the attachment connection.</p>
        pub fn set_protocol(mut self, input: std::option::Option<crate::model::TunnelProtocol>) -> Self {
            self.protocol = input; self
        }
        /// Consumes the builder and constructs a [`ConnectAttachmentOptions`](crate::model::ConnectAttachmentOptions).
        pub fn build(self) -> crate::model::ConnectAttachmentOptions {
            crate::model::ConnectAttachmentOptions {
                protocol: self.protocol
                ,
            }
        }
    }
    
    
}
impl ConnectAttachmentOptions {
    /// Creates a new builder-style object to manufacture [`ConnectAttachmentOptions`](crate::model::ConnectAttachmentOptions).
    pub fn builder() -> crate::model::connect_attachment_options::Builder {
        crate::model::connect_attachment_options::Builder::default()
    }
}

/// <p>Describes the BGP options.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BgpOptions  {
    /// <p>The Peer ASN of the BGP.</p>
    #[doc(hidden)]
    pub peer_asn: std::option::Option<i64>,
}
impl BgpOptions {
    /// <p>The Peer ASN of the BGP.</p>
    pub fn peer_asn(&self) -> std::option::Option<i64> {
        self.peer_asn
    }
}
/// See [`BgpOptions`](crate::model::BgpOptions).
pub mod bgp_options {
    
    /// A builder for [`BgpOptions`](crate::model::BgpOptions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) peer_asn: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The Peer ASN of the BGP.</p>
        pub fn peer_asn(mut self, input: i64) -> Self {
            self.peer_asn = Some(input);
            self
        }
        /// <p>The Peer ASN of the BGP.</p>
        pub fn set_peer_asn(mut self, input: std::option::Option<i64>) -> Self {
            self.peer_asn = input; self
        }
        /// Consumes the builder and constructs a [`BgpOptions`](crate::model::BgpOptions).
        pub fn build(self) -> crate::model::BgpOptions {
            crate::model::BgpOptions {
                peer_asn: self.peer_asn
                ,
            }
        }
    }
    
    
}
impl BgpOptions {
    /// Creates a new builder-style object to manufacture [`BgpOptions`](crate::model::BgpOptions).
    pub fn builder() -> crate::model::bgp_options::Builder {
        crate::model::bgp_options::Builder::default()
    }
}

