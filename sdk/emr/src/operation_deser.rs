// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddInstanceFleetOutput, crate::error::AddInstanceFleetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AddInstanceFleetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AddInstanceFleetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::AddInstanceFleetError { meta: generic, kind: crate::error::AddInstanceFleetErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AddInstanceFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::AddInstanceFleetError { meta: generic, kind: crate::error::AddInstanceFleetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AddInstanceFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AddInstanceFleetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddInstanceFleetOutput, crate::error::AddInstanceFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_instance_fleet_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_add_instance_fleet(response.body().as_ref(), output).map_err(crate::error::AddInstanceFleetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddInstanceGroupsOutput, crate::error::AddInstanceGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AddInstanceGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AddInstanceGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AddInstanceGroupsError { meta: generic, kind: crate::error::AddInstanceGroupsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddInstanceGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AddInstanceGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddInstanceGroupsOutput, crate::error::AddInstanceGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_instance_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_add_instance_groups(response.body().as_ref(), output).map_err(crate::error::AddInstanceGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_job_flow_steps_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddJobFlowStepsOutput, crate::error::AddJobFlowStepsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AddJobFlowStepsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AddJobFlowStepsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AddJobFlowStepsError { meta: generic, kind: crate::error::AddJobFlowStepsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::AddJobFlowStepsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AddJobFlowStepsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_job_flow_steps_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddJobFlowStepsOutput, crate::error::AddJobFlowStepsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_job_flow_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_add_job_flow_steps(response.body().as_ref(), output).map_err(crate::error::AddJobFlowStepsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AddTagsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AddTagsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::AddTagsError { meta: generic, kind: crate::error::AddTagsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::AddTagsError { meta: generic, kind: crate::error::AddTagsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AddTagsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AddTagsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_steps_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelStepsOutput, crate::error::CancelStepsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CancelStepsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CancelStepsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CancelStepsError { meta: generic, kind: crate::error::CancelStepsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CancelStepsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CancelStepsError { meta: generic, kind: crate::error::CancelStepsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CancelStepsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CancelStepsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_steps_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CancelStepsOutput, crate::error::CancelStepsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_cancel_steps(response.body().as_ref(), output).map_err(crate::error::CancelStepsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSecurityConfigurationOutput, crate::error::CreateSecurityConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateSecurityConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::CreateSecurityConfigurationError { meta: generic, kind: crate::error::CreateSecurityConfigurationErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateSecurityConfigurationError { meta: generic, kind: crate::error::CreateSecurityConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateSecurityConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateSecurityConfigurationOutput, crate::error::CreateSecurityConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_security_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_security_configuration(response.body().as_ref(), output).map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStudioOutput, crate::error::CreateStudioError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateStudioError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateStudioError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::CreateStudioError { meta: generic, kind: crate::error::CreateStudioErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateStudioError { meta: generic, kind: crate::error::CreateStudioErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateStudioError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStudioOutput, crate::error::CreateStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_studio_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_studio(response.body().as_ref(), output).map_err(crate::error::CreateStudioError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_session_mapping_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStudioSessionMappingOutput, crate::error::CreateStudioSessionMappingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateStudioSessionMappingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateStudioSessionMappingError { meta: generic, kind: crate::error::CreateStudioSessionMappingErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::CreateStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::CreateStudioSessionMappingError { meta: generic, kind: crate::error::CreateStudioSessionMappingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateStudioSessionMappingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_session_mapping_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStudioSessionMappingOutput, crate::error::CreateStudioSessionMappingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_studio_session_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSecurityConfigurationOutput, crate::error::DeleteSecurityConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteSecurityConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteSecurityConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DeleteSecurityConfigurationError { meta: generic, kind: crate::error::DeleteSecurityConfigurationErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteSecurityConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteSecurityConfigurationError { meta: generic, kind: crate::error::DeleteSecurityConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteSecurityConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteSecurityConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteSecurityConfigurationOutput, crate::error::DeleteSecurityConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_security_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteStudioOutput, crate::error::DeleteStudioError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteStudioError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteStudioError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DeleteStudioError { meta: generic, kind: crate::error::DeleteStudioErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteStudioError { meta: generic, kind: crate::error::DeleteStudioErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteStudioError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteStudioOutput, crate::error::DeleteStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_studio_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_session_mapping_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteStudioSessionMappingOutput, crate::error::DeleteStudioSessionMappingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteStudioSessionMappingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteStudioSessionMappingError { meta: generic, kind: crate::error::DeleteStudioSessionMappingErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DeleteStudioSessionMappingError { meta: generic, kind: crate::error::DeleteStudioSessionMappingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteStudioSessionMappingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_session_mapping_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteStudioSessionMappingOutput, crate::error::DeleteStudioSessionMappingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_studio_session_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClusterOutput, crate::error::DescribeClusterError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeClusterError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeClusterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeClusterError { meta: generic, kind: crate::error::DescribeClusterErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeClusterError { meta: generic, kind: crate::error::DescribeClusterErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeClusterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeClusterOutput, crate::error::DescribeClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_cluster(response.body().as_ref(), output).map_err(crate::error::DescribeClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_job_flows_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeJobFlowsOutput, crate::error::DescribeJobFlowsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeJobFlowsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeJobFlowsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeJobFlowsError { meta: generic, kind: crate::error::DescribeJobFlowsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeJobFlowsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeJobFlowsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_job_flows_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeJobFlowsOutput, crate::error::DescribeJobFlowsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_job_flows_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_job_flows(response.body().as_ref(), output).map_err(crate::error::DescribeJobFlowsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNotebookExecutionOutput, crate::error::DescribeNotebookExecutionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeNotebookExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeNotebookExecutionError { meta: generic, kind: crate::error::DescribeNotebookExecutionErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeNotebookExecutionError { meta: generic, kind: crate::error::DescribeNotebookExecutionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeNotebookExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeNotebookExecutionOutput, crate::error::DescribeNotebookExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_notebook_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_notebook_execution(response.body().as_ref(), output).map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_release_label_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReleaseLabelOutput, crate::error::DescribeReleaseLabelError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeReleaseLabelError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeReleaseLabelError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeReleaseLabelError { meta: generic, kind: crate::error::DescribeReleaseLabelErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeReleaseLabelError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeReleaseLabelError { meta: generic, kind: crate::error::DescribeReleaseLabelErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeReleaseLabelError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeReleaseLabelError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_release_label_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeReleaseLabelOutput, crate::error::DescribeReleaseLabelError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_release_label_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_release_label(response.body().as_ref(), output).map_err(crate::error::DescribeReleaseLabelError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityConfigurationOutput, crate::error::DescribeSecurityConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeSecurityConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeSecurityConfigurationError { meta: generic, kind: crate::error::DescribeSecurityConfigurationErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeSecurityConfigurationError { meta: generic, kind: crate::error::DescribeSecurityConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeSecurityConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeSecurityConfigurationOutput, crate::error::DescribeSecurityConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_security_configuration(response.body().as_ref(), output).map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_step_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStepOutput, crate::error::DescribeStepError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeStepError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeStepError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeStepError { meta: generic, kind: crate::error::DescribeStepErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStepError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeStepError { meta: generic, kind: crate::error::DescribeStepErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStepError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeStepError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_step_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStepOutput, crate::error::DescribeStepError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_step_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_step(response.body().as_ref(), output).map_err(crate::error::DescribeStepError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_studio_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStudioOutput, crate::error::DescribeStudioError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeStudioError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeStudioError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeStudioError { meta: generic, kind: crate::error::DescribeStudioErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::DescribeStudioError { meta: generic, kind: crate::error::DescribeStudioErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeStudioError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_studio_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStudioOutput, crate::error::DescribeStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_studio_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_studio(response.body().as_ref(), output).map_err(crate::error::DescribeStudioError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_auto_termination_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAutoTerminationPolicyOutput, crate::error::GetAutoTerminationPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetAutoTerminationPolicyError::unhandled)?;
    Err(crate::error::GetAutoTerminationPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_auto_termination_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetAutoTerminationPolicyOutput, crate::error::GetAutoTerminationPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_auto_termination_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_auto_termination_policy(response.body().as_ref(), output).map_err(crate::error::GetAutoTerminationPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_block_public_access_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetBlockPublicAccessConfigurationOutput, crate::error::GetBlockPublicAccessConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetBlockPublicAccessConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetBlockPublicAccessConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::GetBlockPublicAccessConfigurationError { meta: generic, kind: crate::error::GetBlockPublicAccessConfigurationErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlockPublicAccessConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetBlockPublicAccessConfigurationError { meta: generic, kind: crate::error::GetBlockPublicAccessConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlockPublicAccessConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetBlockPublicAccessConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_block_public_access_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetBlockPublicAccessConfigurationOutput, crate::error::GetBlockPublicAccessConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_block_public_access_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_block_public_access_configuration(response.body().as_ref(), output).map_err(crate::error::GetBlockPublicAccessConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cluster_session_credentials_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetClusterSessionCredentialsOutput, crate::error::GetClusterSessionCredentialsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetClusterSessionCredentialsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetClusterSessionCredentialsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetClusterSessionCredentialsError { meta: generic, kind: crate::error::GetClusterSessionCredentialsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetClusterSessionCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetClusterSessionCredentialsError { meta: generic, kind: crate::error::GetClusterSessionCredentialsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetClusterSessionCredentialsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetClusterSessionCredentialsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_cluster_session_credentials_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetClusterSessionCredentialsOutput, crate::error::GetClusterSessionCredentialsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_cluster_session_credentials_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_cluster_session_credentials(response.body().as_ref(), output).map_err(crate::error::GetClusterSessionCredentialsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetManagedScalingPolicyOutput, crate::error::GetManagedScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetManagedScalingPolicyError::unhandled)?;
    Err(crate::error::GetManagedScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetManagedScalingPolicyOutput, crate::error::GetManagedScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_managed_scaling_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_managed_scaling_policy(response.body().as_ref(), output).map_err(crate::error::GetManagedScalingPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_studio_session_mapping_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetStudioSessionMappingOutput, crate::error::GetStudioSessionMappingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetStudioSessionMappingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetStudioSessionMappingError { meta: generic, kind: crate::error::GetStudioSessionMappingErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::GetStudioSessionMappingError { meta: generic, kind: crate::error::GetStudioSessionMappingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetStudioSessionMappingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_studio_session_mapping_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetStudioSessionMappingOutput, crate::error::GetStudioSessionMappingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_studio_session_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_studio_session_mapping(response.body().as_ref(), output).map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bootstrap_actions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBootstrapActionsOutput, crate::error::ListBootstrapActionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBootstrapActionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBootstrapActionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListBootstrapActionsError { meta: generic, kind: crate::error::ListBootstrapActionsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBootstrapActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListBootstrapActionsError { meta: generic, kind: crate::error::ListBootstrapActionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBootstrapActionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBootstrapActionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bootstrap_actions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBootstrapActionsOutput, crate::error::ListBootstrapActionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_bootstrap_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_bootstrap_actions(response.body().as_ref(), output).map_err(crate::error::ListBootstrapActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_clusters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListClustersOutput, crate::error::ListClustersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListClustersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListClustersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListClustersError { meta: generic, kind: crate::error::ListClustersErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListClustersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListClustersError { meta: generic, kind: crate::error::ListClustersErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListClustersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListClustersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_clusters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListClustersOutput, crate::error::ListClustersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_clusters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_clusters(response.body().as_ref(), output).map_err(crate::error::ListClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_fleets_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInstanceFleetsOutput, crate::error::ListInstanceFleetsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListInstanceFleetsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListInstanceFleetsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListInstanceFleetsError { meta: generic, kind: crate::error::ListInstanceFleetsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceFleetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListInstanceFleetsError { meta: generic, kind: crate::error::ListInstanceFleetsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceFleetsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListInstanceFleetsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_fleets_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInstanceFleetsOutput, crate::error::ListInstanceFleetsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_fleets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_instance_fleets(response.body().as_ref(), output).map_err(crate::error::ListInstanceFleetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInstanceGroupsOutput, crate::error::ListInstanceGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListInstanceGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListInstanceGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListInstanceGroupsError { meta: generic, kind: crate::error::ListInstanceGroupsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListInstanceGroupsError { meta: generic, kind: crate::error::ListInstanceGroupsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstanceGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListInstanceGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInstanceGroupsOutput, crate::error::ListInstanceGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_instance_groups(response.body().as_ref(), output).map_err(crate::error::ListInstanceGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInstancesOutput, crate::error::ListInstancesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListInstancesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListInstancesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListInstancesError { meta: generic, kind: crate::error::ListInstancesErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListInstancesError { meta: generic, kind: crate::error::ListInstancesErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListInstancesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListInstancesOutput, crate::error::ListInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_instances(response.body().as_ref(), output).map_err(crate::error::ListInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_executions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListNotebookExecutionsOutput, crate::error::ListNotebookExecutionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListNotebookExecutionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListNotebookExecutionsError { meta: generic, kind: crate::error::ListNotebookExecutionsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListNotebookExecutionsError { meta: generic, kind: crate::error::ListNotebookExecutionsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListNotebookExecutionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_executions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListNotebookExecutionsOutput, crate::error::ListNotebookExecutionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_notebook_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_notebook_executions(response.body().as_ref(), output).map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_release_labels_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReleaseLabelsOutput, crate::error::ListReleaseLabelsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListReleaseLabelsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListReleaseLabelsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListReleaseLabelsError { meta: generic, kind: crate::error::ListReleaseLabelsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListReleaseLabelsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListReleaseLabelsError { meta: generic, kind: crate::error::ListReleaseLabelsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListReleaseLabelsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListReleaseLabelsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_release_labels_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListReleaseLabelsOutput, crate::error::ListReleaseLabelsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_release_labels_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_release_labels(response.body().as_ref(), output).map_err(crate::error::ListReleaseLabelsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_security_configurations_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSecurityConfigurationsOutput, crate::error::ListSecurityConfigurationsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListSecurityConfigurationsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListSecurityConfigurationsError { meta: generic, kind: crate::error::ListSecurityConfigurationsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListSecurityConfigurationsError { meta: generic, kind: crate::error::ListSecurityConfigurationsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListSecurityConfigurationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_security_configurations_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListSecurityConfigurationsOutput, crate::error::ListSecurityConfigurationsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_security_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_security_configurations(response.body().as_ref(), output).map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_steps_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListStepsOutput, crate::error::ListStepsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListStepsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListStepsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListStepsError { meta: generic, kind: crate::error::ListStepsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStepsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListStepsError { meta: generic, kind: crate::error::ListStepsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStepsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListStepsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_steps_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListStepsOutput, crate::error::ListStepsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_steps(response.body().as_ref(), output).map_err(crate::error::ListStepsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studios_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListStudiosOutput, crate::error::ListStudiosError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListStudiosError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListStudiosError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListStudiosError { meta: generic, kind: crate::error::ListStudiosErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStudiosError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListStudiosError { meta: generic, kind: crate::error::ListStudiosErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStudiosError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListStudiosError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studios_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListStudiosOutput, crate::error::ListStudiosError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_studios_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_studios(response.body().as_ref(), output).map_err(crate::error::ListStudiosError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studio_session_mappings_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListStudioSessionMappingsOutput, crate::error::ListStudioSessionMappingsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListStudioSessionMappingsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListStudioSessionMappingsError { meta: generic, kind: crate::error::ListStudioSessionMappingsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ListStudioSessionMappingsError { meta: generic, kind: crate::error::ListStudioSessionMappingsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListStudioSessionMappingsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studio_session_mappings_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListStudioSessionMappingsOutput, crate::error::ListStudioSessionMappingsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_studio_session_mappings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_studio_session_mappings(response.body().as_ref(), output).map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ModifyClusterError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ModifyClusterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ModifyClusterError { meta: generic, kind: crate::error::ModifyClusterErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ModifyClusterError { meta: generic, kind: crate::error::ModifyClusterErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyClusterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_modify_cluster(response.body().as_ref(), output).map_err(crate::error::ModifyClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_fleet_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceFleetOutput, crate::error::ModifyInstanceFleetError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ModifyInstanceFleetError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ModifyInstanceFleetError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ModifyInstanceFleetError { meta: generic, kind: crate::error::ModifyInstanceFleetErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::ModifyInstanceFleetError { meta: generic, kind: crate::error::ModifyInstanceFleetErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceFleetError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyInstanceFleetError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_fleet_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceFleetOutput, crate::error::ModifyInstanceFleetError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_fleet_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_groups_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceGroupsOutput, crate::error::ModifyInstanceGroupsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ModifyInstanceGroupsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ModifyInstanceGroupsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ModifyInstanceGroupsError { meta: generic, kind: crate::error::ModifyInstanceGroupsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::ModifyInstanceGroupsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ModifyInstanceGroupsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_groups_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ModifyInstanceGroupsOutput, crate::error::ModifyInstanceGroupsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_groups_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_auto_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutAutoScalingPolicyOutput, crate::error::PutAutoScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutAutoScalingPolicyError::unhandled)?;
    Err(crate::error::PutAutoScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_auto_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutAutoScalingPolicyOutput, crate::error::PutAutoScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_auto_scaling_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_auto_scaling_policy(response.body().as_ref(), output).map_err(crate::error::PutAutoScalingPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_auto_termination_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutAutoTerminationPolicyOutput, crate::error::PutAutoTerminationPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutAutoTerminationPolicyError::unhandled)?;
    Err(crate::error::PutAutoTerminationPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_auto_termination_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutAutoTerminationPolicyOutput, crate::error::PutAutoTerminationPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_auto_termination_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_block_public_access_configuration_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutBlockPublicAccessConfigurationOutput, crate::error::PutBlockPublicAccessConfigurationError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutBlockPublicAccessConfigurationError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutBlockPublicAccessConfigurationError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::PutBlockPublicAccessConfigurationError { meta: generic, kind: crate::error::PutBlockPublicAccessConfigurationErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutBlockPublicAccessConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::PutBlockPublicAccessConfigurationError { meta: generic, kind: crate::error::PutBlockPublicAccessConfigurationErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutBlockPublicAccessConfigurationError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutBlockPublicAccessConfigurationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_block_public_access_configuration_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutBlockPublicAccessConfigurationOutput, crate::error::PutBlockPublicAccessConfigurationError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_block_public_access_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_managed_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutManagedScalingPolicyOutput, crate::error::PutManagedScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutManagedScalingPolicyError::unhandled)?;
    Err(crate::error::PutManagedScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_managed_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutManagedScalingPolicyOutput, crate::error::PutManagedScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_managed_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_auto_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveAutoScalingPolicyOutput, crate::error::RemoveAutoScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RemoveAutoScalingPolicyError::unhandled)?;
    Err(crate::error::RemoveAutoScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_auto_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveAutoScalingPolicyOutput, crate::error::RemoveAutoScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_auto_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_auto_termination_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveAutoTerminationPolicyOutput, crate::error::RemoveAutoTerminationPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RemoveAutoTerminationPolicyError::unhandled)?;
    Err(crate::error::RemoveAutoTerminationPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_auto_termination_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveAutoTerminationPolicyOutput, crate::error::RemoveAutoTerminationPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_auto_termination_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_managed_scaling_policy_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveManagedScalingPolicyOutput, crate::error::RemoveManagedScalingPolicyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RemoveManagedScalingPolicyError::unhandled)?;
    Err(crate::error::RemoveManagedScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_managed_scaling_policy_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveManagedScalingPolicyOutput, crate::error::RemoveManagedScalingPolicyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_managed_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RemoveTagsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RemoveTagsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::RemoveTagsError { meta: generic, kind: crate::error::RemoveTagsErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::RemoveTagsError { meta: generic, kind: crate::error::RemoveTagsErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RemoveTagsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RemoveTagsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_job_flow_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RunJobFlowOutput, crate::error::RunJobFlowError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RunJobFlowError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RunJobFlowError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::RunJobFlowError { meta: generic, kind: crate::error::RunJobFlowErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::RunJobFlowError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RunJobFlowError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_job_flow_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RunJobFlowOutput, crate::error::RunJobFlowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::run_job_flow_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_run_job_flow(response.body().as_ref(), output).map_err(crate::error::RunJobFlowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_termination_protection_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetTerminationProtectionOutput, crate::error::SetTerminationProtectionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SetTerminationProtectionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SetTerminationProtectionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::SetTerminationProtectionError { meta: generic, kind: crate::error::SetTerminationProtectionErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetTerminationProtectionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SetTerminationProtectionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_termination_protection_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetTerminationProtectionOutput, crate::error::SetTerminationProtectionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_termination_protection_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_visible_to_all_users_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetVisibleToAllUsersOutput, crate::error::SetVisibleToAllUsersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SetVisibleToAllUsersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SetVisibleToAllUsersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::SetVisibleToAllUsersError { meta: generic, kind: crate::error::SetVisibleToAllUsersErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::SetVisibleToAllUsersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SetVisibleToAllUsersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_visible_to_all_users_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetVisibleToAllUsersOutput, crate::error::SetVisibleToAllUsersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_visible_to_all_users_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_notebook_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartNotebookExecutionOutput, crate::error::StartNotebookExecutionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartNotebookExecutionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartNotebookExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::StartNotebookExecutionError { meta: generic, kind: crate::error::StartNotebookExecutionErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartNotebookExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StartNotebookExecutionError { meta: generic, kind: crate::error::StartNotebookExecutionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartNotebookExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartNotebookExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_notebook_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartNotebookExecutionOutput, crate::error::StartNotebookExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_notebook_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_notebook_execution(response.body().as_ref(), output).map_err(crate::error::StartNotebookExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_notebook_execution_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopNotebookExecutionOutput, crate::error::StopNotebookExecutionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopNotebookExecutionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopNotebookExecutionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::StopNotebookExecutionError { meta: generic, kind: crate::error::StopNotebookExecutionErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::StopNotebookExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::StopNotebookExecutionError { meta: generic, kind: crate::error::StopNotebookExecutionErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopNotebookExecutionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopNotebookExecutionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_notebook_execution_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopNotebookExecutionOutput, crate::error::StopNotebookExecutionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_notebook_execution_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_job_flows_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateJobFlowsOutput, crate::error::TerminateJobFlowsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::TerminateJobFlowsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TerminateJobFlowsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::TerminateJobFlowsError { meta: generic, kind: crate::error::TerminateJobFlowsErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::TerminateJobFlowsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TerminateJobFlowsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_job_flows_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TerminateJobFlowsOutput, crate::error::TerminateJobFlowsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_job_flows_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateStudioOutput, crate::error::UpdateStudioError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateStudioError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateStudioError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::UpdateStudioError { meta: generic, kind: crate::error::UpdateStudioErrorKind::InternalServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateStudioError { meta: generic, kind: crate::error::UpdateStudioErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateStudioError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateStudioError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateStudioOutput, crate::error::UpdateStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_studio_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_session_mapping_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateStudioSessionMappingOutput, crate::error::UpdateStudioSessionMappingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateStudioSessionMappingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateStudioSessionMappingError { meta: generic, kind: crate::error::UpdateStudioSessionMappingErrorKind::InternalServerError({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_error_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRequestException" => crate::error::UpdateStudioSessionMappingError { meta: generic, kind: crate::error::UpdateStudioSessionMappingErrorKind::InvalidRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateStudioSessionMappingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateStudioSessionMappingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_session_mapping_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateStudioSessionMappingOutput, crate::error::UpdateStudioSessionMappingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_studio_session_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}

