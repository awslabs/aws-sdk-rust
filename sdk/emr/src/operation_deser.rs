// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddInstanceFleetOutput, crate::error::AddInstanceFleetError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddInstanceFleetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddInstanceFleetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::AddInstanceFleetError {
            meta: generic,
            kind: crate::error::AddInstanceFleetErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddInstanceFleetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::AddInstanceFleetError {
            meta: generic,
            kind: crate::error::AddInstanceFleetErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddInstanceFleetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddInstanceFleetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddInstanceFleetOutput, crate::error::AddInstanceFleetError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_instance_fleet_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_add_instance_fleet(response.body().as_ref(), output)
                .map_err(crate::error::AddInstanceFleetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddInstanceGroupsOutput, crate::error::AddInstanceGroupsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddInstanceGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddInstanceGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AddInstanceGroupsError {
            meta: generic,
            kind: crate::error::AddInstanceGroupsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddInstanceGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddInstanceGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_instance_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddInstanceGroupsOutput, crate::error::AddInstanceGroupsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_instance_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_add_instance_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AddInstanceGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_job_flow_steps_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddJobFlowStepsOutput, crate::error::AddJobFlowStepsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddJobFlowStepsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddJobFlowStepsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::AddJobFlowStepsError {
            meta: generic,
            kind: crate::error::AddJobFlowStepsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddJobFlowStepsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddJobFlowStepsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_job_flow_steps_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddJobFlowStepsOutput, crate::error::AddJobFlowStepsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_job_flow_steps_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_add_job_flow_steps(response.body().as_ref(), output)
                .map_err(crate::error::AddJobFlowStepsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::AddTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AddTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::AddTagsError {
            meta: generic,
            kind: crate::error::AddTagsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::AddTagsError {
            meta: generic,
            kind: crate::error::AddTagsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AddTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AddTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_add_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::AddTagsOutput, crate::error::AddTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::add_tags_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_steps_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelStepsOutput, crate::error::CancelStepsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CancelStepsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CancelStepsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CancelStepsError {
            meta: generic,
            kind: crate::error::CancelStepsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CancelStepsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::CancelStepsError {
            meta: generic,
            kind: crate::error::CancelStepsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CancelStepsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CancelStepsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_cancel_steps_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CancelStepsOutput, crate::error::CancelStepsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::cancel_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_cancel_steps(response.body().as_ref(), output)
            .map_err(crate::error::CancelStepsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSecurityConfigurationOutput,
    crate::error::CreateSecurityConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateSecurityConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::CreateSecurityConfigurationError {
            meta: generic,
            kind: crate::error::CreateSecurityConfigurationErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::CreateSecurityConfigurationError {
            meta: generic,
            kind: crate::error::CreateSecurityConfigurationErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateSecurityConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_security_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateSecurityConfigurationOutput,
    crate::error::CreateSecurityConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_security_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_security_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateSecurityConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStudioOutput, crate::error::CreateStudioError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateStudioError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateStudioError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::CreateStudioError {
            meta: generic,
            kind: crate::error::CreateStudioErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::CreateStudioError {
            meta: generic,
            kind: crate::error::CreateStudioErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateStudioError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateStudioOutput, crate::error::CreateStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_studio_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_studio(response.body().as_ref(), output)
            .map_err(crate::error::CreateStudioError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_session_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStudioSessionMappingOutput,
    crate::error::CreateStudioSessionMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateStudioSessionMappingError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::CreateStudioSessionMappingError {
            meta: generic,
            kind: crate::error::CreateStudioSessionMappingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::CreateStudioSessionMappingError {
            meta: generic,
            kind: crate::error::CreateStudioSessionMappingErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateStudioSessionMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_studio_session_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateStudioSessionMappingOutput,
    crate::error::CreateStudioSessionMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_studio_session_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSecurityConfigurationOutput,
    crate::error::DeleteSecurityConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSecurityConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSecurityConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DeleteSecurityConfigurationError {
            meta: generic,
            kind: crate::error::DeleteSecurityConfigurationErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteSecurityConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DeleteSecurityConfigurationError {
            meta: generic,
            kind: crate::error::DeleteSecurityConfigurationErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteSecurityConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteSecurityConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_security_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSecurityConfigurationOutput,
    crate::error::DeleteSecurityConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_security_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStudioOutput, crate::error::DeleteStudioError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteStudioError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteStudioError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DeleteStudioError {
            meta: generic,
            kind: crate::error::DeleteStudioErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DeleteStudioError {
            meta: generic,
            kind: crate::error::DeleteStudioErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteStudioError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteStudioOutput, crate::error::DeleteStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_studio_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_session_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStudioSessionMappingOutput,
    crate::error::DeleteStudioSessionMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteStudioSessionMappingError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DeleteStudioSessionMappingError {
            meta: generic,
            kind: crate::error::DeleteStudioSessionMappingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DeleteStudioSessionMappingError {
            meta: generic,
            kind: crate::error::DeleteStudioSessionMappingErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteStudioSessionMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_studio_session_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteStudioSessionMappingOutput,
    crate::error::DeleteStudioSessionMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_studio_session_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeClusterOutput, crate::error::DescribeClusterError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeClusterError {
            meta: generic,
            kind: crate::error::DescribeClusterErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DescribeClusterError {
            meta: generic,
            kind: crate::error::DescribeClusterErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeClusterOutput, crate::error::DescribeClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_cluster(response.body().as_ref(), output)
                .map_err(crate::error::DescribeClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_job_flows_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeJobFlowsOutput, crate::error::DescribeJobFlowsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeJobFlowsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeJobFlowsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeJobFlowsError {
            meta: generic,
            kind: crate::error::DescribeJobFlowsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeJobFlowsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeJobFlowsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_job_flows_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeJobFlowsOutput, crate::error::DescribeJobFlowsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_job_flows_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_job_flows(response.body().as_ref(), output)
                .map_err(crate::error::DescribeJobFlowsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotebookExecutionOutput,
    crate::error::DescribeNotebookExecutionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeNotebookExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::DescribeNotebookExecutionError {
            meta: generic,
            kind: crate::error::DescribeNotebookExecutionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DescribeNotebookExecutionError {
            meta: generic,
            kind: crate::error::DescribeNotebookExecutionErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeNotebookExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_notebook_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeNotebookExecutionOutput,
    crate::error::DescribeNotebookExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_notebook_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_notebook_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeNotebookExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityConfigurationOutput,
    crate::error::DescribeSecurityConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeSecurityConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeSecurityConfigurationError {
            meta: generic,
            kind: crate::error::DescribeSecurityConfigurationErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DescribeSecurityConfigurationError {
            meta: generic,
            kind: crate::error::DescribeSecurityConfigurationErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeSecurityConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_security_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeSecurityConfigurationOutput,
    crate::error::DescribeSecurityConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_security_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_security_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeSecurityConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_step_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStepOutput, crate::error::DescribeStepError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeStepError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeStepError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeStepError {
            meta: generic,
            kind: crate::error::DescribeStepErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeStepError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DescribeStepError {
            meta: generic,
            kind: crate::error::DescribeStepErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeStepError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeStepError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_step_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStepOutput, crate::error::DescribeStepError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_step_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_step(response.body().as_ref(), output)
            .map_err(crate::error::DescribeStepError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_studio_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStudioOutput, crate::error::DescribeStudioError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DescribeStudioError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeStudioError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::DescribeStudioError {
            meta: generic,
            kind: crate::error::DescribeStudioErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::DescribeStudioError {
            meta: generic,
            kind: crate::error::DescribeStudioErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DescribeStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeStudioError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_studio_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeStudioOutput, crate::error::DescribeStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_studio_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_studio(response.body().as_ref(), output)
                .map_err(crate::error::DescribeStudioError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_block_public_access_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBlockPublicAccessConfigurationOutput,
    crate::error::GetBlockPublicAccessConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBlockPublicAccessConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetBlockPublicAccessConfigurationError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::GetBlockPublicAccessConfigurationError {
            meta: generic,
            kind: crate::error::GetBlockPublicAccessConfigurationErrorKind::InternalServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_exception::Builder::default();
                        let _ = response;
                        output =
                            crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                                response.body().as_ref(),
                                output,
                            )
                            .map_err(
                                crate::error::GetBlockPublicAccessConfigurationError::unhandled,
                            )?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidRequestException" => crate::error::GetBlockPublicAccessConfigurationError {
            meta: generic,
            kind: crate::error::GetBlockPublicAccessConfigurationErrorKind::InvalidRequestException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_request_exception::Builder::default();
                        let _ = response;
                        output =
                            crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                                response.body().as_ref(),
                                output,
                            )
                            .map_err(
                                crate::error::GetBlockPublicAccessConfigurationError::unhandled,
                            )?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::GetBlockPublicAccessConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_block_public_access_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBlockPublicAccessConfigurationOutput,
    crate::error::GetBlockPublicAccessConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_block_public_access_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_block_public_access_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBlockPublicAccessConfigurationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_scaling_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetManagedScalingPolicyOutput,
    crate::error::GetManagedScalingPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetManagedScalingPolicyError::unhandled)?;
    Err(crate::error::GetManagedScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_managed_scaling_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetManagedScalingPolicyOutput,
    crate::error::GetManagedScalingPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_managed_scaling_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_managed_scaling_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetManagedScalingPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_studio_session_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetStudioSessionMappingOutput,
    crate::error::GetStudioSessionMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetStudioSessionMappingError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::GetStudioSessionMappingError {
            meta: generic,
            kind: crate::error::GetStudioSessionMappingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::GetStudioSessionMappingError {
            meta: generic,
            kind: crate::error::GetStudioSessionMappingErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetStudioSessionMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_studio_session_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetStudioSessionMappingOutput,
    crate::error::GetStudioSessionMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_studio_session_mapping_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_studio_session_mapping(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetStudioSessionMappingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bootstrap_actions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBootstrapActionsOutput,
    crate::error::ListBootstrapActionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListBootstrapActionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBootstrapActionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListBootstrapActionsError {
            meta: generic,
            kind: crate::error::ListBootstrapActionsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBootstrapActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListBootstrapActionsError {
            meta: generic,
            kind: crate::error::ListBootstrapActionsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListBootstrapActionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListBootstrapActionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_bootstrap_actions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListBootstrapActionsOutput,
    crate::error::ListBootstrapActionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_bootstrap_actions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_bootstrap_actions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBootstrapActionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_clusters_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListClustersOutput, crate::error::ListClustersError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListClustersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListClustersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListClustersError {
            meta: generic,
            kind: crate::error::ListClustersErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListClustersError {
            meta: generic,
            kind: crate::error::ListClustersErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListClustersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListClustersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_clusters_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListClustersOutput, crate::error::ListClustersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_clusters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_clusters(response.body().as_ref(), output)
            .map_err(crate::error::ListClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_fleets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceFleetsOutput,
    crate::error::ListInstanceFleetsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstanceFleetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstanceFleetsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListInstanceFleetsError {
            meta: generic,
            kind: crate::error::ListInstanceFleetsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceFleetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListInstanceFleetsError {
            meta: generic,
            kind: crate::error::ListInstanceFleetsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceFleetsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstanceFleetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_fleets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceFleetsOutput,
    crate::error::ListInstanceFleetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_fleets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_instance_fleets(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceFleetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceGroupsOutput,
    crate::error::ListInstanceGroupsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstanceGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstanceGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListInstanceGroupsError {
            meta: generic,
            kind: crate::error::ListInstanceGroupsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListInstanceGroupsError {
            meta: generic,
            kind: crate::error::ListInstanceGroupsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstanceGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstanceGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instance_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListInstanceGroupsOutput,
    crate::error::ListInstanceGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instance_groups_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_instance_groups(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListInstanceGroupsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instances_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListInstancesOutput, crate::error::ListInstancesError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListInstancesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListInstancesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListInstancesError {
            meta: generic,
            kind: crate::error::ListInstancesErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListInstancesError {
            meta: generic,
            kind: crate::error::ListInstancesErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListInstancesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListInstancesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_instances_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListInstancesOutput, crate::error::ListInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_instances_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_instances(response.body().as_ref(), output)
                .map_err(crate::error::ListInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_executions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNotebookExecutionsOutput,
    crate::error::ListNotebookExecutionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListNotebookExecutionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListNotebookExecutionsError {
            meta: generic,
            kind: crate::error::ListNotebookExecutionsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListNotebookExecutionsError {
            meta: generic,
            kind: crate::error::ListNotebookExecutionsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListNotebookExecutionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_notebook_executions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListNotebookExecutionsOutput,
    crate::error::ListNotebookExecutionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_notebook_executions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_notebook_executions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListNotebookExecutionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_security_configurations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSecurityConfigurationsOutput,
    crate::error::ListSecurityConfigurationsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListSecurityConfigurationsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListSecurityConfigurationsError {
            meta: generic,
            kind: crate::error::ListSecurityConfigurationsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListSecurityConfigurationsError {
            meta: generic,
            kind: crate::error::ListSecurityConfigurationsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListSecurityConfigurationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_security_configurations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSecurityConfigurationsOutput,
    crate::error::ListSecurityConfigurationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_security_configurations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_security_configurations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSecurityConfigurationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_steps_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStepsOutput, crate::error::ListStepsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListStepsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListStepsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListStepsError {
            meta: generic,
            kind: crate::error::ListStepsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListStepsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListStepsError {
            meta: generic,
            kind: crate::error::ListStepsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListStepsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListStepsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_steps_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStepsOutput, crate::error::ListStepsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_steps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_steps(response.body().as_ref(), output)
            .map_err(crate::error::ListStepsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studios_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStudiosOutput, crate::error::ListStudiosError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListStudiosError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListStudiosError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ListStudiosError {
            meta: generic,
            kind: crate::error::ListStudiosErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListStudiosError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListStudiosError {
            meta: generic,
            kind: crate::error::ListStudiosErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListStudiosError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListStudiosError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studios_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListStudiosOutput, crate::error::ListStudiosError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_studios_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_studios(response.body().as_ref(), output)
            .map_err(crate::error::ListStudiosError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studio_session_mappings_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStudioSessionMappingsOutput,
    crate::error::ListStudioSessionMappingsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListStudioSessionMappingsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ListStudioSessionMappingsError {
            meta: generic,
            kind: crate::error::ListStudioSessionMappingsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ListStudioSessionMappingsError {
            meta: generic,
            kind: crate::error::ListStudioSessionMappingsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListStudioSessionMappingsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_studio_session_mappings_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListStudioSessionMappingsOutput,
    crate::error::ListStudioSessionMappingsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_studio_session_mappings_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_studio_session_mappings(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListStudioSessionMappingsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyClusterError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyClusterError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ModifyClusterError {
            meta: generic,
            kind: crate::error::ModifyClusterErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyClusterError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyClusterError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_cluster_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ModifyClusterOutput, crate::error::ModifyClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_cluster_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_modify_cluster(response.body().as_ref(), output)
                .map_err(crate::error::ModifyClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_fleet_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceFleetOutput,
    crate::error::ModifyInstanceFleetError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyInstanceFleetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyInstanceFleetError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::ModifyInstanceFleetError {
            meta: generic,
            kind: crate::error::ModifyInstanceFleetErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyInstanceFleetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::ModifyInstanceFleetError {
            meta: generic,
            kind: crate::error::ModifyInstanceFleetErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyInstanceFleetError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyInstanceFleetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_fleet_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceFleetOutput,
    crate::error::ModifyInstanceFleetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_fleet_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_groups_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceGroupsOutput,
    crate::error::ModifyInstanceGroupsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ModifyInstanceGroupsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ModifyInstanceGroupsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::ModifyInstanceGroupsError {
            meta: generic,
            kind: crate::error::ModifyInstanceGroupsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ModifyInstanceGroupsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ModifyInstanceGroupsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_modify_instance_groups_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ModifyInstanceGroupsOutput,
    crate::error::ModifyInstanceGroupsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::modify_instance_groups_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_auto_scaling_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAutoScalingPolicyOutput,
    crate::error::PutAutoScalingPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutAutoScalingPolicyError::unhandled)?;
    Err(crate::error::PutAutoScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_auto_scaling_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAutoScalingPolicyOutput,
    crate::error::PutAutoScalingPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_auto_scaling_policy_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_put_auto_scaling_policy(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutAutoScalingPolicyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_block_public_access_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutBlockPublicAccessConfigurationOutput,
    crate::error::PutBlockPublicAccessConfigurationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutBlockPublicAccessConfigurationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutBlockPublicAccessConfigurationError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::PutBlockPublicAccessConfigurationError {
            meta: generic,
            kind: crate::error::PutBlockPublicAccessConfigurationErrorKind::InternalServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::internal_server_exception::Builder::default();
                        let _ = response;
                        output =
                            crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                                response.body().as_ref(),
                                output,
                            )
                            .map_err(
                                crate::error::PutBlockPublicAccessConfigurationError::unhandled,
                            )?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidRequestException" => crate::error::PutBlockPublicAccessConfigurationError {
            meta: generic,
            kind: crate::error::PutBlockPublicAccessConfigurationErrorKind::InvalidRequestException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_request_exception::Builder::default();
                        let _ = response;
                        output =
                            crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                                response.body().as_ref(),
                                output,
                            )
                            .map_err(
                                crate::error::PutBlockPublicAccessConfigurationError::unhandled,
                            )?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::PutBlockPublicAccessConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_block_public_access_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutBlockPublicAccessConfigurationOutput,
    crate::error::PutBlockPublicAccessConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_block_public_access_configuration_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_managed_scaling_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutManagedScalingPolicyOutput,
    crate::error::PutManagedScalingPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutManagedScalingPolicyError::unhandled)?;
    Err(crate::error::PutManagedScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_managed_scaling_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutManagedScalingPolicyOutput,
    crate::error::PutManagedScalingPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_managed_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_auto_scaling_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveAutoScalingPolicyOutput,
    crate::error::RemoveAutoScalingPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveAutoScalingPolicyError::unhandled)?;
    Err(crate::error::RemoveAutoScalingPolicyError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_auto_scaling_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveAutoScalingPolicyOutput,
    crate::error::RemoveAutoScalingPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_auto_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_managed_scaling_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveManagedScalingPolicyOutput,
    crate::error::RemoveManagedScalingPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveManagedScalingPolicyError::unhandled)?;
    Err(crate::error::RemoveManagedScalingPolicyError::generic(
        generic,
    ))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_managed_scaling_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::RemoveManagedScalingPolicyOutput,
    crate::error::RemoveManagedScalingPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_managed_scaling_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RemoveTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RemoveTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::RemoveTagsError {
            meta: generic,
            kind: crate::error::RemoveTagsErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RemoveTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::RemoveTagsError {
            meta: generic,
            kind: crate::error::RemoveTagsErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RemoveTagsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RemoveTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_remove_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RemoveTagsOutput, crate::error::RemoveTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::remove_tags_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_job_flow_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RunJobFlowOutput, crate::error::RunJobFlowError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::RunJobFlowError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::RunJobFlowError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::RunJobFlowError {
            meta: generic,
            kind: crate::error::RunJobFlowErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::RunJobFlowError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::RunJobFlowError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_run_job_flow_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::RunJobFlowOutput, crate::error::RunJobFlowError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::run_job_flow_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_run_job_flow(response.body().as_ref(), output)
            .map_err(crate::error::RunJobFlowError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_termination_protection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetTerminationProtectionOutput,
    crate::error::SetTerminationProtectionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::SetTerminationProtectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SetTerminationProtectionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::SetTerminationProtectionError {
            meta: generic,
            kind: crate::error::SetTerminationProtectionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::SetTerminationProtectionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SetTerminationProtectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_termination_protection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetTerminationProtectionOutput,
    crate::error::SetTerminationProtectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_termination_protection_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_visible_to_all_users_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetVisibleToAllUsersOutput,
    crate::error::SetVisibleToAllUsersError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::SetVisibleToAllUsersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SetVisibleToAllUsersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::SetVisibleToAllUsersError {
            meta: generic,
            kind: crate::error::SetVisibleToAllUsersErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::SetVisibleToAllUsersError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::SetVisibleToAllUsersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_visible_to_all_users_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SetVisibleToAllUsersOutput,
    crate::error::SetVisibleToAllUsersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_visible_to_all_users_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_notebook_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNotebookExecutionOutput,
    crate::error::StartNotebookExecutionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StartNotebookExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartNotebookExecutionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::StartNotebookExecutionError {
            meta: generic,
            kind: crate::error::StartNotebookExecutionErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartNotebookExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::StartNotebookExecutionError {
            meta: generic,
            kind: crate::error::StartNotebookExecutionErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StartNotebookExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartNotebookExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_notebook_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartNotebookExecutionOutput,
    crate::error::StartNotebookExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_notebook_execution_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_start_notebook_execution(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartNotebookExecutionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_notebook_execution_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopNotebookExecutionOutput,
    crate::error::StopNotebookExecutionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::StopNotebookExecutionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopNotebookExecutionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::StopNotebookExecutionError {
            meta: generic,
            kind: crate::error::StopNotebookExecutionErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopNotebookExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::StopNotebookExecutionError {
            meta: generic,
            kind: crate::error::StopNotebookExecutionErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::StopNotebookExecutionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StopNotebookExecutionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_notebook_execution_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopNotebookExecutionOutput,
    crate::error::StopNotebookExecutionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_notebook_execution_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_job_flows_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TerminateJobFlowsOutput, crate::error::TerminateJobFlowsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TerminateJobFlowsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TerminateJobFlowsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::TerminateJobFlowsError {
            meta: generic,
            kind: crate::error::TerminateJobFlowsErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TerminateJobFlowsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TerminateJobFlowsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_terminate_job_flows_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TerminateJobFlowsOutput, crate::error::TerminateJobFlowsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::terminate_job_flows_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStudioOutput, crate::error::UpdateStudioError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateStudioError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateStudioError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerException" => crate::error::UpdateStudioError {
            meta: generic,
            kind: crate::error::UpdateStudioErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::UpdateStudioError {
            meta: generic,
            kind: crate::error::UpdateStudioErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateStudioError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateStudioError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateStudioOutput, crate::error::UpdateStudioError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_studio_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_session_mapping_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateStudioSessionMappingOutput,
    crate::error::UpdateStudioSessionMappingError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateStudioSessionMappingError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateStudioSessionMappingError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InternalServerError" => crate::error::UpdateStudioSessionMappingError {
            meta: generic,
            kind: crate::error::UpdateStudioSessionMappingErrorKind::InternalServerError({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_internal_server_errorjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRequestException" => crate::error::UpdateStudioSessionMappingError {
            meta: generic,
            kind: crate::error::UpdateStudioSessionMappingErrorKind::InvalidRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_request_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateStudioSessionMappingError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateStudioSessionMappingError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_studio_session_mapping_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateStudioSessionMappingOutput,
    crate::error::UpdateStudioSessionMappingError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_studio_session_mapping_output::Builder::default();
        let _ = response;
        output.build()
    })
}
