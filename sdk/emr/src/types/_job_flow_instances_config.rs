// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A description of the Amazon EC2 instance on which the cluster (job flow) runs. A valid JobFlowInstancesConfig must contain either InstanceGroups or InstanceFleets. They cannot be used together. You may also have MasterInstanceType, SlaveInstanceType, and InstanceCount (all three must be present), but we don't recommend this configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobFlowInstancesConfig {
    /// <p>The EC2 instance type of the master node.</p>
    #[doc(hidden)]
    pub master_instance_type: std::option::Option<std::string::String>,
    /// <p>The EC2 instance type of the core and task nodes.</p>
    #[doc(hidden)]
    pub slave_instance_type: std::option::Option<std::string::String>,
    /// <p>The number of EC2 instances in the cluster.</p>
    #[doc(hidden)]
    pub instance_count: std::option::Option<i32>,
    /// <p>Configuration for the instance groups in a cluster.</p>
    #[doc(hidden)]
    pub instance_groups: std::option::Option<std::vec::Vec<crate::types::InstanceGroupConfig>>,
    /// <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    /// <p>Describes the EC2 instances and instance configurations for clusters that use the instance fleet configuration.</p>
    #[doc(hidden)]
    pub instance_fleets: std::option::Option<std::vec::Vec<crate::types::InstanceFleetConfig>>,
    /// <p>The name of the EC2 key pair that can be used to connect to the master node using SSH as the user called "hadoop."</p>
    #[doc(hidden)]
    pub ec2_key_name: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which the cluster runs.</p>
    #[doc(hidden)]
    pub placement: std::option::Option<crate::types::PlacementType>,
    /// <p>Specifies whether the cluster should remain available after completing all steps. Defaults to <code>true</code>. For more information about configuring cluster termination, see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-termination.html">Control Cluster Termination</a> in the <i>EMR Management Guide</i>.</p>
    #[doc(hidden)]
    pub keep_job_flow_alive_when_no_steps: bool,
    /// <p>Specifies whether to lock the cluster to prevent the Amazon EC2 instances from being terminated by API call, user intervention, or in the event of a job-flow error.</p>
    #[doc(hidden)]
    pub termination_protected: bool,
    /// <p>Applies only to Amazon EMR release versions earlier than 4.0. The Hadoop version for the cluster. Valid inputs are "0.18" (no longer maintained), "0.20" (no longer maintained), "0.20.205" (no longer maintained), "1.0.3", "2.2.0", or "2.4.0". If you do not set this value, the default of 0.18 is used, unless the <code>AmiVersion</code> parameter is set in the RunJobFlow call, in which case the default version of Hadoop for that AMI version is used.</p>
    #[doc(hidden)]
    pub hadoop_version: std::option::Option<std::string::String>,
    /// <p>Applies to clusters that use the uniform instance group configuration. To launch the cluster in Amazon Virtual Private Cloud (Amazon VPC), set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do not specify this value and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
    #[doc(hidden)]
    pub ec2_subnet_id: std::option::Option<std::string::String>,
    /// <p>Applies to clusters that use the instance fleet configuration. When multiple EC2 subnet IDs are specified, Amazon EMR evaluates them and launches instances in the optimal subnet.</p> <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    #[doc(hidden)]
    pub ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier of the Amazon EC2 security group for the master node. If you specify <code>EmrManagedMasterSecurityGroup</code>, you must also specify <code>EmrManagedSlaveSecurityGroup</code>.</p>
    #[doc(hidden)]
    pub emr_managed_master_security_group: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon EC2 security group for the core and task nodes. If you specify <code>EmrManagedSlaveSecurityGroup</code>, you must also specify <code>EmrManagedMasterSecurityGroup</code>.</p>
    #[doc(hidden)]
    pub emr_managed_slave_security_group: std::option::Option<std::string::String>,
    /// <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.</p>
    #[doc(hidden)]
    pub service_access_security_group: std::option::Option<std::string::String>,
    /// <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
    #[doc(hidden)]
    pub additional_master_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
    #[doc(hidden)]
    pub additional_slave_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl JobFlowInstancesConfig {
    /// <p>The EC2 instance type of the master node.</p>
    pub fn master_instance_type(&self) -> std::option::Option<&str> {
        self.master_instance_type.as_deref()
    }
    /// <p>The EC2 instance type of the core and task nodes.</p>
    pub fn slave_instance_type(&self) -> std::option::Option<&str> {
        self.slave_instance_type.as_deref()
    }
    /// <p>The number of EC2 instances in the cluster.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>Configuration for the instance groups in a cluster.</p>
    pub fn instance_groups(&self) -> std::option::Option<&[crate::types::InstanceGroupConfig]> {
        self.instance_groups.as_deref()
    }
    /// <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    /// <p>Describes the EC2 instances and instance configurations for clusters that use the instance fleet configuration.</p>
    pub fn instance_fleets(&self) -> std::option::Option<&[crate::types::InstanceFleetConfig]> {
        self.instance_fleets.as_deref()
    }
    /// <p>The name of the EC2 key pair that can be used to connect to the master node using SSH as the user called "hadoop."</p>
    pub fn ec2_key_name(&self) -> std::option::Option<&str> {
        self.ec2_key_name.as_deref()
    }
    /// <p>The Availability Zone in which the cluster runs.</p>
    pub fn placement(&self) -> std::option::Option<&crate::types::PlacementType> {
        self.placement.as_ref()
    }
    /// <p>Specifies whether the cluster should remain available after completing all steps. Defaults to <code>true</code>. For more information about configuring cluster termination, see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-termination.html">Control Cluster Termination</a> in the <i>EMR Management Guide</i>.</p>
    pub fn keep_job_flow_alive_when_no_steps(&self) -> bool {
        self.keep_job_flow_alive_when_no_steps
    }
    /// <p>Specifies whether to lock the cluster to prevent the Amazon EC2 instances from being terminated by API call, user intervention, or in the event of a job-flow error.</p>
    pub fn termination_protected(&self) -> bool {
        self.termination_protected
    }
    /// <p>Applies only to Amazon EMR release versions earlier than 4.0. The Hadoop version for the cluster. Valid inputs are "0.18" (no longer maintained), "0.20" (no longer maintained), "0.20.205" (no longer maintained), "1.0.3", "2.2.0", or "2.4.0". If you do not set this value, the default of 0.18 is used, unless the <code>AmiVersion</code> parameter is set in the RunJobFlow call, in which case the default version of Hadoop for that AMI version is used.</p>
    pub fn hadoop_version(&self) -> std::option::Option<&str> {
        self.hadoop_version.as_deref()
    }
    /// <p>Applies to clusters that use the uniform instance group configuration. To launch the cluster in Amazon Virtual Private Cloud (Amazon VPC), set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do not specify this value and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
    pub fn ec2_subnet_id(&self) -> std::option::Option<&str> {
        self.ec2_subnet_id.as_deref()
    }
    /// <p>Applies to clusters that use the instance fleet configuration. When multiple EC2 subnet IDs are specified, Amazon EMR evaluates them and launches instances in the optimal subnet.</p> <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    pub fn ec2_subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_subnet_ids.as_deref()
    }
    /// <p>The identifier of the Amazon EC2 security group for the master node. If you specify <code>EmrManagedMasterSecurityGroup</code>, you must also specify <code>EmrManagedSlaveSecurityGroup</code>.</p>
    pub fn emr_managed_master_security_group(&self) -> std::option::Option<&str> {
        self.emr_managed_master_security_group.as_deref()
    }
    /// <p>The identifier of the Amazon EC2 security group for the core and task nodes. If you specify <code>EmrManagedSlaveSecurityGroup</code>, you must also specify <code>EmrManagedMasterSecurityGroup</code>.</p>
    pub fn emr_managed_slave_security_group(&self) -> std::option::Option<&str> {
        self.emr_managed_slave_security_group.as_deref()
    }
    /// <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.</p>
    pub fn service_access_security_group(&self) -> std::option::Option<&str> {
        self.service_access_security_group.as_deref()
    }
    /// <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
    pub fn additional_master_security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.additional_master_security_groups.as_deref()
    }
    /// <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
    pub fn additional_slave_security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.additional_slave_security_groups.as_deref()
    }
}
impl JobFlowInstancesConfig {
    /// Creates a new builder-style object to manufacture [`JobFlowInstancesConfig`](crate::types::JobFlowInstancesConfig).
    pub fn builder() -> crate::types::builders::JobFlowInstancesConfigBuilder {
        crate::types::builders::JobFlowInstancesConfigBuilder::default()
    }
}

/// A builder for [`JobFlowInstancesConfig`](crate::types::JobFlowInstancesConfig).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct JobFlowInstancesConfigBuilder {
    pub(crate) master_instance_type: std::option::Option<std::string::String>,
    pub(crate) slave_instance_type: std::option::Option<std::string::String>,
    pub(crate) instance_count: std::option::Option<i32>,
    pub(crate) instance_groups:
        std::option::Option<std::vec::Vec<crate::types::InstanceGroupConfig>>,
    pub(crate) instance_fleets:
        std::option::Option<std::vec::Vec<crate::types::InstanceFleetConfig>>,
    pub(crate) ec2_key_name: std::option::Option<std::string::String>,
    pub(crate) placement: std::option::Option<crate::types::PlacementType>,
    pub(crate) keep_job_flow_alive_when_no_steps: std::option::Option<bool>,
    pub(crate) termination_protected: std::option::Option<bool>,
    pub(crate) hadoop_version: std::option::Option<std::string::String>,
    pub(crate) ec2_subnet_id: std::option::Option<std::string::String>,
    pub(crate) ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) emr_managed_master_security_group: std::option::Option<std::string::String>,
    pub(crate) emr_managed_slave_security_group: std::option::Option<std::string::String>,
    pub(crate) service_access_security_group: std::option::Option<std::string::String>,
    pub(crate) additional_master_security_groups:
        std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) additional_slave_security_groups:
        std::option::Option<std::vec::Vec<std::string::String>>,
}
impl JobFlowInstancesConfigBuilder {
    /// <p>The EC2 instance type of the master node.</p>
    pub fn master_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.master_instance_type = Some(input.into());
        self
    }
    /// <p>The EC2 instance type of the master node.</p>
    pub fn set_master_instance_type(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.master_instance_type = input;
        self
    }
    /// <p>The EC2 instance type of the core and task nodes.</p>
    pub fn slave_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.slave_instance_type = Some(input.into());
        self
    }
    /// <p>The EC2 instance type of the core and task nodes.</p>
    pub fn set_slave_instance_type(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.slave_instance_type = input;
        self
    }
    /// <p>The number of EC2 instances in the cluster.</p>
    pub fn instance_count(mut self, input: i32) -> Self {
        self.instance_count = Some(input);
        self
    }
    /// <p>The number of EC2 instances in the cluster.</p>
    pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
        self.instance_count = input;
        self
    }
    /// Appends an item to `instance_groups`.
    ///
    /// To override the contents of this collection use [`set_instance_groups`](Self::set_instance_groups).
    ///
    /// <p>Configuration for the instance groups in a cluster.</p>
    pub fn instance_groups(mut self, input: crate::types::InstanceGroupConfig) -> Self {
        let mut v = self.instance_groups.unwrap_or_default();
        v.push(input);
        self.instance_groups = Some(v);
        self
    }
    /// <p>Configuration for the instance groups in a cluster.</p>
    pub fn set_instance_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::InstanceGroupConfig>>,
    ) -> Self {
        self.instance_groups = input;
        self
    }
    /// Appends an item to `instance_fleets`.
    ///
    /// To override the contents of this collection use [`set_instance_fleets`](Self::set_instance_fleets).
    ///
    /// <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    /// <p>Describes the EC2 instances and instance configurations for clusters that use the instance fleet configuration.</p>
    pub fn instance_fleets(mut self, input: crate::types::InstanceFleetConfig) -> Self {
        let mut v = self.instance_fleets.unwrap_or_default();
        v.push(input);
        self.instance_fleets = Some(v);
        self
    }
    /// <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    /// <p>Describes the EC2 instances and instance configurations for clusters that use the instance fleet configuration.</p>
    pub fn set_instance_fleets(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::InstanceFleetConfig>>,
    ) -> Self {
        self.instance_fleets = input;
        self
    }
    /// <p>The name of the EC2 key pair that can be used to connect to the master node using SSH as the user called "hadoop."</p>
    pub fn ec2_key_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.ec2_key_name = Some(input.into());
        self
    }
    /// <p>The name of the EC2 key pair that can be used to connect to the master node using SSH as the user called "hadoop."</p>
    pub fn set_ec2_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ec2_key_name = input;
        self
    }
    /// <p>The Availability Zone in which the cluster runs.</p>
    pub fn placement(mut self, input: crate::types::PlacementType) -> Self {
        self.placement = Some(input);
        self
    }
    /// <p>The Availability Zone in which the cluster runs.</p>
    pub fn set_placement(
        mut self,
        input: std::option::Option<crate::types::PlacementType>,
    ) -> Self {
        self.placement = input;
        self
    }
    /// <p>Specifies whether the cluster should remain available after completing all steps. Defaults to <code>true</code>. For more information about configuring cluster termination, see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-termination.html">Control Cluster Termination</a> in the <i>EMR Management Guide</i>.</p>
    pub fn keep_job_flow_alive_when_no_steps(mut self, input: bool) -> Self {
        self.keep_job_flow_alive_when_no_steps = Some(input);
        self
    }
    /// <p>Specifies whether the cluster should remain available after completing all steps. Defaults to <code>true</code>. For more information about configuring cluster termination, see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-termination.html">Control Cluster Termination</a> in the <i>EMR Management Guide</i>.</p>
    pub fn set_keep_job_flow_alive_when_no_steps(
        mut self,
        input: std::option::Option<bool>,
    ) -> Self {
        self.keep_job_flow_alive_when_no_steps = input;
        self
    }
    /// <p>Specifies whether to lock the cluster to prevent the Amazon EC2 instances from being terminated by API call, user intervention, or in the event of a job-flow error.</p>
    pub fn termination_protected(mut self, input: bool) -> Self {
        self.termination_protected = Some(input);
        self
    }
    /// <p>Specifies whether to lock the cluster to prevent the Amazon EC2 instances from being terminated by API call, user intervention, or in the event of a job-flow error.</p>
    pub fn set_termination_protected(mut self, input: std::option::Option<bool>) -> Self {
        self.termination_protected = input;
        self
    }
    /// <p>Applies only to Amazon EMR release versions earlier than 4.0. The Hadoop version for the cluster. Valid inputs are "0.18" (no longer maintained), "0.20" (no longer maintained), "0.20.205" (no longer maintained), "1.0.3", "2.2.0", or "2.4.0". If you do not set this value, the default of 0.18 is used, unless the <code>AmiVersion</code> parameter is set in the RunJobFlow call, in which case the default version of Hadoop for that AMI version is used.</p>
    pub fn hadoop_version(mut self, input: impl Into<std::string::String>) -> Self {
        self.hadoop_version = Some(input.into());
        self
    }
    /// <p>Applies only to Amazon EMR release versions earlier than 4.0. The Hadoop version for the cluster. Valid inputs are "0.18" (no longer maintained), "0.20" (no longer maintained), "0.20.205" (no longer maintained), "1.0.3", "2.2.0", or "2.4.0". If you do not set this value, the default of 0.18 is used, unless the <code>AmiVersion</code> parameter is set in the RunJobFlow call, in which case the default version of Hadoop for that AMI version is used.</p>
    pub fn set_hadoop_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.hadoop_version = input;
        self
    }
    /// <p>Applies to clusters that use the uniform instance group configuration. To launch the cluster in Amazon Virtual Private Cloud (Amazon VPC), set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do not specify this value and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
    pub fn ec2_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.ec2_subnet_id = Some(input.into());
        self
    }
    /// <p>Applies to clusters that use the uniform instance group configuration. To launch the cluster in Amazon Virtual Private Cloud (Amazon VPC), set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do not specify this value and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
    pub fn set_ec2_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ec2_subnet_id = input;
        self
    }
    /// Appends an item to `ec2_subnet_ids`.
    ///
    /// To override the contents of this collection use [`set_ec2_subnet_ids`](Self::set_ec2_subnet_ids).
    ///
    /// <p>Applies to clusters that use the instance fleet configuration. When multiple EC2 subnet IDs are specified, Amazon EMR evaluates them and launches instances in the optimal subnet.</p> <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    pub fn ec2_subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.ec2_subnet_ids.unwrap_or_default();
        v.push(input.into());
        self.ec2_subnet_ids = Some(v);
        self
    }
    /// <p>Applies to clusters that use the instance fleet configuration. When multiple EC2 subnet IDs are specified, Amazon EMR evaluates them and launches instances in the optimal subnet.</p> <note>
    /// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
    /// </note>
    pub fn set_ec2_subnet_ids(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.ec2_subnet_ids = input;
        self
    }
    /// <p>The identifier of the Amazon EC2 security group for the master node. If you specify <code>EmrManagedMasterSecurityGroup</code>, you must also specify <code>EmrManagedSlaveSecurityGroup</code>.</p>
    pub fn emr_managed_master_security_group(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.emr_managed_master_security_group = Some(input.into());
        self
    }
    /// <p>The identifier of the Amazon EC2 security group for the master node. If you specify <code>EmrManagedMasterSecurityGroup</code>, you must also specify <code>EmrManagedSlaveSecurityGroup</code>.</p>
    pub fn set_emr_managed_master_security_group(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.emr_managed_master_security_group = input;
        self
    }
    /// <p>The identifier of the Amazon EC2 security group for the core and task nodes. If you specify <code>EmrManagedSlaveSecurityGroup</code>, you must also specify <code>EmrManagedMasterSecurityGroup</code>.</p>
    pub fn emr_managed_slave_security_group(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.emr_managed_slave_security_group = Some(input.into());
        self
    }
    /// <p>The identifier of the Amazon EC2 security group for the core and task nodes. If you specify <code>EmrManagedSlaveSecurityGroup</code>, you must also specify <code>EmrManagedMasterSecurityGroup</code>.</p>
    pub fn set_emr_managed_slave_security_group(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.emr_managed_slave_security_group = input;
        self
    }
    /// <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.</p>
    pub fn service_access_security_group(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_access_security_group = Some(input.into());
        self
    }
    /// <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private subnets.</p>
    pub fn set_service_access_security_group(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.service_access_security_group = input;
        self
    }
    /// Appends an item to `additional_master_security_groups`.
    ///
    /// To override the contents of this collection use [`set_additional_master_security_groups`](Self::set_additional_master_security_groups).
    ///
    /// <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
    pub fn additional_master_security_groups(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        let mut v = self.additional_master_security_groups.unwrap_or_default();
        v.push(input.into());
        self.additional_master_security_groups = Some(v);
        self
    }
    /// <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
    pub fn set_additional_master_security_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.additional_master_security_groups = input;
        self
    }
    /// Appends an item to `additional_slave_security_groups`.
    ///
    /// To override the contents of this collection use [`set_additional_slave_security_groups`](Self::set_additional_slave_security_groups).
    ///
    /// <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
    pub fn additional_slave_security_groups(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        let mut v = self.additional_slave_security_groups.unwrap_or_default();
        v.push(input.into());
        self.additional_slave_security_groups = Some(v);
        self
    }
    /// <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
    pub fn set_additional_slave_security_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<std::string::String>>,
    ) -> Self {
        self.additional_slave_security_groups = input;
        self
    }
    /// Consumes the builder and constructs a [`JobFlowInstancesConfig`](crate::types::JobFlowInstancesConfig).
    pub fn build(self) -> crate::types::JobFlowInstancesConfig {
        crate::types::JobFlowInstancesConfig {
            master_instance_type: self.master_instance_type,
            slave_instance_type: self.slave_instance_type,
            instance_count: self.instance_count,
            instance_groups: self.instance_groups,
            instance_fleets: self.instance_fleets,
            ec2_key_name: self.ec2_key_name,
            placement: self.placement,
            keep_job_flow_alive_when_no_steps: self
                .keep_job_flow_alive_when_no_steps
                .unwrap_or_default(),
            termination_protected: self.termination_protected.unwrap_or_default(),
            hadoop_version: self.hadoop_version,
            ec2_subnet_id: self.ec2_subnet_id,
            ec2_subnet_ids: self.ec2_subnet_ids,
            emr_managed_master_security_group: self.emr_managed_master_security_group,
            emr_managed_slave_security_group: self.emr_managed_slave_security_group,
            service_access_security_group: self.service_access_security_group,
            additional_master_security_groups: self.additional_master_security_groups,
            additional_slave_security_groups: self.additional_slave_security_groups,
        }
    }
}
