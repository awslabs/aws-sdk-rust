// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A notebook execution. An execution is a specific instance that an Amazon EMR Notebook is run using the <code>StartNotebookExecution</code> action.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct NotebookExecution {
    /// <p>The unique identifier of a notebook execution.</p>
    pub notebook_execution_id: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the Amazon EMR Notebook that is used for the notebook execution.</p>
    pub editor_id: ::std::option::Option<::std::string::String>,
    /// <p>The execution engine, such as an Amazon EMR cluster, used to run the Amazon EMR notebook and perform the notebook execution.</p>
    pub execution_engine: ::std::option::Option<crate::types::ExecutionEngineConfig>,
    /// <p>A name for the notebook execution.</p>
    pub notebook_execution_name: ::std::option::Option<::std::string::String>,
    /// <p>Input parameters in JSON format passed to the Amazon EMR Notebook at runtime for execution.</p>
    pub notebook_params: ::std::option::Option<::std::string::String>,
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub status: ::std::option::Option<crate::types::NotebookExecutionStatus>,
    /// <p>The timestamp when notebook execution started.</p>
    pub start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when notebook execution ended.</p>
    pub end_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub output_notebook_uri: ::std::option::Option<::std::string::String>,
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub last_state_change_reason: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the Amazon EC2 security group associated with the Amazon EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying Amazon EC2 Security Groups for Amazon EMR Notebooks</a> in the <i>Amazon EMR Management Guide</i>.</p>
    pub notebook_instance_security_group_id: ::std::option::Option<::std::string::String>,
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The Amazon S3 location that stores the notebook execution input.</p>
    pub notebook_s3_location: ::std::option::Option<crate::types::NotebookS3LocationForOutput>,
    /// <p>The Amazon S3 location for the notebook execution output.</p>
    pub output_notebook_s3_location: ::std::option::Option<crate::types::OutputNotebookS3LocationForOutput>,
    /// <p>The output format for the notebook execution.</p>
    pub output_notebook_format: ::std::option::Option<crate::types::OutputNotebookFormat>,
    /// <p>The environment variables associated with the notebook execution.</p>
    pub environment_variables: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl NotebookExecution {
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn notebook_execution_id(&self) -> ::std::option::Option<&str> {
        self.notebook_execution_id.as_deref()
    }
    /// <p>The unique identifier of the Amazon EMR Notebook that is used for the notebook execution.</p>
    pub fn editor_id(&self) -> ::std::option::Option<&str> {
        self.editor_id.as_deref()
    }
    /// <p>The execution engine, such as an Amazon EMR cluster, used to run the Amazon EMR notebook and perform the notebook execution.</p>
    pub fn execution_engine(&self) -> ::std::option::Option<&crate::types::ExecutionEngineConfig> {
        self.execution_engine.as_ref()
    }
    /// <p>A name for the notebook execution.</p>
    pub fn notebook_execution_name(&self) -> ::std::option::Option<&str> {
        self.notebook_execution_name.as_deref()
    }
    /// <p>Input parameters in JSON format passed to the Amazon EMR Notebook at runtime for execution.</p>
    pub fn notebook_params(&self) -> ::std::option::Option<&str> {
        self.notebook_params.as_deref()
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn status(&self) -> ::std::option::Option<&crate::types::NotebookExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn start_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn end_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn output_notebook_uri(&self) -> ::std::option::Option<&str> {
        self.output_notebook_uri.as_deref()
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn last_state_change_reason(&self) -> ::std::option::Option<&str> {
        self.last_state_change_reason.as_deref()
    }
    /// <p>The unique identifier of the Amazon EC2 security group associated with the Amazon EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying Amazon EC2 Security Groups for Amazon EMR Notebooks</a> in the <i>Amazon EMR Management Guide</i>.</p>
    pub fn notebook_instance_security_group_id(&self) -> ::std::option::Option<&str> {
        self.notebook_instance_security_group_id.as_deref()
    }
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The Amazon S3 location that stores the notebook execution input.</p>
    pub fn notebook_s3_location(&self) -> ::std::option::Option<&crate::types::NotebookS3LocationForOutput> {
        self.notebook_s3_location.as_ref()
    }
    /// <p>The Amazon S3 location for the notebook execution output.</p>
    pub fn output_notebook_s3_location(&self) -> ::std::option::Option<&crate::types::OutputNotebookS3LocationForOutput> {
        self.output_notebook_s3_location.as_ref()
    }
    /// <p>The output format for the notebook execution.</p>
    pub fn output_notebook_format(&self) -> ::std::option::Option<&crate::types::OutputNotebookFormat> {
        self.output_notebook_format.as_ref()
    }
    /// <p>The environment variables associated with the notebook execution.</p>
    pub fn environment_variables(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.environment_variables.as_ref()
    }
}
impl NotebookExecution {
    /// Creates a new builder-style object to manufacture [`NotebookExecution`](crate::types::NotebookExecution).
    pub fn builder() -> crate::types::builders::NotebookExecutionBuilder {
        crate::types::builders::NotebookExecutionBuilder::default()
    }
}

/// A builder for [`NotebookExecution`](crate::types::NotebookExecution).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct NotebookExecutionBuilder {
    pub(crate) notebook_execution_id: ::std::option::Option<::std::string::String>,
    pub(crate) editor_id: ::std::option::Option<::std::string::String>,
    pub(crate) execution_engine: ::std::option::Option<crate::types::ExecutionEngineConfig>,
    pub(crate) notebook_execution_name: ::std::option::Option<::std::string::String>,
    pub(crate) notebook_params: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::NotebookExecutionStatus>,
    pub(crate) start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) end_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) output_notebook_uri: ::std::option::Option<::std::string::String>,
    pub(crate) last_state_change_reason: ::std::option::Option<::std::string::String>,
    pub(crate) notebook_instance_security_group_id: ::std::option::Option<::std::string::String>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) notebook_s3_location: ::std::option::Option<crate::types::NotebookS3LocationForOutput>,
    pub(crate) output_notebook_s3_location: ::std::option::Option<crate::types::OutputNotebookS3LocationForOutput>,
    pub(crate) output_notebook_format: ::std::option::Option<crate::types::OutputNotebookFormat>,
    pub(crate) environment_variables: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl NotebookExecutionBuilder {
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn notebook_execution_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.notebook_execution_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn set_notebook_execution_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.notebook_execution_id = input;
        self
    }
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn get_notebook_execution_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.notebook_execution_id
    }
    /// <p>The unique identifier of the Amazon EMR Notebook that is used for the notebook execution.</p>
    pub fn editor_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.editor_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Amazon EMR Notebook that is used for the notebook execution.</p>
    pub fn set_editor_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.editor_id = input;
        self
    }
    /// <p>The unique identifier of the Amazon EMR Notebook that is used for the notebook execution.</p>
    pub fn get_editor_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.editor_id
    }
    /// <p>The execution engine, such as an Amazon EMR cluster, used to run the Amazon EMR notebook and perform the notebook execution.</p>
    pub fn execution_engine(mut self, input: crate::types::ExecutionEngineConfig) -> Self {
        self.execution_engine = ::std::option::Option::Some(input);
        self
    }
    /// <p>The execution engine, such as an Amazon EMR cluster, used to run the Amazon EMR notebook and perform the notebook execution.</p>
    pub fn set_execution_engine(mut self, input: ::std::option::Option<crate::types::ExecutionEngineConfig>) -> Self {
        self.execution_engine = input;
        self
    }
    /// <p>The execution engine, such as an Amazon EMR cluster, used to run the Amazon EMR notebook and perform the notebook execution.</p>
    pub fn get_execution_engine(&self) -> &::std::option::Option<crate::types::ExecutionEngineConfig> {
        &self.execution_engine
    }
    /// <p>A name for the notebook execution.</p>
    pub fn notebook_execution_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.notebook_execution_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A name for the notebook execution.</p>
    pub fn set_notebook_execution_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.notebook_execution_name = input;
        self
    }
    /// <p>A name for the notebook execution.</p>
    pub fn get_notebook_execution_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.notebook_execution_name
    }
    /// <p>Input parameters in JSON format passed to the Amazon EMR Notebook at runtime for execution.</p>
    pub fn notebook_params(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.notebook_params = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Input parameters in JSON format passed to the Amazon EMR Notebook at runtime for execution.</p>
    pub fn set_notebook_params(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.notebook_params = input;
        self
    }
    /// <p>Input parameters in JSON format passed to the Amazon EMR Notebook at runtime for execution.</p>
    pub fn get_notebook_params(&self) -> &::std::option::Option<::std::string::String> {
        &self.notebook_params
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn status(mut self, input: crate::types::NotebookExecutionStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::NotebookExecutionStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::NotebookExecutionStatus> {
        &self.status
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn start_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn set_start_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn get_start_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.start_time
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn end_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.end_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn set_end_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.end_time = input;
        self
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn get_end_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.end_time
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn output_notebook_uri(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.output_notebook_uri = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn set_output_notebook_uri(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.output_notebook_uri = input;
        self
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn get_output_notebook_uri(&self) -> &::std::option::Option<::std::string::String> {
        &self.output_notebook_uri
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn last_state_change_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.last_state_change_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn set_last_state_change_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.last_state_change_reason = input;
        self
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn get_last_state_change_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.last_state_change_reason
    }
    /// <p>The unique identifier of the Amazon EC2 security group associated with the Amazon EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying Amazon EC2 Security Groups for Amazon EMR Notebooks</a> in the <i>Amazon EMR Management Guide</i>.</p>
    pub fn notebook_instance_security_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.notebook_instance_security_group_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the Amazon EC2 security group associated with the Amazon EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying Amazon EC2 Security Groups for Amazon EMR Notebooks</a> in the <i>Amazon EMR Management Guide</i>.</p>
    pub fn set_notebook_instance_security_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.notebook_instance_security_group_id = input;
        self
    }
    /// <p>The unique identifier of the Amazon EC2 security group associated with the Amazon EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying Amazon EC2 Security Groups for Amazon EMR Notebooks</a> in the <i>Amazon EMR Management Guide</i>.</p>
    pub fn get_notebook_instance_security_group_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.notebook_instance_security_group_id
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The Amazon S3 location that stores the notebook execution input.</p>
    pub fn notebook_s3_location(mut self, input: crate::types::NotebookS3LocationForOutput) -> Self {
        self.notebook_s3_location = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Amazon S3 location that stores the notebook execution input.</p>
    pub fn set_notebook_s3_location(mut self, input: ::std::option::Option<crate::types::NotebookS3LocationForOutput>) -> Self {
        self.notebook_s3_location = input;
        self
    }
    /// <p>The Amazon S3 location that stores the notebook execution input.</p>
    pub fn get_notebook_s3_location(&self) -> &::std::option::Option<crate::types::NotebookS3LocationForOutput> {
        &self.notebook_s3_location
    }
    /// <p>The Amazon S3 location for the notebook execution output.</p>
    pub fn output_notebook_s3_location(mut self, input: crate::types::OutputNotebookS3LocationForOutput) -> Self {
        self.output_notebook_s3_location = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Amazon S3 location for the notebook execution output.</p>
    pub fn set_output_notebook_s3_location(mut self, input: ::std::option::Option<crate::types::OutputNotebookS3LocationForOutput>) -> Self {
        self.output_notebook_s3_location = input;
        self
    }
    /// <p>The Amazon S3 location for the notebook execution output.</p>
    pub fn get_output_notebook_s3_location(&self) -> &::std::option::Option<crate::types::OutputNotebookS3LocationForOutput> {
        &self.output_notebook_s3_location
    }
    /// <p>The output format for the notebook execution.</p>
    pub fn output_notebook_format(mut self, input: crate::types::OutputNotebookFormat) -> Self {
        self.output_notebook_format = ::std::option::Option::Some(input);
        self
    }
    /// <p>The output format for the notebook execution.</p>
    pub fn set_output_notebook_format(mut self, input: ::std::option::Option<crate::types::OutputNotebookFormat>) -> Self {
        self.output_notebook_format = input;
        self
    }
    /// <p>The output format for the notebook execution.</p>
    pub fn get_output_notebook_format(&self) -> &::std::option::Option<crate::types::OutputNotebookFormat> {
        &self.output_notebook_format
    }
    /// Adds a key-value pair to `environment_variables`.
    ///
    /// To override the contents of this collection use [`set_environment_variables`](Self::set_environment_variables).
    ///
    /// <p>The environment variables associated with the notebook execution.</p>
    pub fn environment_variables(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.environment_variables.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.environment_variables = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>The environment variables associated with the notebook execution.</p>
    pub fn set_environment_variables(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.environment_variables = input;
        self
    }
    /// <p>The environment variables associated with the notebook execution.</p>
    pub fn get_environment_variables(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.environment_variables
    }
    /// Consumes the builder and constructs a [`NotebookExecution`](crate::types::NotebookExecution).
    pub fn build(self) -> crate::types::NotebookExecution {
        crate::types::NotebookExecution {
            notebook_execution_id: self.notebook_execution_id,
            editor_id: self.editor_id,
            execution_engine: self.execution_engine,
            notebook_execution_name: self.notebook_execution_name,
            notebook_params: self.notebook_params,
            status: self.status,
            start_time: self.start_time,
            end_time: self.end_time,
            arn: self.arn,
            output_notebook_uri: self.output_notebook_uri,
            last_state_change_reason: self.last_state_change_reason,
            notebook_instance_security_group_id: self.notebook_instance_security_group_id,
            tags: self.tags,
            notebook_s3_location: self.notebook_s3_location,
            output_notebook_s3_location: self.output_notebook_s3_location,
            output_notebook_format: self.output_notebook_format,
            environment_variables: self.environment_variables,
        }
    }
}
