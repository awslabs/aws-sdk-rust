// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A notebook execution. An execution is a specific instance that an EMR Notebook is run using the <code>StartNotebookExecution</code> action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NotebookExecution {
    /// <p>The unique identifier of a notebook execution.</p>
    #[doc(hidden)]
    pub notebook_execution_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the EMR Notebook that is used for the notebook execution.</p>
    #[doc(hidden)]
    pub editor_id: std::option::Option<std::string::String>,
    /// <p>The execution engine, such as an EMR cluster, used to run the EMR notebook and perform the notebook execution.</p>
    #[doc(hidden)]
    pub execution_engine: std::option::Option<crate::types::ExecutionEngineConfig>,
    /// <p>A name for the notebook execution.</p>
    #[doc(hidden)]
    pub notebook_execution_name: std::option::Option<std::string::String>,
    /// <p>Input parameters in JSON format passed to the EMR Notebook at runtime for execution.</p>
    #[doc(hidden)]
    pub notebook_params: std::option::Option<std::string::String>,
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li>
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li>
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li>
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li>
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li>
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li>
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li>
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li>
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li>
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::NotebookExecutionStatus>,
    /// <p>The timestamp when notebook execution started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp when notebook execution ended.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    #[doc(hidden)]
    pub output_notebook_uri: std::option::Option<std::string::String>,
    /// <p>The reason for the latest status change of the notebook execution.</p>
    #[doc(hidden)]
    pub last_state_change_reason: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the EC2 security group associated with the EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying EC2 Security Groups for EMR Notebooks</a> in the <i>EMR Management Guide</i>.</p>
    #[doc(hidden)]
    pub notebook_instance_security_group_id: std::option::Option<std::string::String>,
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
}
impl NotebookExecution {
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn notebook_execution_id(&self) -> std::option::Option<&str> {
        self.notebook_execution_id.as_deref()
    }
    /// <p>The unique identifier of the EMR Notebook that is used for the notebook execution.</p>
    pub fn editor_id(&self) -> std::option::Option<&str> {
        self.editor_id.as_deref()
    }
    /// <p>The execution engine, such as an EMR cluster, used to run the EMR notebook and perform the notebook execution.</p>
    pub fn execution_engine(&self) -> std::option::Option<&crate::types::ExecutionEngineConfig> {
        self.execution_engine.as_ref()
    }
    /// <p>A name for the notebook execution.</p>
    pub fn notebook_execution_name(&self) -> std::option::Option<&str> {
        self.notebook_execution_name.as_deref()
    }
    /// <p>Input parameters in JSON format passed to the EMR Notebook at runtime for execution.</p>
    pub fn notebook_params(&self) -> std::option::Option<&str> {
        self.notebook_params.as_deref()
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li>
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li>
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li>
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li>
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li>
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li>
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li>
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li>
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li>
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::types::NotebookExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn output_notebook_uri(&self) -> std::option::Option<&str> {
        self.output_notebook_uri.as_deref()
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn last_state_change_reason(&self) -> std::option::Option<&str> {
        self.last_state_change_reason.as_deref()
    }
    /// <p>The unique identifier of the EC2 security group associated with the EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying EC2 Security Groups for EMR Notebooks</a> in the <i>EMR Management Guide</i>.</p>
    pub fn notebook_instance_security_group_id(&self) -> std::option::Option<&str> {
        self.notebook_instance_security_group_id.as_deref()
    }
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::types::Tag]> {
        self.tags.as_deref()
    }
}
impl NotebookExecution {
    /// Creates a new builder-style object to manufacture [`NotebookExecution`](crate::types::NotebookExecution).
    pub fn builder() -> crate::types::builders::NotebookExecutionBuilder {
        crate::types::builders::NotebookExecutionBuilder::default()
    }
}

/// A builder for [`NotebookExecution`](crate::types::NotebookExecution).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct NotebookExecutionBuilder {
    pub(crate) notebook_execution_id: std::option::Option<std::string::String>,
    pub(crate) editor_id: std::option::Option<std::string::String>,
    pub(crate) execution_engine: std::option::Option<crate::types::ExecutionEngineConfig>,
    pub(crate) notebook_execution_name: std::option::Option<std::string::String>,
    pub(crate) notebook_params: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::NotebookExecutionStatus>,
    pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) output_notebook_uri: std::option::Option<std::string::String>,
    pub(crate) last_state_change_reason: std::option::Option<std::string::String>,
    pub(crate) notebook_instance_security_group_id: std::option::Option<std::string::String>,
    pub(crate) tags: std::option::Option<std::vec::Vec<crate::types::Tag>>,
}
impl NotebookExecutionBuilder {
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn notebook_execution_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.notebook_execution_id = Some(input.into());
        self
    }
    /// <p>The unique identifier of a notebook execution.</p>
    pub fn set_notebook_execution_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.notebook_execution_id = input;
        self
    }
    /// <p>The unique identifier of the EMR Notebook that is used for the notebook execution.</p>
    pub fn editor_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.editor_id = Some(input.into());
        self
    }
    /// <p>The unique identifier of the EMR Notebook that is used for the notebook execution.</p>
    pub fn set_editor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.editor_id = input;
        self
    }
    /// <p>The execution engine, such as an EMR cluster, used to run the EMR notebook and perform the notebook execution.</p>
    pub fn execution_engine(mut self, input: crate::types::ExecutionEngineConfig) -> Self {
        self.execution_engine = Some(input);
        self
    }
    /// <p>The execution engine, such as an EMR cluster, used to run the EMR notebook and perform the notebook execution.</p>
    pub fn set_execution_engine(
        mut self,
        input: std::option::Option<crate::types::ExecutionEngineConfig>,
    ) -> Self {
        self.execution_engine = input;
        self
    }
    /// <p>A name for the notebook execution.</p>
    pub fn notebook_execution_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.notebook_execution_name = Some(input.into());
        self
    }
    /// <p>A name for the notebook execution.</p>
    pub fn set_notebook_execution_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.notebook_execution_name = input;
        self
    }
    /// <p>Input parameters in JSON format passed to the EMR Notebook at runtime for execution.</p>
    pub fn notebook_params(mut self, input: impl Into<std::string::String>) -> Self {
        self.notebook_params = Some(input.into());
        self
    }
    /// <p>Input parameters in JSON format passed to the EMR Notebook at runtime for execution.</p>
    pub fn set_notebook_params(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.notebook_params = input;
        self
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li>
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li>
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li>
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li>
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li>
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li>
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li>
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li>
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li>
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li>
    /// </ul>
    pub fn status(mut self, input: crate::types::NotebookExecutionStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The status of the notebook execution.</p>
    /// <ul>
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li>
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li>
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li>
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li>
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li>
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li>
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li>
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li>
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li>
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li>
    /// </ul>
    pub fn set_status(
        mut self,
        input: std::option::Option<crate::types::NotebookExecutionStatus>,
    ) -> Self {
        self.status = input;
        self
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.start_time = Some(input);
        self
    }
    /// <p>The timestamp when notebook execution started.</p>
    pub fn set_start_time(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.end_time = Some(input);
        self
    }
    /// <p>The timestamp when notebook execution ended.</p>
    pub fn set_end_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.end_time = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the notebook execution.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn output_notebook_uri(mut self, input: impl Into<std::string::String>) -> Self {
        self.output_notebook_uri = Some(input.into());
        self
    }
    /// <p>The location of the notebook execution's output file in Amazon S3.</p>
    pub fn set_output_notebook_uri(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.output_notebook_uri = input;
        self
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn last_state_change_reason(mut self, input: impl Into<std::string::String>) -> Self {
        self.last_state_change_reason = Some(input.into());
        self
    }
    /// <p>The reason for the latest status change of the notebook execution.</p>
    pub fn set_last_state_change_reason(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.last_state_change_reason = input;
        self
    }
    /// <p>The unique identifier of the EC2 security group associated with the EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying EC2 Security Groups for EMR Notebooks</a> in the <i>EMR Management Guide</i>.</p>
    pub fn notebook_instance_security_group_id(
        mut self,
        input: impl Into<std::string::String>,
    ) -> Self {
        self.notebook_instance_security_group_id = Some(input.into());
        self
    }
    /// <p>The unique identifier of the EC2 security group associated with the EMR Notebook instance. For more information see <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-managed-notebooks-security-groups.html">Specifying EC2 Security Groups for EMR Notebooks</a> in the <i>EMR Management Guide</i>.</p>
    pub fn set_notebook_instance_security_group_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.notebook_instance_security_group_id = input;
        self
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = Some(v);
        self
    }
    /// <p>A list of tags associated with a notebook execution. Tags are user-defined key-value pairs that consist of a required key string with a maximum of 128 characters and an optional value string with a maximum of 256 characters.</p>
    pub fn set_tags(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::Tag>>,
    ) -> Self {
        self.tags = input;
        self
    }
    /// Consumes the builder and constructs a [`NotebookExecution`](crate::types::NotebookExecution).
    pub fn build(self) -> crate::types::NotebookExecution {
        crate::types::NotebookExecution {
            notebook_execution_id: self.notebook_execution_id,
            editor_id: self.editor_id,
            execution_engine: self.execution_engine,
            notebook_execution_name: self.notebook_execution_name,
            notebook_params: self.notebook_params,
            status: self.status,
            start_time: self.start_time,
            end_time: self.end_time,
            arn: self.arn,
            output_notebook_uri: self.output_notebook_uri,
            last_state_change_reason: self.last_state_change_reason,
            notebook_instance_security_group_id: self.notebook_instance_security_group_id,
            tags: self.tags,
        }
    }
}
