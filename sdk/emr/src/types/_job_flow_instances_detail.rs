// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specify the type of Amazon EC2 instances that the cluster (job flow) runs on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobFlowInstancesDetail  {
    /// <p>The Amazon EC2 master node instance type.</p>
    #[doc(hidden)]
    pub master_instance_type: std::option::Option<std::string::String>,
    /// <p>The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.</p>
    #[doc(hidden)]
    pub master_public_dns_name: std::option::Option<std::string::String>,
    /// <p>The Amazon EC2 instance identifier of the master node.</p>
    #[doc(hidden)]
    pub master_instance_id: std::option::Option<std::string::String>,
    /// <p>The Amazon EC2 core and task node instance type.</p>
    #[doc(hidden)]
    pub slave_instance_type: std::option::Option<std::string::String>,
    /// <p>The number of Amazon EC2 instances in the cluster. If the value is 1, the same instance serves as both the master and core and task node. If the value is greater than 1, one instance is the master node and all others are core and task nodes.</p>
    #[doc(hidden)]
    pub instance_count: std::option::Option<i32>,
    /// <p>Details about the instance groups in a cluster.</p>
    #[doc(hidden)]
    pub instance_groups: std::option::Option<std::vec::Vec<crate::types::InstanceGroupDetail>>,
    /// <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is increased one time for every hour that an m1.small instance runs. Larger instances are weighted more heavily, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being increased incrementally four times. This result is only an approximation and does not reflect the actual billing rate.</p>
    #[doc(hidden)]
    pub normalized_instance_hours: std::option::Option<i32>,
    /// <p>The name of an Amazon EC2 key pair that can be used to connect to the master node using SSH.</p>
    #[doc(hidden)]
    pub ec2_key_name: std::option::Option<std::string::String>,
    /// <p>For clusters launched within Amazon Virtual Private Cloud, this is the identifier of the subnet where the cluster was launched.</p>
    #[doc(hidden)]
    pub ec2_subnet_id: std::option::Option<std::string::String>,
    /// <p>The Amazon EC2 Availability Zone for the cluster.</p>
    #[doc(hidden)]
    pub placement: std::option::Option<crate::types::PlacementType>,
    /// <p>Specifies whether the cluster should remain available after completing all steps.</p>
    #[doc(hidden)]
    pub keep_job_flow_alive_when_no_steps: bool,
    /// <p>Specifies whether the Amazon EC2 instances in the cluster are protected from termination by API calls, user intervention, or in the event of a job-flow error.</p>
    #[doc(hidden)]
    pub termination_protected: bool,
    /// <p>The Hadoop version for the cluster.</p>
    #[doc(hidden)]
    pub hadoop_version: std::option::Option<std::string::String>,
}
impl JobFlowInstancesDetail {
    /// <p>The Amazon EC2 master node instance type.</p>
    pub fn master_instance_type(&self) -> std::option::Option<& str> {
        self.master_instance_type.as_deref()
    }
    /// <p>The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.</p>
    pub fn master_public_dns_name(&self) -> std::option::Option<& str> {
        self.master_public_dns_name.as_deref()
    }
    /// <p>The Amazon EC2 instance identifier of the master node.</p>
    pub fn master_instance_id(&self) -> std::option::Option<& str> {
        self.master_instance_id.as_deref()
    }
    /// <p>The Amazon EC2 core and task node instance type.</p>
    pub fn slave_instance_type(&self) -> std::option::Option<& str> {
        self.slave_instance_type.as_deref()
    }
    /// <p>The number of Amazon EC2 instances in the cluster. If the value is 1, the same instance serves as both the master and core and task node. If the value is greater than 1, one instance is the master node and all others are core and task nodes.</p>
    pub fn instance_count(&self) -> std::option::Option<i32> {
        self.instance_count
    }
    /// <p>Details about the instance groups in a cluster.</p>
    pub fn instance_groups(&self) -> std::option::Option<& [crate::types::InstanceGroupDetail]> {
        self.instance_groups.as_deref()
    }
    /// <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is increased one time for every hour that an m1.small instance runs. Larger instances are weighted more heavily, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being increased incrementally four times. This result is only an approximation and does not reflect the actual billing rate.</p>
    pub fn normalized_instance_hours(&self) -> std::option::Option<i32> {
        self.normalized_instance_hours
    }
    /// <p>The name of an Amazon EC2 key pair that can be used to connect to the master node using SSH.</p>
    pub fn ec2_key_name(&self) -> std::option::Option<& str> {
        self.ec2_key_name.as_deref()
    }
    /// <p>For clusters launched within Amazon Virtual Private Cloud, this is the identifier of the subnet where the cluster was launched.</p>
    pub fn ec2_subnet_id(&self) -> std::option::Option<& str> {
        self.ec2_subnet_id.as_deref()
    }
    /// <p>The Amazon EC2 Availability Zone for the cluster.</p>
    pub fn placement(&self) -> std::option::Option<& crate::types::PlacementType> {
        self.placement.as_ref()
    }
    /// <p>Specifies whether the cluster should remain available after completing all steps.</p>
    pub fn keep_job_flow_alive_when_no_steps(&self) -> bool {
        self.keep_job_flow_alive_when_no_steps
    }
    /// <p>Specifies whether the Amazon EC2 instances in the cluster are protected from termination by API calls, user intervention, or in the event of a job-flow error.</p>
    pub fn termination_protected(&self) -> bool {
        self.termination_protected
    }
    /// <p>The Hadoop version for the cluster.</p>
    pub fn hadoop_version(&self) -> std::option::Option<& str> {
        self.hadoop_version.as_deref()
    }
}
impl JobFlowInstancesDetail {
    /// Creates a new builder-style object to manufacture [`JobFlowInstancesDetail`](crate::types::JobFlowInstancesDetail).
    pub fn builder() -> crate::types::builders::JobFlowInstancesDetailBuilder {
        crate::types::builders::JobFlowInstancesDetailBuilder::default()
    }
}

/// A builder for [`JobFlowInstancesDetail`](crate::types::JobFlowInstancesDetail).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct JobFlowInstancesDetailBuilder {
    pub(crate) master_instance_type: std::option::Option<std::string::String>,
    pub(crate) master_public_dns_name: std::option::Option<std::string::String>,
    pub(crate) master_instance_id: std::option::Option<std::string::String>,
    pub(crate) slave_instance_type: std::option::Option<std::string::String>,
    pub(crate) instance_count: std::option::Option<i32>,
    pub(crate) instance_groups: std::option::Option<std::vec::Vec<crate::types::InstanceGroupDetail>>,
    pub(crate) normalized_instance_hours: std::option::Option<i32>,
    pub(crate) ec2_key_name: std::option::Option<std::string::String>,
    pub(crate) ec2_subnet_id: std::option::Option<std::string::String>,
    pub(crate) placement: std::option::Option<crate::types::PlacementType>,
    pub(crate) keep_job_flow_alive_when_no_steps: std::option::Option<bool>,
    pub(crate) termination_protected: std::option::Option<bool>,
    pub(crate) hadoop_version: std::option::Option<std::string::String>,
}
impl JobFlowInstancesDetailBuilder {
    /// <p>The Amazon EC2 master node instance type.</p>
    pub fn master_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.master_instance_type = Some(input.into());
        self
    }
    /// <p>The Amazon EC2 master node instance type.</p>
    pub fn set_master_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.master_instance_type = input; self
    }
    /// <p>The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.</p>
    pub fn master_public_dns_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.master_public_dns_name = Some(input.into());
        self
    }
    /// <p>The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.</p>
    pub fn set_master_public_dns_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.master_public_dns_name = input; self
    }
    /// <p>The Amazon EC2 instance identifier of the master node.</p>
    pub fn master_instance_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.master_instance_id = Some(input.into());
        self
    }
    /// <p>The Amazon EC2 instance identifier of the master node.</p>
    pub fn set_master_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.master_instance_id = input; self
    }
    /// <p>The Amazon EC2 core and task node instance type.</p>
    pub fn slave_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.slave_instance_type = Some(input.into());
        self
    }
    /// <p>The Amazon EC2 core and task node instance type.</p>
    pub fn set_slave_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.slave_instance_type = input; self
    }
    /// <p>The number of Amazon EC2 instances in the cluster. If the value is 1, the same instance serves as both the master and core and task node. If the value is greater than 1, one instance is the master node and all others are core and task nodes.</p>
    pub fn instance_count(mut self, input: i32) -> Self {
        self.instance_count = Some(input);
        self
    }
    /// <p>The number of Amazon EC2 instances in the cluster. If the value is 1, the same instance serves as both the master and core and task node. If the value is greater than 1, one instance is the master node and all others are core and task nodes.</p>
    pub fn set_instance_count(mut self, input: std::option::Option<i32>) -> Self {
        self.instance_count = input; self
    }
    /// Appends an item to `instance_groups`.
    ///
    /// To override the contents of this collection use [`set_instance_groups`](Self::set_instance_groups).
    ///
    /// <p>Details about the instance groups in a cluster.</p>
    pub fn instance_groups(mut self, input: crate::types::InstanceGroupDetail) -> Self {
        let mut v = self.instance_groups.unwrap_or_default();
                        v.push(input);
                        self.instance_groups = Some(v);
                        self
    }
    /// <p>Details about the instance groups in a cluster.</p>
    pub fn set_instance_groups(mut self, input: std::option::Option<std::vec::Vec<crate::types::InstanceGroupDetail>>) -> Self {
        self.instance_groups = input; self
    }
    /// <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is increased one time for every hour that an m1.small instance runs. Larger instances are weighted more heavily, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being increased incrementally four times. This result is only an approximation and does not reflect the actual billing rate.</p>
    pub fn normalized_instance_hours(mut self, input: i32) -> Self {
        self.normalized_instance_hours = Some(input);
        self
    }
    /// <p>An approximation of the cost of the cluster, represented in m1.small/hours. This value is increased one time for every hour that an m1.small instance runs. Larger instances are weighted more heavily, so an Amazon EC2 instance that is roughly four times more expensive would result in the normalized instance hours being increased incrementally four times. This result is only an approximation and does not reflect the actual billing rate.</p>
    pub fn set_normalized_instance_hours(mut self, input: std::option::Option<i32>) -> Self {
        self.normalized_instance_hours = input; self
    }
    /// <p>The name of an Amazon EC2 key pair that can be used to connect to the master node using SSH.</p>
    pub fn ec2_key_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.ec2_key_name = Some(input.into());
        self
    }
    /// <p>The name of an Amazon EC2 key pair that can be used to connect to the master node using SSH.</p>
    pub fn set_ec2_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ec2_key_name = input; self
    }
    /// <p>For clusters launched within Amazon Virtual Private Cloud, this is the identifier of the subnet where the cluster was launched.</p>
    pub fn ec2_subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.ec2_subnet_id = Some(input.into());
        self
    }
    /// <p>For clusters launched within Amazon Virtual Private Cloud, this is the identifier of the subnet where the cluster was launched.</p>
    pub fn set_ec2_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.ec2_subnet_id = input; self
    }
    /// <p>The Amazon EC2 Availability Zone for the cluster.</p>
    pub fn placement(mut self, input: crate::types::PlacementType) -> Self {
        self.placement = Some(input);
        self
    }
    /// <p>The Amazon EC2 Availability Zone for the cluster.</p>
    pub fn set_placement(mut self, input: std::option::Option<crate::types::PlacementType>) -> Self {
        self.placement = input; self
    }
    /// <p>Specifies whether the cluster should remain available after completing all steps.</p>
    pub fn keep_job_flow_alive_when_no_steps(mut self, input: bool) -> Self {
        self.keep_job_flow_alive_when_no_steps = Some(input);
        self
    }
    /// <p>Specifies whether the cluster should remain available after completing all steps.</p>
    pub fn set_keep_job_flow_alive_when_no_steps(mut self, input: std::option::Option<bool>) -> Self {
        self.keep_job_flow_alive_when_no_steps = input; self
    }
    /// <p>Specifies whether the Amazon EC2 instances in the cluster are protected from termination by API calls, user intervention, or in the event of a job-flow error.</p>
    pub fn termination_protected(mut self, input: bool) -> Self {
        self.termination_protected = Some(input);
        self
    }
    /// <p>Specifies whether the Amazon EC2 instances in the cluster are protected from termination by API calls, user intervention, or in the event of a job-flow error.</p>
    pub fn set_termination_protected(mut self, input: std::option::Option<bool>) -> Self {
        self.termination_protected = input; self
    }
    /// <p>The Hadoop version for the cluster.</p>
    pub fn hadoop_version(mut self, input: impl Into<std::string::String>) -> Self {
        self.hadoop_version = Some(input.into());
        self
    }
    /// <p>The Hadoop version for the cluster.</p>
    pub fn set_hadoop_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.hadoop_version = input; self
    }
    /// Consumes the builder and constructs a [`JobFlowInstancesDetail`](crate::types::JobFlowInstancesDetail).
    pub fn build(self) -> crate::types::JobFlowInstancesDetail {
        crate::types::JobFlowInstancesDetail {
            master_instance_type: self.master_instance_type
            ,
            master_public_dns_name: self.master_public_dns_name
            ,
            master_instance_id: self.master_instance_id
            ,
            slave_instance_type: self.slave_instance_type
            ,
            instance_count: self.instance_count
            ,
            instance_groups: self.instance_groups
            ,
            normalized_instance_hours: self.normalized_instance_hours
            ,
            ec2_key_name: self.ec2_key_name
            ,
            ec2_subnet_id: self.ec2_subnet_id
            ,
            placement: self.placement
            ,
            keep_job_flow_alive_when_no_steps: self.keep_job_flow_alive_when_no_steps
                .unwrap_or_default()
            ,
            termination_protected: self.termination_protected
                .unwrap_or_default()
            ,
            hadoop_version: self.hadoop_version
            ,
        }
    }
}

