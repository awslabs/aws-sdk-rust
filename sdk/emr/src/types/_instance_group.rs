// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>This entity represents an instance group, which is a group of instances that have common purpose. For example, CORE instance group is used for HDFS.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceGroup  {
    /// <p>The identifier of the instance group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the instance group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The marketplace to provision instances for this group. Valid values are ON_DEMAND or SPOT.</p>
    #[doc(hidden)]
    pub market: std::option::Option<crate::types::MarketType>,
    /// <p>The type of the instance group. Valid values are MASTER, CORE or TASK.</p>
    #[doc(hidden)]
    pub instance_group_type: std::option::Option<crate::types::InstanceGroupType>,
    /// <p>If specified, indicates that the instance group uses Spot Instances. This is the maximum price you are willing to pay for Spot Instances. Specify <code>OnDemandPrice</code> to set the amount equal to the On-Demand price, or specify an amount in USD.</p>
    #[doc(hidden)]
    pub bid_price: std::option::Option<std::string::String>,
    /// <p>The EC2 instance type for all instances in the instance group.</p>
    #[doc(hidden)]
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The target number of instances for the instance group.</p>
    #[doc(hidden)]
    pub requested_instance_count: std::option::Option<i32>,
    /// <p>The number of instances currently running in this instance group.</p>
    #[doc(hidden)]
    pub running_instance_count: std::option::Option<i32>,
    /// <p>The current status of the instance group.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::InstanceGroupStatus>,
    /// <note> 
    /// <p>Amazon EMR releases 4.x or later.</p> 
    /// </note> 
    /// <p>The list of configurations supplied for an Amazon EMR cluster instance group. You can specify a separate configuration for each instance group (master, core, and task).</p>
    #[doc(hidden)]
    pub configurations: std::option::Option<std::vec::Vec<crate::types::Configuration>>,
    /// <p>The version number of the requested configuration specification for this instance group.</p>
    #[doc(hidden)]
    pub configurations_version: i64,
    /// <p>A list of configurations that were successfully applied for an instance group last time.</p>
    #[doc(hidden)]
    pub last_successfully_applied_configurations: std::option::Option<std::vec::Vec<crate::types::Configuration>>,
    /// <p>The version number of a configuration specification that was successfully applied for an instance group last time. </p>
    #[doc(hidden)]
    pub last_successfully_applied_configurations_version: i64,
    /// <p>The EBS block devices that are mapped to this instance group.</p>
    #[doc(hidden)]
    pub ebs_block_devices: std::option::Option<std::vec::Vec<crate::types::EbsBlockDevice>>,
    /// <p>If the instance group is EBS-optimized. An Amazon EBS-optimized instance uses an optimized configuration stack and provides additional, dedicated capacity for Amazon EBS I/O.</p>
    #[doc(hidden)]
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>Policy for customizing shrink operations.</p>
    #[doc(hidden)]
    pub shrink_policy: std::option::Option<crate::types::ShrinkPolicy>,
    /// <p>An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster. The automatic scaling policy defines how an instance group dynamically adds and terminates EC2 instances in response to the value of a CloudWatch metric. See PutAutoScalingPolicy.</p>
    #[doc(hidden)]
    pub auto_scaling_policy: std::option::Option<crate::types::AutoScalingPolicyDescription>,
    /// <p>The custom AMI ID to use for the provisioned instance group.</p>
    #[doc(hidden)]
    pub custom_ami_id: std::option::Option<std::string::String>,
}
impl InstanceGroup {
    /// <p>The identifier of the instance group.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The name of the instance group.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The marketplace to provision instances for this group. Valid values are ON_DEMAND or SPOT.</p>
    pub fn market(&self) -> std::option::Option<& crate::types::MarketType> {
        self.market.as_ref()
    }
    /// <p>The type of the instance group. Valid values are MASTER, CORE or TASK.</p>
    pub fn instance_group_type(&self) -> std::option::Option<& crate::types::InstanceGroupType> {
        self.instance_group_type.as_ref()
    }
    /// <p>If specified, indicates that the instance group uses Spot Instances. This is the maximum price you are willing to pay for Spot Instances. Specify <code>OnDemandPrice</code> to set the amount equal to the On-Demand price, or specify an amount in USD.</p>
    pub fn bid_price(&self) -> std::option::Option<& str> {
        self.bid_price.as_deref()
    }
    /// <p>The EC2 instance type for all instances in the instance group.</p>
    pub fn instance_type(&self) -> std::option::Option<& str> {
        self.instance_type.as_deref()
    }
    /// <p>The target number of instances for the instance group.</p>
    pub fn requested_instance_count(&self) -> std::option::Option<i32> {
        self.requested_instance_count
    }
    /// <p>The number of instances currently running in this instance group.</p>
    pub fn running_instance_count(&self) -> std::option::Option<i32> {
        self.running_instance_count
    }
    /// <p>The current status of the instance group.</p>
    pub fn status(&self) -> std::option::Option<& crate::types::InstanceGroupStatus> {
        self.status.as_ref()
    }
    /// <note> 
    /// <p>Amazon EMR releases 4.x or later.</p> 
    /// </note> 
    /// <p>The list of configurations supplied for an Amazon EMR cluster instance group. You can specify a separate configuration for each instance group (master, core, and task).</p>
    pub fn configurations(&self) -> std::option::Option<& [crate::types::Configuration]> {
        self.configurations.as_deref()
    }
    /// <p>The version number of the requested configuration specification for this instance group.</p>
    pub fn configurations_version(&self) -> i64 {
        self.configurations_version
    }
    /// <p>A list of configurations that were successfully applied for an instance group last time.</p>
    pub fn last_successfully_applied_configurations(&self) -> std::option::Option<& [crate::types::Configuration]> {
        self.last_successfully_applied_configurations.as_deref()
    }
    /// <p>The version number of a configuration specification that was successfully applied for an instance group last time. </p>
    pub fn last_successfully_applied_configurations_version(&self) -> i64 {
        self.last_successfully_applied_configurations_version
    }
    /// <p>The EBS block devices that are mapped to this instance group.</p>
    pub fn ebs_block_devices(&self) -> std::option::Option<& [crate::types::EbsBlockDevice]> {
        self.ebs_block_devices.as_deref()
    }
    /// <p>If the instance group is EBS-optimized. An Amazon EBS-optimized instance uses an optimized configuration stack and provides additional, dedicated capacity for Amazon EBS I/O.</p>
    pub fn ebs_optimized(&self) -> std::option::Option<bool> {
        self.ebs_optimized
    }
    /// <p>Policy for customizing shrink operations.</p>
    pub fn shrink_policy(&self) -> std::option::Option<& crate::types::ShrinkPolicy> {
        self.shrink_policy.as_ref()
    }
    /// <p>An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster. The automatic scaling policy defines how an instance group dynamically adds and terminates EC2 instances in response to the value of a CloudWatch metric. See PutAutoScalingPolicy.</p>
    pub fn auto_scaling_policy(&self) -> std::option::Option<& crate::types::AutoScalingPolicyDescription> {
        self.auto_scaling_policy.as_ref()
    }
    /// <p>The custom AMI ID to use for the provisioned instance group.</p>
    pub fn custom_ami_id(&self) -> std::option::Option<& str> {
        self.custom_ami_id.as_deref()
    }
}
impl InstanceGroup {
    /// Creates a new builder-style object to manufacture [`InstanceGroup`](crate::types::InstanceGroup).
    pub fn builder() -> crate::types::builders::InstanceGroupBuilder {
        crate::types::builders::InstanceGroupBuilder::default()
    }
}

/// A builder for [`InstanceGroup`](crate::types::InstanceGroup).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct InstanceGroupBuilder {
    pub(crate) id: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) market: std::option::Option<crate::types::MarketType>,
    pub(crate) instance_group_type: std::option::Option<crate::types::InstanceGroupType>,
    pub(crate) bid_price: std::option::Option<std::string::String>,
    pub(crate) instance_type: std::option::Option<std::string::String>,
    pub(crate) requested_instance_count: std::option::Option<i32>,
    pub(crate) running_instance_count: std::option::Option<i32>,
    pub(crate) status: std::option::Option<crate::types::InstanceGroupStatus>,
    pub(crate) configurations: std::option::Option<std::vec::Vec<crate::types::Configuration>>,
    pub(crate) configurations_version: std::option::Option<i64>,
    pub(crate) last_successfully_applied_configurations: std::option::Option<std::vec::Vec<crate::types::Configuration>>,
    pub(crate) last_successfully_applied_configurations_version: std::option::Option<i64>,
    pub(crate) ebs_block_devices: std::option::Option<std::vec::Vec<crate::types::EbsBlockDevice>>,
    pub(crate) ebs_optimized: std::option::Option<bool>,
    pub(crate) shrink_policy: std::option::Option<crate::types::ShrinkPolicy>,
    pub(crate) auto_scaling_policy: std::option::Option<crate::types::AutoScalingPolicyDescription>,
    pub(crate) custom_ami_id: std::option::Option<std::string::String>,
}
impl InstanceGroupBuilder {
    /// <p>The identifier of the instance group.</p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p>The identifier of the instance group.</p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input; self
    }
    /// <p>The name of the instance group.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the instance group.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input; self
    }
    /// <p>The marketplace to provision instances for this group. Valid values are ON_DEMAND or SPOT.</p>
    pub fn market(mut self, input: crate::types::MarketType) -> Self {
        self.market = Some(input);
        self
    }
    /// <p>The marketplace to provision instances for this group. Valid values are ON_DEMAND or SPOT.</p>
    pub fn set_market(mut self, input: std::option::Option<crate::types::MarketType>) -> Self {
        self.market = input; self
    }
    /// <p>The type of the instance group. Valid values are MASTER, CORE or TASK.</p>
    pub fn instance_group_type(mut self, input: crate::types::InstanceGroupType) -> Self {
        self.instance_group_type = Some(input);
        self
    }
    /// <p>The type of the instance group. Valid values are MASTER, CORE or TASK.</p>
    pub fn set_instance_group_type(mut self, input: std::option::Option<crate::types::InstanceGroupType>) -> Self {
        self.instance_group_type = input; self
    }
    /// <p>If specified, indicates that the instance group uses Spot Instances. This is the maximum price you are willing to pay for Spot Instances. Specify <code>OnDemandPrice</code> to set the amount equal to the On-Demand price, or specify an amount in USD.</p>
    pub fn bid_price(mut self, input: impl Into<std::string::String>) -> Self {
        self.bid_price = Some(input.into());
        self
    }
    /// <p>If specified, indicates that the instance group uses Spot Instances. This is the maximum price you are willing to pay for Spot Instances. Specify <code>OnDemandPrice</code> to set the amount equal to the On-Demand price, or specify an amount in USD.</p>
    pub fn set_bid_price(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.bid_price = input; self
    }
    /// <p>The EC2 instance type for all instances in the instance group.</p>
    pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.instance_type = Some(input.into());
        self
    }
    /// <p>The EC2 instance type for all instances in the instance group.</p>
    pub fn set_instance_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.instance_type = input; self
    }
    /// <p>The target number of instances for the instance group.</p>
    pub fn requested_instance_count(mut self, input: i32) -> Self {
        self.requested_instance_count = Some(input);
        self
    }
    /// <p>The target number of instances for the instance group.</p>
    pub fn set_requested_instance_count(mut self, input: std::option::Option<i32>) -> Self {
        self.requested_instance_count = input; self
    }
    /// <p>The number of instances currently running in this instance group.</p>
    pub fn running_instance_count(mut self, input: i32) -> Self {
        self.running_instance_count = Some(input);
        self
    }
    /// <p>The number of instances currently running in this instance group.</p>
    pub fn set_running_instance_count(mut self, input: std::option::Option<i32>) -> Self {
        self.running_instance_count = input; self
    }
    /// <p>The current status of the instance group.</p>
    pub fn status(mut self, input: crate::types::InstanceGroupStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The current status of the instance group.</p>
    pub fn set_status(mut self, input: std::option::Option<crate::types::InstanceGroupStatus>) -> Self {
        self.status = input; self
    }
    /// Appends an item to `configurations`.
    ///
    /// To override the contents of this collection use [`set_configurations`](Self::set_configurations).
    ///
    /// <note> 
    /// <p>Amazon EMR releases 4.x or later.</p> 
    /// </note> 
    /// <p>The list of configurations supplied for an Amazon EMR cluster instance group. You can specify a separate configuration for each instance group (master, core, and task).</p>
    pub fn configurations(mut self, input: crate::types::Configuration) -> Self {
        let mut v = self.configurations.unwrap_or_default();
                        v.push(input);
                        self.configurations = Some(v);
                        self
    }
    /// <note> 
    /// <p>Amazon EMR releases 4.x or later.</p> 
    /// </note> 
    /// <p>The list of configurations supplied for an Amazon EMR cluster instance group. You can specify a separate configuration for each instance group (master, core, and task).</p>
    pub fn set_configurations(mut self, input: std::option::Option<std::vec::Vec<crate::types::Configuration>>) -> Self {
        self.configurations = input; self
    }
    /// <p>The version number of the requested configuration specification for this instance group.</p>
    pub fn configurations_version(mut self, input: i64) -> Self {
        self.configurations_version = Some(input);
        self
    }
    /// <p>The version number of the requested configuration specification for this instance group.</p>
    pub fn set_configurations_version(mut self, input: std::option::Option<i64>) -> Self {
        self.configurations_version = input; self
    }
    /// Appends an item to `last_successfully_applied_configurations`.
    ///
    /// To override the contents of this collection use [`set_last_successfully_applied_configurations`](Self::set_last_successfully_applied_configurations).
    ///
    /// <p>A list of configurations that were successfully applied for an instance group last time.</p>
    pub fn last_successfully_applied_configurations(mut self, input: crate::types::Configuration) -> Self {
        let mut v = self.last_successfully_applied_configurations.unwrap_or_default();
                        v.push(input);
                        self.last_successfully_applied_configurations = Some(v);
                        self
    }
    /// <p>A list of configurations that were successfully applied for an instance group last time.</p>
    pub fn set_last_successfully_applied_configurations(mut self, input: std::option::Option<std::vec::Vec<crate::types::Configuration>>) -> Self {
        self.last_successfully_applied_configurations = input; self
    }
    /// <p>The version number of a configuration specification that was successfully applied for an instance group last time. </p>
    pub fn last_successfully_applied_configurations_version(mut self, input: i64) -> Self {
        self.last_successfully_applied_configurations_version = Some(input);
        self
    }
    /// <p>The version number of a configuration specification that was successfully applied for an instance group last time. </p>
    pub fn set_last_successfully_applied_configurations_version(mut self, input: std::option::Option<i64>) -> Self {
        self.last_successfully_applied_configurations_version = input; self
    }
    /// Appends an item to `ebs_block_devices`.
    ///
    /// To override the contents of this collection use [`set_ebs_block_devices`](Self::set_ebs_block_devices).
    ///
    /// <p>The EBS block devices that are mapped to this instance group.</p>
    pub fn ebs_block_devices(mut self, input: crate::types::EbsBlockDevice) -> Self {
        let mut v = self.ebs_block_devices.unwrap_or_default();
                        v.push(input);
                        self.ebs_block_devices = Some(v);
                        self
    }
    /// <p>The EBS block devices that are mapped to this instance group.</p>
    pub fn set_ebs_block_devices(mut self, input: std::option::Option<std::vec::Vec<crate::types::EbsBlockDevice>>) -> Self {
        self.ebs_block_devices = input; self
    }
    /// <p>If the instance group is EBS-optimized. An Amazon EBS-optimized instance uses an optimized configuration stack and provides additional, dedicated capacity for Amazon EBS I/O.</p>
    pub fn ebs_optimized(mut self, input: bool) -> Self {
        self.ebs_optimized = Some(input);
        self
    }
    /// <p>If the instance group is EBS-optimized. An Amazon EBS-optimized instance uses an optimized configuration stack and provides additional, dedicated capacity for Amazon EBS I/O.</p>
    pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
        self.ebs_optimized = input; self
    }
    /// <p>Policy for customizing shrink operations.</p>
    pub fn shrink_policy(mut self, input: crate::types::ShrinkPolicy) -> Self {
        self.shrink_policy = Some(input);
        self
    }
    /// <p>Policy for customizing shrink operations.</p>
    pub fn set_shrink_policy(mut self, input: std::option::Option<crate::types::ShrinkPolicy>) -> Self {
        self.shrink_policy = input; self
    }
    /// <p>An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster. The automatic scaling policy defines how an instance group dynamically adds and terminates EC2 instances in response to the value of a CloudWatch metric. See PutAutoScalingPolicy.</p>
    pub fn auto_scaling_policy(mut self, input: crate::types::AutoScalingPolicyDescription) -> Self {
        self.auto_scaling_policy = Some(input);
        self
    }
    /// <p>An automatic scaling policy for a core instance group or task instance group in an Amazon EMR cluster. The automatic scaling policy defines how an instance group dynamically adds and terminates EC2 instances in response to the value of a CloudWatch metric. See PutAutoScalingPolicy.</p>
    pub fn set_auto_scaling_policy(mut self, input: std::option::Option<crate::types::AutoScalingPolicyDescription>) -> Self {
        self.auto_scaling_policy = input; self
    }
    /// <p>The custom AMI ID to use for the provisioned instance group.</p>
    pub fn custom_ami_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.custom_ami_id = Some(input.into());
        self
    }
    /// <p>The custom AMI ID to use for the provisioned instance group.</p>
    pub fn set_custom_ami_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.custom_ami_id = input; self
    }
    /// Consumes the builder and constructs a [`InstanceGroup`](crate::types::InstanceGroup).
    pub fn build(self) -> crate::types::InstanceGroup {
        crate::types::InstanceGroup {
            id: self.id
            ,
            name: self.name
            ,
            market: self.market
            ,
            instance_group_type: self.instance_group_type
            ,
            bid_price: self.bid_price
            ,
            instance_type: self.instance_type
            ,
            requested_instance_count: self.requested_instance_count
            ,
            running_instance_count: self.running_instance_count
            ,
            status: self.status
            ,
            configurations: self.configurations
            ,
            configurations_version: self.configurations_version
                .unwrap_or_default()
            ,
            last_successfully_applied_configurations: self.last_successfully_applied_configurations
            ,
            last_successfully_applied_configurations_version: self.last_successfully_applied_configurations_version
                .unwrap_or_default()
            ,
            ebs_block_devices: self.ebs_block_devices
            ,
            ebs_optimized: self.ebs_optimized
            ,
            shrink_policy: self.shrink_policy
            ,
            auto_scaling_policy: self.auto_scaling_policy
            ,
            custom_ami_id: self.custom_ami_id
            ,
        }
    }
}

