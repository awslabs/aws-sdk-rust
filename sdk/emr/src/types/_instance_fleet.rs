// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes an instance fleet, which is a group of EC2 instances that host a particular node type (master, core, or task) in an Amazon EMR cluster. Instance fleets can consist of a mix of instance types and On-Demand and Spot Instances, which are provisioned to meet a defined target capacity. </p> <note>
/// <p>The instance fleet configuration is available only in Amazon EMR versions 4.8.0 and later, excluding 5.0.x versions.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceFleet {
    /// <p>The unique identifier of the instance fleet.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>A friendly name for the instance fleet.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The current status of the instance fleet. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::InstanceFleetStatus>,
    /// <p>The node type that the instance fleet hosts. Valid values are MASTER, CORE, or TASK. </p>
    #[doc(hidden)]
    pub instance_fleet_type: std::option::Option<crate::types::InstanceFleetType>,
    /// <p>The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand Instances to provision. When the instance fleet launches, Amazon EMR tries to provision On-Demand Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When an On-Demand Instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedOnDemandCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only Spot Instances are provisioned for the instance fleet using <code>TargetSpotCapacity</code>. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    #[doc(hidden)]
    pub target_on_demand_capacity: std::option::Option<i32>,
    /// <p>The target capacity of Spot units for the instance fleet, which determines how many Spot Instances to provision. When the instance fleet launches, Amazon EMR tries to provision Spot Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When a Spot instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedSpotCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only On-Demand Instances are provisioned for the instance fleet. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    #[doc(hidden)]
    pub target_spot_capacity: std::option::Option<i32>,
    /// <p>The number of On-Demand units that have been provisioned for the instance fleet to fulfill <code>TargetOnDemandCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetOnDemandCapacity</code>.</p>
    #[doc(hidden)]
    pub provisioned_on_demand_capacity: std::option::Option<i32>,
    /// <p>The number of Spot units that have been provisioned for this instance fleet to fulfill <code>TargetSpotCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetSpotCapacity</code>.</p>
    #[doc(hidden)]
    pub provisioned_spot_capacity: std::option::Option<i32>,
    /// <p>An array of specifications for the instance types that comprise an instance fleet.</p>
    #[doc(hidden)]
    pub instance_type_specifications:
        std::option::Option<std::vec::Vec<crate::types::InstanceTypeSpecification>>,
    /// <p>Describes the launch specification for an instance fleet. </p>
    #[doc(hidden)]
    pub launch_specifications:
        std::option::Option<crate::types::InstanceFleetProvisioningSpecifications>,
}
impl InstanceFleet {
    /// <p>The unique identifier of the instance fleet.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>A friendly name for the instance fleet.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The current status of the instance fleet. </p>
    pub fn status(&self) -> std::option::Option<&crate::types::InstanceFleetStatus> {
        self.status.as_ref()
    }
    /// <p>The node type that the instance fleet hosts. Valid values are MASTER, CORE, or TASK. </p>
    pub fn instance_fleet_type(&self) -> std::option::Option<&crate::types::InstanceFleetType> {
        self.instance_fleet_type.as_ref()
    }
    /// <p>The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand Instances to provision. When the instance fleet launches, Amazon EMR tries to provision On-Demand Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When an On-Demand Instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedOnDemandCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only Spot Instances are provisioned for the instance fleet using <code>TargetSpotCapacity</code>. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    pub fn target_on_demand_capacity(&self) -> std::option::Option<i32> {
        self.target_on_demand_capacity
    }
    /// <p>The target capacity of Spot units for the instance fleet, which determines how many Spot Instances to provision. When the instance fleet launches, Amazon EMR tries to provision Spot Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When a Spot instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedSpotCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only On-Demand Instances are provisioned for the instance fleet. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    pub fn target_spot_capacity(&self) -> std::option::Option<i32> {
        self.target_spot_capacity
    }
    /// <p>The number of On-Demand units that have been provisioned for the instance fleet to fulfill <code>TargetOnDemandCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetOnDemandCapacity</code>.</p>
    pub fn provisioned_on_demand_capacity(&self) -> std::option::Option<i32> {
        self.provisioned_on_demand_capacity
    }
    /// <p>The number of Spot units that have been provisioned for this instance fleet to fulfill <code>TargetSpotCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetSpotCapacity</code>.</p>
    pub fn provisioned_spot_capacity(&self) -> std::option::Option<i32> {
        self.provisioned_spot_capacity
    }
    /// <p>An array of specifications for the instance types that comprise an instance fleet.</p>
    pub fn instance_type_specifications(
        &self,
    ) -> std::option::Option<&[crate::types::InstanceTypeSpecification]> {
        self.instance_type_specifications.as_deref()
    }
    /// <p>Describes the launch specification for an instance fleet. </p>
    pub fn launch_specifications(
        &self,
    ) -> std::option::Option<&crate::types::InstanceFleetProvisioningSpecifications> {
        self.launch_specifications.as_ref()
    }
}
impl InstanceFleet {
    /// Creates a new builder-style object to manufacture [`InstanceFleet`](crate::types::InstanceFleet).
    pub fn builder() -> crate::types::builders::InstanceFleetBuilder {
        crate::types::builders::InstanceFleetBuilder::default()
    }
}

/// A builder for [`InstanceFleet`](crate::types::InstanceFleet).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct InstanceFleetBuilder {
    pub(crate) id: std::option::Option<std::string::String>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::InstanceFleetStatus>,
    pub(crate) instance_fleet_type: std::option::Option<crate::types::InstanceFleetType>,
    pub(crate) target_on_demand_capacity: std::option::Option<i32>,
    pub(crate) target_spot_capacity: std::option::Option<i32>,
    pub(crate) provisioned_on_demand_capacity: std::option::Option<i32>,
    pub(crate) provisioned_spot_capacity: std::option::Option<i32>,
    pub(crate) instance_type_specifications:
        std::option::Option<std::vec::Vec<crate::types::InstanceTypeSpecification>>,
    pub(crate) launch_specifications:
        std::option::Option<crate::types::InstanceFleetProvisioningSpecifications>,
}
impl InstanceFleetBuilder {
    /// <p>The unique identifier of the instance fleet.</p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p>The unique identifier of the instance fleet.</p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>A friendly name for the instance fleet.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>A friendly name for the instance fleet.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The current status of the instance fleet. </p>
    pub fn status(mut self, input: crate::types::InstanceFleetStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The current status of the instance fleet. </p>
    pub fn set_status(
        mut self,
        input: std::option::Option<crate::types::InstanceFleetStatus>,
    ) -> Self {
        self.status = input;
        self
    }
    /// <p>The node type that the instance fleet hosts. Valid values are MASTER, CORE, or TASK. </p>
    pub fn instance_fleet_type(mut self, input: crate::types::InstanceFleetType) -> Self {
        self.instance_fleet_type = Some(input);
        self
    }
    /// <p>The node type that the instance fleet hosts. Valid values are MASTER, CORE, or TASK. </p>
    pub fn set_instance_fleet_type(
        mut self,
        input: std::option::Option<crate::types::InstanceFleetType>,
    ) -> Self {
        self.instance_fleet_type = input;
        self
    }
    /// <p>The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand Instances to provision. When the instance fleet launches, Amazon EMR tries to provision On-Demand Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When an On-Demand Instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedOnDemandCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only Spot Instances are provisioned for the instance fleet using <code>TargetSpotCapacity</code>. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    pub fn target_on_demand_capacity(mut self, input: i32) -> Self {
        self.target_on_demand_capacity = Some(input);
        self
    }
    /// <p>The target capacity of On-Demand units for the instance fleet, which determines how many On-Demand Instances to provision. When the instance fleet launches, Amazon EMR tries to provision On-Demand Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When an On-Demand Instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedOnDemandCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only Spot Instances are provisioned for the instance fleet using <code>TargetSpotCapacity</code>. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    pub fn set_target_on_demand_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.target_on_demand_capacity = input;
        self
    }
    /// <p>The target capacity of Spot units for the instance fleet, which determines how many Spot Instances to provision. When the instance fleet launches, Amazon EMR tries to provision Spot Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When a Spot instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedSpotCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only On-Demand Instances are provisioned for the instance fleet. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    pub fn target_spot_capacity(mut self, input: i32) -> Self {
        self.target_spot_capacity = Some(input);
        self
    }
    /// <p>The target capacity of Spot units for the instance fleet, which determines how many Spot Instances to provision. When the instance fleet launches, Amazon EMR tries to provision Spot Instances as specified by <code>InstanceTypeConfig</code>. Each instance configuration has a specified <code>WeightedCapacity</code>. When a Spot instance is provisioned, the <code>WeightedCapacity</code> units count toward the target capacity. Amazon EMR provisions instances until the target capacity is totally fulfilled, even if this results in an overage. For example, if there are 2 units remaining to fulfill capacity, and Amazon EMR can only provision an instance with a <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the target capacity is exceeded by 3 units. You can use <code>InstanceFleet$ProvisionedSpotCapacity</code> to determine the Spot capacity units that have been provisioned for the instance fleet.</p> <note>
    /// <p>If not specified or set to 0, only On-Demand Instances are provisioned for the instance fleet. At least one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> should be greater than 0. For a master instance fleet, only one of <code>TargetSpotCapacity</code> and <code>TargetOnDemandCapacity</code> can be specified, and its value must be 1.</p>
    /// </note>
    pub fn set_target_spot_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.target_spot_capacity = input;
        self
    }
    /// <p>The number of On-Demand units that have been provisioned for the instance fleet to fulfill <code>TargetOnDemandCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetOnDemandCapacity</code>.</p>
    pub fn provisioned_on_demand_capacity(mut self, input: i32) -> Self {
        self.provisioned_on_demand_capacity = Some(input);
        self
    }
    /// <p>The number of On-Demand units that have been provisioned for the instance fleet to fulfill <code>TargetOnDemandCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetOnDemandCapacity</code>.</p>
    pub fn set_provisioned_on_demand_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.provisioned_on_demand_capacity = input;
        self
    }
    /// <p>The number of Spot units that have been provisioned for this instance fleet to fulfill <code>TargetSpotCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetSpotCapacity</code>.</p>
    pub fn provisioned_spot_capacity(mut self, input: i32) -> Self {
        self.provisioned_spot_capacity = Some(input);
        self
    }
    /// <p>The number of Spot units that have been provisioned for this instance fleet to fulfill <code>TargetSpotCapacity</code>. This provisioned capacity might be less than or greater than <code>TargetSpotCapacity</code>.</p>
    pub fn set_provisioned_spot_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.provisioned_spot_capacity = input;
        self
    }
    /// Appends an item to `instance_type_specifications`.
    ///
    /// To override the contents of this collection use [`set_instance_type_specifications`](Self::set_instance_type_specifications).
    ///
    /// <p>An array of specifications for the instance types that comprise an instance fleet.</p>
    pub fn instance_type_specifications(
        mut self,
        input: crate::types::InstanceTypeSpecification,
    ) -> Self {
        let mut v = self.instance_type_specifications.unwrap_or_default();
        v.push(input);
        self.instance_type_specifications = Some(v);
        self
    }
    /// <p>An array of specifications for the instance types that comprise an instance fleet.</p>
    pub fn set_instance_type_specifications(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::InstanceTypeSpecification>>,
    ) -> Self {
        self.instance_type_specifications = input;
        self
    }
    /// <p>Describes the launch specification for an instance fleet. </p>
    pub fn launch_specifications(
        mut self,
        input: crate::types::InstanceFleetProvisioningSpecifications,
    ) -> Self {
        self.launch_specifications = Some(input);
        self
    }
    /// <p>Describes the launch specification for an instance fleet. </p>
    pub fn set_launch_specifications(
        mut self,
        input: std::option::Option<crate::types::InstanceFleetProvisioningSpecifications>,
    ) -> Self {
        self.launch_specifications = input;
        self
    }
    /// Consumes the builder and constructs a [`InstanceFleet`](crate::types::InstanceFleet).
    pub fn build(self) -> crate::types::InstanceFleet {
        crate::types::InstanceFleet {
            id: self.id,
            name: self.name,
            status: self.status,
            instance_fleet_type: self.instance_fleet_type,
            target_on_demand_capacity: self.target_on_demand_capacity,
            target_spot_capacity: self.target_spot_capacity,
            provisioned_on_demand_capacity: self.provisioned_on_demand_capacity,
            provisioned_spot_capacity: self.provisioned_spot_capacity,
            instance_type_specifications: self.instance_type_specifications,
            launch_specifications: self.launch_specifications,
        }
    }
}
