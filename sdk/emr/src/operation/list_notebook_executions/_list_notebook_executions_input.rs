// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ListNotebookExecutionsInput {
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub editor_id: ::std::option::Option<::std::string::String>,
    /// <p>The status filter for listing notebook executions.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub status: ::std::option::Option<crate::types::NotebookExecutionStatus>,
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub from: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub to: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub marker: ::std::option::Option<::std::string::String>,
    /// <p>The unique ID of the execution engine.</p>
    pub execution_engine_id: ::std::option::Option<::std::string::String>,
}
impl ListNotebookExecutionsInput {
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn editor_id(&self) -> ::std::option::Option<&str> {
        self.editor_id.as_deref()
    }
    /// <p>The status filter for listing notebook executions.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn status(&self) -> ::std::option::Option<&crate::types::NotebookExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn from(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.from.as_ref()
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn to(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.to.as_ref()
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn marker(&self) -> ::std::option::Option<&str> {
        self.marker.as_deref()
    }
    /// <p>The unique ID of the execution engine.</p>
    pub fn execution_engine_id(&self) -> ::std::option::Option<&str> {
        self.execution_engine_id.as_deref()
    }
}
impl ListNotebookExecutionsInput {
    /// Creates a new builder-style object to manufacture [`ListNotebookExecutionsInput`](crate::operation::list_notebook_executions::ListNotebookExecutionsInput).
    pub fn builder() -> crate::operation::list_notebook_executions::builders::ListNotebookExecutionsInputBuilder {
        crate::operation::list_notebook_executions::builders::ListNotebookExecutionsInputBuilder::default()
    }
}

/// A builder for [`ListNotebookExecutionsInput`](crate::operation::list_notebook_executions::ListNotebookExecutionsInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ListNotebookExecutionsInputBuilder {
    pub(crate) editor_id: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<crate::types::NotebookExecutionStatus>,
    pub(crate) from: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) to: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) marker: ::std::option::Option<::std::string::String>,
    pub(crate) execution_engine_id: ::std::option::Option<::std::string::String>,
}
impl ListNotebookExecutionsInputBuilder {
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn editor_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.editor_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn set_editor_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.editor_id = input;
        self
    }
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn get_editor_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.editor_id
    }
    /// <p>The status filter for listing notebook executions.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn status(mut self, input: crate::types::NotebookExecutionStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status filter for listing notebook executions.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::NotebookExecutionStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status filter for listing notebook executions.</p>
    /// <ul>
    /// <li>
    /// <p><code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p></li>
    /// <li>
    /// <p><code>STARTING</code> indicates that the execution is starting on the cluster.</p></li>
    /// <li>
    /// <p><code>RUNNING</code> indicates that the execution is being processed by the cluster.</p></li>
    /// <li>
    /// <p><code>FINISHING</code> indicates that execution processing is in the final stages.</p></li>
    /// <li>
    /// <p><code>FINISHED</code> indicates that the execution has completed without error.</p></li>
    /// <li>
    /// <p><code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p></li>
    /// <li>
    /// <p><code>FAILED</code> indicates that the execution failed.</p></li>
    /// <li>
    /// <p><code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p></li>
    /// <li>
    /// <p><code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p></li>
    /// <li>
    /// <p><code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p></li>
    /// </ul>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::NotebookExecutionStatus> {
        &self.status
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn from(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.from = ::std::option::Option::Some(input);
        self
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn set_from(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.from = input;
        self
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn get_from(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.from
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn to(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.to = ::std::option::Option::Some(input);
        self
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn set_to(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.to = input;
        self
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn get_to(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.to
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn marker(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.marker = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn set_marker(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.marker = input;
        self
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn get_marker(&self) -> &::std::option::Option<::std::string::String> {
        &self.marker
    }
    /// <p>The unique ID of the execution engine.</p>
    pub fn execution_engine_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.execution_engine_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique ID of the execution engine.</p>
    pub fn set_execution_engine_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.execution_engine_id = input;
        self
    }
    /// <p>The unique ID of the execution engine.</p>
    pub fn get_execution_engine_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.execution_engine_id
    }
    /// Consumes the builder and constructs a [`ListNotebookExecutionsInput`](crate::operation::list_notebook_executions::ListNotebookExecutionsInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::list_notebook_executions::ListNotebookExecutionsInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::list_notebook_executions::ListNotebookExecutionsInput {
            editor_id: self.editor_id,
            status: self.status,
            from: self.from,
            to: self.to,
            marker: self.marker,
            execution_engine_id: self.execution_engine_id,
        })
    }
}
