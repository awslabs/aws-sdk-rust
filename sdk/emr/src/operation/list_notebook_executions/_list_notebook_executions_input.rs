// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListNotebookExecutionsInput  {
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    #[doc(hidden)]
    pub editor_id: std::option::Option<std::string::String>,
    /// <p>The status filter for listing notebook executions.</p> 
    /// <ul> 
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li> 
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li> 
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li> 
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li> 
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li> 
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li> 
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li> 
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li> 
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::NotebookExecutionStatus>,
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    #[doc(hidden)]
    pub from: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    #[doc(hidden)]
    pub to: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    #[doc(hidden)]
    pub marker: std::option::Option<std::string::String>,
}
impl ListNotebookExecutionsInput {
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn editor_id(&self) -> std::option::Option<& str> {
        self.editor_id.as_deref()
    }
    /// <p>The status filter for listing notebook executions.</p> 
    /// <ul> 
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li> 
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li> 
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li> 
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li> 
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li> 
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li> 
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li> 
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li> 
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// </ul>
    pub fn status(&self) -> std::option::Option<& crate::types::NotebookExecutionStatus> {
        self.status.as_ref()
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn from(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.from.as_ref()
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn to(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.to.as_ref()
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn marker(&self) -> std::option::Option<& str> {
        self.marker.as_deref()
    }
}
impl ListNotebookExecutionsInput {
    /// Creates a new builder-style object to manufacture [`ListNotebookExecutionsInput`](crate::operation::list_notebook_executions::ListNotebookExecutionsInput).
    pub fn builder() -> crate::operation::list_notebook_executions::builders::ListNotebookExecutionsInputBuilder {
        crate::operation::list_notebook_executions::builders::ListNotebookExecutionsInputBuilder::default()
    }
}

/// A builder for [`ListNotebookExecutionsInput`](crate::operation::list_notebook_executions::ListNotebookExecutionsInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ListNotebookExecutionsInputBuilder {
    pub(crate) editor_id: std::option::Option<std::string::String>,
    pub(crate) status: std::option::Option<crate::types::NotebookExecutionStatus>,
    pub(crate) from: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) to: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) marker: std::option::Option<std::string::String>,
}
impl ListNotebookExecutionsInputBuilder {
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn editor_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.editor_id = Some(input.into());
        self
    }
    /// <p>The unique ID of the editor associated with the notebook execution.</p>
    pub fn set_editor_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.editor_id = input; self
    }
    /// <p>The status filter for listing notebook executions.</p> 
    /// <ul> 
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li> 
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li> 
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li> 
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li> 
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li> 
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li> 
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li> 
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li> 
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// </ul>
    pub fn status(mut self, input: crate::types::NotebookExecutionStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The status filter for listing notebook executions.</p> 
    /// <ul> 
    /// <li> <p> <code>START_PENDING</code> indicates that the cluster has received the execution request but execution has not begun.</p> </li> 
    /// <li> <p> <code>STARTING</code> indicates that the execution is starting on the cluster.</p> </li> 
    /// <li> <p> <code>RUNNING</code> indicates that the execution is being processed by the cluster.</p> </li> 
    /// <li> <p> <code>FINISHING</code> indicates that execution processing is in the final stages.</p> </li> 
    /// <li> <p> <code>FINISHED</code> indicates that the execution has completed without error.</p> </li> 
    /// <li> <p> <code>FAILING</code> indicates that the execution is failing and will not finish successfully.</p> </li> 
    /// <li> <p> <code>FAILED</code> indicates that the execution failed.</p> </li> 
    /// <li> <p> <code>STOP_PENDING</code> indicates that the cluster has received a <code>StopNotebookExecution</code> request and the stop is pending.</p> </li> 
    /// <li> <p> <code>STOPPING</code> indicates that the cluster is in the process of stopping the execution as a result of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// <li> <p> <code>STOPPED</code> indicates that the execution stopped because of a <code>StopNotebookExecution</code> request.</p> </li> 
    /// </ul>
    pub fn set_status(mut self, input: std::option::Option<crate::types::NotebookExecutionStatus>) -> Self {
        self.status = input; self
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn from(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.from = Some(input);
        self
    }
    /// <p>The beginning of time range filter for listing notebook executions. The default is the timestamp of 30 days ago.</p>
    pub fn set_from(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.from = input; self
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn to(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.to = Some(input);
        self
    }
    /// <p>The end of time range filter for listing notebook executions. The default is the current timestamp.</p>
    pub fn set_to(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.to = input; self
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
        self.marker = Some(input.into());
        self
    }
    /// <p>The pagination token, returned by a previous <code>ListNotebookExecutions</code> call, that indicates the start of the list for this <code>ListNotebookExecutions</code> call.</p>
    pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.marker = input; self
    }
    /// Consumes the builder and constructs a [`ListNotebookExecutionsInput`](crate::operation::list_notebook_executions::ListNotebookExecutionsInput).
    pub fn build(self) -> Result<crate::operation::list_notebook_executions::ListNotebookExecutionsInput, aws_smithy_http::operation::error::BuildError> {
        Ok(
            crate::operation::list_notebook_executions::ListNotebookExecutionsInput {
                editor_id: self.editor_id
                ,
                status: self.status
                ,
                from: self.from
                ,
                to: self.to
                ,
                marker: self.marker
                ,
            }
        )
    }
}

