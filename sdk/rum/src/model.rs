// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Use this structure to define one extended metric that RUM will send to CloudWatch or CloudWatch Evidently. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-vended-metrics.html"> Additional metrics that you can send to CloudWatch and CloudWatch Evidently</a>.</p>
/// <p>Only certain combinations of values for <code>Name</code>, <code>ValueKey</code>, and <code>EventPattern</code> are valid. In addition to what is displayed in the list below, the <code>EventPattern</code> can also include information used by the <code>DimensionKeys</code> field.</p>
/// <ul>
/// <li> <p>If <code>Name</code> is <code>PerformanceNavigationDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_navigation_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>PerformanceResourceDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_resource_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationSatisfiedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;",2000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationToleratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",2000,"&lt;"8000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationFrustratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",8000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsCumulativeLayoutShift</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.cumulative_layout_shift_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsFirstInputDelay</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.first_input_delay_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsLargestContentfulPaint</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.largest_contentful_paint_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>JsErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.js_error_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>HttpErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.http_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>SessionCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.session_start_event"]}</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    #[doc(hidden)]
    pub value_key: std::option::Option<std::string::String>,
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    #[doc(hidden)]
    pub unit_label: std::option::Option<std::string::String>,
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    #[doc(hidden)]
    pub dimension_keys:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    #[doc(hidden)]
    pub event_pattern: std::option::Option<std::string::String>,
}
impl MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(&self) -> std::option::Option<&str> {
        self.value_key.as_deref()
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(&self) -> std::option::Option<&str> {
        self.unit_label.as_deref()
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.dimension_keys.as_ref()
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(&self) -> std::option::Option<&str> {
        self.event_pattern.as_deref()
    }
}
impl MetricDefinitionRequest {
    /// Creates a new builder-style object to manufacture [`MetricDefinitionRequest`](crate::model::MetricDefinitionRequest).
    pub fn builder() -> crate::model::metric_definition_request::Builder {
        crate::model::metric_definition_request::Builder::default()
    }
}

/// See [`MetricDefinitionRequest`](crate::model::MetricDefinitionRequest).
pub mod metric_definition_request {

    /// A builder for [`MetricDefinitionRequest`](crate::model::MetricDefinitionRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value_key: std::option::Option<std::string::String>,
        pub(crate) unit_label: std::option::Option<std::string::String>,
        pub(crate) dimension_keys: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) event_pattern: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
        /// <ul>
        /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
        /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
        /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
        /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
        /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
        /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
        /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
        /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
        /// <li> <p> <code>JsErrorCount</code> </p> </li>
        /// <li> <p> <code>HttpErrorCount</code> </p> </li>
        /// <li> <p> <code>SessionCount</code> </p> </li>
        /// </ul>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
        /// <ul>
        /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
        /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
        /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
        /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
        /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
        /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
        /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
        /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
        /// <li> <p> <code>JsErrorCount</code> </p> </li>
        /// <li> <p> <code>HttpErrorCount</code> </p> </li>
        /// <li> <p> <code>SessionCount</code> </p> </li>
        /// </ul>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The field within the event object that the metric value is sourced from.</p>
        /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
        /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
        pub fn value_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.value_key = Some(input.into());
            self
        }
        /// <p>The field within the event object that the metric value is sourced from.</p>
        /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
        /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
        pub fn set_value_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value_key = input;
            self
        }
        /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
        pub fn unit_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit_label = Some(input.into());
            self
        }
        /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
        pub fn set_unit_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit_label = input;
            self
        }
        /// Adds a key-value pair to `dimension_keys`.
        ///
        /// To override the contents of this collection use [`set_dimension_keys`](Self::set_dimension_keys).
        ///
        /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
        /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
        /// <ul>
        /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
        /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
        /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
        /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
        /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
        /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
        /// </ul>
        /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
        pub fn dimension_keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.dimension_keys.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.dimension_keys = Some(hash_map);
            self
        }
        /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
        /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
        /// <ul>
        /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
        /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
        /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
        /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
        /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
        /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
        /// </ul>
        /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
        pub fn set_dimension_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.dimension_keys = input;
            self
        }
        /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
        /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
        /// <p>Example event patterns:</p>
        /// <ul>
        /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
        /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
        /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
        /// </ul>
        /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
        pub fn event_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_pattern = Some(input.into());
            self
        }
        /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
        /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
        /// <p>Example event patterns:</p>
        /// <ul>
        /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
        /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
        /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
        /// </ul>
        /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
        pub fn set_event_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_pattern = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDefinitionRequest`](crate::model::MetricDefinitionRequest).
        pub fn build(self) -> crate::model::MetricDefinitionRequest {
            crate::model::MetricDefinitionRequest {
                name: self.name,
                value_key: self.value_key,
                unit_label: self.unit_label,
                dimension_keys: self.dimension_keys,
                event_pattern: self.event_pattern,
            }
        }
    }
}

/// When writing a match expression against `MetricDestination`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let metricdestination = unimplemented!();
/// match metricdestination {
///     MetricDestination::CloudWatch => { /* ... */ },
///     MetricDestination::Evidently => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `metricdestination` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MetricDestination::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MetricDestination::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MetricDestination::NewFeature` is defined.
/// Specifically, when `metricdestination` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MetricDestination::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricDestination {
    #[allow(missing_docs)] // documentation missing in model
    CloudWatch,
    #[allow(missing_docs)] // documentation missing in model
    Evidently,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MetricDestination {
    fn from(s: &str) -> Self {
        match s {
            "CloudWatch" => MetricDestination::CloudWatch,
            "Evidently" => MetricDestination::Evidently,
            other => {
                MetricDestination::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for MetricDestination {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricDestination::from(s))
    }
}
impl MetricDestination {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MetricDestination::CloudWatch => "CloudWatch",
            MetricDestination::Evidently => "Evidently",
            MetricDestination::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CloudWatch", "Evidently"]
    }
}
impl AsRef<str> for MetricDestination {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that displays information about one destination that CloudWatch RUM sends extended metrics to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricDestinationSummary {
    /// <p>Specifies whether the destination is <code>CloudWatch</code> or <code>Evidently</code>.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<crate::model::MetricDestination>,
    /// <p>If the destination is <code>Evidently</code>, this specifies the ARN of the Evidently experiment that receives the metrics.</p>
    #[doc(hidden)]
    pub destination_arn: std::option::Option<std::string::String>,
    /// <p>This field appears only when the destination is <code>Evidently</code>. It specifies the ARN of the IAM role that is used to write to the Evidently experiment that receives the metrics.</p>
    #[doc(hidden)]
    pub iam_role_arn: std::option::Option<std::string::String>,
}
impl MetricDestinationSummary {
    /// <p>Specifies whether the destination is <code>CloudWatch</code> or <code>Evidently</code>.</p>
    pub fn destination(&self) -> std::option::Option<&crate::model::MetricDestination> {
        self.destination.as_ref()
    }
    /// <p>If the destination is <code>Evidently</code>, this specifies the ARN of the Evidently experiment that receives the metrics.</p>
    pub fn destination_arn(&self) -> std::option::Option<&str> {
        self.destination_arn.as_deref()
    }
    /// <p>This field appears only when the destination is <code>Evidently</code>. It specifies the ARN of the IAM role that is used to write to the Evidently experiment that receives the metrics.</p>
    pub fn iam_role_arn(&self) -> std::option::Option<&str> {
        self.iam_role_arn.as_deref()
    }
}
impl MetricDestinationSummary {
    /// Creates a new builder-style object to manufacture [`MetricDestinationSummary`](crate::model::MetricDestinationSummary).
    pub fn builder() -> crate::model::metric_destination_summary::Builder {
        crate::model::metric_destination_summary::Builder::default()
    }
}

/// See [`MetricDestinationSummary`](crate::model::MetricDestinationSummary).
pub mod metric_destination_summary {

    /// A builder for [`MetricDestinationSummary`](crate::model::MetricDestinationSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination: std::option::Option<crate::model::MetricDestination>,
        pub(crate) destination_arn: std::option::Option<std::string::String>,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether the destination is <code>CloudWatch</code> or <code>Evidently</code>.</p>
        pub fn destination(mut self, input: crate::model::MetricDestination) -> Self {
            self.destination = Some(input);
            self
        }
        /// <p>Specifies whether the destination is <code>CloudWatch</code> or <code>Evidently</code>.</p>
        pub fn set_destination(
            mut self,
            input: std::option::Option<crate::model::MetricDestination>,
        ) -> Self {
            self.destination = input;
            self
        }
        /// <p>If the destination is <code>Evidently</code>, this specifies the ARN of the Evidently experiment that receives the metrics.</p>
        pub fn destination_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_arn = Some(input.into());
            self
        }
        /// <p>If the destination is <code>Evidently</code>, this specifies the ARN of the Evidently experiment that receives the metrics.</p>
        pub fn set_destination_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_arn = input;
            self
        }
        /// <p>This field appears only when the destination is <code>Evidently</code>. It specifies the ARN of the IAM role that is used to write to the Evidently experiment that receives the metrics.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        /// <p>This field appears only when the destination is <code>Evidently</code>. It specifies the ARN of the IAM role that is used to write to the Evidently experiment that receives the metrics.</p>
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDestinationSummary`](crate::model::MetricDestinationSummary).
        pub fn build(self) -> crate::model::MetricDestinationSummary {
            crate::model::MetricDestinationSummary {
                destination: self.destination,
                destination_arn: self.destination_arn,
                iam_role_arn: self.iam_role_arn,
            }
        }
    }
}

/// <p>A structure that defines a key and values that you can use to filter the results. The only performance events that are returned are those that have values matching the ones that you specify in one of your <code>QueryFilter</code> structures.</p>
/// <p>For example, you could specify <code>Browser</code> as the <code>Name</code> and specify <code>Chrome,Firefox</code> as the <code>Values</code> to return events generated only from those browsers.</p>
/// <p>Specifying <code>Invert</code> as the <code>Name</code> works as a "not equal to" filter. For example, specify <code>Invert</code> as the <code>Name</code> and specify <code>Chrome</code> as the value to return all events except events from user sessions with the Chrome browser.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct QueryFilter {
    /// <p>The name of a key to search for. The filter returns only the events that match the <code>Name</code> and <code>Values</code> that you specify. </p>
    /// <p>Valid values for <code>Name</code> are <code>Browser</code> | <code>Device</code> | <code>Country</code> | <code>Page</code> | <code>OS</code> | <code>EventType</code> | <code>Invert</code> </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The values of the <code>Name</code> that are to be be included in the returned results.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl QueryFilter {
    /// <p>The name of a key to search for. The filter returns only the events that match the <code>Name</code> and <code>Values</code> that you specify. </p>
    /// <p>Valid values for <code>Name</code> are <code>Browser</code> | <code>Device</code> | <code>Country</code> | <code>Page</code> | <code>OS</code> | <code>EventType</code> | <code>Invert</code> </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The values of the <code>Name</code> that are to be be included in the returned results.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl QueryFilter {
    /// Creates a new builder-style object to manufacture [`QueryFilter`](crate::model::QueryFilter).
    pub fn builder() -> crate::model::query_filter::Builder {
        crate::model::query_filter::Builder::default()
    }
}

/// See [`QueryFilter`](crate::model::QueryFilter).
pub mod query_filter {

    /// A builder for [`QueryFilter`](crate::model::QueryFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of a key to search for. The filter returns only the events that match the <code>Name</code> and <code>Values</code> that you specify. </p>
        /// <p>Valid values for <code>Name</code> are <code>Browser</code> | <code>Device</code> | <code>Country</code> | <code>Page</code> | <code>OS</code> | <code>EventType</code> | <code>Invert</code> </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a key to search for. The filter returns only the events that match the <code>Name</code> and <code>Values</code> that you specify. </p>
        /// <p>Valid values for <code>Name</code> are <code>Browser</code> | <code>Device</code> | <code>Country</code> | <code>Page</code> | <code>OS</code> | <code>EventType</code> | <code>Invert</code> </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The values of the <code>Name</code> that are to be be included in the returned results.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The values of the <code>Name</code> that are to be be included in the returned results.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`QueryFilter`](crate::model::QueryFilter).
        pub fn build(self) -> crate::model::QueryFilter {
            crate::model::QueryFilter {
                name: self.name,
                values: self.values,
            }
        }
    }
}

/// <p>A structure that defines the time range that you want to retrieve results from.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TimeRange {
    /// <p>The beginning of the time range to retrieve performance events from.</p>
    #[doc(hidden)]
    pub after: i64,
    /// <p>The end of the time range to retrieve performance events from. If you omit this, the time range extends to the time that this operation is performed.</p>
    #[doc(hidden)]
    pub before: i64,
}
impl TimeRange {
    /// <p>The beginning of the time range to retrieve performance events from.</p>
    pub fn after(&self) -> i64 {
        self.after
    }
    /// <p>The end of the time range to retrieve performance events from. If you omit this, the time range extends to the time that this operation is performed.</p>
    pub fn before(&self) -> i64 {
        self.before
    }
}
impl TimeRange {
    /// Creates a new builder-style object to manufacture [`TimeRange`](crate::model::TimeRange).
    pub fn builder() -> crate::model::time_range::Builder {
        crate::model::time_range::Builder::default()
    }
}

/// See [`TimeRange`](crate::model::TimeRange).
pub mod time_range {

    /// A builder for [`TimeRange`](crate::model::TimeRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) after: std::option::Option<i64>,
        pub(crate) before: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The beginning of the time range to retrieve performance events from.</p>
        pub fn after(mut self, input: i64) -> Self {
            self.after = Some(input);
            self
        }
        /// <p>The beginning of the time range to retrieve performance events from.</p>
        pub fn set_after(mut self, input: std::option::Option<i64>) -> Self {
            self.after = input;
            self
        }
        /// <p>The end of the time range to retrieve performance events from. If you omit this, the time range extends to the time that this operation is performed.</p>
        pub fn before(mut self, input: i64) -> Self {
            self.before = Some(input);
            self
        }
        /// <p>The end of the time range to retrieve performance events from. If you omit this, the time range extends to the time that this operation is performed.</p>
        pub fn set_before(mut self, input: std::option::Option<i64>) -> Self {
            self.before = input;
            self
        }
        /// Consumes the builder and constructs a [`TimeRange`](crate::model::TimeRange).
        pub fn build(self) -> crate::model::TimeRange {
            crate::model::TimeRange {
                after: self.after.unwrap_or_default(),
                before: self.before.unwrap_or_default(),
            }
        }
    }
}

/// <p>A structure that contains information about custom events for this app monitor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CustomEvents {
    /// <p>Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be <code>DISABLED</code>.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CustomEventsStatus>,
}
impl CustomEvents {
    /// <p>Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be <code>DISABLED</code>.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CustomEventsStatus> {
        self.status.as_ref()
    }
}
impl CustomEvents {
    /// Creates a new builder-style object to manufacture [`CustomEvents`](crate::model::CustomEvents).
    pub fn builder() -> crate::model::custom_events::Builder {
        crate::model::custom_events::Builder::default()
    }
}

/// See [`CustomEvents`](crate::model::CustomEvents).
pub mod custom_events {

    /// A builder for [`CustomEvents`](crate::model::CustomEvents).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::CustomEventsStatus>,
    }
    impl Builder {
        /// <p>Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be <code>DISABLED</code>.</p>
        pub fn status(mut self, input: crate::model::CustomEventsStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be <code>DISABLED</code>.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CustomEventsStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomEvents`](crate::model::CustomEvents).
        pub fn build(self) -> crate::model::CustomEvents {
            crate::model::CustomEvents {
                status: self.status,
            }
        }
    }
}

/// When writing a match expression against `CustomEventsStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let customeventsstatus = unimplemented!();
/// match customeventsstatus {
///     CustomEventsStatus::Disabled => { /* ... */ },
///     CustomEventsStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `customeventsstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CustomEventsStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CustomEventsStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CustomEventsStatus::NewFeature` is defined.
/// Specifically, when `customeventsstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CustomEventsStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CustomEventsStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CustomEventsStatus {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => CustomEventsStatus::Disabled,
            "ENABLED" => CustomEventsStatus::Enabled,
            other => {
                CustomEventsStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CustomEventsStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CustomEventsStatus::from(s))
    }
}
impl CustomEventsStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CustomEventsStatus::Disabled => "DISABLED",
            CustomEventsStatus::Enabled => "ENABLED",
            CustomEventsStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for CustomEventsStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>This structure contains much of the configuration data for the app monitor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppMonitorConfiguration {
    /// <p>The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
    #[doc(hidden)]
    pub identity_pool_id: std::option::Option<std::string::String>,
    /// <p>A list of URLs in your website or application to exclude from RUM data collection.</p>
    /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
    #[doc(hidden)]
    pub excluded_pages: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. </p>
    /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
    #[doc(hidden)]
    pub included_pages: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of pages in your application that are to be displayed with a "favorite" icon in the CloudWatch RUM console.</p>
    #[doc(hidden)]
    pub favorite_pages: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the portion of user sessions to use for RUM data collection. Choosing a higher portion gives you more data but also incurs more costs.</p>
    /// <p>The range for this value is 0 to 1 inclusive. Setting this to 1 means that 100% of user sessions are sampled, and setting it to 0.1 means that 10% of user sessions are sampled.</p>
    /// <p>If you omit this parameter, the default of 0.1 is used, and 10% of sessions will be sampled.</p>
    #[doc(hidden)]
    pub session_sample_rate: f64,
    /// <p>The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
    #[doc(hidden)]
    pub guest_role_arn: std::option::Option<std::string::String>,
    /// <p>If you set this to <code>true</code>, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.</p>
    #[doc(hidden)]
    pub allow_cookies: std::option::Option<bool>,
    /// <p>An array that lists the types of telemetry data that this app monitor is to collect.</p>
    /// <ul>
    /// <li> <p> <code>errors</code> indicates that RUM collects data about unhandled JavaScript errors raised by your application.</p> </li>
    /// <li> <p> <code>performance</code> indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.</p> </li>
    /// <li> <p> <code>http</code> indicates that RUM collects data about HTTP errors thrown by your application.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub telemetries: std::option::Option<std::vec::Vec<crate::model::Telemetry>>,
    /// <p>If you set this to <code>true</code>, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">What is X-Ray?</a> </p>
    #[doc(hidden)]
    pub enable_x_ray: std::option::Option<bool>,
}
impl AppMonitorConfiguration {
    /// <p>The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
    pub fn identity_pool_id(&self) -> std::option::Option<&str> {
        self.identity_pool_id.as_deref()
    }
    /// <p>A list of URLs in your website or application to exclude from RUM data collection.</p>
    /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
    pub fn excluded_pages(&self) -> std::option::Option<&[std::string::String]> {
        self.excluded_pages.as_deref()
    }
    /// <p>If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. </p>
    /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
    pub fn included_pages(&self) -> std::option::Option<&[std::string::String]> {
        self.included_pages.as_deref()
    }
    /// <p>A list of pages in your application that are to be displayed with a "favorite" icon in the CloudWatch RUM console.</p>
    pub fn favorite_pages(&self) -> std::option::Option<&[std::string::String]> {
        self.favorite_pages.as_deref()
    }
    /// <p>Specifies the portion of user sessions to use for RUM data collection. Choosing a higher portion gives you more data but also incurs more costs.</p>
    /// <p>The range for this value is 0 to 1 inclusive. Setting this to 1 means that 100% of user sessions are sampled, and setting it to 0.1 means that 10% of user sessions are sampled.</p>
    /// <p>If you omit this parameter, the default of 0.1 is used, and 10% of sessions will be sampled.</p>
    pub fn session_sample_rate(&self) -> f64 {
        self.session_sample_rate
    }
    /// <p>The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
    pub fn guest_role_arn(&self) -> std::option::Option<&str> {
        self.guest_role_arn.as_deref()
    }
    /// <p>If you set this to <code>true</code>, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.</p>
    pub fn allow_cookies(&self) -> std::option::Option<bool> {
        self.allow_cookies
    }
    /// <p>An array that lists the types of telemetry data that this app monitor is to collect.</p>
    /// <ul>
    /// <li> <p> <code>errors</code> indicates that RUM collects data about unhandled JavaScript errors raised by your application.</p> </li>
    /// <li> <p> <code>performance</code> indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.</p> </li>
    /// <li> <p> <code>http</code> indicates that RUM collects data about HTTP errors thrown by your application.</p> </li>
    /// </ul>
    pub fn telemetries(&self) -> std::option::Option<&[crate::model::Telemetry]> {
        self.telemetries.as_deref()
    }
    /// <p>If you set this to <code>true</code>, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">What is X-Ray?</a> </p>
    pub fn enable_x_ray(&self) -> std::option::Option<bool> {
        self.enable_x_ray
    }
}
impl AppMonitorConfiguration {
    /// Creates a new builder-style object to manufacture [`AppMonitorConfiguration`](crate::model::AppMonitorConfiguration).
    pub fn builder() -> crate::model::app_monitor_configuration::Builder {
        crate::model::app_monitor_configuration::Builder::default()
    }
}

/// See [`AppMonitorConfiguration`](crate::model::AppMonitorConfiguration).
pub mod app_monitor_configuration {

    /// A builder for [`AppMonitorConfiguration`](crate::model::AppMonitorConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_pool_id: std::option::Option<std::string::String>,
        pub(crate) excluded_pages: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) included_pages: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) favorite_pages: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) session_sample_rate: std::option::Option<f64>,
        pub(crate) guest_role_arn: std::option::Option<std::string::String>,
        pub(crate) allow_cookies: std::option::Option<bool>,
        pub(crate) telemetries: std::option::Option<std::vec::Vec<crate::model::Telemetry>>,
        pub(crate) enable_x_ray: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
        pub fn identity_pool_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_pool_id = Some(input.into());
            self
        }
        /// <p>The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
        pub fn set_identity_pool_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_pool_id = input;
            self
        }
        /// Appends an item to `excluded_pages`.
        ///
        /// To override the contents of this collection use [`set_excluded_pages`](Self::set_excluded_pages).
        ///
        /// <p>A list of URLs in your website or application to exclude from RUM data collection.</p>
        /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
        pub fn excluded_pages(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.excluded_pages.unwrap_or_default();
            v.push(input.into());
            self.excluded_pages = Some(v);
            self
        }
        /// <p>A list of URLs in your website or application to exclude from RUM data collection.</p>
        /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
        pub fn set_excluded_pages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.excluded_pages = input;
            self
        }
        /// Appends an item to `included_pages`.
        ///
        /// To override the contents of this collection use [`set_included_pages`](Self::set_included_pages).
        ///
        /// <p>If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. </p>
        /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
        pub fn included_pages(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.included_pages.unwrap_or_default();
            v.push(input.into());
            self.included_pages = Some(v);
            self
        }
        /// <p>If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. </p>
        /// <p>You can't include both <code>ExcludedPages</code> and <code>IncludedPages</code> in the same operation.</p>
        pub fn set_included_pages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.included_pages = input;
            self
        }
        /// Appends an item to `favorite_pages`.
        ///
        /// To override the contents of this collection use [`set_favorite_pages`](Self::set_favorite_pages).
        ///
        /// <p>A list of pages in your application that are to be displayed with a "favorite" icon in the CloudWatch RUM console.</p>
        pub fn favorite_pages(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.favorite_pages.unwrap_or_default();
            v.push(input.into());
            self.favorite_pages = Some(v);
            self
        }
        /// <p>A list of pages in your application that are to be displayed with a "favorite" icon in the CloudWatch RUM console.</p>
        pub fn set_favorite_pages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.favorite_pages = input;
            self
        }
        /// <p>Specifies the portion of user sessions to use for RUM data collection. Choosing a higher portion gives you more data but also incurs more costs.</p>
        /// <p>The range for this value is 0 to 1 inclusive. Setting this to 1 means that 100% of user sessions are sampled, and setting it to 0.1 means that 10% of user sessions are sampled.</p>
        /// <p>If you omit this parameter, the default of 0.1 is used, and 10% of sessions will be sampled.</p>
        pub fn session_sample_rate(mut self, input: f64) -> Self {
            self.session_sample_rate = Some(input);
            self
        }
        /// <p>Specifies the portion of user sessions to use for RUM data collection. Choosing a higher portion gives you more data but also incurs more costs.</p>
        /// <p>The range for this value is 0 to 1 inclusive. Setting this to 1 means that 100% of user sessions are sampled, and setting it to 0.1 means that 10% of user sessions are sampled.</p>
        /// <p>If you omit this parameter, the default of 0.1 is used, and 10% of sessions will be sampled.</p>
        pub fn set_session_sample_rate(mut self, input: std::option::Option<f64>) -> Self {
            self.session_sample_rate = input;
            self
        }
        /// <p>The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
        pub fn guest_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.guest_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.</p>
        pub fn set_guest_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.guest_role_arn = input;
            self
        }
        /// <p>If you set this to <code>true</code>, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.</p>
        pub fn allow_cookies(mut self, input: bool) -> Self {
            self.allow_cookies = Some(input);
            self
        }
        /// <p>If you set this to <code>true</code>, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.</p>
        pub fn set_allow_cookies(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_cookies = input;
            self
        }
        /// Appends an item to `telemetries`.
        ///
        /// To override the contents of this collection use [`set_telemetries`](Self::set_telemetries).
        ///
        /// <p>An array that lists the types of telemetry data that this app monitor is to collect.</p>
        /// <ul>
        /// <li> <p> <code>errors</code> indicates that RUM collects data about unhandled JavaScript errors raised by your application.</p> </li>
        /// <li> <p> <code>performance</code> indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.</p> </li>
        /// <li> <p> <code>http</code> indicates that RUM collects data about HTTP errors thrown by your application.</p> </li>
        /// </ul>
        pub fn telemetries(mut self, input: crate::model::Telemetry) -> Self {
            let mut v = self.telemetries.unwrap_or_default();
            v.push(input);
            self.telemetries = Some(v);
            self
        }
        /// <p>An array that lists the types of telemetry data that this app monitor is to collect.</p>
        /// <ul>
        /// <li> <p> <code>errors</code> indicates that RUM collects data about unhandled JavaScript errors raised by your application.</p> </li>
        /// <li> <p> <code>performance</code> indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.</p> </li>
        /// <li> <p> <code>http</code> indicates that RUM collects data about HTTP errors thrown by your application.</p> </li>
        /// </ul>
        pub fn set_telemetries(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Telemetry>>,
        ) -> Self {
            self.telemetries = input;
            self
        }
        /// <p>If you set this to <code>true</code>, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">What is X-Ray?</a> </p>
        pub fn enable_x_ray(mut self, input: bool) -> Self {
            self.enable_x_ray = Some(input);
            self
        }
        /// <p>If you set this to <code>true</code>, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html">What is X-Ray?</a> </p>
        pub fn set_enable_x_ray(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_x_ray = input;
            self
        }
        /// Consumes the builder and constructs a [`AppMonitorConfiguration`](crate::model::AppMonitorConfiguration).
        pub fn build(self) -> crate::model::AppMonitorConfiguration {
            crate::model::AppMonitorConfiguration {
                identity_pool_id: self.identity_pool_id,
                excluded_pages: self.excluded_pages,
                included_pages: self.included_pages,
                favorite_pages: self.favorite_pages,
                session_sample_rate: self.session_sample_rate.unwrap_or_default(),
                guest_role_arn: self.guest_role_arn,
                allow_cookies: self.allow_cookies,
                telemetries: self.telemetries,
                enable_x_ray: self.enable_x_ray,
            }
        }
    }
}

/// When writing a match expression against `Telemetry`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let telemetry = unimplemented!();
/// match telemetry {
///     Telemetry::Errors => { /* ... */ },
///     Telemetry::Http => { /* ... */ },
///     Telemetry::Performance => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `telemetry` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Telemetry::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Telemetry::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Telemetry::NewFeature` is defined.
/// Specifically, when `telemetry` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Telemetry::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Telemetry {
    /// Includes JS error event plugin
    Errors,
    /// Includes X-Ray Xhr and X-Ray Fetch plugin
    Http,
    /// Includes navigation, paint, resource and web vital event plugins
    Performance,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Telemetry {
    fn from(s: &str) -> Self {
        match s {
            "errors" => Telemetry::Errors,
            "http" => Telemetry::Http,
            "performance" => Telemetry::Performance,
            other => Telemetry::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Telemetry {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Telemetry::from(s))
    }
}
impl Telemetry {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Telemetry::Errors => "errors",
            Telemetry::Http => "http",
            Telemetry::Performance => "performance",
            Telemetry::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["errors", "http", "performance"]
    }
}
impl AsRef<str> for Telemetry {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A structure that displays the definition of one extended metric that RUM sends to CloudWatch or CloudWatch Evidently. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-vended-metrics.html"> Additional metrics that you can send to CloudWatch and CloudWatch Evidently</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricDefinition {
    /// <p>The ID of this metric definition.</p>
    #[doc(hidden)]
    pub metric_definition_id: std::option::Option<std::string::String>,
    /// <p>The name of the metric that is defined in this structure.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The field within the event object that the metric value is sourced from.</p>
    #[doc(hidden)]
    pub value_key: std::option::Option<std::string::String>,
    /// <p>Use this field only if you are sending this metric to CloudWatch. It defines the CloudWatch metric unit that this metric is measured in. </p>
    #[doc(hidden)]
    pub unit_label: std::option::Option<std::string::String>,
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch The value of this field is used only if the metric destination is <code>CloudWatch</code>. If the metric destination is <code>Evidently</code>, the value of <code>DimensionKeys</code> is ignored.</p>
    #[doc(hidden)]
    pub dimension_keys:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The pattern that defines the metric. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>If the metrics destination is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    #[doc(hidden)]
    pub event_pattern: std::option::Option<std::string::String>,
}
impl MetricDefinition {
    /// <p>The ID of this metric definition.</p>
    pub fn metric_definition_id(&self) -> std::option::Option<&str> {
        self.metric_definition_id.as_deref()
    }
    /// <p>The name of the metric that is defined in this structure.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    pub fn value_key(&self) -> std::option::Option<&str> {
        self.value_key.as_deref()
    }
    /// <p>Use this field only if you are sending this metric to CloudWatch. It defines the CloudWatch metric unit that this metric is measured in. </p>
    pub fn unit_label(&self) -> std::option::Option<&str> {
        self.unit_label.as_deref()
    }
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch The value of this field is used only if the metric destination is <code>CloudWatch</code>. If the metric destination is <code>Evidently</code>, the value of <code>DimensionKeys</code> is ignored.</p>
    pub fn dimension_keys(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.dimension_keys.as_ref()
    }
    /// <p>The pattern that defines the metric. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>If the metrics destination is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(&self) -> std::option::Option<&str> {
        self.event_pattern.as_deref()
    }
}
impl MetricDefinition {
    /// Creates a new builder-style object to manufacture [`MetricDefinition`](crate::model::MetricDefinition).
    pub fn builder() -> crate::model::metric_definition::Builder {
        crate::model::metric_definition::Builder::default()
    }
}

/// See [`MetricDefinition`](crate::model::MetricDefinition).
pub mod metric_definition {

    /// A builder for [`MetricDefinition`](crate::model::MetricDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_definition_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value_key: std::option::Option<std::string::String>,
        pub(crate) unit_label: std::option::Option<std::string::String>,
        pub(crate) dimension_keys: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) event_pattern: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of this metric definition.</p>
        pub fn metric_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_definition_id = Some(input.into());
            self
        }
        /// <p>The ID of this metric definition.</p>
        pub fn set_metric_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metric_definition_id = input;
            self
        }
        /// <p>The name of the metric that is defined in this structure.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the metric that is defined in this structure.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The field within the event object that the metric value is sourced from.</p>
        pub fn value_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.value_key = Some(input.into());
            self
        }
        /// <p>The field within the event object that the metric value is sourced from.</p>
        pub fn set_value_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value_key = input;
            self
        }
        /// <p>Use this field only if you are sending this metric to CloudWatch. It defines the CloudWatch metric unit that this metric is measured in. </p>
        pub fn unit_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit_label = Some(input.into());
            self
        }
        /// <p>Use this field only if you are sending this metric to CloudWatch. It defines the CloudWatch metric unit that this metric is measured in. </p>
        pub fn set_unit_label(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit_label = input;
            self
        }
        /// Adds a key-value pair to `dimension_keys`.
        ///
        /// To override the contents of this collection use [`set_dimension_keys`](Self::set_dimension_keys).
        ///
        /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch The value of this field is used only if the metric destination is <code>CloudWatch</code>. If the metric destination is <code>Evidently</code>, the value of <code>DimensionKeys</code> is ignored.</p>
        pub fn dimension_keys(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.dimension_keys.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.dimension_keys = Some(hash_map);
            self
        }
        /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch The value of this field is used only if the metric destination is <code>CloudWatch</code>. If the metric destination is <code>Evidently</code>, the value of <code>DimensionKeys</code> is ignored.</p>
        pub fn set_dimension_keys(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.dimension_keys = input;
            self
        }
        /// <p>The pattern that defines the metric. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
        /// <p>If the metrics destination is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
        pub fn event_pattern(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_pattern = Some(input.into());
            self
        }
        /// <p>The pattern that defines the metric. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
        /// <p>If the metrics destination is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
        pub fn set_event_pattern(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_pattern = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDefinition`](crate::model::MetricDefinition).
        pub fn build(self) -> crate::model::MetricDefinition {
            crate::model::MetricDefinition {
                metric_definition_id: self.metric_definition_id,
                name: self.name,
                value_key: self.value_key,
                unit_label: self.unit_label,
                dimension_keys: self.dimension_keys,
                event_pattern: self.event_pattern,
            }
        }
    }
}

/// <p>A structure that defines one error caused by a <a href="https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_BatchDeleteRumMetricsDefinitions.html">BatchCreateRumMetricsDefinitions</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchDeleteRumMetricDefinitionsError {
    /// <p>The ID of the metric definition that caused this error.</p>
    #[doc(hidden)]
    pub metric_definition_id: std::option::Option<std::string::String>,
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message for this metric definition.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchDeleteRumMetricDefinitionsError {
    /// <p>The ID of the metric definition that caused this error.</p>
    pub fn metric_definition_id(&self) -> std::option::Option<&str> {
        self.metric_definition_id.as_deref()
    }
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message for this metric definition.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl BatchDeleteRumMetricDefinitionsError {
    /// Creates a new builder-style object to manufacture [`BatchDeleteRumMetricDefinitionsError`](crate::model::BatchDeleteRumMetricDefinitionsError).
    pub fn builder() -> crate::model::batch_delete_rum_metric_definitions_error::Builder {
        crate::model::batch_delete_rum_metric_definitions_error::Builder::default()
    }
}

/// See [`BatchDeleteRumMetricDefinitionsError`](crate::model::BatchDeleteRumMetricDefinitionsError).
pub mod batch_delete_rum_metric_definitions_error {

    /// A builder for [`BatchDeleteRumMetricDefinitionsError`](crate::model::BatchDeleteRumMetricDefinitionsError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_definition_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the metric definition that caused this error.</p>
        pub fn metric_definition_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_definition_id = Some(input.into());
            self
        }
        /// <p>The ID of the metric definition that caused this error.</p>
        pub fn set_metric_definition_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metric_definition_id = input;
            self
        }
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message for this metric definition.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message for this metric definition.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchDeleteRumMetricDefinitionsError`](crate::model::BatchDeleteRumMetricDefinitionsError).
        pub fn build(self) -> crate::model::BatchDeleteRumMetricDefinitionsError {
            crate::model::BatchDeleteRumMetricDefinitionsError {
                metric_definition_id: self.metric_definition_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}

/// <p>A structure that defines one error caused by a <a href="https://docs.aws.amazon.com/cloudwatchrum/latest/APIReference/API_BatchCreateRumMetricsDefinitions.html">BatchCreateRumMetricsDefinitions</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchCreateRumMetricDefinitionsError {
    /// <p>The metric definition that caused this error.</p>
    #[doc(hidden)]
    pub metric_definition: std::option::Option<crate::model::MetricDefinitionRequest>,
    /// <p>The error code.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message for this metric definition.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl BatchCreateRumMetricDefinitionsError {
    /// <p>The metric definition that caused this error.</p>
    pub fn metric_definition(&self) -> std::option::Option<&crate::model::MetricDefinitionRequest> {
        self.metric_definition.as_ref()
    }
    /// <p>The error code.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message for this metric definition.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
impl BatchCreateRumMetricDefinitionsError {
    /// Creates a new builder-style object to manufacture [`BatchCreateRumMetricDefinitionsError`](crate::model::BatchCreateRumMetricDefinitionsError).
    pub fn builder() -> crate::model::batch_create_rum_metric_definitions_error::Builder {
        crate::model::batch_create_rum_metric_definitions_error::Builder::default()
    }
}

/// See [`BatchCreateRumMetricDefinitionsError`](crate::model::BatchCreateRumMetricDefinitionsError).
pub mod batch_create_rum_metric_definitions_error {

    /// A builder for [`BatchCreateRumMetricDefinitionsError`](crate::model::BatchCreateRumMetricDefinitionsError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_definition: std::option::Option<crate::model::MetricDefinitionRequest>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric definition that caused this error.</p>
        pub fn metric_definition(mut self, input: crate::model::MetricDefinitionRequest) -> Self {
            self.metric_definition = Some(input);
            self
        }
        /// <p>The metric definition that caused this error.</p>
        pub fn set_metric_definition(
            mut self,
            input: std::option::Option<crate::model::MetricDefinitionRequest>,
        ) -> Self {
            self.metric_definition = input;
            self
        }
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message for this metric definition.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message for this metric definition.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateRumMetricDefinitionsError`](crate::model::BatchCreateRumMetricDefinitionsError).
        pub fn build(self) -> crate::model::BatchCreateRumMetricDefinitionsError {
            crate::model::BatchCreateRumMetricDefinitionsError {
                metric_definition: self.metric_definition,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}

/// <p>A structure that includes some data about app monitors and their settings.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppMonitorSummary {
    /// <p>The name of this app monitor.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique ID of this app monitor.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The date and time that the app monitor was created.</p>
    #[doc(hidden)]
    pub created: std::option::Option<std::string::String>,
    /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The current state of this app monitor.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StateEnum>,
}
impl AppMonitorSummary {
    /// <p>The name of this app monitor.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique ID of this app monitor.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The date and time that the app monitor was created.</p>
    pub fn created(&self) -> std::option::Option<&str> {
        self.created.as_deref()
    }
    /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
    /// <p>The current state of this app monitor.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StateEnum> {
        self.state.as_ref()
    }
}
impl AppMonitorSummary {
    /// Creates a new builder-style object to manufacture [`AppMonitorSummary`](crate::model::AppMonitorSummary).
    pub fn builder() -> crate::model::app_monitor_summary::Builder {
        crate::model::app_monitor_summary::Builder::default()
    }
}

/// See [`AppMonitorSummary`](crate::model::AppMonitorSummary).
pub mod app_monitor_summary {

    /// A builder for [`AppMonitorSummary`](crate::model::AppMonitorSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StateEnum>,
    }
    impl Builder {
        /// <p>The name of this app monitor.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of this app monitor.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique ID of this app monitor.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of this app monitor.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date and time that the app monitor was created.</p>
        pub fn created(mut self, input: impl Into<std::string::String>) -> Self {
            self.created = Some(input.into());
            self
        }
        /// <p>The date and time that the app monitor was created.</p>
        pub fn set_created(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created = input;
            self
        }
        /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// <p>The current state of this app monitor.</p>
        pub fn state(mut self, input: crate::model::StateEnum) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of this app monitor.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::StateEnum>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`AppMonitorSummary`](crate::model::AppMonitorSummary).
        pub fn build(self) -> crate::model::AppMonitorSummary {
            crate::model::AppMonitorSummary {
                name: self.name,
                id: self.id,
                created: self.created,
                last_modified: self.last_modified,
                state: self.state,
            }
        }
    }
}

/// When writing a match expression against `StateEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let stateenum = unimplemented!();
/// match stateenum {
///     StateEnum::Active => { /* ... */ },
///     StateEnum::Created => { /* ... */ },
///     StateEnum::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `stateenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StateEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StateEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StateEnum::NewFeature` is defined.
/// Specifically, when `stateenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StateEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StateEnum {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StateEnum {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => StateEnum::Active,
            "CREATED" => StateEnum::Created,
            "DELETING" => StateEnum::Deleting,
            other => StateEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StateEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StateEnum::from(s))
    }
}
impl StateEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StateEnum::Active => "ACTIVE",
            StateEnum::Created => "CREATED",
            StateEnum::Deleting => "DELETING",
            StateEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "CREATED", "DELETING"]
    }
}
impl AsRef<str> for StateEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A RUM app monitor collects telemetry data from your application and sends that data to RUM. The data includes performance and reliability information such as page load time, client-side errors, and user behavior.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppMonitor {
    /// <p>The name of the app monitor.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The top-level internet domain name for which your application has administrative authority.</p>
    #[doc(hidden)]
    pub domain: std::option::Option<std::string::String>,
    /// <p>The unique ID of this app monitor.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The date and time that this app monitor was created.</p>
    #[doc(hidden)]
    pub created: std::option::Option<std::string::String>,
    /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
    #[doc(hidden)]
    pub last_modified: std::option::Option<std::string::String>,
    /// <p>The list of tag keys and values associated with this app monitor.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The current state of the app monitor.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StateEnum>,
    /// <p>A structure that contains much of the configuration data for the app monitor.</p>
    #[doc(hidden)]
    pub app_monitor_configuration: std::option::Option<crate::model::AppMonitorConfiguration>,
    /// <p>A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.</p>
    #[doc(hidden)]
    pub data_storage: std::option::Option<crate::model::DataStorage>,
    /// <p>Specifies whether this app monitor allows the web client to define and send custom events.</p>
    /// <p>For more information about custom events, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html">Send custom events</a>.</p>
    #[doc(hidden)]
    pub custom_events: std::option::Option<crate::model::CustomEvents>,
}
impl AppMonitor {
    /// <p>The name of the app monitor.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The top-level internet domain name for which your application has administrative authority.</p>
    pub fn domain(&self) -> std::option::Option<&str> {
        self.domain.as_deref()
    }
    /// <p>The unique ID of this app monitor.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The date and time that this app monitor was created.</p>
    pub fn created(&self) -> std::option::Option<&str> {
        self.created.as_deref()
    }
    /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
    pub fn last_modified(&self) -> std::option::Option<&str> {
        self.last_modified.as_deref()
    }
    /// <p>The list of tag keys and values associated with this app monitor.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The current state of the app monitor.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StateEnum> {
        self.state.as_ref()
    }
    /// <p>A structure that contains much of the configuration data for the app monitor.</p>
    pub fn app_monitor_configuration(
        &self,
    ) -> std::option::Option<&crate::model::AppMonitorConfiguration> {
        self.app_monitor_configuration.as_ref()
    }
    /// <p>A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.</p>
    pub fn data_storage(&self) -> std::option::Option<&crate::model::DataStorage> {
        self.data_storage.as_ref()
    }
    /// <p>Specifies whether this app monitor allows the web client to define and send custom events.</p>
    /// <p>For more information about custom events, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html">Send custom events</a>.</p>
    pub fn custom_events(&self) -> std::option::Option<&crate::model::CustomEvents> {
        self.custom_events.as_ref()
    }
}
impl AppMonitor {
    /// Creates a new builder-style object to manufacture [`AppMonitor`](crate::model::AppMonitor).
    pub fn builder() -> crate::model::app_monitor::Builder {
        crate::model::app_monitor::Builder::default()
    }
}

/// See [`AppMonitor`](crate::model::AppMonitor).
pub mod app_monitor {

    /// A builder for [`AppMonitor`](crate::model::AppMonitor).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) domain: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<std::string::String>,
        pub(crate) last_modified: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) state: std::option::Option<crate::model::StateEnum>,
        pub(crate) app_monitor_configuration:
            std::option::Option<crate::model::AppMonitorConfiguration>,
        pub(crate) data_storage: std::option::Option<crate::model::DataStorage>,
        pub(crate) custom_events: std::option::Option<crate::model::CustomEvents>,
    }
    impl Builder {
        /// <p>The name of the app monitor.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the app monitor.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The top-level internet domain name for which your application has administrative authority.</p>
        pub fn domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain = Some(input.into());
            self
        }
        /// <p>The top-level internet domain name for which your application has administrative authority.</p>
        pub fn set_domain(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain = input;
            self
        }
        /// <p>The unique ID of this app monitor.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of this app monitor.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date and time that this app monitor was created.</p>
        pub fn created(mut self, input: impl Into<std::string::String>) -> Self {
            self.created = Some(input.into());
            self
        }
        /// <p>The date and time that this app monitor was created.</p>
        pub fn set_created(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created = input;
            self
        }
        /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
        pub fn last_modified(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified = Some(input.into());
            self
        }
        /// <p>The date and time of the most recent changes to this app monitor's configuration.</p>
        pub fn set_last_modified(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The list of tag keys and values associated with this app monitor.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The list of tag keys and values associated with this app monitor.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The current state of the app monitor.</p>
        pub fn state(mut self, input: crate::model::StateEnum) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the app monitor.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::StateEnum>) -> Self {
            self.state = input;
            self
        }
        /// <p>A structure that contains much of the configuration data for the app monitor.</p>
        pub fn app_monitor_configuration(
            mut self,
            input: crate::model::AppMonitorConfiguration,
        ) -> Self {
            self.app_monitor_configuration = Some(input);
            self
        }
        /// <p>A structure that contains much of the configuration data for the app monitor.</p>
        pub fn set_app_monitor_configuration(
            mut self,
            input: std::option::Option<crate::model::AppMonitorConfiguration>,
        ) -> Self {
            self.app_monitor_configuration = input;
            self
        }
        /// <p>A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.</p>
        pub fn data_storage(mut self, input: crate::model::DataStorage) -> Self {
            self.data_storage = Some(input);
            self
        }
        /// <p>A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.</p>
        pub fn set_data_storage(
            mut self,
            input: std::option::Option<crate::model::DataStorage>,
        ) -> Self {
            self.data_storage = input;
            self
        }
        /// <p>Specifies whether this app monitor allows the web client to define and send custom events.</p>
        /// <p>For more information about custom events, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html">Send custom events</a>.</p>
        pub fn custom_events(mut self, input: crate::model::CustomEvents) -> Self {
            self.custom_events = Some(input);
            self
        }
        /// <p>Specifies whether this app monitor allows the web client to define and send custom events.</p>
        /// <p>For more information about custom events, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-custom-events.html">Send custom events</a>.</p>
        pub fn set_custom_events(
            mut self,
            input: std::option::Option<crate::model::CustomEvents>,
        ) -> Self {
            self.custom_events = input;
            self
        }
        /// Consumes the builder and constructs a [`AppMonitor`](crate::model::AppMonitor).
        pub fn build(self) -> crate::model::AppMonitor {
            crate::model::AppMonitor {
                name: self.name,
                domain: self.domain,
                id: self.id,
                created: self.created,
                last_modified: self.last_modified,
                tags: self.tags,
                state: self.state,
                app_monitor_configuration: self.app_monitor_configuration,
                data_storage: self.data_storage,
                custom_events: self.custom_events,
            }
        }
    }
}

/// <p>A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataStorage {
    /// <p>A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.</p>
    #[doc(hidden)]
    pub cw_log: std::option::Option<crate::model::CwLog>,
}
impl DataStorage {
    /// <p>A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.</p>
    pub fn cw_log(&self) -> std::option::Option<&crate::model::CwLog> {
        self.cw_log.as_ref()
    }
}
impl DataStorage {
    /// Creates a new builder-style object to manufacture [`DataStorage`](crate::model::DataStorage).
    pub fn builder() -> crate::model::data_storage::Builder {
        crate::model::data_storage::Builder::default()
    }
}

/// See [`DataStorage`](crate::model::DataStorage).
pub mod data_storage {

    /// A builder for [`DataStorage`](crate::model::DataStorage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cw_log: std::option::Option<crate::model::CwLog>,
    }
    impl Builder {
        /// <p>A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.</p>
        pub fn cw_log(mut self, input: crate::model::CwLog) -> Self {
            self.cw_log = Some(input);
            self
        }
        /// <p>A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.</p>
        pub fn set_cw_log(mut self, input: std::option::Option<crate::model::CwLog>) -> Self {
            self.cw_log = input;
            self
        }
        /// Consumes the builder and constructs a [`DataStorage`](crate::model::DataStorage).
        pub fn build(self) -> crate::model::DataStorage {
            crate::model::DataStorage {
                cw_log: self.cw_log,
            }
        }
    }
}

/// <p>A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CwLog {
    /// <p>Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.</p>
    #[doc(hidden)]
    pub cw_log_enabled: std::option::Option<bool>,
    /// <p>The name of the log group where the copies are stored.</p>
    #[doc(hidden)]
    pub cw_log_group: std::option::Option<std::string::String>,
}
impl CwLog {
    /// <p>Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.</p>
    pub fn cw_log_enabled(&self) -> std::option::Option<bool> {
        self.cw_log_enabled
    }
    /// <p>The name of the log group where the copies are stored.</p>
    pub fn cw_log_group(&self) -> std::option::Option<&str> {
        self.cw_log_group.as_deref()
    }
}
impl CwLog {
    /// Creates a new builder-style object to manufacture [`CwLog`](crate::model::CwLog).
    pub fn builder() -> crate::model::cw_log::Builder {
        crate::model::cw_log::Builder::default()
    }
}

/// See [`CwLog`](crate::model::CwLog).
pub mod cw_log {

    /// A builder for [`CwLog`](crate::model::CwLog).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cw_log_enabled: std::option::Option<bool>,
        pub(crate) cw_log_group: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.</p>
        pub fn cw_log_enabled(mut self, input: bool) -> Self {
            self.cw_log_enabled = Some(input);
            self
        }
        /// <p>Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.</p>
        pub fn set_cw_log_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cw_log_enabled = input;
            self
        }
        /// <p>The name of the log group where the copies are stored.</p>
        pub fn cw_log_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.cw_log_group = Some(input.into());
            self
        }
        /// <p>The name of the log group where the copies are stored.</p>
        pub fn set_cw_log_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cw_log_group = input;
            self
        }
        /// Consumes the builder and constructs a [`CwLog`](crate::model::CwLog).
        pub fn build(self) -> crate::model::CwLog {
            crate::model::CwLog {
                cw_log_enabled: self.cw_log_enabled,
                cw_log_group: self.cw_log_group,
            }
        }
    }
}

/// <p>A structure that contains the information for one performance event that RUM collects from a user session with your application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RumEvent {
    /// <p>A unique ID for this event.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The exact time that this event occurred.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The JSON schema that denotes the type of event this is, such as a page load or a new session.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.</p>
    #[doc(hidden)]
    pub metadata: std::option::Option<std::string::String>,
    /// <p>A string containing details about the event.</p>
    #[doc(hidden)]
    pub details: std::option::Option<std::string::String>,
}
impl RumEvent {
    /// <p>A unique ID for this event.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The exact time that this event occurred.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
    /// <p>The JSON schema that denotes the type of event this is, such as a page load or a new session.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.</p>
    pub fn metadata(&self) -> std::option::Option<&str> {
        self.metadata.as_deref()
    }
    /// <p>A string containing details about the event.</p>
    pub fn details(&self) -> std::option::Option<&str> {
        self.details.as_deref()
    }
}
impl RumEvent {
    /// Creates a new builder-style object to manufacture [`RumEvent`](crate::model::RumEvent).
    pub fn builder() -> crate::model::rum_event::Builder {
        crate::model::rum_event::Builder::default()
    }
}

/// See [`RumEvent`](crate::model::RumEvent).
pub mod rum_event {

    /// A builder for [`RumEvent`](crate::model::RumEvent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) metadata: std::option::Option<std::string::String>,
        pub(crate) details: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique ID for this event.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>A unique ID for this event.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The exact time that this event occurred.</p>
        pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.timestamp = Some(input);
            self
        }
        /// <p>The exact time that this event occurred.</p>
        pub fn set_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.timestamp = input;
            self
        }
        /// <p>The JSON schema that denotes the type of event this is, such as a page load or a new session.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The JSON schema that denotes the type of event this is, such as a page load or a new session.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.</p>
        pub fn metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.metadata = Some(input.into());
            self
        }
        /// <p>Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.</p>
        pub fn set_metadata(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metadata = input;
            self
        }
        /// <p>A string containing details about the event.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.details = Some(input.into());
            self
        }
        /// <p>A string containing details about the event.</p>
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.details = input;
            self
        }
        /// Consumes the builder and constructs a [`RumEvent`](crate::model::RumEvent).
        pub fn build(self) -> crate::model::RumEvent {
            crate::model::RumEvent {
                id: self.id,
                timestamp: self.timestamp,
                r#type: self.r#type,
                metadata: self.metadata,
                details: self.details,
            }
        }
    }
}

/// <p>A structure that contains information about the user session that this batch of events was collected from.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserDetails {
    /// <p>The ID of the user for this user session. This ID is generated by RUM and does not include any personally identifiable information about the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The session ID that the performance events are from.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
}
impl UserDetails {
    /// <p>The ID of the user for this user session. This ID is generated by RUM and does not include any personally identifiable information about the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The session ID that the performance events are from.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
}
impl UserDetails {
    /// Creates a new builder-style object to manufacture [`UserDetails`](crate::model::UserDetails).
    pub fn builder() -> crate::model::user_details::Builder {
        crate::model::user_details::Builder::default()
    }
}

/// See [`UserDetails`](crate::model::UserDetails).
pub mod user_details {

    /// A builder for [`UserDetails`](crate::model::UserDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) session_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the user for this user session. This ID is generated by RUM and does not include any personally identifiable information about the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The ID of the user for this user session. This ID is generated by RUM and does not include any personally identifiable information about the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The session ID that the performance events are from.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        /// <p>The session ID that the performance events are from.</p>
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// Consumes the builder and constructs a [`UserDetails`](crate::model::UserDetails).
        pub fn build(self) -> crate::model::UserDetails {
            crate::model::UserDetails {
                user_id: self.user_id,
                session_id: self.session_id,
            }
        }
    }
}

/// <p>A structure that contains information about the RUM app monitor.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AppMonitorDetails {
    /// <p>The name of the app monitor.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique ID of the app monitor.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The version of the app monitor.</p>
    #[doc(hidden)]
    pub version: std::option::Option<std::string::String>,
}
impl AppMonitorDetails {
    /// <p>The name of the app monitor.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique ID of the app monitor.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The version of the app monitor.</p>
    pub fn version(&self) -> std::option::Option<&str> {
        self.version.as_deref()
    }
}
impl AppMonitorDetails {
    /// Creates a new builder-style object to manufacture [`AppMonitorDetails`](crate::model::AppMonitorDetails).
    pub fn builder() -> crate::model::app_monitor_details::Builder {
        crate::model::app_monitor_details::Builder::default()
    }
}

/// See [`AppMonitorDetails`](crate::model::AppMonitorDetails).
pub mod app_monitor_details {

    /// A builder for [`AppMonitorDetails`](crate::model::AppMonitorDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the app monitor.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the app monitor.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique ID of the app monitor.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique ID of the app monitor.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The version of the app monitor.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the app monitor.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`AppMonitorDetails`](crate::model::AppMonitorDetails).
        pub fn build(self) -> crate::model::AppMonitorDetails {
            crate::model::AppMonitorDetails {
                name: self.name,
                id: self.id,
                version: self.version,
            }
        }
    }
}
