// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Use this structure to define one extended metric that RUM will send to CloudWatch or CloudWatch Evidently. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-vended-metrics.html"> Additional metrics that you can send to CloudWatch and CloudWatch Evidently</a>.</p>
/// <p>Only certain combinations of values for <code>Name</code>, <code>ValueKey</code>, and <code>EventPattern</code> are valid. In addition to what is displayed in the list below, the <code>EventPattern</code> can also include information used by the <code>DimensionKeys</code> field.</p>
/// <ul>
/// <li> <p>If <code>Name</code> is <code>PerformanceNavigationDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_navigation_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>PerformanceResourceDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_resource_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationSatisfiedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;",2000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationToleratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",2000,"&lt;"8000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationFrustratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",8000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsCumulativeLayoutShift</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.cumulative_layout_shift_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsFirstInputDelay</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.first_input_delay_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsLargestContentfulPaint</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.largest_contentful_paint_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>JsErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.js_error_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>HttpErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.http_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>SessionCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.session_start_event"]}</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    #[doc(hidden)]
    pub value_key: std::option::Option<std::string::String>,
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    #[doc(hidden)]
    pub unit_label: std::option::Option<std::string::String>,
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    #[doc(hidden)]
    pub dimension_keys:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    #[doc(hidden)]
    pub event_pattern: std::option::Option<std::string::String>,
}
impl MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(&self) -> std::option::Option<&str> {
        self.value_key.as_deref()
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(&self) -> std::option::Option<&str> {
        self.unit_label.as_deref()
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.dimension_keys.as_ref()
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(&self) -> std::option::Option<&str> {
        self.event_pattern.as_deref()
    }
}
impl MetricDefinitionRequest {
    /// Creates a new builder-style object to manufacture [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
    pub fn builder() -> crate::types::builders::MetricDefinitionRequestBuilder {
        crate::types::builders::MetricDefinitionRequestBuilder::default()
    }
}

/// A builder for [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct MetricDefinitionRequestBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) value_key: std::option::Option<std::string::String>,
    pub(crate) unit_label: std::option::Option<std::string::String>,
    pub(crate) dimension_keys:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) event_pattern: std::option::Option<std::string::String>,
}
impl MetricDefinitionRequestBuilder {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(mut self, input: impl Into<std::string::String>) -> Self {
        self.value_key = Some(input.into());
        self
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn set_value_key(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.value_key = input;
        self
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(mut self, input: impl Into<std::string::String>) -> Self {
        self.unit_label = Some(input.into());
        self
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn set_unit_label(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.unit_label = input;
        self
    }
    /// Adds a key-value pair to `dimension_keys`.
    ///
    /// To override the contents of this collection use [`set_dimension_keys`](Self::set_dimension_keys).
    ///
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(
        mut self,
        k: impl Into<std::string::String>,
        v: impl Into<std::string::String>,
    ) -> Self {
        let mut hash_map = self.dimension_keys.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.dimension_keys = Some(hash_map);
        self
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn set_dimension_keys(
        mut self,
        input: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    ) -> Self {
        self.dimension_keys = input;
        self
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(mut self, input: impl Into<std::string::String>) -> Self {
        self.event_pattern = Some(input.into());
        self
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn set_event_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.event_pattern = input;
        self
    }
    /// Consumes the builder and constructs a [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
    pub fn build(self) -> crate::types::MetricDefinitionRequest {
        crate::types::MetricDefinitionRequest {
            name: self.name,
            value_key: self.value_key,
            unit_label: self.unit_label,
            dimension_keys: self.dimension_keys,
            event_pattern: self.event_pattern,
        }
    }
}
