// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Use this structure to define one extended metric or custom metric that RUM will send to CloudWatch or CloudWatch Evidently. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-vended-metrics.html"> Additional metrics that you can send to CloudWatch and CloudWatch Evidently</a>.</p>
/// <p>This structure is validated differently for extended metrics and custom metrics. For extended metrics that are sent to the <code>AWS/RUM</code> namespace, the following validations apply:</p>
/// <ul>
/// <li> <p>The <code>Namespace</code> parameter must be omitted or set to <code>AWS/RUM</code>.</p> </li>
/// <li> <p>Only certain combinations of values for <code>Name</code>, <code>ValueKey</code>, and <code>EventPattern</code> are valid. In addition to what is displayed in the list below, the <code>EventPattern</code> can also include information used by the <code>DimensionKeys</code> field.</p>
/// <ul>
/// <li> <p>If <code>Name</code> is <code>PerformanceNavigationDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_navigation_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>PerformanceResourceDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_resource_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationSatisfiedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;",2000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationToleratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",2000,"&lt;"8000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>NavigationFrustratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",8000] }] } }</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsCumulativeLayoutShift</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.cumulative_layout_shift_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsFirstInputDelay</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.first_input_delay_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>WebVitalsLargestContentfulPaint</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.largest_contentful_paint_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>JsErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.js_error_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>HttpErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.http_event"]}</code> </p> </li>
/// <li> <p>If <code>Name</code> is <code>SessionCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.session_start_event"]}</code> </p> </li>
/// </ul> </li>
/// </ul>
/// <p>For custom metrics, the following validation rules apply:</p>
/// <ul>
/// <li> <p>The namespace can't be omitted and can't be <code>AWS/RUM</code>. You can use the <code>AWS/RUM</code> namespace only for extended metrics.</p> </li>
/// <li> <p>All dimensions listed in the <code>DimensionKeys</code> field must be present in the value of <code>EventPattern</code>.</p> </li>
/// <li> <p>The values that you specify for <code>ValueKey</code>, <code>EventPattern</code>, and <code>DimensionKeys</code> must be fields in RUM events, so all first-level keys in these fields must be one of the keys in the list later in this section.</p> </li>
/// <li> <p>If you set a value for <code>EventPattern</code>, it must be a JSON object.</p> </li>
/// <li> <p>For every non-empty <code>event_details</code>, there must be a non-empty <code>event_type</code>.</p> </li>
/// <li> <p>If <code>EventPattern</code> contains an <code>event_details</code> field, it must also contain an <code>event_type</code>. For every built-in <code>event_type</code> that you use, you must use a value for <code>event_details</code> that corresponds to that <code>event_type</code>. For information about event details that correspond to event types, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-datacollected.html#CloudWatch-RUM-datacollected-eventDetails"> RUM event details</a>.</p> </li>
/// <li> <p>In <code>EventPattern</code>, any JSON array must contain only one value.</p> </li>
/// </ul>
/// <p>Valid key values for first-level keys in the <code>ValueKey</code>, <code>EventPattern</code>, and <code>DimensionKeys</code> fields:</p>
/// <ul>
/// <li> <p> <code>account_id</code> </p> </li>
/// <li> <p> <code>application_Id</code> </p> </li>
/// <li> <p> <code>application_version</code> </p> </li>
/// <li> <p> <code>application_name</code> </p> </li>
/// <li> <p> <code>batch_id</code> </p> </li>
/// <li> <p> <code>event_details</code> </p> </li>
/// <li> <p> <code>event_id</code> </p> </li>
/// <li> <p> <code>event_interaction</code> </p> </li>
/// <li> <p> <code>event_timestamp</code> </p> </li>
/// <li> <p> <code>event_type</code> </p> </li>
/// <li> <p> <code>event_version</code> </p> </li>
/// <li> <p> <code>log_stream</code> </p> </li>
/// <li> <p> <code>metadata</code> </p> </li>
/// <li> <p> <code>sessionId</code> </p> </li>
/// <li> <p> <code>user_details</code> </p> </li>
/// <li> <p> <code>userId</code> </p> </li>
/// </ul>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. For custom metrics, you can specify any name that you like. For extended metrics, valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub name: ::std::string::String,
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub value_key: ::std::option::Option<::std::string::String>,
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub unit_label: ::std::option::Option<::std::string::String>,
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> For both extended metrics and custom metrics, all dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub dimension_keys: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub event_pattern: ::std::option::Option<::std::string::String>,
    /// <p>If this structure is for a custom metric instead of an extended metrics, use this parameter to define the metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric.</p>
    /// <p>You cannot use any string that starts with <code>AWS/</code> for your namespace.</p>
    pub namespace: ::std::option::Option<::std::string::String>,
}
impl MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. For custom metrics, you can specify any name that you like. For extended metrics, valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(&self) -> ::std::option::Option<&str> {
        self.value_key.as_deref()
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(&self) -> ::std::option::Option<&str> {
        self.unit_label.as_deref()
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> For both extended metrics and custom metrics, all dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.dimension_keys.as_ref()
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(&self) -> ::std::option::Option<&str> {
        self.event_pattern.as_deref()
    }
    /// <p>If this structure is for a custom metric instead of an extended metrics, use this parameter to define the metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric.</p>
    /// <p>You cannot use any string that starts with <code>AWS/</code> for your namespace.</p>
    pub fn namespace(&self) -> ::std::option::Option<&str> {
        self.namespace.as_deref()
    }
}
impl MetricDefinitionRequest {
    /// Creates a new builder-style object to manufacture [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
    pub fn builder() -> crate::types::builders::MetricDefinitionRequestBuilder {
        crate::types::builders::MetricDefinitionRequestBuilder::default()
    }
}

/// A builder for [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct MetricDefinitionRequestBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) value_key: ::std::option::Option<::std::string::String>,
    pub(crate) unit_label: ::std::option::Option<::std::string::String>,
    pub(crate) dimension_keys: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) event_pattern: ::std::option::Option<::std::string::String>,
    pub(crate) namespace: ::std::option::Option<::std::string::String>,
}
impl MetricDefinitionRequestBuilder {
    /// <p>The name for the metric that is defined in this structure. For custom metrics, you can specify any name that you like. For extended metrics, valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name for the metric that is defined in this structure. For custom metrics, you can specify any name that you like. For extended metrics, valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name for the metric that is defined in this structure. For custom metrics, you can specify any name that you like. For extended metrics, valid values are the following:</p>
    /// <ul>
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li>
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li>
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li>
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li>
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li>
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li>
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li>
    /// <li> <p> <code>JsErrorCount</code> </p> </li>
    /// <li> <p> <code>HttpErrorCount</code> </p> </li>
    /// <li> <p> <code>SessionCount</code> </p> </li>
    /// </ul>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.value_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn set_value_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.value_key = input;
        self
    }
    /// <p>The field within the event object that the metric value is sourced from.</p>
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p>
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn get_value_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.value_key
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.unit_label = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn set_unit_label(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.unit_label = input;
        self
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn get_unit_label(&self) -> &::std::option::Option<::std::string::String> {
        &self.unit_label
    }
    /// Adds a key-value pair to `dimension_keys`.
    ///
    /// To override the contents of this collection use [`set_dimension_keys`](Self::set_dimension_keys).
    ///
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> For both extended metrics and custom metrics, all dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.dimension_keys.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.dimension_keys = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> For both extended metrics and custom metrics, all dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn set_dimension_keys(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.dimension_keys = input;
        self
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p>
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:</p>
    /// <ul>
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li>
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li>
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li>
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li>
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li>
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li>
    /// </ul>
    /// <p> For both extended metrics and custom metrics, all dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn get_dimension_keys(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.dimension_keys
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.event_pattern = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn set_event_pattern(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.event_pattern = input;
        self
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p>
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p>
    /// <p>Example event patterns:</p>
    /// <ul>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li>
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li>
    /// </ul>
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn get_event_pattern(&self) -> &::std::option::Option<::std::string::String> {
        &self.event_pattern
    }
    /// <p>If this structure is for a custom metric instead of an extended metrics, use this parameter to define the metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric.</p>
    /// <p>You cannot use any string that starts with <code>AWS/</code> for your namespace.</p>
    pub fn namespace(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.namespace = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If this structure is for a custom metric instead of an extended metrics, use this parameter to define the metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric.</p>
    /// <p>You cannot use any string that starts with <code>AWS/</code> for your namespace.</p>
    pub fn set_namespace(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.namespace = input;
        self
    }
    /// <p>If this structure is for a custom metric instead of an extended metrics, use this parameter to define the metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric.</p>
    /// <p>You cannot use any string that starts with <code>AWS/</code> for your namespace.</p>
    pub fn get_namespace(&self) -> &::std::option::Option<::std::string::String> {
        &self.namespace
    }
    /// Consumes the builder and constructs a [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
    /// This method will fail if any of the following fields are not set:
    /// - [`name`](crate::types::builders::MetricDefinitionRequestBuilder::name)
    pub fn build(self) -> ::std::result::Result<crate::types::MetricDefinitionRequest, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::MetricDefinitionRequest {
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building MetricDefinitionRequest",
                )
            })?,
            value_key: self.value_key,
            unit_label: self.unit_label,
            dimension_keys: self.dimension_keys,
            event_pattern: self.event_pattern,
            namespace: self.namespace,
        })
    }
}
