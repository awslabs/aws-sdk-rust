// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Use this structure to define one extended metric that RUM will send to CloudWatch or CloudWatch Evidently. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-RUM-vended-metrics.html"> Additional metrics that you can send to CloudWatch and CloudWatch Evidently</a>.</p> 
/// <p>Only certain combinations of values for <code>Name</code>, <code>ValueKey</code>, and <code>EventPattern</code> are valid. In addition to what is displayed in the list below, the <code>EventPattern</code> can also include information used by the <code>DimensionKeys</code> field.</p> 
/// <ul> 
/// <li> <p>If <code>Name</code> is <code>PerformanceNavigationDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_navigation_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>PerformanceResourceDuration</code>, then <code>ValueKey</code>must be <code>event_details.duration</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.performance_resource_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>NavigationSatisfiedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;",2000] }] } }</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>NavigationToleratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",2000,"&lt;"8000] }] } }</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>NavigationFrustratedTransaction</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{ "event_type": ["com.amazon.rum.performance_navigation_event"], "event_details": { "duration": [{ "numeric": ["&gt;=",8000] }] } }</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>WebVitalsCumulativeLayoutShift</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.cumulative_layout_shift_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>WebVitalsFirstInputDelay</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.first_input_delay_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>WebVitalsLargestContentfulPaint</code>, then <code>ValueKey</code>must be <code>event_details.value</code> and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.largest_contentful_paint_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>JsErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.js_error_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>HttpErrorCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.http_event"]}</code> </p> </li> 
/// <li> <p>If <code>Name</code> is <code>SessionCount</code>, then <code>ValueKey</code>must be null and the <code>EventPattern</code> must include <code>{"event_type":["com.amazon.rum.session_start_event"]}</code> </p> </li> 
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricDefinitionRequest  {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li> 
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li> 
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li> 
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li> 
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li> 
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li> 
    /// <li> <p> <code>JsErrorCount</code> </p> </li> 
    /// <li> <p> <code>HttpErrorCount</code> </p> </li> 
    /// <li> <p> <code>SessionCount</code> </p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The field within the event object that the metric value is sourced from.</p> 
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p> 
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    #[doc(hidden)]
    pub value_key: std::option::Option<std::string::String>,
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    #[doc(hidden)]
    pub unit_label: std::option::Option<std::string::String>,
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p> 
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li> 
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li> 
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li> 
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li> 
    /// </ul> 
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    #[doc(hidden)]
    pub dimension_keys: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p> 
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p> 
    /// <p>Example event patterns:</p> 
    /// <ul> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li> 
    /// </ul> 
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    #[doc(hidden)]
    pub event_pattern: std::option::Option<std::string::String>,
}
impl MetricDefinitionRequest {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li> 
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li> 
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li> 
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li> 
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li> 
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li> 
    /// <li> <p> <code>JsErrorCount</code> </p> </li> 
    /// <li> <p> <code>HttpErrorCount</code> </p> </li> 
    /// <li> <p> <code>SessionCount</code> </p> </li> 
    /// </ul>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The field within the event object that the metric value is sourced from.</p> 
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p> 
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(&self) -> std::option::Option<& str> {
        self.value_key.as_deref()
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(&self) -> std::option::Option<& str> {
        self.unit_label.as_deref()
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p> 
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li> 
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li> 
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li> 
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li> 
    /// </ul> 
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.dimension_keys.as_ref()
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p> 
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p> 
    /// <p>Example event patterns:</p> 
    /// <ul> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li> 
    /// </ul> 
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(&self) -> std::option::Option<& str> {
        self.event_pattern.as_deref()
    }
}
impl MetricDefinitionRequest {
    /// Creates a new builder-style object to manufacture [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
    pub fn builder() -> crate::types::builders::MetricDefinitionRequestBuilder {
        crate::types::builders::MetricDefinitionRequestBuilder::default()
    }
}

/// A builder for [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct MetricDefinitionRequestBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) value_key: std::option::Option<std::string::String>,
    pub(crate) unit_label: std::option::Option<std::string::String>,
    pub(crate) dimension_keys: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) event_pattern: std::option::Option<std::string::String>,
}
impl MetricDefinitionRequestBuilder {
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li> 
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li> 
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li> 
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li> 
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li> 
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li> 
    /// <li> <p> <code>JsErrorCount</code> </p> </li> 
    /// <li> <p> <code>HttpErrorCount</code> </p> </li> 
    /// <li> <p> <code>SessionCount</code> </p> </li> 
    /// </ul>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name for the metric that is defined in this structure. Valid values are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>PerformanceNavigationDuration</code> </p> </li> 
    /// <li> <p> <code>PerformanceResourceDuration </code> </p> </li> 
    /// <li> <p> <code>NavigationSatisfiedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationToleratedTransaction</code> </p> </li> 
    /// <li> <p> <code>NavigationFrustratedTransaction</code> </p> </li> 
    /// <li> <p> <code>WebVitalsCumulativeLayoutShift</code> </p> </li> 
    /// <li> <p> <code>WebVitalsFirstInputDelay</code> </p> </li> 
    /// <li> <p> <code>WebVitalsLargestContentfulPaint</code> </p> </li> 
    /// <li> <p> <code>JsErrorCount</code> </p> </li> 
    /// <li> <p> <code>HttpErrorCount</code> </p> </li> 
    /// <li> <p> <code>SessionCount</code> </p> </li> 
    /// </ul>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input; self
    }
    /// <p>The field within the event object that the metric value is sourced from.</p> 
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p> 
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn value_key(mut self, input: impl Into<std::string::String>) -> Self {
        self.value_key = Some(input.into());
        self
    }
    /// <p>The field within the event object that the metric value is sourced from.</p> 
    /// <p>If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches. </p> 
    /// <p>If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.</p>
    pub fn set_value_key(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.value_key = input; self
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn unit_label(mut self, input: impl Into<std::string::String>) -> Self {
        self.unit_label = Some(input.into());
        self
    }
    /// <p>The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.</p>
    pub fn set_unit_label(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.unit_label = input; self
    }
    /// Adds a key-value pair to `dimension_keys`.
    ///
    /// To override the contents of this collection use [`set_dimension_keys`](Self::set_dimension_keys).
    ///
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p> 
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li> 
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li> 
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li> 
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li> 
    /// </ul> 
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn dimension_keys(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.dimension_keys.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.dimension_keys = Some(hash_map);
                        self
    }
    /// <p>Use this field only if you are sending the metric to CloudWatch.</p> 
    /// <p>This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. Valid values for the entries in this field are the following:</p> 
    /// <ul> 
    /// <li> <p> <code>"metadata.pageId": "PageId"</code> </p> </li> 
    /// <li> <p> <code>"metadata.browserName": "BrowserName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.deviceType": "DeviceType"</code> </p> </li> 
    /// <li> <p> <code>"metadata.osName": "OSName"</code> </p> </li> 
    /// <li> <p> <code>"metadata.countryCode": "CountryCode"</code> </p> </li> 
    /// <li> <p> <code>"event_details.fileType": "FileType"</code> </p> </li> 
    /// </ul> 
    /// <p> All dimensions listed in this field must also be included in <code>EventPattern</code>.</p>
    pub fn set_dimension_keys(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.dimension_keys = input; self
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p> 
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p> 
    /// <p>Example event patterns:</p> 
    /// <ul> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li> 
    /// </ul> 
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn event_pattern(mut self, input: impl Into<std::string::String>) -> Self {
        self.event_pattern = Some(input.into());
        self
    }
    /// <p>The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.</p> 
    /// <p>When you define extended metrics, the metric definition is not valid if <code>EventPattern</code> is omitted.</p> 
    /// <p>Example event patterns:</p> 
    /// <ul> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'</code> </p> </li> 
    /// <li> <p> <code>'{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'</code> </p> </li> 
    /// </ul> 
    /// <p>If the metrics destination' is <code>CloudWatch</code> and the event also matches a value in <code>DimensionKeys</code>, then the metric is published with the specified dimensions. </p>
    pub fn set_event_pattern(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.event_pattern = input; self
    }
    /// Consumes the builder and constructs a [`MetricDefinitionRequest`](crate::types::MetricDefinitionRequest).
    pub fn build(self) -> crate::types::MetricDefinitionRequest {
        crate::types::MetricDefinitionRequest {
            name: self.name
            ,
            value_key: self.value_key
            ,
            unit_label: self.unit_label
            ,
            dimension_keys: self.dimension_keys
            ,
            event_pattern: self.event_pattern
            ,
        }
    }
}

