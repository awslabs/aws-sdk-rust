// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates a batch of variables.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchCreateVariable {
    _private: (),
}
impl BatchCreateVariable {
    /// Creates a new builder-style object to manufacture [`BatchCreateVariableInput`](crate::input::BatchCreateVariableInput)
    pub fn builder() -> crate::input::batch_create_variable_input::Builder {
        crate::input::batch_create_variable_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchCreateVariable {
    type Output = std::result::Result<
        crate::output::BatchCreateVariableOutput,
        crate::error::BatchCreateVariableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_create_variable_error(response)
        } else {
            crate::operation_ser::parse_batch_create_variable_response(response)
        }
    }
}

/// <p>Gets a batch of variables.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetVariable {
    _private: (),
}
impl BatchGetVariable {
    /// Creates a new builder-style object to manufacture [`BatchGetVariableInput`](crate::input::BatchGetVariableInput)
    pub fn builder() -> crate::input::batch_get_variable_input::Builder {
        crate::input::batch_get_variable_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetVariable {
    type Output = std::result::Result<
        crate::output::BatchGetVariableOutput,
        crate::error::BatchGetVariableError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_batch_get_variable_error(response)
        } else {
            crate::operation_ser::parse_batch_get_variable_response(response)
        }
    }
}

/// <p>Cancels the specified batch prediction job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelBatchPredictionJob {
    _private: (),
}
impl CancelBatchPredictionJob {
    /// Creates a new builder-style object to manufacture [`CancelBatchPredictionJobInput`](crate::input::CancelBatchPredictionJobInput)
    pub fn builder() -> crate::input::cancel_batch_prediction_job_input::Builder {
        crate::input::cancel_batch_prediction_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelBatchPredictionJob {
    type Output = std::result::Result<
        crate::output::CancelBatchPredictionJobOutput,
        crate::error::CancelBatchPredictionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_cancel_batch_prediction_job_error(response)
        } else {
            crate::operation_ser::parse_cancel_batch_prediction_job_response(response)
        }
    }
}

/// <p>Creates a batch prediction job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBatchPredictionJob {
    _private: (),
}
impl CreateBatchPredictionJob {
    /// Creates a new builder-style object to manufacture [`CreateBatchPredictionJobInput`](crate::input::CreateBatchPredictionJobInput)
    pub fn builder() -> crate::input::create_batch_prediction_job_input::Builder {
        crate::input::create_batch_prediction_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBatchPredictionJob {
    type Output = std::result::Result<
        crate::output::CreateBatchPredictionJobOutput,
        crate::error::CreateBatchPredictionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_batch_prediction_job_error(response)
        } else {
            crate::operation_ser::parse_create_batch_prediction_job_response(response)
        }
    }
}

/// <p>Creates a detector version. The detector version starts in a <code>DRAFT</code> status.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDetectorVersion {
    _private: (),
}
impl CreateDetectorVersion {
    /// Creates a new builder-style object to manufacture [`CreateDetectorVersionInput`](crate::input::CreateDetectorVersionInput)
    pub fn builder() -> crate::input::create_detector_version_input::Builder {
        crate::input::create_detector_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDetectorVersion {
    type Output = std::result::Result<
        crate::output::CreateDetectorVersionOutput,
        crate::error::CreateDetectorVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_detector_version_error(response)
        } else {
            crate::operation_ser::parse_create_detector_version_response(response)
        }
    }
}

/// <p>Creates a model using the specified model type.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateModel {
    _private: (),
}
impl CreateModel {
    /// Creates a new builder-style object to manufacture [`CreateModelInput`](crate::input::CreateModelInput)
    pub fn builder() -> crate::input::create_model_input::Builder {
        crate::input::create_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateModel {
    type Output =
        std::result::Result<crate::output::CreateModelOutput, crate::error::CreateModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_model_error(response)
        } else {
            crate::operation_ser::parse_create_model_response(response)
        }
    }
}

/// <p>Creates a version of the model using the specified model type and model id.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateModelVersion {
    _private: (),
}
impl CreateModelVersion {
    /// Creates a new builder-style object to manufacture [`CreateModelVersionInput`](crate::input::CreateModelVersionInput)
    pub fn builder() -> crate::input::create_model_version_input::Builder {
        crate::input::create_model_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateModelVersion {
    type Output = std::result::Result<
        crate::output::CreateModelVersionOutput,
        crate::error::CreateModelVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_model_version_error(response)
        } else {
            crate::operation_ser::parse_create_model_version_response(response)
        }
    }
}

/// <p>Creates a rule for use with the specified detector. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRule {
    _private: (),
}
impl CreateRule {
    /// Creates a new builder-style object to manufacture [`CreateRuleInput`](crate::input::CreateRuleInput)
    pub fn builder() -> crate::input::create_rule_input::Builder {
        crate::input::create_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRule {
    type Output =
        std::result::Result<crate::output::CreateRuleOutput, crate::error::CreateRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_rule_error(response)
        } else {
            crate::operation_ser::parse_create_rule_response(response)
        }
    }
}

/// <p>Creates a variable.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateVariable {
    _private: (),
}
impl CreateVariable {
    /// Creates a new builder-style object to manufacture [`CreateVariableInput`](crate::input::CreateVariableInput)
    pub fn builder() -> crate::input::create_variable_input::Builder {
        crate::input::create_variable_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateVariable {
    type Output =
        std::result::Result<crate::output::CreateVariableOutput, crate::error::CreateVariableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_create_variable_error(response)
        } else {
            crate::operation_ser::parse_create_variable_response(response)
        }
    }
}

/// <p>Deletes a batch prediction job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBatchPredictionJob {
    _private: (),
}
impl DeleteBatchPredictionJob {
    /// Creates a new builder-style object to manufacture [`DeleteBatchPredictionJobInput`](crate::input::DeleteBatchPredictionJobInput)
    pub fn builder() -> crate::input::delete_batch_prediction_job_input::Builder {
        crate::input::delete_batch_prediction_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBatchPredictionJob {
    type Output = std::result::Result<
        crate::output::DeleteBatchPredictionJobOutput,
        crate::error::DeleteBatchPredictionJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_batch_prediction_job_error(response)
        } else {
            crate::operation_ser::parse_delete_batch_prediction_job_response(response)
        }
    }
}

/// <p>Deletes the detector. Before deleting a detector, you must first delete all detector versions and rule versions associated with the detector.</p>
/// <p>When you delete a detector, Amazon Fraud Detector permanently deletes the detector and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDetector {
    _private: (),
}
impl DeleteDetector {
    /// Creates a new builder-style object to manufacture [`DeleteDetectorInput`](crate::input::DeleteDetectorInput)
    pub fn builder() -> crate::input::delete_detector_input::Builder {
        crate::input::delete_detector_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDetector {
    type Output =
        std::result::Result<crate::output::DeleteDetectorOutput, crate::error::DeleteDetectorError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_detector_error(response)
        } else {
            crate::operation_ser::parse_delete_detector_response(response)
        }
    }
}

/// <p>Deletes the detector version. You cannot delete detector versions that are in <code>ACTIVE</code> status.</p>
/// <p>When you delete a detector version, Amazon Fraud Detector permanently deletes the detector and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDetectorVersion {
    _private: (),
}
impl DeleteDetectorVersion {
    /// Creates a new builder-style object to manufacture [`DeleteDetectorVersionInput`](crate::input::DeleteDetectorVersionInput)
    pub fn builder() -> crate::input::delete_detector_version_input::Builder {
        crate::input::delete_detector_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDetectorVersion {
    type Output = std::result::Result<
        crate::output::DeleteDetectorVersionOutput,
        crate::error::DeleteDetectorVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_detector_version_error(response)
        } else {
            crate::operation_ser::parse_delete_detector_version_response(response)
        }
    }
}

/// <p>Deletes an entity type.</p>
/// <p>You cannot delete an entity type that is included in an event type.</p>
/// <p>When you delete an entity type, Amazon Fraud Detector permanently deletes that entity type and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEntityType {
    _private: (),
}
impl DeleteEntityType {
    /// Creates a new builder-style object to manufacture [`DeleteEntityTypeInput`](crate::input::DeleteEntityTypeInput)
    pub fn builder() -> crate::input::delete_entity_type_input::Builder {
        crate::input::delete_entity_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEntityType {
    type Output = std::result::Result<
        crate::output::DeleteEntityTypeOutput,
        crate::error::DeleteEntityTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_entity_type_error(response)
        } else {
            crate::operation_ser::parse_delete_entity_type_response(response)
        }
    }
}

/// <p>Deletes the specified event.</p>
/// <p>When you delete an event, Amazon Fraud Detector permanently deletes that event and the event data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEvent {
    _private: (),
}
impl DeleteEvent {
    /// Creates a new builder-style object to manufacture [`DeleteEventInput`](crate::input::DeleteEventInput)
    pub fn builder() -> crate::input::delete_event_input::Builder {
        crate::input::delete_event_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEvent {
    type Output =
        std::result::Result<crate::output::DeleteEventOutput, crate::error::DeleteEventError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_event_error(response)
        } else {
            crate::operation_ser::parse_delete_event_response(response)
        }
    }
}

/// <p>Deletes an event type.</p>
/// <p>You cannot delete an event type that is used in a detector or a model.</p>
/// <p>When you delete an entity type, Amazon Fraud Detector permanently deletes that entity type and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEventType {
    _private: (),
}
impl DeleteEventType {
    /// Creates a new builder-style object to manufacture [`DeleteEventTypeInput`](crate::input::DeleteEventTypeInput)
    pub fn builder() -> crate::input::delete_event_type_input::Builder {
        crate::input::delete_event_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEventType {
    type Output = std::result::Result<
        crate::output::DeleteEventTypeOutput,
        crate::error::DeleteEventTypeError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_event_type_error(response)
        } else {
            crate::operation_ser::parse_delete_event_type_response(response)
        }
    }
}

/// <p>Removes a SageMaker model from Amazon Fraud Detector.</p>
/// <p>You can remove an Amazon SageMaker model if it is not associated with a detector version. Removing a SageMaker model disconnects it from Amazon Fraud Detector, but the model remains available in SageMaker.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteExternalModel {
    _private: (),
}
impl DeleteExternalModel {
    /// Creates a new builder-style object to manufacture [`DeleteExternalModelInput`](crate::input::DeleteExternalModelInput)
    pub fn builder() -> crate::input::delete_external_model_input::Builder {
        crate::input::delete_external_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteExternalModel {
    type Output = std::result::Result<
        crate::output::DeleteExternalModelOutput,
        crate::error::DeleteExternalModelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_external_model_error(response)
        } else {
            crate::operation_ser::parse_delete_external_model_response(response)
        }
    }
}

/// <p>Deletes a label.</p>
/// <p>You cannot delete labels that are included in an event type in Amazon Fraud Detector.</p>
/// <p>You cannot delete a label assigned to an event ID. You must first delete the relevant event ID.</p>
/// <p>When you delete a label, Amazon Fraud Detector permanently deletes that label and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLabel {
    _private: (),
}
impl DeleteLabel {
    /// Creates a new builder-style object to manufacture [`DeleteLabelInput`](crate::input::DeleteLabelInput)
    pub fn builder() -> crate::input::delete_label_input::Builder {
        crate::input::delete_label_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLabel {
    type Output =
        std::result::Result<crate::output::DeleteLabelOutput, crate::error::DeleteLabelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_label_error(response)
        } else {
            crate::operation_ser::parse_delete_label_response(response)
        }
    }
}

/// <p>Deletes a model.</p>
/// <p>You can delete models and model versions in Amazon Fraud Detector, provided that they are not associated with a detector version.</p>
/// <p> When you delete a model, Amazon Fraud Detector permanently deletes that model and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteModel {
    _private: (),
}
impl DeleteModel {
    /// Creates a new builder-style object to manufacture [`DeleteModelInput`](crate::input::DeleteModelInput)
    pub fn builder() -> crate::input::delete_model_input::Builder {
        crate::input::delete_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteModel {
    type Output =
        std::result::Result<crate::output::DeleteModelOutput, crate::error::DeleteModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_model_error(response)
        } else {
            crate::operation_ser::parse_delete_model_response(response)
        }
    }
}

/// <p>Deletes a model version.</p>
/// <p>You can delete models and model versions in Amazon Fraud Detector, provided that they are not associated with a detector version.</p>
/// <p> When you delete a model version, Amazon Fraud Detector permanently deletes that model version and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteModelVersion {
    _private: (),
}
impl DeleteModelVersion {
    /// Creates a new builder-style object to manufacture [`DeleteModelVersionInput`](crate::input::DeleteModelVersionInput)
    pub fn builder() -> crate::input::delete_model_version_input::Builder {
        crate::input::delete_model_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteModelVersion {
    type Output = std::result::Result<
        crate::output::DeleteModelVersionOutput,
        crate::error::DeleteModelVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_model_version_error(response)
        } else {
            crate::operation_ser::parse_delete_model_version_response(response)
        }
    }
}

/// <p>Deletes an outcome.</p>
/// <p>You cannot delete an outcome that is used in a rule version.</p>
/// <p>When you delete an outcome, Amazon Fraud Detector permanently deletes that outcome and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteOutcome {
    _private: (),
}
impl DeleteOutcome {
    /// Creates a new builder-style object to manufacture [`DeleteOutcomeInput`](crate::input::DeleteOutcomeInput)
    pub fn builder() -> crate::input::delete_outcome_input::Builder {
        crate::input::delete_outcome_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteOutcome {
    type Output =
        std::result::Result<crate::output::DeleteOutcomeOutput, crate::error::DeleteOutcomeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_outcome_error(response)
        } else {
            crate::operation_ser::parse_delete_outcome_response(response)
        }
    }
}

/// <p>Deletes the rule. You cannot delete a rule if it is used by an <code>ACTIVE</code> or <code>INACTIVE</code> detector version.</p>
/// <p>When you delete a rule, Amazon Fraud Detector permanently deletes that rule and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRule {
    _private: (),
}
impl DeleteRule {
    /// Creates a new builder-style object to manufacture [`DeleteRuleInput`](crate::input::DeleteRuleInput)
    pub fn builder() -> crate::input::delete_rule_input::Builder {
        crate::input::delete_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRule {
    type Output =
        std::result::Result<crate::output::DeleteRuleOutput, crate::error::DeleteRuleError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_rule_error(response)
        } else {
            crate::operation_ser::parse_delete_rule_response(response)
        }
    }
}

/// <p>Deletes a variable.</p>
/// <p>You can't delete variables that are included in an event type in Amazon Fraud Detector.</p>
/// <p>Amazon Fraud Detector automatically deletes model output variables and SageMaker model output variables when you delete the model. You can't delete these variables manually.</p>
/// <p>When you delete a variable, Amazon Fraud Detector permanently deletes that variable and the data is no longer stored in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteVariable {
    _private: (),
}
impl DeleteVariable {
    /// Creates a new builder-style object to manufacture [`DeleteVariableInput`](crate::input::DeleteVariableInput)
    pub fn builder() -> crate::input::delete_variable_input::Builder {
        crate::input::delete_variable_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteVariable {
    type Output =
        std::result::Result<crate::output::DeleteVariableOutput, crate::error::DeleteVariableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_delete_variable_error(response)
        } else {
            crate::operation_ser::parse_delete_variable_response(response)
        }
    }
}

/// <p>Gets all versions for a specified detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeDetector {
    _private: (),
}
impl DescribeDetector {
    /// Creates a new builder-style object to manufacture [`DescribeDetectorInput`](crate::input::DescribeDetectorInput)
    pub fn builder() -> crate::input::describe_detector_input::Builder {
        crate::input::describe_detector_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeDetector {
    type Output = std::result::Result<
        crate::output::DescribeDetectorOutput,
        crate::error::DescribeDetectorError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_detector_error(response)
        } else {
            crate::operation_ser::parse_describe_detector_response(response)
        }
    }
}

/// <p>Gets all of the model versions for the specified model type or for the specified model type and model ID. You can also get details for a single, specified model version. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeModelVersions {
    _private: (),
}
impl DescribeModelVersions {
    /// Creates a new builder-style object to manufacture [`DescribeModelVersionsInput`](crate::input::DescribeModelVersionsInput)
    pub fn builder() -> crate::input::describe_model_versions_input::Builder {
        crate::input::describe_model_versions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeModelVersions {
    type Output = std::result::Result<
        crate::output::DescribeModelVersionsOutput,
        crate::error::DescribeModelVersionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_describe_model_versions_error(response)
        } else {
            crate::operation_ser::parse_describe_model_versions_response(response)
        }
    }
}

/// <p>Gets all batch prediction jobs or a specific job if you specify a job ID. This is a paginated API. If you provide a null maxResults, this action retrieves a maximum of 50 records per page. If you provide a maxResults, the value must be between 1 and 50. To get the next page results, provide the pagination token from the GetBatchPredictionJobsResponse as part of your request. A null pagination token fetches the records from the beginning.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBatchPredictionJobs {
    _private: (),
}
impl GetBatchPredictionJobs {
    /// Creates a new builder-style object to manufacture [`GetBatchPredictionJobsInput`](crate::input::GetBatchPredictionJobsInput)
    pub fn builder() -> crate::input::get_batch_prediction_jobs_input::Builder {
        crate::input::get_batch_prediction_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBatchPredictionJobs {
    type Output = std::result::Result<
        crate::output::GetBatchPredictionJobsOutput,
        crate::error::GetBatchPredictionJobsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_batch_prediction_jobs_error(response)
        } else {
            crate::operation_ser::parse_get_batch_prediction_jobs_response(response)
        }
    }
}

/// <p>Gets all detectors or a single detector if a <code>detectorId</code> is specified. This is a paginated API. If you
/// provide a null <code>maxResults</code>, this action retrieves a maximum of 10 records
/// per page. If you provide a <code>maxResults</code>, the value must be between 5 and 10.
/// To get the next page results, provide the pagination token from the
/// <code>GetDetectorsResponse</code> as part of your request. A null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDetectors {
    _private: (),
}
impl GetDetectors {
    /// Creates a new builder-style object to manufacture [`GetDetectorsInput`](crate::input::GetDetectorsInput)
    pub fn builder() -> crate::input::get_detectors_input::Builder {
        crate::input::get_detectors_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDetectors {
    type Output =
        std::result::Result<crate::output::GetDetectorsOutput, crate::error::GetDetectorsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_detectors_error(response)
        } else {
            crate::operation_ser::parse_get_detectors_response(response)
        }
    }
}

/// <p>Gets a particular detector version. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDetectorVersion {
    _private: (),
}
impl GetDetectorVersion {
    /// Creates a new builder-style object to manufacture [`GetDetectorVersionInput`](crate::input::GetDetectorVersionInput)
    pub fn builder() -> crate::input::get_detector_version_input::Builder {
        crate::input::get_detector_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDetectorVersion {
    type Output = std::result::Result<
        crate::output::GetDetectorVersionOutput,
        crate::error::GetDetectorVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_detector_version_error(response)
        } else {
            crate::operation_ser::parse_get_detector_version_response(response)
        }
    }
}

/// <p>Gets all entity types or a specific entity type if a name is specified. This is a paginated API. If you
/// provide a null <code>maxResults</code>, this action retrieves a maximum of 10 records
/// per page. If you provide a <code>maxResults</code>, the value must be between 5 and 10.
/// To get the next page results, provide the pagination token from the
/// <code>GetEntityTypesResponse</code> as part of your request. A null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEntityTypes {
    _private: (),
}
impl GetEntityTypes {
    /// Creates a new builder-style object to manufacture [`GetEntityTypesInput`](crate::input::GetEntityTypesInput)
    pub fn builder() -> crate::input::get_entity_types_input::Builder {
        crate::input::get_entity_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEntityTypes {
    type Output =
        std::result::Result<crate::output::GetEntityTypesOutput, crate::error::GetEntityTypesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_entity_types_error(response)
        } else {
            crate::operation_ser::parse_get_entity_types_response(response)
        }
    }
}

/// <p>Evaluates an event against a detector version. If a version ID is not provided, the detectorâ€™s (<code>ACTIVE</code>) version is used.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEventPrediction {
    _private: (),
}
impl GetEventPrediction {
    /// Creates a new builder-style object to manufacture [`GetEventPredictionInput`](crate::input::GetEventPredictionInput)
    pub fn builder() -> crate::input::get_event_prediction_input::Builder {
        crate::input::get_event_prediction_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEventPrediction {
    type Output = std::result::Result<
        crate::output::GetEventPredictionOutput,
        crate::error::GetEventPredictionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_event_prediction_error(response)
        } else {
            crate::operation_ser::parse_get_event_prediction_response(response)
        }
    }
}

/// <p>Gets all event types or a specific event type if name is provided. This is a paginated API. If you
/// provide a null <code>maxResults</code>, this action retrieves a maximum of 10 records
/// per page. If you provide a <code>maxResults</code>, the value must be between 5 and 10.
/// To get the next page results, provide the pagination token from the
/// <code>GetEventTypesResponse</code> as part of your request. A null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEventTypes {
    _private: (),
}
impl GetEventTypes {
    /// Creates a new builder-style object to manufacture [`GetEventTypesInput`](crate::input::GetEventTypesInput)
    pub fn builder() -> crate::input::get_event_types_input::Builder {
        crate::input::get_event_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEventTypes {
    type Output =
        std::result::Result<crate::output::GetEventTypesOutput, crate::error::GetEventTypesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_event_types_error(response)
        } else {
            crate::operation_ser::parse_get_event_types_response(response)
        }
    }
}

/// <p>Gets the details for one or more Amazon SageMaker models that have been imported into the
/// service. This is a paginated API. If you provide a null <code>maxResults</code>, this
/// actions retrieves a maximum of 10 records per page. If you provide a
/// <code>maxResults</code>, the value must be between 5 and 10. To get the next page
/// results, provide the pagination token from the <code>GetExternalModelsResult</code> as part
/// of your request. A null pagination token fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetExternalModels {
    _private: (),
}
impl GetExternalModels {
    /// Creates a new builder-style object to manufacture [`GetExternalModelsInput`](crate::input::GetExternalModelsInput)
    pub fn builder() -> crate::input::get_external_models_input::Builder {
        crate::input::get_external_models_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetExternalModels {
    type Output = std::result::Result<
        crate::output::GetExternalModelsOutput,
        crate::error::GetExternalModelsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_external_models_error(response)
        } else {
            crate::operation_ser::parse_get_external_models_response(response)
        }
    }
}

/// <p>Gets the encryption key if a Key Management Service (KMS) customer master key (CMK) has been specified to be used to encrypt content in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetKMSEncryptionKey {
    _private: (),
}
impl GetKMSEncryptionKey {
    /// Creates a new builder-style object to manufacture [`GetKmsEncryptionKeyInput`](crate::input::GetKmsEncryptionKeyInput)
    pub fn builder() -> crate::input::get_kms_encryption_key_input::Builder {
        crate::input::get_kms_encryption_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetKMSEncryptionKey {
    type Output = std::result::Result<
        crate::output::GetKmsEncryptionKeyOutput,
        crate::error::GetKMSEncryptionKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_kms_encryption_key_error(response)
        } else {
            crate::operation_ser::parse_get_kms_encryption_key_response(response)
        }
    }
}

/// <p>Gets all labels or a specific label if name is provided. This is a paginated API. If you
/// provide a null <code>maxResults</code>, this action retrieves a maximum of 50 records
/// per page. If you provide a <code>maxResults</code>, the value must be between 10 and 50.
/// To get the next page results, provide the pagination token from the
/// <code>GetGetLabelsResponse</code> as part of your request. A null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLabels {
    _private: (),
}
impl GetLabels {
    /// Creates a new builder-style object to manufacture [`GetLabelsInput`](crate::input::GetLabelsInput)
    pub fn builder() -> crate::input::get_labels_input::Builder {
        crate::input::get_labels_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLabels {
    type Output = std::result::Result<crate::output::GetLabelsOutput, crate::error::GetLabelsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_labels_error(response)
        } else {
            crate::operation_ser::parse_get_labels_response(response)
        }
    }
}

/// <p>Gets one or more models. Gets all models for the Amazon Web Services account if no model type and no model id provided. Gets all models for the Amazon Web Services account and model type, if the model type is specified but model id is not provided. Gets a specific model if (model type, model id) tuple is specified. </p>
/// <p>This is a paginated API. If you
/// provide a null <code>maxResults</code>, this action retrieves a maximum of 10 records
/// per page. If you provide a <code>maxResults</code>, the value must be between 1 and 10.
/// To get the next page results, provide the pagination token from the
/// response as part of your request. A null pagination token
/// fetches the records from the beginning.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetModels {
    _private: (),
}
impl GetModels {
    /// Creates a new builder-style object to manufacture [`GetModelsInput`](crate::input::GetModelsInput)
    pub fn builder() -> crate::input::get_models_input::Builder {
        crate::input::get_models_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetModels {
    type Output = std::result::Result<crate::output::GetModelsOutput, crate::error::GetModelsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_models_error(response)
        } else {
            crate::operation_ser::parse_get_models_response(response)
        }
    }
}

/// <p>Gets the details of the specified model version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetModelVersion {
    _private: (),
}
impl GetModelVersion {
    /// Creates a new builder-style object to manufacture [`GetModelVersionInput`](crate::input::GetModelVersionInput)
    pub fn builder() -> crate::input::get_model_version_input::Builder {
        crate::input::get_model_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetModelVersion {
    type Output = std::result::Result<
        crate::output::GetModelVersionOutput,
        crate::error::GetModelVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_model_version_error(response)
        } else {
            crate::operation_ser::parse_get_model_version_response(response)
        }
    }
}

/// <p>Gets one or more outcomes. This is a paginated
/// API. If you provide a null <code>maxResults</code>, this actions retrieves a maximum of
/// 100 records per page. If you provide a <code>maxResults</code>, the value must be
/// between 50 and 100. To get the next page results, provide the pagination token from the
/// <code>GetOutcomesResult</code> as part of your request. A null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOutcomes {
    _private: (),
}
impl GetOutcomes {
    /// Creates a new builder-style object to manufacture [`GetOutcomesInput`](crate::input::GetOutcomesInput)
    pub fn builder() -> crate::input::get_outcomes_input::Builder {
        crate::input::get_outcomes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOutcomes {
    type Output =
        std::result::Result<crate::output::GetOutcomesOutput, crate::error::GetOutcomesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_outcomes_error(response)
        } else {
            crate::operation_ser::parse_get_outcomes_response(response)
        }
    }
}

/// <p>Get all rules for a detector (paginated) if <code>ruleId</code> and <code>ruleVersion</code> are not specified. Gets all rules for the detector and the <code>ruleId</code> if present (paginated). Gets a specific rule if both the <code>ruleId</code> and the <code>ruleVersion</code> are specified.</p>
/// <p>This is a paginated API. Providing null maxResults results in retrieving maximum of 100 records per page. If you provide maxResults the value must be between 50 and 100. To get the next page result, a provide a pagination token from GetRulesResult as part of your request. Null pagination token fetches the records from the beginning.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRules {
    _private: (),
}
impl GetRules {
    /// Creates a new builder-style object to manufacture [`GetRulesInput`](crate::input::GetRulesInput)
    pub fn builder() -> crate::input::get_rules_input::Builder {
        crate::input::get_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRules {
    type Output = std::result::Result<crate::output::GetRulesOutput, crate::error::GetRulesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_rules_error(response)
        } else {
            crate::operation_ser::parse_get_rules_response(response)
        }
    }
}

/// <p>Gets all of the variables or the specific variable. This is a
/// paginated API. Providing null <code>maxSizePerPage</code> results in retrieving maximum of
/// 100 records per page. If you provide <code>maxSizePerPage</code> the value must be between
/// 50 and 100. To get the next page result, a provide a pagination token from
/// <code>GetVariablesResult</code> as part of your request. Null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetVariables {
    _private: (),
}
impl GetVariables {
    /// Creates a new builder-style object to manufacture [`GetVariablesInput`](crate::input::GetVariablesInput)
    pub fn builder() -> crate::input::get_variables_input::Builder {
        crate::input::get_variables_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetVariables {
    type Output =
        std::result::Result<crate::output::GetVariablesOutput, crate::error::GetVariablesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_get_variables_error(response)
        } else {
            crate::operation_ser::parse_get_variables_response(response)
        }
    }
}

/// <p>Lists all tags associated with the resource. This is a paginated API. To get the next page results, provide the pagination token from the
/// response as part of your request. A null pagination token
/// fetches the records from the beginning. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_ser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Creates or updates a detector. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDetector {
    _private: (),
}
impl PutDetector {
    /// Creates a new builder-style object to manufacture [`PutDetectorInput`](crate::input::PutDetectorInput)
    pub fn builder() -> crate::input::put_detector_input::Builder {
        crate::input::put_detector_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDetector {
    type Output =
        std::result::Result<crate::output::PutDetectorOutput, crate::error::PutDetectorError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_detector_error(response)
        } else {
            crate::operation_ser::parse_put_detector_response(response)
        }
    }
}

/// <p>Creates or updates an entity type. An entity represents who is performing the event. As part of a fraud prediction, you pass the entity ID to indicate the specific entity who performed the event. An entity type classifies the entity. Example classifications include customer, merchant, or account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEntityType {
    _private: (),
}
impl PutEntityType {
    /// Creates a new builder-style object to manufacture [`PutEntityTypeInput`](crate::input::PutEntityTypeInput)
    pub fn builder() -> crate::input::put_entity_type_input::Builder {
        crate::input::put_entity_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEntityType {
    type Output =
        std::result::Result<crate::output::PutEntityTypeOutput, crate::error::PutEntityTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_entity_type_error(response)
        } else {
            crate::operation_ser::parse_put_entity_type_response(response)
        }
    }
}

/// <p>Creates or updates an event type. An event is a business activity that is evaluated for fraud risk. With Amazon Fraud Detector, you generate fraud predictions for events. An event type defines the structure for an event sent to Amazon Fraud Detector. This includes the variables sent as part of the event, the entity performing the event (such as a customer), and the labels that classify the event. Example event types include online payment transactions, account registrations, and authentications.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEventType {
    _private: (),
}
impl PutEventType {
    /// Creates a new builder-style object to manufacture [`PutEventTypeInput`](crate::input::PutEventTypeInput)
    pub fn builder() -> crate::input::put_event_type_input::Builder {
        crate::input::put_event_type_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEventType {
    type Output =
        std::result::Result<crate::output::PutEventTypeOutput, crate::error::PutEventTypeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_event_type_error(response)
        } else {
            crate::operation_ser::parse_put_event_type_response(response)
        }
    }
}

/// <p>Creates or updates an Amazon SageMaker model endpoint. You can also use this action to update the configuration of the model endpoint, including the IAM role and/or the mapped variables.  </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutExternalModel {
    _private: (),
}
impl PutExternalModel {
    /// Creates a new builder-style object to manufacture [`PutExternalModelInput`](crate::input::PutExternalModelInput)
    pub fn builder() -> crate::input::put_external_model_input::Builder {
        crate::input::put_external_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutExternalModel {
    type Output = std::result::Result<
        crate::output::PutExternalModelOutput,
        crate::error::PutExternalModelError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_external_model_error(response)
        } else {
            crate::operation_ser::parse_put_external_model_response(response)
        }
    }
}

/// <p>Specifies the Key Management Service (KMS) customer master key (CMK) to be used to encrypt content in Amazon Fraud Detector.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutKMSEncryptionKey {
    _private: (),
}
impl PutKMSEncryptionKey {
    /// Creates a new builder-style object to manufacture [`PutKmsEncryptionKeyInput`](crate::input::PutKmsEncryptionKeyInput)
    pub fn builder() -> crate::input::put_kms_encryption_key_input::Builder {
        crate::input::put_kms_encryption_key_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutKMSEncryptionKey {
    type Output = std::result::Result<
        crate::output::PutKmsEncryptionKeyOutput,
        crate::error::PutKMSEncryptionKeyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_kms_encryption_key_error(response)
        } else {
            crate::operation_ser::parse_put_kms_encryption_key_response(response)
        }
    }
}

/// <p>Creates or updates label. A label classifies an event as fraudulent or legitimate. Labels are associated with event types and used to train supervised machine learning models in Amazon Fraud Detector. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutLabel {
    _private: (),
}
impl PutLabel {
    /// Creates a new builder-style object to manufacture [`PutLabelInput`](crate::input::PutLabelInput)
    pub fn builder() -> crate::input::put_label_input::Builder {
        crate::input::put_label_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutLabel {
    type Output = std::result::Result<crate::output::PutLabelOutput, crate::error::PutLabelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_label_error(response)
        } else {
            crate::operation_ser::parse_put_label_response(response)
        }
    }
}

/// <p>Creates or updates an outcome. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutOutcome {
    _private: (),
}
impl PutOutcome {
    /// Creates a new builder-style object to manufacture [`PutOutcomeInput`](crate::input::PutOutcomeInput)
    pub fn builder() -> crate::input::put_outcome_input::Builder {
        crate::input::put_outcome_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutOutcome {
    type Output =
        std::result::Result<crate::output::PutOutcomeOutput, crate::error::PutOutcomeError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_put_outcome_error(response)
        } else {
            crate::operation_ser::parse_put_outcome_response(response)
        }
    }
}

/// <p>Assigns tags to a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_tag_resource_error(response)
        } else {
            crate::operation_ser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_untag_resource_error(response)
        } else {
            crate::operation_ser::parse_untag_resource_response(response)
        }
    }
}

/// <p> Updates a detector version. The detector version attributes that you can update include models, external model endpoints, rules, rule execution mode, and description. You can only update a <code>DRAFT</code> detector version.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDetectorVersion {
    _private: (),
}
impl UpdateDetectorVersion {
    /// Creates a new builder-style object to manufacture [`UpdateDetectorVersionInput`](crate::input::UpdateDetectorVersionInput)
    pub fn builder() -> crate::input::update_detector_version_input::Builder {
        crate::input::update_detector_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDetectorVersion {
    type Output = std::result::Result<
        crate::output::UpdateDetectorVersionOutput,
        crate::error::UpdateDetectorVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_detector_version_error(response)
        } else {
            crate::operation_ser::parse_update_detector_version_response(response)
        }
    }
}

/// <p>Updates the detector version's description. You can update the metadata for any detector version (<code>DRAFT, ACTIVE,</code> or
/// <code>INACTIVE</code>). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDetectorVersionMetadata {
    _private: (),
}
impl UpdateDetectorVersionMetadata {
    /// Creates a new builder-style object to manufacture [`UpdateDetectorVersionMetadataInput`](crate::input::UpdateDetectorVersionMetadataInput)
    pub fn builder() -> crate::input::update_detector_version_metadata_input::Builder {
        crate::input::update_detector_version_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDetectorVersionMetadata {
    type Output = std::result::Result<
        crate::output::UpdateDetectorVersionMetadataOutput,
        crate::error::UpdateDetectorVersionMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_detector_version_metadata_error(response)
        } else {
            crate::operation_ser::parse_update_detector_version_metadata_response(response)
        }
    }
}

/// <p>Updates the detector versionâ€™s status. You can perform the following promotions or
/// demotions using <code>UpdateDetectorVersionStatus</code>: <code>DRAFT</code> to <code>ACTIVE</code>, <code>ACTIVE</code> to <code>INACTIVE</code>, and <code>INACTIVE</code> to <code>ACTIVE</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDetectorVersionStatus {
    _private: (),
}
impl UpdateDetectorVersionStatus {
    /// Creates a new builder-style object to manufacture [`UpdateDetectorVersionStatusInput`](crate::input::UpdateDetectorVersionStatusInput)
    pub fn builder() -> crate::input::update_detector_version_status_input::Builder {
        crate::input::update_detector_version_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDetectorVersionStatus {
    type Output = std::result::Result<
        crate::output::UpdateDetectorVersionStatusOutput,
        crate::error::UpdateDetectorVersionStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_detector_version_status_error(response)
        } else {
            crate::operation_ser::parse_update_detector_version_status_response(response)
        }
    }
}

/// <p>Updates a model. You can update the description attribute using this action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateModel {
    _private: (),
}
impl UpdateModel {
    /// Creates a new builder-style object to manufacture [`UpdateModelInput`](crate::input::UpdateModelInput)
    pub fn builder() -> crate::input::update_model_input::Builder {
        crate::input::update_model_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateModel {
    type Output =
        std::result::Result<crate::output::UpdateModelOutput, crate::error::UpdateModelError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_model_error(response)
        } else {
            crate::operation_ser::parse_update_model_response(response)
        }
    }
}

/// <p>Updates a model version. Updating a model version retrains an existing model version using updated training data and produces a new minor version of the model. You can update the training data set location and data access role attributes using this action. This action creates and trains a new minor version of the model, for example version 1.01, 1.02, 1.03.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateModelVersion {
    _private: (),
}
impl UpdateModelVersion {
    /// Creates a new builder-style object to manufacture [`UpdateModelVersionInput`](crate::input::UpdateModelVersionInput)
    pub fn builder() -> crate::input::update_model_version_input::Builder {
        crate::input::update_model_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateModelVersion {
    type Output = std::result::Result<
        crate::output::UpdateModelVersionOutput,
        crate::error::UpdateModelVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_model_version_error(response)
        } else {
            crate::operation_ser::parse_update_model_version_response(response)
        }
    }
}

/// <p>Updates the status of a model version.</p>
/// <p>You can perform the following status updates:</p>
/// <ol>
/// <li>
/// <p>Change the <code>TRAINING_COMPLETE</code> status to <code>ACTIVE</code>.</p>
/// </li>
/// <li>
/// <p>Change <code>ACTIVE</code>to <code>INACTIVE</code>.</p>
/// </li>
/// </ol>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateModelVersionStatus {
    _private: (),
}
impl UpdateModelVersionStatus {
    /// Creates a new builder-style object to manufacture [`UpdateModelVersionStatusInput`](crate::input::UpdateModelVersionStatusInput)
    pub fn builder() -> crate::input::update_model_version_status_input::Builder {
        crate::input::update_model_version_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateModelVersionStatus {
    type Output = std::result::Result<
        crate::output::UpdateModelVersionStatusOutput,
        crate::error::UpdateModelVersionStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_model_version_status_error(response)
        } else {
            crate::operation_ser::parse_update_model_version_status_response(response)
        }
    }
}

/// <p>Updates a rule's metadata. The description attribute can be updated.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRuleMetadata {
    _private: (),
}
impl UpdateRuleMetadata {
    /// Creates a new builder-style object to manufacture [`UpdateRuleMetadataInput`](crate::input::UpdateRuleMetadataInput)
    pub fn builder() -> crate::input::update_rule_metadata_input::Builder {
        crate::input::update_rule_metadata_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRuleMetadata {
    type Output = std::result::Result<
        crate::output::UpdateRuleMetadataOutput,
        crate::error::UpdateRuleMetadataError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_rule_metadata_error(response)
        } else {
            crate::operation_ser::parse_update_rule_metadata_response(response)
        }
    }
}

/// <p>Updates a rule version resulting in a new rule version. Updates a rule version resulting in a new rule version (version 1, 2, 3 ...). </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRuleVersion {
    _private: (),
}
impl UpdateRuleVersion {
    /// Creates a new builder-style object to manufacture [`UpdateRuleVersionInput`](crate::input::UpdateRuleVersionInput)
    pub fn builder() -> crate::input::update_rule_version_input::Builder {
        crate::input::update_rule_version_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRuleVersion {
    type Output = std::result::Result<
        crate::output::UpdateRuleVersionOutput,
        crate::error::UpdateRuleVersionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_rule_version_error(response)
        } else {
            crate::operation_ser::parse_update_rule_version_response(response)
        }
    }
}

/// <p>Updates a variable.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateVariable {
    _private: (),
}
impl UpdateVariable {
    /// Creates a new builder-style object to manufacture [`UpdateVariableInput`](crate::input::UpdateVariableInput)
    pub fn builder() -> crate::input::update_variable_input::Builder {
        crate::input::update_variable_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateVariable {
    type Output =
        std::result::Result<crate::output::UpdateVariableOutput, crate::error::UpdateVariableError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_ser::parse_update_variable_error(response)
        } else {
            crate::operation_ser::parse_update_variable_response(response)
        }
    }
}
