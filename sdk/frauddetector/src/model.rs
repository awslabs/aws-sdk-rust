// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Rule {
    /// <p>The detector for which the rule is associated.</p>
    #[doc(hidden)]
    pub detector_id: std::option::Option<std::string::String>,
    /// <p>The rule ID.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The rule version.</p>
    #[doc(hidden)]
    pub rule_version: std::option::Option<std::string::String>,
}
impl Rule {
    /// <p>The detector for which the rule is associated.</p>
    pub fn detector_id(&self) -> std::option::Option<&str> {
        self.detector_id.as_deref()
    }
    /// <p>The rule ID.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The rule version.</p>
    pub fn rule_version(&self) -> std::option::Option<&str> {
        self.rule_version.as_deref()
    }
}
impl Rule {
    /// Creates a new builder-style object to manufacture [`Rule`](crate::model::Rule).
    pub fn builder() -> crate::model::rule::Builder {
        crate::model::rule::Builder::default()
    }
}

/// See [`Rule`](crate::model::Rule).
pub mod rule {

    /// A builder for [`Rule`](crate::model::Rule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detector_id: std::option::Option<std::string::String>,
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) rule_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The detector for which the rule is associated.</p>
        pub fn detector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_id = Some(input.into());
            self
        }
        /// <p>The detector for which the rule is associated.</p>
        pub fn set_detector_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detector_id = input;
            self
        }
        /// <p>The rule ID.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The rule ID.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The rule version.</p>
        pub fn rule_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_version = Some(input.into());
            self
        }
        /// <p>The rule version.</p>
        pub fn set_rule_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_version = input;
            self
        }
        /// Consumes the builder and constructs a [`Rule`](crate::model::Rule).
        pub fn build(self) -> crate::model::Rule {
            crate::model::Rule {
                detector_id: self.detector_id,
                rule_id: self.rule_id,
                rule_version: self.rule_version,
            }
        }
    }
}

/// <p>A key and value pair. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>A tag key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>A value assigned to a tag key.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>A tag key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>A value assigned to a tag key.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A tag key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A value assigned to a tag key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A value assigned to a tag key.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// When writing a match expression against `Language`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let language = unimplemented!();
/// match language {
///     Language::Detectorpl => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `language` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Language::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Language::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Language::NewFeature` is defined.
/// Specifically, when `language` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Language::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Language {
    #[allow(missing_docs)] // documentation missing in model
    Detectorpl,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Language {
    fn from(s: &str) -> Self {
        match s {
            "DETECTORPL" => Language::Detectorpl,
            other => Language::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Language {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Language::from(s))
    }
}
impl Language {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Language::Detectorpl => "DETECTORPL",
            Language::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DETECTORPL"]
    }
}
impl AsRef<str> for Language {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ModelVersionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelversionstatus = unimplemented!();
/// match modelversionstatus {
///     ModelVersionStatus::Active => { /* ... */ },
///     ModelVersionStatus::Inactive => { /* ... */ },
///     ModelVersionStatus::TrainingCancelled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelversionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelVersionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelVersionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelVersionStatus::NewFeature` is defined.
/// Specifically, when `modelversionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelVersionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelVersionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    #[allow(missing_docs)] // documentation missing in model
    TrainingCancelled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ModelVersionStatus::Active,
            "INACTIVE" => ModelVersionStatus::Inactive,
            "TRAINING_CANCELLED" => ModelVersionStatus::TrainingCancelled,
            other => {
                ModelVersionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ModelVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelVersionStatus::from(s))
    }
}
impl ModelVersionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelVersionStatus::Active => "ACTIVE",
            ModelVersionStatus::Inactive => "INACTIVE",
            ModelVersionStatus::TrainingCancelled => "TRAINING_CANCELLED",
            ModelVersionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE", "TRAINING_CANCELLED"]
    }
}
impl AsRef<str> for ModelVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ModelTypeEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modeltypeenum = unimplemented!();
/// match modeltypeenum {
///     ModelTypeEnum::AccountTakeoverInsights => { /* ... */ },
///     ModelTypeEnum::OnlineFraudInsights => { /* ... */ },
///     ModelTypeEnum::TransactionFraudInsights => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modeltypeenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelTypeEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelTypeEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelTypeEnum::NewFeature` is defined.
/// Specifically, when `modeltypeenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelTypeEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelTypeEnum {
    #[allow(missing_docs)] // documentation missing in model
    AccountTakeoverInsights,
    #[allow(missing_docs)] // documentation missing in model
    OnlineFraudInsights,
    #[allow(missing_docs)] // documentation missing in model
    TransactionFraudInsights,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelTypeEnum {
    fn from(s: &str) -> Self {
        match s {
            "ACCOUNT_TAKEOVER_INSIGHTS" => ModelTypeEnum::AccountTakeoverInsights,
            "ONLINE_FRAUD_INSIGHTS" => ModelTypeEnum::OnlineFraudInsights,
            "TRANSACTION_FRAUD_INSIGHTS" => ModelTypeEnum::TransactionFraudInsights,
            other => ModelTypeEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ModelTypeEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelTypeEnum::from(s))
    }
}
impl ModelTypeEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelTypeEnum::AccountTakeoverInsights => "ACCOUNT_TAKEOVER_INSIGHTS",
            ModelTypeEnum::OnlineFraudInsights => "ONLINE_FRAUD_INSIGHTS",
            ModelTypeEnum::TransactionFraudInsights => "TRANSACTION_FRAUD_INSIGHTS",
            ModelTypeEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCOUNT_TAKEOVER_INSIGHTS",
            "ONLINE_FRAUD_INSIGHTS",
            "TRANSACTION_FRAUD_INSIGHTS",
        ]
    }
}
impl AsRef<str> for ModelTypeEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of the ingested event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IngestedEventsDetail {
    /// <p>The start and stop time of the ingested events.</p>
    #[doc(hidden)]
    pub ingested_events_time_window: std::option::Option<crate::model::IngestedEventsTimeWindow>,
}
impl IngestedEventsDetail {
    /// <p>The start and stop time of the ingested events.</p>
    pub fn ingested_events_time_window(
        &self,
    ) -> std::option::Option<&crate::model::IngestedEventsTimeWindow> {
        self.ingested_events_time_window.as_ref()
    }
}
impl IngestedEventsDetail {
    /// Creates a new builder-style object to manufacture [`IngestedEventsDetail`](crate::model::IngestedEventsDetail).
    pub fn builder() -> crate::model::ingested_events_detail::Builder {
        crate::model::ingested_events_detail::Builder::default()
    }
}

/// See [`IngestedEventsDetail`](crate::model::IngestedEventsDetail).
pub mod ingested_events_detail {

    /// A builder for [`IngestedEventsDetail`](crate::model::IngestedEventsDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ingested_events_time_window:
            std::option::Option<crate::model::IngestedEventsTimeWindow>,
    }
    impl Builder {
        /// <p>The start and stop time of the ingested events.</p>
        pub fn ingested_events_time_window(
            mut self,
            input: crate::model::IngestedEventsTimeWindow,
        ) -> Self {
            self.ingested_events_time_window = Some(input);
            self
        }
        /// <p>The start and stop time of the ingested events.</p>
        pub fn set_ingested_events_time_window(
            mut self,
            input: std::option::Option<crate::model::IngestedEventsTimeWindow>,
        ) -> Self {
            self.ingested_events_time_window = input;
            self
        }
        /// Consumes the builder and constructs a [`IngestedEventsDetail`](crate::model::IngestedEventsDetail).
        pub fn build(self) -> crate::model::IngestedEventsDetail {
            crate::model::IngestedEventsDetail {
                ingested_events_time_window: self.ingested_events_time_window,
            }
        }
    }
}

/// <p>The start and stop time of the ingested events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IngestedEventsTimeWindow {
    /// <p>Timestamp of the first ingensted event.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of the final ingested event.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<std::string::String>,
}
impl IngestedEventsTimeWindow {
    /// <p>Timestamp of the first ingensted event.</p>
    pub fn start_time(&self) -> std::option::Option<&str> {
        self.start_time.as_deref()
    }
    /// <p>Timestamp of the final ingested event.</p>
    pub fn end_time(&self) -> std::option::Option<&str> {
        self.end_time.as_deref()
    }
}
impl IngestedEventsTimeWindow {
    /// Creates a new builder-style object to manufacture [`IngestedEventsTimeWindow`](crate::model::IngestedEventsTimeWindow).
    pub fn builder() -> crate::model::ingested_events_time_window::Builder {
        crate::model::ingested_events_time_window::Builder::default()
    }
}

/// See [`IngestedEventsTimeWindow`](crate::model::IngestedEventsTimeWindow).
pub mod ingested_events_time_window {

    /// A builder for [`IngestedEventsTimeWindow`](crate::model::IngestedEventsTimeWindow).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<std::string::String>,
        pub(crate) end_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Timestamp of the first ingensted event.</p>
        pub fn start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time = Some(input.into());
            self
        }
        /// <p>Timestamp of the first ingensted event.</p>
        pub fn set_start_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Timestamp of the final ingested event.</p>
        pub fn end_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_time = Some(input.into());
            self
        }
        /// <p>Timestamp of the final ingested event.</p>
        pub fn set_end_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`IngestedEventsTimeWindow`](crate::model::IngestedEventsTimeWindow).
        pub fn build(self) -> crate::model::IngestedEventsTimeWindow {
            crate::model::IngestedEventsTimeWindow {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}

/// <p>Details for the external events data used for model version training.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExternalEventsDetail {
    /// <p>The Amazon S3 bucket location for the data.</p>
    #[doc(hidden)]
    pub data_location: std::option::Option<std::string::String>,
    /// <p>The ARN of the role that provides Amazon Fraud Detector access to the data location.</p>
    #[doc(hidden)]
    pub data_access_role_arn: std::option::Option<std::string::String>,
}
impl ExternalEventsDetail {
    /// <p>The Amazon S3 bucket location for the data.</p>
    pub fn data_location(&self) -> std::option::Option<&str> {
        self.data_location.as_deref()
    }
    /// <p>The ARN of the role that provides Amazon Fraud Detector access to the data location.</p>
    pub fn data_access_role_arn(&self) -> std::option::Option<&str> {
        self.data_access_role_arn.as_deref()
    }
}
impl ExternalEventsDetail {
    /// Creates a new builder-style object to manufacture [`ExternalEventsDetail`](crate::model::ExternalEventsDetail).
    pub fn builder() -> crate::model::external_events_detail::Builder {
        crate::model::external_events_detail::Builder::default()
    }
}

/// See [`ExternalEventsDetail`](crate::model::ExternalEventsDetail).
pub mod external_events_detail {

    /// A builder for [`ExternalEventsDetail`](crate::model::ExternalEventsDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_location: std::option::Option<std::string::String>,
        pub(crate) data_access_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 bucket location for the data.</p>
        pub fn data_location(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_location = Some(input.into());
            self
        }
        /// <p>The Amazon S3 bucket location for the data.</p>
        pub fn set_data_location(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_location = input;
            self
        }
        /// <p>The ARN of the role that provides Amazon Fraud Detector access to the data location.</p>
        pub fn data_access_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_access_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the role that provides Amazon Fraud Detector access to the data location.</p>
        pub fn set_data_access_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_access_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ExternalEventsDetail`](crate::model::ExternalEventsDetail).
        pub fn build(self) -> crate::model::ExternalEventsDetail {
            crate::model::ExternalEventsDetail {
                data_location: self.data_location,
                data_access_role_arn: self.data_access_role_arn,
            }
        }
    }
}

/// When writing a match expression against `DetectorVersionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let detectorversionstatus = unimplemented!();
/// match detectorversionstatus {
///     DetectorVersionStatus::Active => { /* ... */ },
///     DetectorVersionStatus::Draft => { /* ... */ },
///     DetectorVersionStatus::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `detectorversionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DetectorVersionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DetectorVersionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DetectorVersionStatus::NewFeature` is defined.
/// Specifically, when `detectorversionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DetectorVersionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DetectorVersionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DetectorVersionStatus {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => DetectorVersionStatus::Active,
            "DRAFT" => DetectorVersionStatus::Draft,
            "INACTIVE" => DetectorVersionStatus::Inactive,
            other => {
                DetectorVersionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DetectorVersionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DetectorVersionStatus::from(s))
    }
}
impl DetectorVersionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DetectorVersionStatus::Active => "ACTIVE",
            DetectorVersionStatus::Draft => "DRAFT",
            DetectorVersionStatus::Inactive => "INACTIVE",
            DetectorVersionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DRAFT", "INACTIVE"]
    }
}
impl AsRef<str> for DetectorVersionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RuleExecutionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ruleexecutionmode = unimplemented!();
/// match ruleexecutionmode {
///     RuleExecutionMode::AllMatched => { /* ... */ },
///     RuleExecutionMode::FirstMatched => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ruleexecutionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RuleExecutionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RuleExecutionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RuleExecutionMode::NewFeature` is defined.
/// Specifically, when `ruleexecutionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RuleExecutionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RuleExecutionMode {
    #[allow(missing_docs)] // documentation missing in model
    AllMatched,
    #[allow(missing_docs)] // documentation missing in model
    FirstMatched,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RuleExecutionMode {
    fn from(s: &str) -> Self {
        match s {
            "ALL_MATCHED" => RuleExecutionMode::AllMatched,
            "FIRST_MATCHED" => RuleExecutionMode::FirstMatched,
            other => {
                RuleExecutionMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for RuleExecutionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RuleExecutionMode::from(s))
    }
}
impl RuleExecutionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RuleExecutionMode::AllMatched => "ALL_MATCHED",
            RuleExecutionMode::FirstMatched => "FIRST_MATCHED",
            RuleExecutionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALL_MATCHED", "FIRST_MATCHED"]
    }
}
impl AsRef<str> for RuleExecutionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The model version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelVersion {
    /// <p>The model ID.</p>
    #[doc(hidden)]
    pub model_id: std::option::Option<std::string::String>,
    /// <p>The model type.</p>
    #[doc(hidden)]
    pub model_type: std::option::Option<crate::model::ModelTypeEnum>,
    /// <p>The model version number.</p>
    #[doc(hidden)]
    pub model_version_number: std::option::Option<std::string::String>,
    /// <p>The model version ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl ModelVersion {
    /// <p>The model ID.</p>
    pub fn model_id(&self) -> std::option::Option<&str> {
        self.model_id.as_deref()
    }
    /// <p>The model type.</p>
    pub fn model_type(&self) -> std::option::Option<&crate::model::ModelTypeEnum> {
        self.model_type.as_ref()
    }
    /// <p>The model version number.</p>
    pub fn model_version_number(&self) -> std::option::Option<&str> {
        self.model_version_number.as_deref()
    }
    /// <p>The model version ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl ModelVersion {
    /// Creates a new builder-style object to manufacture [`ModelVersion`](crate::model::ModelVersion).
    pub fn builder() -> crate::model::model_version::Builder {
        crate::model::model_version::Builder::default()
    }
}

/// See [`ModelVersion`](crate::model::ModelVersion).
pub mod model_version {

    /// A builder for [`ModelVersion`](crate::model::ModelVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_id: std::option::Option<std::string::String>,
        pub(crate) model_type: std::option::Option<crate::model::ModelTypeEnum>,
        pub(crate) model_version_number: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The model ID.</p>
        pub fn model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_id = Some(input.into());
            self
        }
        /// <p>The model ID.</p>
        pub fn set_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_id = input;
            self
        }
        /// <p>The model type.</p>
        pub fn model_type(mut self, input: crate::model::ModelTypeEnum) -> Self {
            self.model_type = Some(input);
            self
        }
        /// <p>The model type.</p>
        pub fn set_model_type(
            mut self,
            input: std::option::Option<crate::model::ModelTypeEnum>,
        ) -> Self {
            self.model_type = input;
            self
        }
        /// <p>The model version number.</p>
        pub fn model_version_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version_number = Some(input.into());
            self
        }
        /// <p>The model version number.</p>
        pub fn set_model_version_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version_number = input;
            self
        }
        /// <p>The model version ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The model version ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelVersion`](crate::model::ModelVersion).
        pub fn build(self) -> crate::model::ModelVersion {
            crate::model::ModelVersion {
                model_id: self.model_id,
                model_type: self.model_type,
                model_version_number: self.model_version_number,
                arn: self.arn,
            }
        }
    }
}

/// <p>The entity details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Entity {
    /// <p>The entity type.</p>
    #[doc(hidden)]
    pub entity_type: std::option::Option<std::string::String>,
    /// <p>The entity ID. If you do not know the <code>entityId</code>, you can pass <code>unknown</code>, which is areserved string literal.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
}
impl Entity {
    /// <p>The entity type.</p>
    pub fn entity_type(&self) -> std::option::Option<&str> {
        self.entity_type.as_deref()
    }
    /// <p>The entity ID. If you do not know the <code>entityId</code>, you can pass <code>unknown</code>, which is areserved string literal.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
}
impl std::fmt::Debug for Entity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Entity");
        formatter.field("entity_type", &"*** Sensitive Data Redacted ***");
        formatter.field("entity_id", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl Entity {
    /// Creates a new builder-style object to manufacture [`Entity`](crate::model::Entity).
    pub fn builder() -> crate::model::entity::Builder {
        crate::model::entity::Builder::default()
    }
}

/// See [`Entity`](crate::model::Entity).
pub mod entity {

    /// A builder for [`Entity`](crate::model::Entity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) entity_type: std::option::Option<std::string::String>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The entity type.</p>
        pub fn entity_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_type = Some(input.into());
            self
        }
        /// <p>The entity type.</p>
        pub fn set_entity_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_type = input;
            self
        }
        /// <p>The entity ID. If you do not know the <code>entityId</code>, you can pass <code>unknown</code>, which is areserved string literal.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The entity ID. If you do not know the <code>entityId</code>, you can pass <code>unknown</code>, which is areserved string literal.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Entity`](crate::model::Entity).
        pub fn build(self) -> crate::model::Entity {
            crate::model::Entity {
                entity_type: self.entity_type,
                entity_id: self.entity_id,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("entity_type", &"*** Sensitive Data Redacted ***");
            formatter.field("entity_id", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// When writing a match expression against `ModelEndpointStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelendpointstatus = unimplemented!();
/// match modelendpointstatus {
///     ModelEndpointStatus::Associated => { /* ... */ },
///     ModelEndpointStatus::Dissociated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelendpointstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelEndpointStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelEndpointStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelEndpointStatus::NewFeature` is defined.
/// Specifically, when `modelendpointstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelEndpointStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelEndpointStatus {
    #[allow(missing_docs)] // documentation missing in model
    Associated,
    #[allow(missing_docs)] // documentation missing in model
    Dissociated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelEndpointStatus {
    fn from(s: &str) -> Self {
        match s {
            "ASSOCIATED" => ModelEndpointStatus::Associated,
            "DISSOCIATED" => ModelEndpointStatus::Dissociated,
            other => {
                ModelEndpointStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ModelEndpointStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelEndpointStatus::from(s))
    }
}
impl ModelEndpointStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelEndpointStatus::Associated => "ASSOCIATED",
            ModelEndpointStatus::Dissociated => "DISSOCIATED",
            ModelEndpointStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ASSOCIATED", "DISSOCIATED"]
    }
}
impl AsRef<str> for ModelEndpointStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides the Amazon Sagemaker model output configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelOutputConfiguration {
    /// <p>The format of the model output configuration.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::ModelOutputDataFormat>,
    /// <p>A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables. </p>
    #[doc(hidden)]
    pub json_key_to_variable_map:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables. </p>
    #[doc(hidden)]
    pub csv_index_to_variable_map:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ModelOutputConfiguration {
    /// <p>The format of the model output configuration.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::ModelOutputDataFormat> {
        self.format.as_ref()
    }
    /// <p>A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables. </p>
    pub fn json_key_to_variable_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.json_key_to_variable_map.as_ref()
    }
    /// <p>A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables. </p>
    pub fn csv_index_to_variable_map(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.csv_index_to_variable_map.as_ref()
    }
}
impl ModelOutputConfiguration {
    /// Creates a new builder-style object to manufacture [`ModelOutputConfiguration`](crate::model::ModelOutputConfiguration).
    pub fn builder() -> crate::model::model_output_configuration::Builder {
        crate::model::model_output_configuration::Builder::default()
    }
}

/// See [`ModelOutputConfiguration`](crate::model::ModelOutputConfiguration).
pub mod model_output_configuration {

    /// A builder for [`ModelOutputConfiguration`](crate::model::ModelOutputConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) format: std::option::Option<crate::model::ModelOutputDataFormat>,
        pub(crate) json_key_to_variable_map: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) csv_index_to_variable_map: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The format of the model output configuration.</p>
        pub fn format(mut self, input: crate::model::ModelOutputDataFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The format of the model output configuration.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::ModelOutputDataFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// Adds a key-value pair to `json_key_to_variable_map`.
        ///
        /// To override the contents of this collection use [`set_json_key_to_variable_map`](Self::set_json_key_to_variable_map).
        ///
        /// <p>A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables. </p>
        pub fn json_key_to_variable_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.json_key_to_variable_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.json_key_to_variable_map = Some(hash_map);
            self
        }
        /// <p>A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables. </p>
        pub fn set_json_key_to_variable_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.json_key_to_variable_map = input;
            self
        }
        /// Adds a key-value pair to `csv_index_to_variable_map`.
        ///
        /// To override the contents of this collection use [`set_csv_index_to_variable_map`](Self::set_csv_index_to_variable_map).
        ///
        /// <p>A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables. </p>
        pub fn csv_index_to_variable_map(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.csv_index_to_variable_map.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.csv_index_to_variable_map = Some(hash_map);
            self
        }
        /// <p>A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables. </p>
        pub fn set_csv_index_to_variable_map(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.csv_index_to_variable_map = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelOutputConfiguration`](crate::model::ModelOutputConfiguration).
        pub fn build(self) -> crate::model::ModelOutputConfiguration {
            crate::model::ModelOutputConfiguration {
                format: self.format,
                json_key_to_variable_map: self.json_key_to_variable_map,
                csv_index_to_variable_map: self.csv_index_to_variable_map,
            }
        }
    }
}

/// When writing a match expression against `ModelOutputDataFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modeloutputdataformat = unimplemented!();
/// match modeloutputdataformat {
///     ModelOutputDataFormat::Jsonlines => { /* ... */ },
///     ModelOutputDataFormat::Csv => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modeloutputdataformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelOutputDataFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelOutputDataFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelOutputDataFormat::NewFeature` is defined.
/// Specifically, when `modeloutputdataformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelOutputDataFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelOutputDataFormat {
    #[allow(missing_docs)] // documentation missing in model
    Jsonlines,
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelOutputDataFormat {
    fn from(s: &str) -> Self {
        match s {
            "APPLICATION_JSONLINES" => ModelOutputDataFormat::Jsonlines,
            "TEXT_CSV" => ModelOutputDataFormat::Csv,
            other => {
                ModelOutputDataFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ModelOutputDataFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelOutputDataFormat::from(s))
    }
}
impl ModelOutputDataFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelOutputDataFormat::Jsonlines => "APPLICATION_JSONLINES",
            ModelOutputDataFormat::Csv => "TEXT_CSV",
            ModelOutputDataFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPLICATION_JSONLINES", "TEXT_CSV"]
    }
}
impl AsRef<str> for ModelOutputDataFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The Amazon SageMaker model input configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelInputConfiguration {
    /// <p>The event type name.</p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p> The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.</p>
    #[doc(hidden)]
    pub format: std::option::Option<crate::model::ModelInputDataFormat>,
    /// <p>The event variables.</p>
    #[doc(hidden)]
    pub use_event_variables: std::option::Option<bool>,
    /// <p> Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker. </p>
    #[doc(hidden)]
    pub json_input_template: std::option::Option<std::string::String>,
    /// <p> Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker. </p>
    #[doc(hidden)]
    pub csv_input_template: std::option::Option<std::string::String>,
}
impl ModelInputConfiguration {
    /// <p>The event type name.</p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p> The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.</p>
    pub fn format(&self) -> std::option::Option<&crate::model::ModelInputDataFormat> {
        self.format.as_ref()
    }
    /// <p>The event variables.</p>
    pub fn use_event_variables(&self) -> std::option::Option<bool> {
        self.use_event_variables
    }
    /// <p> Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker. </p>
    pub fn json_input_template(&self) -> std::option::Option<&str> {
        self.json_input_template.as_deref()
    }
    /// <p> Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker. </p>
    pub fn csv_input_template(&self) -> std::option::Option<&str> {
        self.csv_input_template.as_deref()
    }
}
impl ModelInputConfiguration {
    /// Creates a new builder-style object to manufacture [`ModelInputConfiguration`](crate::model::ModelInputConfiguration).
    pub fn builder() -> crate::model::model_input_configuration::Builder {
        crate::model::model_input_configuration::Builder::default()
    }
}

/// See [`ModelInputConfiguration`](crate::model::ModelInputConfiguration).
pub mod model_input_configuration {

    /// A builder for [`ModelInputConfiguration`](crate::model::ModelInputConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::ModelInputDataFormat>,
        pub(crate) use_event_variables: std::option::Option<bool>,
        pub(crate) json_input_template: std::option::Option<std::string::String>,
        pub(crate) csv_input_template: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The event type name.</p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p>The event type name.</p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p> The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.</p>
        pub fn format(mut self, input: crate::model::ModelInputDataFormat) -> Self {
            self.format = Some(input);
            self
        }
        /// <p> The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.</p>
        pub fn set_format(
            mut self,
            input: std::option::Option<crate::model::ModelInputDataFormat>,
        ) -> Self {
            self.format = input;
            self
        }
        /// <p>The event variables.</p>
        pub fn use_event_variables(mut self, input: bool) -> Self {
            self.use_event_variables = Some(input);
            self
        }
        /// <p>The event variables.</p>
        pub fn set_use_event_variables(mut self, input: std::option::Option<bool>) -> Self {
            self.use_event_variables = input;
            self
        }
        /// <p> Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker. </p>
        pub fn json_input_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_input_template = Some(input.into());
            self
        }
        /// <p> Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker. </p>
        pub fn set_json_input_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.json_input_template = input;
            self
        }
        /// <p> Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker. </p>
        pub fn csv_input_template(mut self, input: impl Into<std::string::String>) -> Self {
            self.csv_input_template = Some(input.into());
            self
        }
        /// <p> Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker. </p>
        pub fn set_csv_input_template(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.csv_input_template = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelInputConfiguration`](crate::model::ModelInputConfiguration).
        pub fn build(self) -> crate::model::ModelInputConfiguration {
            crate::model::ModelInputConfiguration {
                event_type_name: self.event_type_name,
                format: self.format,
                use_event_variables: self.use_event_variables,
                json_input_template: self.json_input_template,
                csv_input_template: self.csv_input_template,
            }
        }
    }
}

/// When writing a match expression against `ModelInputDataFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelinputdataformat = unimplemented!();
/// match modelinputdataformat {
///     ModelInputDataFormat::Json => { /* ... */ },
///     ModelInputDataFormat::Csv => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelinputdataformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelInputDataFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelInputDataFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelInputDataFormat::NewFeature` is defined.
/// Specifically, when `modelinputdataformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelInputDataFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelInputDataFormat {
    #[allow(missing_docs)] // documentation missing in model
    Json,
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelInputDataFormat {
    fn from(s: &str) -> Self {
        match s {
            "APPLICATION_JSON" => ModelInputDataFormat::Json,
            "TEXT_CSV" => ModelInputDataFormat::Csv,
            other => {
                ModelInputDataFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ModelInputDataFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelInputDataFormat::from(s))
    }
}
impl ModelInputDataFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelInputDataFormat::Json => "APPLICATION_JSON",
            ModelInputDataFormat::Csv => "TEXT_CSV",
            ModelInputDataFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPLICATION_JSON", "TEXT_CSV"]
    }
}
impl AsRef<str> for ModelInputDataFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ModelSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modelsource = unimplemented!();
/// match modelsource {
///     ModelSource::Sagemaker => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modelsource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModelSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModelSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModelSource::NewFeature` is defined.
/// Specifically, when `modelsource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModelSource::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModelSource {
    #[allow(missing_docs)] // documentation missing in model
    Sagemaker,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModelSource {
    fn from(s: &str) -> Self {
        match s {
            "SAGEMAKER" => ModelSource::Sagemaker,
            other => ModelSource::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ModelSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModelSource::from(s))
    }
}
impl ModelSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModelSource::Sagemaker => "SAGEMAKER",
            ModelSource::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SAGEMAKER"]
    }
}
impl AsRef<str> for ModelSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EventIngestion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventingestion = unimplemented!();
/// match eventingestion {
///     EventIngestion::Disabled => { /* ... */ },
///     EventIngestion::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventingestion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventIngestion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventIngestion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventIngestion::NewFeature` is defined.
/// Specifically, when `eventingestion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventIngestion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventIngestion {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventIngestion {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => EventIngestion::Disabled,
            "ENABLED" => EventIngestion::Enabled,
            other => EventIngestion::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EventIngestion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventIngestion::from(s))
    }
}
impl EventIngestion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventIngestion::Disabled => "DISABLED",
            EventIngestion::Enabled => "ENABLED",
            EventIngestion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for EventIngestion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> Information about the summary of an event prediction. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventPredictionSummary {
    /// <p> The event ID. </p>
    #[doc(hidden)]
    pub event_id: std::option::Option<std::string::String>,
    /// <p> The event type. </p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p> The timestamp of the event. </p>
    #[doc(hidden)]
    pub event_timestamp: std::option::Option<std::string::String>,
    /// <p> The timestamp when the prediction was generated. </p>
    #[doc(hidden)]
    pub prediction_timestamp: std::option::Option<std::string::String>,
    /// <p> The detector ID. </p>
    #[doc(hidden)]
    pub detector_id: std::option::Option<std::string::String>,
    /// <p> The detector version ID. </p>
    #[doc(hidden)]
    pub detector_version_id: std::option::Option<std::string::String>,
}
impl EventPredictionSummary {
    /// <p> The event ID. </p>
    pub fn event_id(&self) -> std::option::Option<&str> {
        self.event_id.as_deref()
    }
    /// <p> The event type. </p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p> The timestamp of the event. </p>
    pub fn event_timestamp(&self) -> std::option::Option<&str> {
        self.event_timestamp.as_deref()
    }
    /// <p> The timestamp when the prediction was generated. </p>
    pub fn prediction_timestamp(&self) -> std::option::Option<&str> {
        self.prediction_timestamp.as_deref()
    }
    /// <p> The detector ID. </p>
    pub fn detector_id(&self) -> std::option::Option<&str> {
        self.detector_id.as_deref()
    }
    /// <p> The detector version ID. </p>
    pub fn detector_version_id(&self) -> std::option::Option<&str> {
        self.detector_version_id.as_deref()
    }
}
impl EventPredictionSummary {
    /// Creates a new builder-style object to manufacture [`EventPredictionSummary`](crate::model::EventPredictionSummary).
    pub fn builder() -> crate::model::event_prediction_summary::Builder {
        crate::model::event_prediction_summary::Builder::default()
    }
}

/// See [`EventPredictionSummary`](crate::model::EventPredictionSummary).
pub mod event_prediction_summary {

    /// A builder for [`EventPredictionSummary`](crate::model::EventPredictionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) event_timestamp: std::option::Option<std::string::String>,
        pub(crate) prediction_timestamp: std::option::Option<std::string::String>,
        pub(crate) detector_id: std::option::Option<std::string::String>,
        pub(crate) detector_version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The event ID. </p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p> The event ID. </p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p> The event type. </p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p> The event type. </p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p> The timestamp of the event. </p>
        pub fn event_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_timestamp = Some(input.into());
            self
        }
        /// <p> The timestamp of the event. </p>
        pub fn set_event_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_timestamp = input;
            self
        }
        /// <p> The timestamp when the prediction was generated. </p>
        pub fn prediction_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.prediction_timestamp = Some(input.into());
            self
        }
        /// <p> The timestamp when the prediction was generated. </p>
        pub fn set_prediction_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.prediction_timestamp = input;
            self
        }
        /// <p> The detector ID. </p>
        pub fn detector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_id = Some(input.into());
            self
        }
        /// <p> The detector ID. </p>
        pub fn set_detector_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detector_id = input;
            self
        }
        /// <p> The detector version ID. </p>
        pub fn detector_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_version_id = Some(input.into());
            self
        }
        /// <p> The detector version ID. </p>
        pub fn set_detector_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detector_version_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EventPredictionSummary`](crate::model::EventPredictionSummary).
        pub fn build(self) -> crate::model::EventPredictionSummary {
            crate::model::EventPredictionSummary {
                event_id: self.event_id,
                event_type_name: self.event_type_name,
                event_timestamp: self.event_timestamp,
                prediction_timestamp: self.prediction_timestamp,
                detector_id: self.detector_id,
                detector_version_id: self.detector_version_id,
            }
        }
    }
}

/// <p> The time period for when the predictions were generated. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictionTimeRange {
    /// <p> The start time of the time period for when the predictions were generated. </p>
    #[doc(hidden)]
    pub start_time: std::option::Option<std::string::String>,
    /// <p> The end time of the time period for when the predictions were generated. </p>
    #[doc(hidden)]
    pub end_time: std::option::Option<std::string::String>,
}
impl PredictionTimeRange {
    /// <p> The start time of the time period for when the predictions were generated. </p>
    pub fn start_time(&self) -> std::option::Option<&str> {
        self.start_time.as_deref()
    }
    /// <p> The end time of the time period for when the predictions were generated. </p>
    pub fn end_time(&self) -> std::option::Option<&str> {
        self.end_time.as_deref()
    }
}
impl PredictionTimeRange {
    /// Creates a new builder-style object to manufacture [`PredictionTimeRange`](crate::model::PredictionTimeRange).
    pub fn builder() -> crate::model::prediction_time_range::Builder {
        crate::model::prediction_time_range::Builder::default()
    }
}

/// See [`PredictionTimeRange`](crate::model::PredictionTimeRange).
pub mod prediction_time_range {

    /// A builder for [`PredictionTimeRange`](crate::model::PredictionTimeRange).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<std::string::String>,
        pub(crate) end_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The start time of the time period for when the predictions were generated. </p>
        pub fn start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time = Some(input.into());
            self
        }
        /// <p> The start time of the time period for when the predictions were generated. </p>
        pub fn set_start_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_time = input;
            self
        }
        /// <p> The end time of the time period for when the predictions were generated. </p>
        pub fn end_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_time = Some(input.into());
            self
        }
        /// <p> The end time of the time period for when the predictions were generated. </p>
        pub fn set_end_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictionTimeRange`](crate::model::PredictionTimeRange).
        pub fn build(self) -> crate::model::PredictionTimeRange {
            crate::model::PredictionTimeRange {
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}

/// <p> A conditional statement for filtering a list of past predictions. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilterCondition {
    /// <p> A statement containing a resource property and a value to specify filter condition. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl FilterCondition {
    /// <p> A statement containing a resource property and a value to specify filter condition. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl FilterCondition {
    /// Creates a new builder-style object to manufacture [`FilterCondition`](crate::model::FilterCondition).
    pub fn builder() -> crate::model::filter_condition::Builder {
        crate::model::filter_condition::Builder::default()
    }
}

/// See [`FilterCondition`](crate::model::FilterCondition).
pub mod filter_condition {

    /// A builder for [`FilterCondition`](crate::model::FilterCondition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> A statement containing a resource property and a value to specify filter condition. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> A statement containing a resource property and a value to specify filter condition. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FilterCondition`](crate::model::FilterCondition).
        pub fn build(self) -> crate::model::FilterCondition {
            crate::model::FilterCondition { value: self.value }
        }
    }
}

/// <p>The variable.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Variable {
    /// <p>The name of the variable.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::DataType>,
    /// <p>The data source of the variable.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<crate::model::DataSource>,
    /// <p>The default value of the variable.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The description of the variable. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The variable type of the variable.</p>
    /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
    #[doc(hidden)]
    pub variable_type: std::option::Option<std::string::String>,
    /// <p>The time when variable was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>The time when the variable was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The ARN of the variable.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl Variable {
    /// <p>The name of the variable.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    pub fn data_type(&self) -> std::option::Option<&crate::model::DataType> {
        self.data_type.as_ref()
    }
    /// <p>The data source of the variable.</p>
    pub fn data_source(&self) -> std::option::Option<&crate::model::DataSource> {
        self.data_source.as_ref()
    }
    /// <p>The default value of the variable.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p>The description of the variable. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The variable type of the variable.</p>
    /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
    pub fn variable_type(&self) -> std::option::Option<&str> {
        self.variable_type.as_deref()
    }
    /// <p>The time when variable was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>The time when the variable was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The ARN of the variable.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl Variable {
    /// Creates a new builder-style object to manufacture [`Variable`](crate::model::Variable).
    pub fn builder() -> crate::model::variable::Builder {
        crate::model::variable::Builder::default()
    }
}

/// See [`Variable`](crate::model::Variable).
pub mod variable {

    /// A builder for [`Variable`](crate::model::Variable).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<crate::model::DataType>,
        pub(crate) data_source: std::option::Option<crate::model::DataSource>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) variable_type: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the variable.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the variable.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
        pub fn data_type(mut self, input: crate::model::DataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>The data type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
        pub fn set_data_type(mut self, input: std::option::Option<crate::model::DataType>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data source of the variable.</p>
        pub fn data_source(mut self, input: crate::model::DataSource) -> Self {
            self.data_source = Some(input);
            self
        }
        /// <p>The data source of the variable.</p>
        pub fn set_data_source(
            mut self,
            input: std::option::Option<crate::model::DataSource>,
        ) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The default value of the variable.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value of the variable.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The description of the variable. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the variable. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The variable type of the variable.</p>
        /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
        pub fn variable_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.variable_type = Some(input.into());
            self
        }
        /// <p>The variable type of the variable.</p>
        /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
        pub fn set_variable_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.variable_type = input;
            self
        }
        /// <p>The time when variable was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>The time when variable was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The time when the variable was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The time when the variable was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The ARN of the variable.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the variable.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Variable`](crate::model::Variable).
        pub fn build(self) -> crate::model::Variable {
            crate::model::Variable {
                name: self.name,
                data_type: self.data_type,
                data_source: self.data_source,
                default_value: self.default_value,
                description: self.description,
                variable_type: self.variable_type,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
}

/// When writing a match expression against `DataSource`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasource = unimplemented!();
/// match datasource {
///     DataSource::Event => { /* ... */ },
///     DataSource::ExternalModelScore => { /* ... */ },
///     DataSource::ModelScore => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasource` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataSource::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataSource::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataSource::NewFeature` is defined.
/// Specifically, when `datasource` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataSource::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataSource {
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    ExternalModelScore,
    #[allow(missing_docs)] // documentation missing in model
    ModelScore,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataSource {
    fn from(s: &str) -> Self {
        match s {
            "EVENT" => DataSource::Event,
            "EXTERNAL_MODEL_SCORE" => DataSource::ExternalModelScore,
            "MODEL_SCORE" => DataSource::ModelScore,
            other => DataSource::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataSource {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataSource::from(s))
    }
}
impl DataSource {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataSource::Event => "EVENT",
            DataSource::ExternalModelScore => "EXTERNAL_MODEL_SCORE",
            DataSource::ModelScore => "MODEL_SCORE",
            DataSource::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EVENT", "EXTERNAL_MODEL_SCORE", "MODEL_SCORE"]
    }
}
impl AsRef<str> for DataSource {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datatype = unimplemented!();
/// match datatype {
///     DataType::Boolean => { /* ... */ },
///     DataType::Float => { /* ... */ },
///     DataType::Integer => { /* ... */ },
///     DataType::String => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataType::NewFeature` is defined.
/// Specifically, when `datatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataType {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    String,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataType {
    fn from(s: &str) -> Self {
        match s {
            "BOOLEAN" => DataType::Boolean,
            "FLOAT" => DataType::Float,
            "INTEGER" => DataType::Integer,
            "STRING" => DataType::String,
            other => DataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataType::from(s))
    }
}
impl DataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataType::Boolean => "BOOLEAN",
            DataType::Float => "FLOAT",
            DataType::Integer => "INTEGER",
            DataType::String => "STRING",
            DataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["BOOLEAN", "FLOAT", "INTEGER", "STRING"]
    }
}
impl AsRef<str> for DataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of the rule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RuleDetail {
    /// <p>The rule ID.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The detector for which the rule is associated.</p>
    #[doc(hidden)]
    pub detector_id: std::option::Option<std::string::String>,
    /// <p>The rule version.</p>
    #[doc(hidden)]
    pub rule_version: std::option::Option<std::string::String>,
    /// <p>The rule expression.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>The rule language.</p>
    #[doc(hidden)]
    pub language: std::option::Option<crate::model::Language>,
    /// <p>The rule outcomes.</p>
    #[doc(hidden)]
    pub outcomes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Timestamp of the last time the rule was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>The timestamp of when the rule was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The rule ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl RuleDetail {
    /// <p>The rule ID.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The detector for which the rule is associated.</p>
    pub fn detector_id(&self) -> std::option::Option<&str> {
        self.detector_id.as_deref()
    }
    /// <p>The rule version.</p>
    pub fn rule_version(&self) -> std::option::Option<&str> {
        self.rule_version.as_deref()
    }
    /// <p>The rule expression.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The rule language.</p>
    pub fn language(&self) -> std::option::Option<&crate::model::Language> {
        self.language.as_ref()
    }
    /// <p>The rule outcomes.</p>
    pub fn outcomes(&self) -> std::option::Option<&[std::string::String]> {
        self.outcomes.as_deref()
    }
    /// <p>Timestamp of the last time the rule was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>The timestamp of when the rule was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The rule ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for RuleDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RuleDetail");
        formatter.field("rule_id", &self.rule_id);
        formatter.field("description", &self.description);
        formatter.field("detector_id", &self.detector_id);
        formatter.field("rule_version", &self.rule_version);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("language", &self.language);
        formatter.field("outcomes", &self.outcomes);
        formatter.field("last_updated_time", &self.last_updated_time);
        formatter.field("created_time", &self.created_time);
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
impl RuleDetail {
    /// Creates a new builder-style object to manufacture [`RuleDetail`](crate::model::RuleDetail).
    pub fn builder() -> crate::model::rule_detail::Builder {
        crate::model::rule_detail::Builder::default()
    }
}

/// See [`RuleDetail`](crate::model::RuleDetail).
pub mod rule_detail {

    /// A builder for [`RuleDetail`](crate::model::RuleDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) detector_id: std::option::Option<std::string::String>,
        pub(crate) rule_version: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) language: std::option::Option<crate::model::Language>,
        pub(crate) outcomes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The rule ID.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The rule ID.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p>The rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The detector for which the rule is associated.</p>
        pub fn detector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_id = Some(input.into());
            self
        }
        /// <p>The detector for which the rule is associated.</p>
        pub fn set_detector_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detector_id = input;
            self
        }
        /// <p>The rule version.</p>
        pub fn rule_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_version = Some(input.into());
            self
        }
        /// <p>The rule version.</p>
        pub fn set_rule_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_version = input;
            self
        }
        /// <p>The rule expression.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The rule expression.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The rule language.</p>
        pub fn language(mut self, input: crate::model::Language) -> Self {
            self.language = Some(input);
            self
        }
        /// <p>The rule language.</p>
        pub fn set_language(mut self, input: std::option::Option<crate::model::Language>) -> Self {
            self.language = input;
            self
        }
        /// Appends an item to `outcomes`.
        ///
        /// To override the contents of this collection use [`set_outcomes`](Self::set_outcomes).
        ///
        /// <p>The rule outcomes.</p>
        pub fn outcomes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.outcomes.unwrap_or_default();
            v.push(input.into());
            self.outcomes = Some(v);
            self
        }
        /// <p>The rule outcomes.</p>
        pub fn set_outcomes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.outcomes = input;
            self
        }
        /// <p>Timestamp of the last time the rule was updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of the last time the rule was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The timestamp of when the rule was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The timestamp of when the rule was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The rule ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The rule ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleDetail`](crate::model::RuleDetail).
        pub fn build(self) -> crate::model::RuleDetail {
            crate::model::RuleDetail {
                rule_id: self.rule_id,
                description: self.description,
                detector_id: self.detector_id,
                rule_version: self.rule_version,
                expression: self.expression,
                language: self.language,
                outcomes: self.outcomes,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("rule_id", &self.rule_id);
            formatter.field("description", &self.description);
            formatter.field("detector_id", &self.detector_id);
            formatter.field("rule_version", &self.rule_version);
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("language", &self.language);
            formatter.field("outcomes", &self.outcomes);
            formatter.field("last_updated_time", &self.last_updated_time);
            formatter.field("created_time", &self.created_time);
            formatter.field("arn", &self.arn);
            formatter.finish()
        }
    }
}

/// <p>The outcome.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Outcome {
    /// <p>The outcome name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The outcome description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The timestamp when the outcome was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>The timestamp when the outcome was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The outcome ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl Outcome {
    /// <p>The outcome name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The outcome description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The timestamp when the outcome was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>The timestamp when the outcome was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The outcome ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl Outcome {
    /// Creates a new builder-style object to manufacture [`Outcome`](crate::model::Outcome).
    pub fn builder() -> crate::model::outcome::Builder {
        crate::model::outcome::Builder::default()
    }
}

/// See [`Outcome`](crate::model::Outcome).
pub mod outcome {

    /// A builder for [`Outcome`](crate::model::Outcome).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The outcome name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The outcome name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The outcome description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The outcome description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The timestamp when the outcome was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>The timestamp when the outcome was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The timestamp when the outcome was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The timestamp when the outcome was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The outcome ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The outcome ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Outcome`](crate::model::Outcome).
        pub fn build(self) -> crate::model::Outcome {
            crate::model::Outcome {
                name: self.name,
                description: self.description,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
}

/// <p>The training data schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrainingDataSchema {
    /// <p>The training data schema variables.</p>
    #[doc(hidden)]
    pub model_variables: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The label schema.</p>
    #[doc(hidden)]
    pub label_schema: std::option::Option<crate::model::LabelSchema>,
}
impl TrainingDataSchema {
    /// <p>The training data schema variables.</p>
    pub fn model_variables(&self) -> std::option::Option<&[std::string::String]> {
        self.model_variables.as_deref()
    }
    /// <p>The label schema.</p>
    pub fn label_schema(&self) -> std::option::Option<&crate::model::LabelSchema> {
        self.label_schema.as_ref()
    }
}
impl TrainingDataSchema {
    /// Creates a new builder-style object to manufacture [`TrainingDataSchema`](crate::model::TrainingDataSchema).
    pub fn builder() -> crate::model::training_data_schema::Builder {
        crate::model::training_data_schema::Builder::default()
    }
}

/// See [`TrainingDataSchema`](crate::model::TrainingDataSchema).
pub mod training_data_schema {

    /// A builder for [`TrainingDataSchema`](crate::model::TrainingDataSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_variables: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) label_schema: std::option::Option<crate::model::LabelSchema>,
    }
    impl Builder {
        /// Appends an item to `model_variables`.
        ///
        /// To override the contents of this collection use [`set_model_variables`](Self::set_model_variables).
        ///
        /// <p>The training data schema variables.</p>
        pub fn model_variables(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.model_variables.unwrap_or_default();
            v.push(input.into());
            self.model_variables = Some(v);
            self
        }
        /// <p>The training data schema variables.</p>
        pub fn set_model_variables(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.model_variables = input;
            self
        }
        /// <p>The label schema.</p>
        pub fn label_schema(mut self, input: crate::model::LabelSchema) -> Self {
            self.label_schema = Some(input);
            self
        }
        /// <p>The label schema.</p>
        pub fn set_label_schema(
            mut self,
            input: std::option::Option<crate::model::LabelSchema>,
        ) -> Self {
            self.label_schema = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingDataSchema`](crate::model::TrainingDataSchema).
        pub fn build(self) -> crate::model::TrainingDataSchema {
            crate::model::TrainingDataSchema {
                model_variables: self.model_variables,
                label_schema: self.label_schema,
            }
        }
    }
}

/// <p>The label schema.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LabelSchema {
    /// <p>The label mapper maps the Amazon Fraud Detector supported model classification labels (<code>FRAUD</code>, <code>LEGIT</code>) to the appropriate event type labels. For example, if "<code>FRAUD</code>" and "<code>LEGIT</code>" are Amazon Fraud Detector supported labels, this mapper could be: <code>{"FRAUD" =&gt; ["0"]</code>, <code>"LEGIT" =&gt; ["1"]}</code> or <code>{"FRAUD" =&gt; ["false"]</code>, <code>"LEGIT" =&gt; ["true"]}</code> or <code>{"FRAUD" =&gt; ["fraud", "abuse"]</code>, <code>"LEGIT" =&gt; ["legit", "safe"]}</code>. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label. </p>
    #[doc(hidden)]
    pub label_mapper: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The action to take for unlabeled events.</p>
    #[doc(hidden)]
    pub unlabeled_events_treatment: std::option::Option<crate::model::UnlabeledEventsTreatment>,
}
impl LabelSchema {
    /// <p>The label mapper maps the Amazon Fraud Detector supported model classification labels (<code>FRAUD</code>, <code>LEGIT</code>) to the appropriate event type labels. For example, if "<code>FRAUD</code>" and "<code>LEGIT</code>" are Amazon Fraud Detector supported labels, this mapper could be: <code>{"FRAUD" =&gt; ["0"]</code>, <code>"LEGIT" =&gt; ["1"]}</code> or <code>{"FRAUD" =&gt; ["false"]</code>, <code>"LEGIT" =&gt; ["true"]}</code> or <code>{"FRAUD" =&gt; ["fraud", "abuse"]</code>, <code>"LEGIT" =&gt; ["legit", "safe"]}</code>. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label. </p>
    pub fn label_mapper(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    > {
        self.label_mapper.as_ref()
    }
    /// <p>The action to take for unlabeled events.</p>
    pub fn unlabeled_events_treatment(
        &self,
    ) -> std::option::Option<&crate::model::UnlabeledEventsTreatment> {
        self.unlabeled_events_treatment.as_ref()
    }
}
impl LabelSchema {
    /// Creates a new builder-style object to manufacture [`LabelSchema`](crate::model::LabelSchema).
    pub fn builder() -> crate::model::label_schema::Builder {
        crate::model::label_schema::Builder::default()
    }
}

/// See [`LabelSchema`](crate::model::LabelSchema).
pub mod label_schema {

    /// A builder for [`LabelSchema`](crate::model::LabelSchema).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) label_mapper: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) unlabeled_events_treatment:
            std::option::Option<crate::model::UnlabeledEventsTreatment>,
    }
    impl Builder {
        /// Adds a key-value pair to `label_mapper`.
        ///
        /// To override the contents of this collection use [`set_label_mapper`](Self::set_label_mapper).
        ///
        /// <p>The label mapper maps the Amazon Fraud Detector supported model classification labels (<code>FRAUD</code>, <code>LEGIT</code>) to the appropriate event type labels. For example, if "<code>FRAUD</code>" and "<code>LEGIT</code>" are Amazon Fraud Detector supported labels, this mapper could be: <code>{"FRAUD" =&gt; ["0"]</code>, <code>"LEGIT" =&gt; ["1"]}</code> or <code>{"FRAUD" =&gt; ["false"]</code>, <code>"LEGIT" =&gt; ["true"]}</code> or <code>{"FRAUD" =&gt; ["fraud", "abuse"]</code>, <code>"LEGIT" =&gt; ["legit", "safe"]}</code>. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label. </p>
        pub fn label_mapper(
            mut self,
            k: impl Into<std::string::String>,
            v: std::vec::Vec<std::string::String>,
        ) -> Self {
            let mut hash_map = self.label_mapper.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.label_mapper = Some(hash_map);
            self
        }
        /// <p>The label mapper maps the Amazon Fraud Detector supported model classification labels (<code>FRAUD</code>, <code>LEGIT</code>) to the appropriate event type labels. For example, if "<code>FRAUD</code>" and "<code>LEGIT</code>" are Amazon Fraud Detector supported labels, this mapper could be: <code>{"FRAUD" =&gt; ["0"]</code>, <code>"LEGIT" =&gt; ["1"]}</code> or <code>{"FRAUD" =&gt; ["false"]</code>, <code>"LEGIT" =&gt; ["true"]}</code> or <code>{"FRAUD" =&gt; ["fraud", "abuse"]</code>, <code>"LEGIT" =&gt; ["legit", "safe"]}</code>. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label. </p>
        pub fn set_label_mapper(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.label_mapper = input;
            self
        }
        /// <p>The action to take for unlabeled events.</p>
        pub fn unlabeled_events_treatment(
            mut self,
            input: crate::model::UnlabeledEventsTreatment,
        ) -> Self {
            self.unlabeled_events_treatment = Some(input);
            self
        }
        /// <p>The action to take for unlabeled events.</p>
        pub fn set_unlabeled_events_treatment(
            mut self,
            input: std::option::Option<crate::model::UnlabeledEventsTreatment>,
        ) -> Self {
            self.unlabeled_events_treatment = input;
            self
        }
        /// Consumes the builder and constructs a [`LabelSchema`](crate::model::LabelSchema).
        pub fn build(self) -> crate::model::LabelSchema {
            crate::model::LabelSchema {
                label_mapper: self.label_mapper,
                unlabeled_events_treatment: self.unlabeled_events_treatment,
            }
        }
    }
}

/// When writing a match expression against `UnlabeledEventsTreatment`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let unlabeledeventstreatment = unimplemented!();
/// match unlabeledeventstreatment {
///     UnlabeledEventsTreatment::Fraud => { /* ... */ },
///     UnlabeledEventsTreatment::Ignore => { /* ... */ },
///     UnlabeledEventsTreatment::Legit => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `unlabeledeventstreatment` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UnlabeledEventsTreatment::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UnlabeledEventsTreatment::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UnlabeledEventsTreatment::NewFeature` is defined.
/// Specifically, when `unlabeledeventstreatment` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UnlabeledEventsTreatment::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UnlabeledEventsTreatment {
    #[allow(missing_docs)] // documentation missing in model
    Fraud,
    #[allow(missing_docs)] // documentation missing in model
    Ignore,
    #[allow(missing_docs)] // documentation missing in model
    Legit,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UnlabeledEventsTreatment {
    fn from(s: &str) -> Self {
        match s {
            "FRAUD" => UnlabeledEventsTreatment::Fraud,
            "IGNORE" => UnlabeledEventsTreatment::Ignore,
            "LEGIT" => UnlabeledEventsTreatment::Legit,
            other => UnlabeledEventsTreatment::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for UnlabeledEventsTreatment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UnlabeledEventsTreatment::from(s))
    }
}
impl UnlabeledEventsTreatment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UnlabeledEventsTreatment::Fraud => "FRAUD",
            UnlabeledEventsTreatment::Ignore => "IGNORE",
            UnlabeledEventsTreatment::Legit => "LEGIT",
            UnlabeledEventsTreatment::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FRAUD", "IGNORE", "LEGIT"]
    }
}
impl AsRef<str> for UnlabeledEventsTreatment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `TrainingDataSourceEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let trainingdatasourceenum = unimplemented!();
/// match trainingdatasourceenum {
///     TrainingDataSourceEnum::ExternalEvents => { /* ... */ },
///     TrainingDataSourceEnum::IngestedEvents => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `trainingdatasourceenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TrainingDataSourceEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TrainingDataSourceEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TrainingDataSourceEnum::NewFeature` is defined.
/// Specifically, when `trainingdatasourceenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TrainingDataSourceEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TrainingDataSourceEnum {
    #[allow(missing_docs)] // documentation missing in model
    ExternalEvents,
    #[allow(missing_docs)] // documentation missing in model
    IngestedEvents,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TrainingDataSourceEnum {
    fn from(s: &str) -> Self {
        match s {
            "EXTERNAL_EVENTS" => TrainingDataSourceEnum::ExternalEvents,
            "INGESTED_EVENTS" => TrainingDataSourceEnum::IngestedEvents,
            other => {
                TrainingDataSourceEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TrainingDataSourceEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TrainingDataSourceEnum::from(s))
    }
}
impl TrainingDataSourceEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TrainingDataSourceEnum::ExternalEvents => "EXTERNAL_EVENTS",
            TrainingDataSourceEnum::IngestedEvents => "INGESTED_EVENTS",
            TrainingDataSourceEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EXTERNAL_EVENTS", "INGESTED_EVENTS"]
    }
}
impl AsRef<str> for TrainingDataSourceEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Model {
    /// <p>The model ID.</p>
    #[doc(hidden)]
    pub model_id: std::option::Option<std::string::String>,
    /// <p>The model type.</p>
    #[doc(hidden)]
    pub model_type: std::option::Option<crate::model::ModelTypeEnum>,
    /// <p>The model description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the event type.</p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the model was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of last time the model was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>The ARN of the model.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl Model {
    /// <p>The model ID.</p>
    pub fn model_id(&self) -> std::option::Option<&str> {
        self.model_id.as_deref()
    }
    /// <p>The model type.</p>
    pub fn model_type(&self) -> std::option::Option<&crate::model::ModelTypeEnum> {
        self.model_type.as_ref()
    }
    /// <p>The model description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the event type.</p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p>Timestamp of when the model was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>Timestamp of last time the model was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>The ARN of the model.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl Model {
    /// Creates a new builder-style object to manufacture [`Model`](crate::model::Model).
    pub fn builder() -> crate::model::model::Builder {
        crate::model::model::Builder::default()
    }
}

/// See [`Model`](crate::model::Model).
pub mod model {

    /// A builder for [`Model`](crate::model::Model).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_id: std::option::Option<std::string::String>,
        pub(crate) model_type: std::option::Option<crate::model::ModelTypeEnum>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The model ID.</p>
        pub fn model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_id = Some(input.into());
            self
        }
        /// <p>The model ID.</p>
        pub fn set_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_id = input;
            self
        }
        /// <p>The model type.</p>
        pub fn model_type(mut self, input: crate::model::ModelTypeEnum) -> Self {
            self.model_type = Some(input);
            self
        }
        /// <p>The model type.</p>
        pub fn set_model_type(
            mut self,
            input: std::option::Option<crate::model::ModelTypeEnum>,
        ) -> Self {
            self.model_type = input;
            self
        }
        /// <p>The model description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The model description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the event type.</p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p>The name of the event type.</p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p>Timestamp of when the model was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the model was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Timestamp of last time the model was updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of last time the model was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The ARN of the model.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the model.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Model`](crate::model::Model).
        pub fn build(self) -> crate::model::Model {
            crate::model::Model {
                model_id: self.model_id,
                model_type: self.model_type,
                description: self.description,
                event_type_name: self.event_type_name,
                created_time: self.created_time,
                last_updated_time: self.last_updated_time,
                arn: self.arn,
            }
        }
    }
}

/// <p>The label details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Label {
    /// <p>The label name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The label description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the label was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the event type was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The label ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl Label {
    /// <p>The label name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The label description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Timestamp of when the label was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>Timestamp of when the event type was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The label ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl Label {
    /// Creates a new builder-style object to manufacture [`Label`](crate::model::Label).
    pub fn builder() -> crate::model::label::Builder {
        crate::model::label::Builder::default()
    }
}

/// See [`Label`](crate::model::Label).
pub mod label {

    /// A builder for [`Label`](crate::model::Label).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The label name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The label name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The label description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The label description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Timestamp of when the label was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the label was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Timestamp of when the event type was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the event type was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The label ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The label ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Label`](crate::model::Label).
        pub fn build(self) -> crate::model::Label {
            crate::model::Label {
                name: self.name,
                description: self.description,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
}

/// <p>The KMS key details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KmsKey {
    /// <p>The encryption key ARN.</p>
    #[doc(hidden)]
    pub kms_encryption_key_arn: std::option::Option<std::string::String>,
}
impl KmsKey {
    /// <p>The encryption key ARN.</p>
    pub fn kms_encryption_key_arn(&self) -> std::option::Option<&str> {
        self.kms_encryption_key_arn.as_deref()
    }
}
impl KmsKey {
    /// Creates a new builder-style object to manufacture [`KmsKey`](crate::model::KmsKey).
    pub fn builder() -> crate::model::kms_key::Builder {
        crate::model::kms_key::Builder::default()
    }
}

/// See [`KmsKey`](crate::model::KmsKey).
pub mod kms_key {

    /// A builder for [`KmsKey`](crate::model::KmsKey).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) kms_encryption_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption key ARN.</p>
        pub fn kms_encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_encryption_key_arn = Some(input.into());
            self
        }
        /// <p>The encryption key ARN.</p>
        pub fn set_kms_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.kms_encryption_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`KmsKey`](crate::model::KmsKey).
        pub fn build(self) -> crate::model::KmsKey {
            crate::model::KmsKey {
                kms_encryption_key_arn: self.kms_encryption_key_arn,
            }
        }
    }
}

/// <p>The Amazon SageMaker model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExternalModel {
    /// <p>The Amazon SageMaker model endpoints.</p>
    #[doc(hidden)]
    pub model_endpoint: std::option::Option<std::string::String>,
    /// <p>The source of the model.</p>
    #[doc(hidden)]
    pub model_source: std::option::Option<crate::model::ModelSource>,
    /// <p>The role used to invoke the model. </p>
    #[doc(hidden)]
    pub invoke_model_endpoint_role_arn: std::option::Option<std::string::String>,
    /// <p>The input configuration.</p>
    #[doc(hidden)]
    pub input_configuration: std::option::Option<crate::model::ModelInputConfiguration>,
    /// <p>The output configuration.</p>
    #[doc(hidden)]
    pub output_configuration: std::option::Option<crate::model::ModelOutputConfiguration>,
    /// <p>The Amazon Fraud Detector status for the external model endpoint</p>
    #[doc(hidden)]
    pub model_endpoint_status: std::option::Option<crate::model::ModelEndpointStatus>,
    /// <p>Timestamp of when the model was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the model was last created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The model ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl ExternalModel {
    /// <p>The Amazon SageMaker model endpoints.</p>
    pub fn model_endpoint(&self) -> std::option::Option<&str> {
        self.model_endpoint.as_deref()
    }
    /// <p>The source of the model.</p>
    pub fn model_source(&self) -> std::option::Option<&crate::model::ModelSource> {
        self.model_source.as_ref()
    }
    /// <p>The role used to invoke the model. </p>
    pub fn invoke_model_endpoint_role_arn(&self) -> std::option::Option<&str> {
        self.invoke_model_endpoint_role_arn.as_deref()
    }
    /// <p>The input configuration.</p>
    pub fn input_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ModelInputConfiguration> {
        self.input_configuration.as_ref()
    }
    /// <p>The output configuration.</p>
    pub fn output_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ModelOutputConfiguration> {
        self.output_configuration.as_ref()
    }
    /// <p>The Amazon Fraud Detector status for the external model endpoint</p>
    pub fn model_endpoint_status(&self) -> std::option::Option<&crate::model::ModelEndpointStatus> {
        self.model_endpoint_status.as_ref()
    }
    /// <p>Timestamp of when the model was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>Timestamp of when the model was last created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The model ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl ExternalModel {
    /// Creates a new builder-style object to manufacture [`ExternalModel`](crate::model::ExternalModel).
    pub fn builder() -> crate::model::external_model::Builder {
        crate::model::external_model::Builder::default()
    }
}

/// See [`ExternalModel`](crate::model::ExternalModel).
pub mod external_model {

    /// A builder for [`ExternalModel`](crate::model::ExternalModel).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_endpoint: std::option::Option<std::string::String>,
        pub(crate) model_source: std::option::Option<crate::model::ModelSource>,
        pub(crate) invoke_model_endpoint_role_arn: std::option::Option<std::string::String>,
        pub(crate) input_configuration: std::option::Option<crate::model::ModelInputConfiguration>,
        pub(crate) output_configuration:
            std::option::Option<crate::model::ModelOutputConfiguration>,
        pub(crate) model_endpoint_status: std::option::Option<crate::model::ModelEndpointStatus>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon SageMaker model endpoints.</p>
        pub fn model_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_endpoint = Some(input.into());
            self
        }
        /// <p>The Amazon SageMaker model endpoints.</p>
        pub fn set_model_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_endpoint = input;
            self
        }
        /// <p>The source of the model.</p>
        pub fn model_source(mut self, input: crate::model::ModelSource) -> Self {
            self.model_source = Some(input);
            self
        }
        /// <p>The source of the model.</p>
        pub fn set_model_source(
            mut self,
            input: std::option::Option<crate::model::ModelSource>,
        ) -> Self {
            self.model_source = input;
            self
        }
        /// <p>The role used to invoke the model. </p>
        pub fn invoke_model_endpoint_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.invoke_model_endpoint_role_arn = Some(input.into());
            self
        }
        /// <p>The role used to invoke the model. </p>
        pub fn set_invoke_model_endpoint_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.invoke_model_endpoint_role_arn = input;
            self
        }
        /// <p>The input configuration.</p>
        pub fn input_configuration(mut self, input: crate::model::ModelInputConfiguration) -> Self {
            self.input_configuration = Some(input);
            self
        }
        /// <p>The input configuration.</p>
        pub fn set_input_configuration(
            mut self,
            input: std::option::Option<crate::model::ModelInputConfiguration>,
        ) -> Self {
            self.input_configuration = input;
            self
        }
        /// <p>The output configuration.</p>
        pub fn output_configuration(
            mut self,
            input: crate::model::ModelOutputConfiguration,
        ) -> Self {
            self.output_configuration = Some(input);
            self
        }
        /// <p>The output configuration.</p>
        pub fn set_output_configuration(
            mut self,
            input: std::option::Option<crate::model::ModelOutputConfiguration>,
        ) -> Self {
            self.output_configuration = input;
            self
        }
        /// <p>The Amazon Fraud Detector status for the external model endpoint</p>
        pub fn model_endpoint_status(mut self, input: crate::model::ModelEndpointStatus) -> Self {
            self.model_endpoint_status = Some(input);
            self
        }
        /// <p>The Amazon Fraud Detector status for the external model endpoint</p>
        pub fn set_model_endpoint_status(
            mut self,
            input: std::option::Option<crate::model::ModelEndpointStatus>,
        ) -> Self {
            self.model_endpoint_status = input;
            self
        }
        /// <p>Timestamp of when the model was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the model was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Timestamp of when the model was last created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the model was last created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The model ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The model ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ExternalModel`](crate::model::ExternalModel).
        pub fn build(self) -> crate::model::ExternalModel {
            crate::model::ExternalModel {
                model_endpoint: self.model_endpoint,
                model_source: self.model_source,
                invoke_model_endpoint_role_arn: self.invoke_model_endpoint_role_arn,
                input_configuration: self.input_configuration,
                output_configuration: self.output_configuration,
                model_endpoint_status: self.model_endpoint_status,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
}

/// <p>The event type details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventType {
    /// <p>The event type name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The event type description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The event type event variables.</p>
    #[doc(hidden)]
    pub event_variables: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The event type labels.</p>
    #[doc(hidden)]
    pub labels: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The event type entity types.</p>
    #[doc(hidden)]
    pub entity_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>If <code>Enabled</code>, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as <code>INGESTED_EVENTS</code>, to train your model and improve fraud predictions.</p>
    #[doc(hidden)]
    pub event_ingestion: std::option::Option<crate::model::EventIngestion>,
    /// <p>Data about the stored events.</p>
    #[doc(hidden)]
    pub ingested_event_statistics: std::option::Option<crate::model::IngestedEventStatistics>,
    /// <p>Timestamp of when the event type was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the event type was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The entity type ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl EventType {
    /// <p>The event type name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The event type description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The event type event variables.</p>
    pub fn event_variables(&self) -> std::option::Option<&[std::string::String]> {
        self.event_variables.as_deref()
    }
    /// <p>The event type labels.</p>
    pub fn labels(&self) -> std::option::Option<&[std::string::String]> {
        self.labels.as_deref()
    }
    /// <p>The event type entity types.</p>
    pub fn entity_types(&self) -> std::option::Option<&[std::string::String]> {
        self.entity_types.as_deref()
    }
    /// <p>If <code>Enabled</code>, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as <code>INGESTED_EVENTS</code>, to train your model and improve fraud predictions.</p>
    pub fn event_ingestion(&self) -> std::option::Option<&crate::model::EventIngestion> {
        self.event_ingestion.as_ref()
    }
    /// <p>Data about the stored events.</p>
    pub fn ingested_event_statistics(
        &self,
    ) -> std::option::Option<&crate::model::IngestedEventStatistics> {
        self.ingested_event_statistics.as_ref()
    }
    /// <p>Timestamp of when the event type was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>Timestamp of when the event type was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The entity type ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for EventType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventType");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("event_variables", &"*** Sensitive Data Redacted ***");
        formatter.field("labels", &"*** Sensitive Data Redacted ***");
        formatter.field("entity_types", &"*** Sensitive Data Redacted ***");
        formatter.field("event_ingestion", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "ingested_event_statistics",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("last_updated_time", &"*** Sensitive Data Redacted ***");
        formatter.field("created_time", &"*** Sensitive Data Redacted ***");
        formatter.field("arn", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl EventType {
    /// Creates a new builder-style object to manufacture [`EventType`](crate::model::EventType).
    pub fn builder() -> crate::model::event_type::Builder {
        crate::model::event_type::Builder::default()
    }
}

/// See [`EventType`](crate::model::EventType).
pub mod event_type {

    /// A builder for [`EventType`](crate::model::EventType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) event_variables: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) labels: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) entity_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) event_ingestion: std::option::Option<crate::model::EventIngestion>,
        pub(crate) ingested_event_statistics:
            std::option::Option<crate::model::IngestedEventStatistics>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The event type name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The event type name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The event type description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The event type description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `event_variables`.
        ///
        /// To override the contents of this collection use [`set_event_variables`](Self::set_event_variables).
        ///
        /// <p>The event type event variables.</p>
        pub fn event_variables(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.event_variables.unwrap_or_default();
            v.push(input.into());
            self.event_variables = Some(v);
            self
        }
        /// <p>The event type event variables.</p>
        pub fn set_event_variables(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.event_variables = input;
            self
        }
        /// Appends an item to `labels`.
        ///
        /// To override the contents of this collection use [`set_labels`](Self::set_labels).
        ///
        /// <p>The event type labels.</p>
        pub fn labels(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.labels.unwrap_or_default();
            v.push(input.into());
            self.labels = Some(v);
            self
        }
        /// <p>The event type labels.</p>
        pub fn set_labels(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.labels = input;
            self
        }
        /// Appends an item to `entity_types`.
        ///
        /// To override the contents of this collection use [`set_entity_types`](Self::set_entity_types).
        ///
        /// <p>The event type entity types.</p>
        pub fn entity_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entity_types.unwrap_or_default();
            v.push(input.into());
            self.entity_types = Some(v);
            self
        }
        /// <p>The event type entity types.</p>
        pub fn set_entity_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entity_types = input;
            self
        }
        /// <p>If <code>Enabled</code>, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as <code>INGESTED_EVENTS</code>, to train your model and improve fraud predictions.</p>
        pub fn event_ingestion(mut self, input: crate::model::EventIngestion) -> Self {
            self.event_ingestion = Some(input);
            self
        }
        /// <p>If <code>Enabled</code>, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as <code>INGESTED_EVENTS</code>, to train your model and improve fraud predictions.</p>
        pub fn set_event_ingestion(
            mut self,
            input: std::option::Option<crate::model::EventIngestion>,
        ) -> Self {
            self.event_ingestion = input;
            self
        }
        /// <p>Data about the stored events.</p>
        pub fn ingested_event_statistics(
            mut self,
            input: crate::model::IngestedEventStatistics,
        ) -> Self {
            self.ingested_event_statistics = Some(input);
            self
        }
        /// <p>Data about the stored events.</p>
        pub fn set_ingested_event_statistics(
            mut self,
            input: std::option::Option<crate::model::IngestedEventStatistics>,
        ) -> Self {
            self.ingested_event_statistics = input;
            self
        }
        /// <p>Timestamp of when the event type was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the event type was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Timestamp of when the event type was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the event type was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The entity type ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The entity type ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EventType`](crate::model::EventType).
        pub fn build(self) -> crate::model::EventType {
            crate::model::EventType {
                name: self.name,
                description: self.description,
                event_variables: self.event_variables,
                labels: self.labels,
                entity_types: self.entity_types,
                event_ingestion: self.event_ingestion,
                ingested_event_statistics: self.ingested_event_statistics,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("event_variables", &"*** Sensitive Data Redacted ***");
            formatter.field("labels", &"*** Sensitive Data Redacted ***");
            formatter.field("entity_types", &"*** Sensitive Data Redacted ***");
            formatter.field("event_ingestion", &"*** Sensitive Data Redacted ***");
            formatter.field(
                "ingested_event_statistics",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.field("last_updated_time", &"*** Sensitive Data Redacted ***");
            formatter.field("created_time", &"*** Sensitive Data Redacted ***");
            formatter.field("arn", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>Data about the stored events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IngestedEventStatistics {
    /// <p>The number of stored events.</p>
    #[doc(hidden)]
    pub number_of_events: std::option::Option<i64>,
    /// <p>The total size of the stored events.</p>
    #[doc(hidden)]
    pub event_data_size_in_bytes: std::option::Option<i64>,
    /// <p>The oldest stored event.</p>
    #[doc(hidden)]
    pub least_recent_event: std::option::Option<std::string::String>,
    /// <p>The newest stored event.</p>
    #[doc(hidden)]
    pub most_recent_event: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the stored event was last updated. </p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
}
impl IngestedEventStatistics {
    /// <p>The number of stored events.</p>
    pub fn number_of_events(&self) -> std::option::Option<i64> {
        self.number_of_events
    }
    /// <p>The total size of the stored events.</p>
    pub fn event_data_size_in_bytes(&self) -> std::option::Option<i64> {
        self.event_data_size_in_bytes
    }
    /// <p>The oldest stored event.</p>
    pub fn least_recent_event(&self) -> std::option::Option<&str> {
        self.least_recent_event.as_deref()
    }
    /// <p>The newest stored event.</p>
    pub fn most_recent_event(&self) -> std::option::Option<&str> {
        self.most_recent_event.as_deref()
    }
    /// <p>Timestamp of when the stored event was last updated. </p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
}
impl IngestedEventStatistics {
    /// Creates a new builder-style object to manufacture [`IngestedEventStatistics`](crate::model::IngestedEventStatistics).
    pub fn builder() -> crate::model::ingested_event_statistics::Builder {
        crate::model::ingested_event_statistics::Builder::default()
    }
}

/// See [`IngestedEventStatistics`](crate::model::IngestedEventStatistics).
pub mod ingested_event_statistics {

    /// A builder for [`IngestedEventStatistics`](crate::model::IngestedEventStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) number_of_events: std::option::Option<i64>,
        pub(crate) event_data_size_in_bytes: std::option::Option<i64>,
        pub(crate) least_recent_event: std::option::Option<std::string::String>,
        pub(crate) most_recent_event: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of stored events.</p>
        pub fn number_of_events(mut self, input: i64) -> Self {
            self.number_of_events = Some(input);
            self
        }
        /// <p>The number of stored events.</p>
        pub fn set_number_of_events(mut self, input: std::option::Option<i64>) -> Self {
            self.number_of_events = input;
            self
        }
        /// <p>The total size of the stored events.</p>
        pub fn event_data_size_in_bytes(mut self, input: i64) -> Self {
            self.event_data_size_in_bytes = Some(input);
            self
        }
        /// <p>The total size of the stored events.</p>
        pub fn set_event_data_size_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.event_data_size_in_bytes = input;
            self
        }
        /// <p>The oldest stored event.</p>
        pub fn least_recent_event(mut self, input: impl Into<std::string::String>) -> Self {
            self.least_recent_event = Some(input.into());
            self
        }
        /// <p>The oldest stored event.</p>
        pub fn set_least_recent_event(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.least_recent_event = input;
            self
        }
        /// <p>The newest stored event.</p>
        pub fn most_recent_event(mut self, input: impl Into<std::string::String>) -> Self {
            self.most_recent_event = Some(input.into());
            self
        }
        /// <p>The newest stored event.</p>
        pub fn set_most_recent_event(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.most_recent_event = input;
            self
        }
        /// <p>Timestamp of when the stored event was last updated. </p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the stored event was last updated. </p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`IngestedEventStatistics`](crate::model::IngestedEventStatistics).
        pub fn build(self) -> crate::model::IngestedEventStatistics {
            crate::model::IngestedEventStatistics {
                number_of_events: self.number_of_events,
                event_data_size_in_bytes: self.event_data_size_in_bytes,
                least_recent_event: self.least_recent_event,
                most_recent_event: self.most_recent_event,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}

/// <p> The details of the external (Amazon Sagemaker) model evaluated for generating predictions. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EvaluatedExternalModel {
    /// <p> The endpoint of the external (Amazon Sagemaker) model. </p>
    #[doc(hidden)]
    pub model_endpoint: std::option::Option<std::string::String>,
    /// <p> Indicates whether event variables were used to generate predictions. </p>
    #[doc(hidden)]
    pub use_event_variables: std::option::Option<bool>,
    /// <p> Input variables use for generating predictions. </p>
    #[doc(hidden)]
    pub input_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p> Output variables. </p>
    #[doc(hidden)]
    pub output_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl EvaluatedExternalModel {
    /// <p> The endpoint of the external (Amazon Sagemaker) model. </p>
    pub fn model_endpoint(&self) -> std::option::Option<&str> {
        self.model_endpoint.as_deref()
    }
    /// <p> Indicates whether event variables were used to generate predictions. </p>
    pub fn use_event_variables(&self) -> std::option::Option<bool> {
        self.use_event_variables
    }
    /// <p> Input variables use for generating predictions. </p>
    pub fn input_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.input_variables.as_ref()
    }
    /// <p> Output variables. </p>
    pub fn output_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.output_variables.as_ref()
    }
}
impl std::fmt::Debug for EvaluatedExternalModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EvaluatedExternalModel");
        formatter.field("model_endpoint", &self.model_endpoint);
        formatter.field("use_event_variables", &self.use_event_variables);
        formatter.field("input_variables", &"*** Sensitive Data Redacted ***");
        formatter.field("output_variables", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl EvaluatedExternalModel {
    /// Creates a new builder-style object to manufacture [`EvaluatedExternalModel`](crate::model::EvaluatedExternalModel).
    pub fn builder() -> crate::model::evaluated_external_model::Builder {
        crate::model::evaluated_external_model::Builder::default()
    }
}

/// See [`EvaluatedExternalModel`](crate::model::EvaluatedExternalModel).
pub mod evaluated_external_model {

    /// A builder for [`EvaluatedExternalModel`](crate::model::EvaluatedExternalModel).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) model_endpoint: std::option::Option<std::string::String>,
        pub(crate) use_event_variables: std::option::Option<bool>,
        pub(crate) input_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) output_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p> The endpoint of the external (Amazon Sagemaker) model. </p>
        pub fn model_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_endpoint = Some(input.into());
            self
        }
        /// <p> The endpoint of the external (Amazon Sagemaker) model. </p>
        pub fn set_model_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_endpoint = input;
            self
        }
        /// <p> Indicates whether event variables were used to generate predictions. </p>
        pub fn use_event_variables(mut self, input: bool) -> Self {
            self.use_event_variables = Some(input);
            self
        }
        /// <p> Indicates whether event variables were used to generate predictions. </p>
        pub fn set_use_event_variables(mut self, input: std::option::Option<bool>) -> Self {
            self.use_event_variables = input;
            self
        }
        /// Adds a key-value pair to `input_variables`.
        ///
        /// To override the contents of this collection use [`set_input_variables`](Self::set_input_variables).
        ///
        /// <p> Input variables use for generating predictions. </p>
        pub fn input_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.input_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.input_variables = Some(hash_map);
            self
        }
        /// <p> Input variables use for generating predictions. </p>
        pub fn set_input_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.input_variables = input;
            self
        }
        /// Adds a key-value pair to `output_variables`.
        ///
        /// To override the contents of this collection use [`set_output_variables`](Self::set_output_variables).
        ///
        /// <p> Output variables. </p>
        pub fn output_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.output_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.output_variables = Some(hash_map);
            self
        }
        /// <p> Output variables. </p>
        pub fn set_output_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.output_variables = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluatedExternalModel`](crate::model::EvaluatedExternalModel).
        pub fn build(self) -> crate::model::EvaluatedExternalModel {
            crate::model::EvaluatedExternalModel {
                model_endpoint: self.model_endpoint,
                use_event_variables: self.use_event_variables,
                input_variables: self.input_variables,
                output_variables: self.output_variables,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("model_endpoint", &self.model_endpoint);
            formatter.field("use_event_variables", &self.use_event_variables);
            formatter.field("input_variables", &"*** Sensitive Data Redacted ***");
            formatter.field("output_variables", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p> The model version evaluated for generating prediction. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EvaluatedModelVersion {
    /// <p> The model ID. </p>
    #[doc(hidden)]
    pub model_id: std::option::Option<std::string::String>,
    /// <p> The model version. </p>
    #[doc(hidden)]
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The model type. </p>
    /// <p>Valid values: <code>ONLINE_FRAUD_INSIGHTS</code> | <code>TRANSACTION_FRAUD_INSIGHTS</code> </p>
    #[doc(hidden)]
    pub model_type: std::option::Option<std::string::String>,
    /// <p> Evaluations generated for the model version. </p>
    #[doc(hidden)]
    pub evaluations: std::option::Option<std::vec::Vec<crate::model::ModelVersionEvaluation>>,
}
impl EvaluatedModelVersion {
    /// <p> The model ID. </p>
    pub fn model_id(&self) -> std::option::Option<&str> {
        self.model_id.as_deref()
    }
    /// <p> The model version. </p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p>The model type. </p>
    /// <p>Valid values: <code>ONLINE_FRAUD_INSIGHTS</code> | <code>TRANSACTION_FRAUD_INSIGHTS</code> </p>
    pub fn model_type(&self) -> std::option::Option<&str> {
        self.model_type.as_deref()
    }
    /// <p> Evaluations generated for the model version. </p>
    pub fn evaluations(&self) -> std::option::Option<&[crate::model::ModelVersionEvaluation]> {
        self.evaluations.as_deref()
    }
}
impl EvaluatedModelVersion {
    /// Creates a new builder-style object to manufacture [`EvaluatedModelVersion`](crate::model::EvaluatedModelVersion).
    pub fn builder() -> crate::model::evaluated_model_version::Builder {
        crate::model::evaluated_model_version::Builder::default()
    }
}

/// See [`EvaluatedModelVersion`](crate::model::EvaluatedModelVersion).
pub mod evaluated_model_version {

    /// A builder for [`EvaluatedModelVersion`](crate::model::EvaluatedModelVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_id: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) model_type: std::option::Option<std::string::String>,
        pub(crate) evaluations:
            std::option::Option<std::vec::Vec<crate::model::ModelVersionEvaluation>>,
    }
    impl Builder {
        /// <p> The model ID. </p>
        pub fn model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_id = Some(input.into());
            self
        }
        /// <p> The model ID. </p>
        pub fn set_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_id = input;
            self
        }
        /// <p> The model version. </p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p> The model version. </p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The model type. </p>
        /// <p>Valid values: <code>ONLINE_FRAUD_INSIGHTS</code> | <code>TRANSACTION_FRAUD_INSIGHTS</code> </p>
        pub fn model_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_type = Some(input.into());
            self
        }
        /// <p>The model type. </p>
        /// <p>Valid values: <code>ONLINE_FRAUD_INSIGHTS</code> | <code>TRANSACTION_FRAUD_INSIGHTS</code> </p>
        pub fn set_model_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_type = input;
            self
        }
        /// Appends an item to `evaluations`.
        ///
        /// To override the contents of this collection use [`set_evaluations`](Self::set_evaluations).
        ///
        /// <p> Evaluations generated for the model version. </p>
        pub fn evaluations(mut self, input: crate::model::ModelVersionEvaluation) -> Self {
            let mut v = self.evaluations.unwrap_or_default();
            v.push(input);
            self.evaluations = Some(v);
            self
        }
        /// <p> Evaluations generated for the model version. </p>
        pub fn set_evaluations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModelVersionEvaluation>>,
        ) -> Self {
            self.evaluations = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluatedModelVersion`](crate::model::EvaluatedModelVersion).
        pub fn build(self) -> crate::model::EvaluatedModelVersion {
            crate::model::EvaluatedModelVersion {
                model_id: self.model_id,
                model_version: self.model_version,
                model_type: self.model_type,
                evaluations: self.evaluations,
            }
        }
    }
}

/// <p> The model version evalutions. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelVersionEvaluation {
    /// <p> The output variable name. </p>
    #[doc(hidden)]
    pub output_variable_name: std::option::Option<std::string::String>,
    /// <p> The evaluation score generated for the model version. </p>
    #[doc(hidden)]
    pub evaluation_score: std::option::Option<std::string::String>,
    /// <p> The prediction explanations generated for the model version. </p>
    #[doc(hidden)]
    pub prediction_explanations: std::option::Option<crate::model::PredictionExplanations>,
}
impl ModelVersionEvaluation {
    /// <p> The output variable name. </p>
    pub fn output_variable_name(&self) -> std::option::Option<&str> {
        self.output_variable_name.as_deref()
    }
    /// <p> The evaluation score generated for the model version. </p>
    pub fn evaluation_score(&self) -> std::option::Option<&str> {
        self.evaluation_score.as_deref()
    }
    /// <p> The prediction explanations generated for the model version. </p>
    pub fn prediction_explanations(
        &self,
    ) -> std::option::Option<&crate::model::PredictionExplanations> {
        self.prediction_explanations.as_ref()
    }
}
impl ModelVersionEvaluation {
    /// Creates a new builder-style object to manufacture [`ModelVersionEvaluation`](crate::model::ModelVersionEvaluation).
    pub fn builder() -> crate::model::model_version_evaluation::Builder {
        crate::model::model_version_evaluation::Builder::default()
    }
}

/// See [`ModelVersionEvaluation`](crate::model::ModelVersionEvaluation).
pub mod model_version_evaluation {

    /// A builder for [`ModelVersionEvaluation`](crate::model::ModelVersionEvaluation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) output_variable_name: std::option::Option<std::string::String>,
        pub(crate) evaluation_score: std::option::Option<std::string::String>,
        pub(crate) prediction_explanations:
            std::option::Option<crate::model::PredictionExplanations>,
    }
    impl Builder {
        /// <p> The output variable name. </p>
        pub fn output_variable_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_variable_name = Some(input.into());
            self
        }
        /// <p> The output variable name. </p>
        pub fn set_output_variable_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.output_variable_name = input;
            self
        }
        /// <p> The evaluation score generated for the model version. </p>
        pub fn evaluation_score(mut self, input: impl Into<std::string::String>) -> Self {
            self.evaluation_score = Some(input.into());
            self
        }
        /// <p> The evaluation score generated for the model version. </p>
        pub fn set_evaluation_score(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.evaluation_score = input;
            self
        }
        /// <p> The prediction explanations generated for the model version. </p>
        pub fn prediction_explanations(
            mut self,
            input: crate::model::PredictionExplanations,
        ) -> Self {
            self.prediction_explanations = Some(input);
            self
        }
        /// <p> The prediction explanations generated for the model version. </p>
        pub fn set_prediction_explanations(
            mut self,
            input: std::option::Option<crate::model::PredictionExplanations>,
        ) -> Self {
            self.prediction_explanations = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelVersionEvaluation`](crate::model::ModelVersionEvaluation).
        pub fn build(self) -> crate::model::ModelVersionEvaluation {
            crate::model::ModelVersionEvaluation {
                output_variable_name: self.output_variable_name,
                evaluation_score: self.evaluation_score,
                prediction_explanations: self.prediction_explanations,
            }
        }
    }
}

/// <p> The prediction explanations that provide insight into how each event variable impacted the model version's fraud prediction score. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PredictionExplanations {
    /// <p> The details of the event variable's impact on the prediction score. </p>
    #[doc(hidden)]
    pub variable_impact_explanations:
        std::option::Option<std::vec::Vec<crate::model::VariableImpactExplanation>>,
    /// <p> The details of the aggregated variables impact on the prediction score. </p>
    /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
    #[doc(hidden)]
    pub aggregated_variables_impact_explanations:
        std::option::Option<std::vec::Vec<crate::model::AggregatedVariablesImpactExplanation>>,
}
impl PredictionExplanations {
    /// <p> The details of the event variable's impact on the prediction score. </p>
    pub fn variable_impact_explanations(
        &self,
    ) -> std::option::Option<&[crate::model::VariableImpactExplanation]> {
        self.variable_impact_explanations.as_deref()
    }
    /// <p> The details of the aggregated variables impact on the prediction score. </p>
    /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
    pub fn aggregated_variables_impact_explanations(
        &self,
    ) -> std::option::Option<&[crate::model::AggregatedVariablesImpactExplanation]> {
        self.aggregated_variables_impact_explanations.as_deref()
    }
}
impl PredictionExplanations {
    /// Creates a new builder-style object to manufacture [`PredictionExplanations`](crate::model::PredictionExplanations).
    pub fn builder() -> crate::model::prediction_explanations::Builder {
        crate::model::prediction_explanations::Builder::default()
    }
}

/// See [`PredictionExplanations`](crate::model::PredictionExplanations).
pub mod prediction_explanations {

    /// A builder for [`PredictionExplanations`](crate::model::PredictionExplanations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variable_impact_explanations:
            std::option::Option<std::vec::Vec<crate::model::VariableImpactExplanation>>,
        pub(crate) aggregated_variables_impact_explanations:
            std::option::Option<std::vec::Vec<crate::model::AggregatedVariablesImpactExplanation>>,
    }
    impl Builder {
        /// Appends an item to `variable_impact_explanations`.
        ///
        /// To override the contents of this collection use [`set_variable_impact_explanations`](Self::set_variable_impact_explanations).
        ///
        /// <p> The details of the event variable's impact on the prediction score. </p>
        pub fn variable_impact_explanations(
            mut self,
            input: crate::model::VariableImpactExplanation,
        ) -> Self {
            let mut v = self.variable_impact_explanations.unwrap_or_default();
            v.push(input);
            self.variable_impact_explanations = Some(v);
            self
        }
        /// <p> The details of the event variable's impact on the prediction score. </p>
        pub fn set_variable_impact_explanations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::VariableImpactExplanation>>,
        ) -> Self {
            self.variable_impact_explanations = input;
            self
        }
        /// Appends an item to `aggregated_variables_impact_explanations`.
        ///
        /// To override the contents of this collection use [`set_aggregated_variables_impact_explanations`](Self::set_aggregated_variables_impact_explanations).
        ///
        /// <p> The details of the aggregated variables impact on the prediction score. </p>
        /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
        pub fn aggregated_variables_impact_explanations(
            mut self,
            input: crate::model::AggregatedVariablesImpactExplanation,
        ) -> Self {
            let mut v = self
                .aggregated_variables_impact_explanations
                .unwrap_or_default();
            v.push(input);
            self.aggregated_variables_impact_explanations = Some(v);
            self
        }
        /// <p> The details of the aggregated variables impact on the prediction score. </p>
        /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
        pub fn set_aggregated_variables_impact_explanations(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::AggregatedVariablesImpactExplanation>,
            >,
        ) -> Self {
            self.aggregated_variables_impact_explanations = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictionExplanations`](crate::model::PredictionExplanations).
        pub fn build(self) -> crate::model::PredictionExplanations {
            crate::model::PredictionExplanations {
                variable_impact_explanations: self.variable_impact_explanations,
                aggregated_variables_impact_explanations: self
                    .aggregated_variables_impact_explanations,
            }
        }
    }
}

/// <p> The details of the impact of aggregated variables on the prediction score. </p>
/// <p>Account Takeover Insights (ATI) model uses the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, the model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregatedVariablesImpactExplanation {
    /// <p> The names of all the event variables that were used to derive the aggregated variables. </p>
    #[doc(hidden)]
    pub event_variable_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The relative impact of the aggregated variables in terms of magnitude on the prediction scores. </p>
    #[doc(hidden)]
    pub relative_impact: std::option::Option<std::string::String>,
    /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from -infinity to +infinity.</p>
    /// <ul>
    /// <li> <p>A positive value indicates that the variables drove the risk score up.</p> </li>
    /// <li> <p>A negative value indicates that the variables drove the risk score down.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub log_odds_impact: std::option::Option<f32>,
}
impl AggregatedVariablesImpactExplanation {
    /// <p> The names of all the event variables that were used to derive the aggregated variables. </p>
    pub fn event_variable_names(&self) -> std::option::Option<&[std::string::String]> {
        self.event_variable_names.as_deref()
    }
    /// <p> The relative impact of the aggregated variables in terms of magnitude on the prediction scores. </p>
    pub fn relative_impact(&self) -> std::option::Option<&str> {
        self.relative_impact.as_deref()
    }
    /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from -infinity to +infinity.</p>
    /// <ul>
    /// <li> <p>A positive value indicates that the variables drove the risk score up.</p> </li>
    /// <li> <p>A negative value indicates that the variables drove the risk score down.</p> </li>
    /// </ul>
    pub fn log_odds_impact(&self) -> std::option::Option<f32> {
        self.log_odds_impact
    }
}
impl AggregatedVariablesImpactExplanation {
    /// Creates a new builder-style object to manufacture [`AggregatedVariablesImpactExplanation`](crate::model::AggregatedVariablesImpactExplanation).
    pub fn builder() -> crate::model::aggregated_variables_impact_explanation::Builder {
        crate::model::aggregated_variables_impact_explanation::Builder::default()
    }
}

/// See [`AggregatedVariablesImpactExplanation`](crate::model::AggregatedVariablesImpactExplanation).
pub mod aggregated_variables_impact_explanation {

    /// A builder for [`AggregatedVariablesImpactExplanation`](crate::model::AggregatedVariablesImpactExplanation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_variable_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) relative_impact: std::option::Option<std::string::String>,
        pub(crate) log_odds_impact: std::option::Option<f32>,
    }
    impl Builder {
        /// Appends an item to `event_variable_names`.
        ///
        /// To override the contents of this collection use [`set_event_variable_names`](Self::set_event_variable_names).
        ///
        /// <p> The names of all the event variables that were used to derive the aggregated variables. </p>
        pub fn event_variable_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.event_variable_names.unwrap_or_default();
            v.push(input.into());
            self.event_variable_names = Some(v);
            self
        }
        /// <p> The names of all the event variables that were used to derive the aggregated variables. </p>
        pub fn set_event_variable_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.event_variable_names = input;
            self
        }
        /// <p> The relative impact of the aggregated variables in terms of magnitude on the prediction scores. </p>
        pub fn relative_impact(mut self, input: impl Into<std::string::String>) -> Self {
            self.relative_impact = Some(input.into());
            self
        }
        /// <p> The relative impact of the aggregated variables in terms of magnitude on the prediction scores. </p>
        pub fn set_relative_impact(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relative_impact = input;
            self
        }
        /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from -infinity to +infinity.</p>
        /// <ul>
        /// <li> <p>A positive value indicates that the variables drove the risk score up.</p> </li>
        /// <li> <p>A negative value indicates that the variables drove the risk score down.</p> </li>
        /// </ul>
        pub fn log_odds_impact(mut self, input: f32) -> Self {
            self.log_odds_impact = Some(input);
            self
        }
        /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from -infinity to +infinity.</p>
        /// <ul>
        /// <li> <p>A positive value indicates that the variables drove the risk score up.</p> </li>
        /// <li> <p>A negative value indicates that the variables drove the risk score down.</p> </li>
        /// </ul>
        pub fn set_log_odds_impact(mut self, input: std::option::Option<f32>) -> Self {
            self.log_odds_impact = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregatedVariablesImpactExplanation`](crate::model::AggregatedVariablesImpactExplanation).
        pub fn build(self) -> crate::model::AggregatedVariablesImpactExplanation {
            crate::model::AggregatedVariablesImpactExplanation {
                event_variable_names: self.event_variable_names,
                relative_impact: self.relative_impact,
                log_odds_impact: self.log_odds_impact,
            }
        }
    }
}

/// <p> The details of the event variable's impact on the prediction score. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariableImpactExplanation {
    /// <p> The event variable name. </p>
    #[doc(hidden)]
    pub event_variable_name: std::option::Option<std::string::String>,
    /// <p> The event variable's relative impact in terms of magnitude on the prediction scores. The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk. </p>
    #[doc(hidden)]
    pub relative_impact: std::option::Option<std::string::String>,
    /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.</p>
    /// <ul>
    /// <li> <p>A positive value indicates that the variable drove the risk score up.</p> </li>
    /// <li> <p>A negative value indicates that the variable drove the risk score down.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub log_odds_impact: std::option::Option<f32>,
}
impl VariableImpactExplanation {
    /// <p> The event variable name. </p>
    pub fn event_variable_name(&self) -> std::option::Option<&str> {
        self.event_variable_name.as_deref()
    }
    /// <p> The event variable's relative impact in terms of magnitude on the prediction scores. The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk. </p>
    pub fn relative_impact(&self) -> std::option::Option<&str> {
        self.relative_impact.as_deref()
    }
    /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.</p>
    /// <ul>
    /// <li> <p>A positive value indicates that the variable drove the risk score up.</p> </li>
    /// <li> <p>A negative value indicates that the variable drove the risk score down.</p> </li>
    /// </ul>
    pub fn log_odds_impact(&self) -> std::option::Option<f32> {
        self.log_odds_impact
    }
}
impl VariableImpactExplanation {
    /// Creates a new builder-style object to manufacture [`VariableImpactExplanation`](crate::model::VariableImpactExplanation).
    pub fn builder() -> crate::model::variable_impact_explanation::Builder {
        crate::model::variable_impact_explanation::Builder::default()
    }
}

/// See [`VariableImpactExplanation`](crate::model::VariableImpactExplanation).
pub mod variable_impact_explanation {

    /// A builder for [`VariableImpactExplanation`](crate::model::VariableImpactExplanation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_variable_name: std::option::Option<std::string::String>,
        pub(crate) relative_impact: std::option::Option<std::string::String>,
        pub(crate) log_odds_impact: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The event variable name. </p>
        pub fn event_variable_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_variable_name = Some(input.into());
            self
        }
        /// <p> The event variable name. </p>
        pub fn set_event_variable_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_variable_name = input;
            self
        }
        /// <p> The event variable's relative impact in terms of magnitude on the prediction scores. The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk. </p>
        pub fn relative_impact(mut self, input: impl Into<std::string::String>) -> Self {
            self.relative_impact = Some(input.into());
            self
        }
        /// <p> The event variable's relative impact in terms of magnitude on the prediction scores. The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk. </p>
        pub fn set_relative_impact(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relative_impact = input;
            self
        }
        /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.</p>
        /// <ul>
        /// <li> <p>A positive value indicates that the variable drove the risk score up.</p> </li>
        /// <li> <p>A negative value indicates that the variable drove the risk score down.</p> </li>
        /// </ul>
        pub fn log_odds_impact(mut self, input: f32) -> Self {
            self.log_odds_impact = Some(input);
            self
        }
        /// <p> The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.</p>
        /// <ul>
        /// <li> <p>A positive value indicates that the variable drove the risk score up.</p> </li>
        /// <li> <p>A negative value indicates that the variable drove the risk score down.</p> </li>
        /// </ul>
        pub fn set_log_odds_impact(mut self, input: std::option::Option<f32>) -> Self {
            self.log_odds_impact = input;
            self
        }
        /// Consumes the builder and constructs a [`VariableImpactExplanation`](crate::model::VariableImpactExplanation).
        pub fn build(self) -> crate::model::VariableImpactExplanation {
            crate::model::VariableImpactExplanation {
                event_variable_name: self.event_variable_name,
                relative_impact: self.relative_impact,
                log_odds_impact: self.log_odds_impact,
            }
        }
    }
}

/// <p> The details of the rule used for evaluating variable values. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EvaluatedRule {
    /// <p> The rule ID. </p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p> The rule version. </p>
    #[doc(hidden)]
    pub rule_version: std::option::Option<std::string::String>,
    /// <p> The rule expression. </p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p> The rule expression value. </p>
    #[doc(hidden)]
    pub expression_with_values: std::option::Option<std::string::String>,
    /// <p> The rule outcome. </p>
    #[doc(hidden)]
    pub outcomes: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> Indicates whether the rule was evaluated. </p>
    #[doc(hidden)]
    pub evaluated: std::option::Option<bool>,
    /// <p> Indicates whether the rule matched. </p>
    #[doc(hidden)]
    pub matched: std::option::Option<bool>,
}
impl EvaluatedRule {
    /// <p> The rule ID. </p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p> The rule version. </p>
    pub fn rule_version(&self) -> std::option::Option<&str> {
        self.rule_version.as_deref()
    }
    /// <p> The rule expression. </p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p> The rule expression value. </p>
    pub fn expression_with_values(&self) -> std::option::Option<&str> {
        self.expression_with_values.as_deref()
    }
    /// <p> The rule outcome. </p>
    pub fn outcomes(&self) -> std::option::Option<&[std::string::String]> {
        self.outcomes.as_deref()
    }
    /// <p> Indicates whether the rule was evaluated. </p>
    pub fn evaluated(&self) -> std::option::Option<bool> {
        self.evaluated
    }
    /// <p> Indicates whether the rule matched. </p>
    pub fn matched(&self) -> std::option::Option<bool> {
        self.matched
    }
}
impl std::fmt::Debug for EvaluatedRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EvaluatedRule");
        formatter.field("rule_id", &self.rule_id);
        formatter.field("rule_version", &self.rule_version);
        formatter.field("expression", &"*** Sensitive Data Redacted ***");
        formatter.field("expression_with_values", &"*** Sensitive Data Redacted ***");
        formatter.field("outcomes", &self.outcomes);
        formatter.field("evaluated", &self.evaluated);
        formatter.field("matched", &self.matched);
        formatter.finish()
    }
}
impl EvaluatedRule {
    /// Creates a new builder-style object to manufacture [`EvaluatedRule`](crate::model::EvaluatedRule).
    pub fn builder() -> crate::model::evaluated_rule::Builder {
        crate::model::evaluated_rule::Builder::default()
    }
}

/// See [`EvaluatedRule`](crate::model::EvaluatedRule).
pub mod evaluated_rule {

    /// A builder for [`EvaluatedRule`](crate::model::EvaluatedRule).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) rule_version: std::option::Option<std::string::String>,
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) expression_with_values: std::option::Option<std::string::String>,
        pub(crate) outcomes: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) evaluated: std::option::Option<bool>,
        pub(crate) matched: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> The rule ID. </p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p> The rule ID. </p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// <p> The rule version. </p>
        pub fn rule_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_version = Some(input.into());
            self
        }
        /// <p> The rule version. </p>
        pub fn set_rule_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_version = input;
            self
        }
        /// <p> The rule expression. </p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p> The rule expression. </p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p> The rule expression value. </p>
        pub fn expression_with_values(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression_with_values = Some(input.into());
            self
        }
        /// <p> The rule expression value. </p>
        pub fn set_expression_with_values(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expression_with_values = input;
            self
        }
        /// Appends an item to `outcomes`.
        ///
        /// To override the contents of this collection use [`set_outcomes`](Self::set_outcomes).
        ///
        /// <p> The rule outcome. </p>
        pub fn outcomes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.outcomes.unwrap_or_default();
            v.push(input.into());
            self.outcomes = Some(v);
            self
        }
        /// <p> The rule outcome. </p>
        pub fn set_outcomes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.outcomes = input;
            self
        }
        /// <p> Indicates whether the rule was evaluated. </p>
        pub fn evaluated(mut self, input: bool) -> Self {
            self.evaluated = Some(input);
            self
        }
        /// <p> Indicates whether the rule was evaluated. </p>
        pub fn set_evaluated(mut self, input: std::option::Option<bool>) -> Self {
            self.evaluated = input;
            self
        }
        /// <p> Indicates whether the rule matched. </p>
        pub fn matched(mut self, input: bool) -> Self {
            self.matched = Some(input);
            self
        }
        /// <p> Indicates whether the rule matched. </p>
        pub fn set_matched(mut self, input: std::option::Option<bool>) -> Self {
            self.matched = input;
            self
        }
        /// Consumes the builder and constructs a [`EvaluatedRule`](crate::model::EvaluatedRule).
        pub fn build(self) -> crate::model::EvaluatedRule {
            crate::model::EvaluatedRule {
                rule_id: self.rule_id,
                rule_version: self.rule_version,
                expression: self.expression,
                expression_with_values: self.expression_with_values,
                outcomes: self.outcomes,
                evaluated: self.evaluated,
                matched: self.matched,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("rule_id", &self.rule_id);
            formatter.field("rule_version", &self.rule_version);
            formatter.field("expression", &"*** Sensitive Data Redacted ***");
            formatter.field("expression_with_values", &"*** Sensitive Data Redacted ***");
            formatter.field("outcomes", &self.outcomes);
            formatter.field("evaluated", &self.evaluated);
            formatter.field("matched", &self.matched);
            formatter.finish()
        }
    }
}

/// <p> Information about the summary of an event variable that was evaluated for generating prediction. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventVariableSummary {
    /// <p> The event variable name. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> The value of the event variable. </p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p> The event variable source. </p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
}
impl EventVariableSummary {
    /// <p> The event variable name. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> The value of the event variable. </p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p> The event variable source. </p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
}
impl std::fmt::Debug for EventVariableSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventVariableSummary");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("value", &"*** Sensitive Data Redacted ***");
        formatter.field("source", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl EventVariableSummary {
    /// Creates a new builder-style object to manufacture [`EventVariableSummary`](crate::model::EventVariableSummary).
    pub fn builder() -> crate::model::event_variable_summary::Builder {
        crate::model::event_variable_summary::Builder::default()
    }
}

/// See [`EventVariableSummary`](crate::model::EventVariableSummary).
pub mod event_variable_summary {

    /// A builder for [`EventVariableSummary`](crate::model::EventVariableSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The event variable name. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> The event variable name. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> The value of the event variable. </p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> The value of the event variable. </p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p> The event variable source. </p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p> The event variable source. </p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`EventVariableSummary`](crate::model::EventVariableSummary).
        pub fn build(self) -> crate::model::EventVariableSummary {
            crate::model::EventVariableSummary {
                name: self.name,
                value: self.value,
                source: self.source,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("value", &"*** Sensitive Data Redacted ***");
            formatter.field("source", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>The fraud prediction scores from Amazon SageMaker model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExternalModelOutputs {
    /// <p>The Amazon SageMaker model.</p>
    #[doc(hidden)]
    pub external_model: std::option::Option<crate::model::ExternalModelSummary>,
    /// <p>The fraud prediction scores from Amazon SageMaker model.</p>
    #[doc(hidden)]
    pub outputs:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl ExternalModelOutputs {
    /// <p>The Amazon SageMaker model.</p>
    pub fn external_model(&self) -> std::option::Option<&crate::model::ExternalModelSummary> {
        self.external_model.as_ref()
    }
    /// <p>The fraud prediction scores from Amazon SageMaker model.</p>
    pub fn outputs(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.outputs.as_ref()
    }
}
impl ExternalModelOutputs {
    /// Creates a new builder-style object to manufacture [`ExternalModelOutputs`](crate::model::ExternalModelOutputs).
    pub fn builder() -> crate::model::external_model_outputs::Builder {
        crate::model::external_model_outputs::Builder::default()
    }
}

/// See [`ExternalModelOutputs`](crate::model::ExternalModelOutputs).
pub mod external_model_outputs {

    /// A builder for [`ExternalModelOutputs`](crate::model::ExternalModelOutputs).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) external_model: std::option::Option<crate::model::ExternalModelSummary>,
        pub(crate) outputs: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon SageMaker model.</p>
        pub fn external_model(mut self, input: crate::model::ExternalModelSummary) -> Self {
            self.external_model = Some(input);
            self
        }
        /// <p>The Amazon SageMaker model.</p>
        pub fn set_external_model(
            mut self,
            input: std::option::Option<crate::model::ExternalModelSummary>,
        ) -> Self {
            self.external_model = input;
            self
        }
        /// Adds a key-value pair to `outputs`.
        ///
        /// To override the contents of this collection use [`set_outputs`](Self::set_outputs).
        ///
        /// <p>The fraud prediction scores from Amazon SageMaker model.</p>
        pub fn outputs(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.outputs.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.outputs = Some(hash_map);
            self
        }
        /// <p>The fraud prediction scores from Amazon SageMaker model.</p>
        pub fn set_outputs(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.outputs = input;
            self
        }
        /// Consumes the builder and constructs a [`ExternalModelOutputs`](crate::model::ExternalModelOutputs).
        pub fn build(self) -> crate::model::ExternalModelOutputs {
            crate::model::ExternalModelOutputs {
                external_model: self.external_model,
                outputs: self.outputs,
            }
        }
    }
}

/// <p>The Amazon SageMaker model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ExternalModelSummary {
    /// <p>The endpoint of the Amazon SageMaker model.</p>
    #[doc(hidden)]
    pub model_endpoint: std::option::Option<std::string::String>,
    /// <p>The source of the model.</p>
    #[doc(hidden)]
    pub model_source: std::option::Option<crate::model::ModelSource>,
}
impl ExternalModelSummary {
    /// <p>The endpoint of the Amazon SageMaker model.</p>
    pub fn model_endpoint(&self) -> std::option::Option<&str> {
        self.model_endpoint.as_deref()
    }
    /// <p>The source of the model.</p>
    pub fn model_source(&self) -> std::option::Option<&crate::model::ModelSource> {
        self.model_source.as_ref()
    }
}
impl ExternalModelSummary {
    /// Creates a new builder-style object to manufacture [`ExternalModelSummary`](crate::model::ExternalModelSummary).
    pub fn builder() -> crate::model::external_model_summary::Builder {
        crate::model::external_model_summary::Builder::default()
    }
}

/// See [`ExternalModelSummary`](crate::model::ExternalModelSummary).
pub mod external_model_summary {

    /// A builder for [`ExternalModelSummary`](crate::model::ExternalModelSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_endpoint: std::option::Option<std::string::String>,
        pub(crate) model_source: std::option::Option<crate::model::ModelSource>,
    }
    impl Builder {
        /// <p>The endpoint of the Amazon SageMaker model.</p>
        pub fn model_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the Amazon SageMaker model.</p>
        pub fn set_model_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_endpoint = input;
            self
        }
        /// <p>The source of the model.</p>
        pub fn model_source(mut self, input: crate::model::ModelSource) -> Self {
            self.model_source = Some(input);
            self
        }
        /// <p>The source of the model.</p>
        pub fn set_model_source(
            mut self,
            input: std::option::Option<crate::model::ModelSource>,
        ) -> Self {
            self.model_source = input;
            self
        }
        /// Consumes the builder and constructs a [`ExternalModelSummary`](crate::model::ExternalModelSummary).
        pub fn build(self) -> crate::model::ExternalModelSummary {
            crate::model::ExternalModelSummary {
                model_endpoint: self.model_endpoint,
                model_source: self.model_source,
            }
        }
    }
}

/// <p>The rule results.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RuleResult {
    /// <p>The rule ID that was matched, based on the rule execution mode.</p>
    #[doc(hidden)]
    pub rule_id: std::option::Option<std::string::String>,
    /// <p>The outcomes of the matched rule, based on the rule execution mode.</p>
    #[doc(hidden)]
    pub outcomes: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl RuleResult {
    /// <p>The rule ID that was matched, based on the rule execution mode.</p>
    pub fn rule_id(&self) -> std::option::Option<&str> {
        self.rule_id.as_deref()
    }
    /// <p>The outcomes of the matched rule, based on the rule execution mode.</p>
    pub fn outcomes(&self) -> std::option::Option<&[std::string::String]> {
        self.outcomes.as_deref()
    }
}
impl RuleResult {
    /// Creates a new builder-style object to manufacture [`RuleResult`](crate::model::RuleResult).
    pub fn builder() -> crate::model::rule_result::Builder {
        crate::model::rule_result::Builder::default()
    }
}

/// See [`RuleResult`](crate::model::RuleResult).
pub mod rule_result {

    /// A builder for [`RuleResult`](crate::model::RuleResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rule_id: std::option::Option<std::string::String>,
        pub(crate) outcomes: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The rule ID that was matched, based on the rule execution mode.</p>
        pub fn rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_id = Some(input.into());
            self
        }
        /// <p>The rule ID that was matched, based on the rule execution mode.</p>
        pub fn set_rule_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_id = input;
            self
        }
        /// Appends an item to `outcomes`.
        ///
        /// To override the contents of this collection use [`set_outcomes`](Self::set_outcomes).
        ///
        /// <p>The outcomes of the matched rule, based on the rule execution mode.</p>
        pub fn outcomes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.outcomes.unwrap_or_default();
            v.push(input.into());
            self.outcomes = Some(v);
            self
        }
        /// <p>The outcomes of the matched rule, based on the rule execution mode.</p>
        pub fn set_outcomes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.outcomes = input;
            self
        }
        /// Consumes the builder and constructs a [`RuleResult`](crate::model::RuleResult).
        pub fn build(self) -> crate::model::RuleResult {
            crate::model::RuleResult {
                rule_id: self.rule_id,
                outcomes: self.outcomes,
            }
        }
    }
}

/// <p>The fraud prediction scores.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelScores {
    /// <p>The model version.</p>
    #[doc(hidden)]
    pub model_version: std::option::Option<crate::model::ModelVersion>,
    /// <p>The model's fraud prediction scores.</p>
    #[doc(hidden)]
    pub scores: std::option::Option<std::collections::HashMap<std::string::String, f32>>,
}
impl ModelScores {
    /// <p>The model version.</p>
    pub fn model_version(&self) -> std::option::Option<&crate::model::ModelVersion> {
        self.model_version.as_ref()
    }
    /// <p>The model's fraud prediction scores.</p>
    pub fn scores(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, f32>> {
        self.scores.as_ref()
    }
}
impl ModelScores {
    /// Creates a new builder-style object to manufacture [`ModelScores`](crate::model::ModelScores).
    pub fn builder() -> crate::model::model_scores::Builder {
        crate::model::model_scores::Builder::default()
    }
}

/// See [`ModelScores`](crate::model::ModelScores).
pub mod model_scores {

    /// A builder for [`ModelScores`](crate::model::ModelScores).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_version: std::option::Option<crate::model::ModelVersion>,
        pub(crate) scores: std::option::Option<std::collections::HashMap<std::string::String, f32>>,
    }
    impl Builder {
        /// <p>The model version.</p>
        pub fn model_version(mut self, input: crate::model::ModelVersion) -> Self {
            self.model_version = Some(input);
            self
        }
        /// <p>The model version.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<crate::model::ModelVersion>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Adds a key-value pair to `scores`.
        ///
        /// To override the contents of this collection use [`set_scores`](Self::set_scores).
        ///
        /// <p>The model's fraud prediction scores.</p>
        pub fn scores(mut self, k: impl Into<std::string::String>, v: f32) -> Self {
            let mut hash_map = self.scores.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.scores = Some(hash_map);
            self
        }
        /// <p>The model's fraud prediction scores.</p>
        pub fn set_scores(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f32>>,
        ) -> Self {
            self.scores = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelScores`](crate::model::ModelScores).
        pub fn build(self) -> crate::model::ModelScores {
            crate::model::ModelScores {
                model_version: self.model_version,
                scores: self.scores,
            }
        }
    }
}

/// <p>A pre-formed Amazon SageMaker model input you can include if your detector version includes an imported Amazon SageMaker model endpoint with pass-through input configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelEndpointDataBlob {
    /// <p>The byte buffer of the Amazon SageMaker model endpoint input data blob.</p>
    #[doc(hidden)]
    pub byte_buffer: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The content type of the Amazon SageMaker model endpoint input data blob. </p>
    #[doc(hidden)]
    pub content_type: std::option::Option<std::string::String>,
}
impl ModelEndpointDataBlob {
    /// <p>The byte buffer of the Amazon SageMaker model endpoint input data blob.</p>
    pub fn byte_buffer(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.byte_buffer.as_ref()
    }
    /// <p>The content type of the Amazon SageMaker model endpoint input data blob. </p>
    pub fn content_type(&self) -> std::option::Option<&str> {
        self.content_type.as_deref()
    }
}
impl ModelEndpointDataBlob {
    /// Creates a new builder-style object to manufacture [`ModelEndpointDataBlob`](crate::model::ModelEndpointDataBlob).
    pub fn builder() -> crate::model::model_endpoint_data_blob::Builder {
        crate::model::model_endpoint_data_blob::Builder::default()
    }
}

/// See [`ModelEndpointDataBlob`](crate::model::ModelEndpointDataBlob).
pub mod model_endpoint_data_blob {

    /// A builder for [`ModelEndpointDataBlob`](crate::model::ModelEndpointDataBlob).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) byte_buffer: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) content_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The byte buffer of the Amazon SageMaker model endpoint input data blob.</p>
        pub fn byte_buffer(mut self, input: aws_smithy_types::Blob) -> Self {
            self.byte_buffer = Some(input);
            self
        }
        /// <p>The byte buffer of the Amazon SageMaker model endpoint input data blob.</p>
        pub fn set_byte_buffer(
            mut self,
            input: std::option::Option<aws_smithy_types::Blob>,
        ) -> Self {
            self.byte_buffer = input;
            self
        }
        /// <p>The content type of the Amazon SageMaker model endpoint input data blob. </p>
        pub fn content_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.content_type = Some(input.into());
            self
        }
        /// <p>The content type of the Amazon SageMaker model endpoint input data blob. </p>
        pub fn set_content_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelEndpointDataBlob`](crate::model::ModelEndpointDataBlob).
        pub fn build(self) -> crate::model::ModelEndpointDataBlob {
            crate::model::ModelEndpointDataBlob {
                byte_buffer: self.byte_buffer,
                content_type: self.content_type,
            }
        }
    }
}

/// <p>The event details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Event {
    /// <p>The event ID.</p>
    #[doc(hidden)]
    pub event_id: std::option::Option<std::string::String>,
    /// <p>The event type.</p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p>The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.</p>
    #[doc(hidden)]
    pub event_timestamp: std::option::Option<std::string::String>,
    /// <p>Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.</p>
    #[doc(hidden)]
    pub event_variables:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The label associated with the event.</p>
    #[doc(hidden)]
    pub current_label: std::option::Option<std::string::String>,
    /// <p>The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.</p>
    #[doc(hidden)]
    pub label_timestamp: std::option::Option<std::string::String>,
    /// <p>The event entities.</p>
    #[doc(hidden)]
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
}
impl Event {
    /// <p>The event ID.</p>
    pub fn event_id(&self) -> std::option::Option<&str> {
        self.event_id.as_deref()
    }
    /// <p>The event type.</p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p>The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.</p>
    pub fn event_timestamp(&self) -> std::option::Option<&str> {
        self.event_timestamp.as_deref()
    }
    /// <p>Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.</p>
    pub fn event_variables(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.event_variables.as_ref()
    }
    /// <p>The label associated with the event.</p>
    pub fn current_label(&self) -> std::option::Option<&str> {
        self.current_label.as_deref()
    }
    /// <p>The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.</p>
    pub fn label_timestamp(&self) -> std::option::Option<&str> {
        self.label_timestamp.as_deref()
    }
    /// <p>The event entities.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
}
impl Event {
    /// Creates a new builder-style object to manufacture [`Event`](crate::model::Event).
    pub fn builder() -> crate::model::event::Builder {
        crate::model::event::Builder::default()
    }
}

/// See [`Event`](crate::model::Event).
pub mod event {

    /// A builder for [`Event`](crate::model::Event).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_id: std::option::Option<std::string::String>,
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) event_timestamp: std::option::Option<std::string::String>,
        pub(crate) event_variables: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) current_label: std::option::Option<std::string::String>,
        pub(crate) label_timestamp: std::option::Option<std::string::String>,
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    }
    impl Builder {
        /// <p>The event ID.</p>
        pub fn event_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_id = Some(input.into());
            self
        }
        /// <p>The event ID.</p>
        pub fn set_event_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_id = input;
            self
        }
        /// <p>The event type.</p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p>The event type.</p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p>The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.</p>
        pub fn event_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_timestamp = Some(input.into());
            self
        }
        /// <p>The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.</p>
        pub fn set_event_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_timestamp = input;
            self
        }
        /// Adds a key-value pair to `event_variables`.
        ///
        /// To override the contents of this collection use [`set_event_variables`](Self::set_event_variables).
        ///
        /// <p>Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.</p>
        pub fn event_variables(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.event_variables.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.event_variables = Some(hash_map);
            self
        }
        /// <p>Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.</p>
        pub fn set_event_variables(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.event_variables = input;
            self
        }
        /// <p>The label associated with the event.</p>
        pub fn current_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.current_label = Some(input.into());
            self
        }
        /// <p>The label associated with the event.</p>
        pub fn set_current_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.current_label = input;
            self
        }
        /// <p>The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.</p>
        pub fn label_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.label_timestamp = Some(input.into());
            self
        }
        /// <p>The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.</p>
        pub fn set_label_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.label_timestamp = input;
            self
        }
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The event entities.</p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>The event entities.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Consumes the builder and constructs a [`Event`](crate::model::Event).
        pub fn build(self) -> crate::model::Event {
            crate::model::Event {
                event_id: self.event_id,
                event_type_name: self.event_type_name,
                event_timestamp: self.event_timestamp,
                event_variables: self.event_variables,
                current_label: self.current_label,
                label_timestamp: self.label_timestamp,
                entities: self.entities,
            }
        }
    }
}

/// <p>The entity type details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EntityType {
    /// <p>The entity type name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The entity type description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the entity type was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the entity type was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The entity type ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl EntityType {
    /// <p>The entity type name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The entity type description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Timestamp of when the entity type was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>Timestamp of when the entity type was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The entity type ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl EntityType {
    /// Creates a new builder-style object to manufacture [`EntityType`](crate::model::EntityType).
    pub fn builder() -> crate::model::entity_type::Builder {
        crate::model::entity_type::Builder::default()
    }
}

/// See [`EntityType`](crate::model::EntityType).
pub mod entity_type {

    /// A builder for [`EntityType`](crate::model::EntityType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The entity type name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The entity type name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The entity type description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The entity type description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Timestamp of when the entity type was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the entity type was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Timestamp of when the entity type was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the entity type was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The entity type ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The entity type ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EntityType`](crate::model::EntityType).
        pub fn build(self) -> crate::model::EntityType {
            crate::model::EntityType {
                name: self.name,
                description: self.description,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
}

/// <p>The detector.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Detector {
    /// <p>The detector ID.</p>
    #[doc(hidden)]
    pub detector_id: std::option::Option<std::string::String>,
    /// <p>The detector description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the event type.</p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the detector was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the detector was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The detector ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl Detector {
    /// <p>The detector ID.</p>
    pub fn detector_id(&self) -> std::option::Option<&str> {
        self.detector_id.as_deref()
    }
    /// <p>The detector description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the event type.</p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p>Timestamp of when the detector was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>Timestamp of when the detector was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The detector ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl Detector {
    /// Creates a new builder-style object to manufacture [`Detector`](crate::model::Detector).
    pub fn builder() -> crate::model::detector::Builder {
        crate::model::detector::Builder::default()
    }
}

/// See [`Detector`](crate::model::Detector).
pub mod detector {

    /// A builder for [`Detector`](crate::model::Detector).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detector_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The detector ID.</p>
        pub fn detector_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_id = Some(input.into());
            self
        }
        /// <p>The detector ID.</p>
        pub fn set_detector_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detector_id = input;
            self
        }
        /// <p>The detector description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The detector description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the event type.</p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p>The name of the event type.</p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p>Timestamp of when the detector was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the detector was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>Timestamp of when the detector was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the detector was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The detector ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The detector ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Detector`](crate::model::Detector).
        pub fn build(self) -> crate::model::Detector {
            crate::model::Detector {
                detector_id: self.detector_id,
                description: self.description,
                event_type_name: self.event_type_name,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
            }
        }
    }
}

/// When writing a match expression against `AsyncJobStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let asyncjobstatus = unimplemented!();
/// match asyncjobstatus {
///     AsyncJobStatus::Canceled => { /* ... */ },
///     AsyncJobStatus::CancelInProgress => { /* ... */ },
///     AsyncJobStatus::Complete => { /* ... */ },
///     AsyncJobStatus::Failed => { /* ... */ },
///     AsyncJobStatus::InProgress => { /* ... */ },
///     AsyncJobStatus::InProgressInitializing => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `asyncjobstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AsyncJobStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AsyncJobStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AsyncJobStatus::NewFeature` is defined.
/// Specifically, when `asyncjobstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AsyncJobStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AsyncJobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Canceled,
    #[allow(missing_docs)] // documentation missing in model
    CancelInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Complete,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    InProgressInitializing,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AsyncJobStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELED" => AsyncJobStatus::Canceled,
            "CANCEL_IN_PROGRESS" => AsyncJobStatus::CancelInProgress,
            "COMPLETE" => AsyncJobStatus::Complete,
            "FAILED" => AsyncJobStatus::Failed,
            "IN_PROGRESS" => AsyncJobStatus::InProgress,
            "IN_PROGRESS_INITIALIZING" => AsyncJobStatus::InProgressInitializing,
            other => AsyncJobStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AsyncJobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AsyncJobStatus::from(s))
    }
}
impl AsyncJobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AsyncJobStatus::Canceled => "CANCELED",
            AsyncJobStatus::CancelInProgress => "CANCEL_IN_PROGRESS",
            AsyncJobStatus::Complete => "COMPLETE",
            AsyncJobStatus::Failed => "FAILED",
            AsyncJobStatus::InProgress => "IN_PROGRESS",
            AsyncJobStatus::InProgressInitializing => "IN_PROGRESS_INITIALIZING",
            AsyncJobStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELED",
            "CANCEL_IN_PROGRESS",
            "COMPLETE",
            "FAILED",
            "IN_PROGRESS",
            "IN_PROGRESS_INITIALIZING",
        ]
    }
}
impl AsRef<str> for AsyncJobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The batch prediction details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPrediction {
    /// <p>The job ID for the batch prediction.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The batch prediction status.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AsyncJobStatus>,
    /// <p>The reason a batch prediction job failed.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the batch prediction job started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the batch prediction job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of most recent heartbeat indicating the batch prediction job was making progress.</p>
    #[doc(hidden)]
    pub last_heartbeat_time: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location of your training file.</p>
    #[doc(hidden)]
    pub input_path: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location of your output file.</p>
    #[doc(hidden)]
    pub output_path: std::option::Option<std::string::String>,
    /// <p>The name of the event type.</p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p>The name of the detector.</p>
    #[doc(hidden)]
    pub detector_name: std::option::Option<std::string::String>,
    /// <p>The detector version. </p>
    #[doc(hidden)]
    pub detector_version: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role to use for this job request.</p>
    #[doc(hidden)]
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of batch prediction job.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The number of records processed by the batch prediction job.</p>
    #[doc(hidden)]
    pub processed_records_count: std::option::Option<i32>,
    /// <p>The total number of records in the batch prediction job.</p>
    #[doc(hidden)]
    pub total_records_count: std::option::Option<i32>,
}
impl BatchPrediction {
    /// <p>The job ID for the batch prediction.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The batch prediction status.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AsyncJobStatus> {
        self.status.as_ref()
    }
    /// <p>The reason a batch prediction job failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>Timestamp of when the batch prediction job started.</p>
    pub fn start_time(&self) -> std::option::Option<&str> {
        self.start_time.as_deref()
    }
    /// <p>Timestamp of when the batch prediction job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&str> {
        self.completion_time.as_deref()
    }
    /// <p>Timestamp of most recent heartbeat indicating the batch prediction job was making progress.</p>
    pub fn last_heartbeat_time(&self) -> std::option::Option<&str> {
        self.last_heartbeat_time.as_deref()
    }
    /// <p>The Amazon S3 location of your training file.</p>
    pub fn input_path(&self) -> std::option::Option<&str> {
        self.input_path.as_deref()
    }
    /// <p>The Amazon S3 location of your output file.</p>
    pub fn output_path(&self) -> std::option::Option<&str> {
        self.output_path.as_deref()
    }
    /// <p>The name of the event type.</p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p>The name of the detector.</p>
    pub fn detector_name(&self) -> std::option::Option<&str> {
        self.detector_name.as_deref()
    }
    /// <p>The detector version. </p>
    pub fn detector_version(&self) -> std::option::Option<&str> {
        self.detector_version.as_deref()
    }
    /// <p>The ARN of the IAM role to use for this job request.</p>
    pub fn iam_role_arn(&self) -> std::option::Option<&str> {
        self.iam_role_arn.as_deref()
    }
    /// <p>The ARN of batch prediction job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The number of records processed by the batch prediction job.</p>
    pub fn processed_records_count(&self) -> std::option::Option<i32> {
        self.processed_records_count
    }
    /// <p>The total number of records in the batch prediction job.</p>
    pub fn total_records_count(&self) -> std::option::Option<i32> {
        self.total_records_count
    }
}
impl BatchPrediction {
    /// Creates a new builder-style object to manufacture [`BatchPrediction`](crate::model::BatchPrediction).
    pub fn builder() -> crate::model::batch_prediction::Builder {
        crate::model::batch_prediction::Builder::default()
    }
}

/// See [`BatchPrediction`](crate::model::BatchPrediction).
pub mod batch_prediction {

    /// A builder for [`BatchPrediction`](crate::model::BatchPrediction).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AsyncJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<std::string::String>,
        pub(crate) completion_time: std::option::Option<std::string::String>,
        pub(crate) last_heartbeat_time: std::option::Option<std::string::String>,
        pub(crate) input_path: std::option::Option<std::string::String>,
        pub(crate) output_path: std::option::Option<std::string::String>,
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) detector_name: std::option::Option<std::string::String>,
        pub(crate) detector_version: std::option::Option<std::string::String>,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) processed_records_count: std::option::Option<i32>,
        pub(crate) total_records_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The job ID for the batch prediction.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The job ID for the batch prediction.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The batch prediction status.</p>
        pub fn status(mut self, input: crate::model::AsyncJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The batch prediction status.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AsyncJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason a batch prediction job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason a batch prediction job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Timestamp of when the batch prediction job started.</p>
        pub fn start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the batch prediction job started.</p>
        pub fn set_start_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Timestamp of when the batch prediction job completed.</p>
        pub fn completion_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.completion_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the batch prediction job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>Timestamp of most recent heartbeat indicating the batch prediction job was making progress.</p>
        pub fn last_heartbeat_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_heartbeat_time = Some(input.into());
            self
        }
        /// <p>Timestamp of most recent heartbeat indicating the batch prediction job was making progress.</p>
        pub fn set_last_heartbeat_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_heartbeat_time = input;
            self
        }
        /// <p>The Amazon S3 location of your training file.</p>
        pub fn input_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of your training file.</p>
        pub fn set_input_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_path = input;
            self
        }
        /// <p>The Amazon S3 location of your output file.</p>
        pub fn output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of your output file.</p>
        pub fn set_output_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_path = input;
            self
        }
        /// <p>The name of the event type.</p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p>The name of the event type.</p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p>The name of the detector.</p>
        pub fn detector_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_name = Some(input.into());
            self
        }
        /// <p>The name of the detector.</p>
        pub fn set_detector_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detector_name = input;
            self
        }
        /// <p>The detector version. </p>
        pub fn detector_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_version = Some(input.into());
            self
        }
        /// <p>The detector version. </p>
        pub fn set_detector_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detector_version = input;
            self
        }
        /// <p>The ARN of the IAM role to use for this job request.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role to use for this job request.</p>
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>The ARN of batch prediction job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of batch prediction job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The number of records processed by the batch prediction job.</p>
        pub fn processed_records_count(mut self, input: i32) -> Self {
            self.processed_records_count = Some(input);
            self
        }
        /// <p>The number of records processed by the batch prediction job.</p>
        pub fn set_processed_records_count(mut self, input: std::option::Option<i32>) -> Self {
            self.processed_records_count = input;
            self
        }
        /// <p>The total number of records in the batch prediction job.</p>
        pub fn total_records_count(mut self, input: i32) -> Self {
            self.total_records_count = Some(input);
            self
        }
        /// <p>The total number of records in the batch prediction job.</p>
        pub fn set_total_records_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_records_count = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPrediction`](crate::model::BatchPrediction).
        pub fn build(self) -> crate::model::BatchPrediction {
            crate::model::BatchPrediction {
                job_id: self.job_id,
                status: self.status,
                failure_reason: self.failure_reason,
                start_time: self.start_time,
                completion_time: self.completion_time,
                last_heartbeat_time: self.last_heartbeat_time,
                input_path: self.input_path,
                output_path: self.output_path,
                event_type_name: self.event_type_name,
                detector_name: self.detector_name,
                detector_version: self.detector_version,
                iam_role_arn: self.iam_role_arn,
                arn: self.arn,
                processed_records_count: self.processed_records_count,
                total_records_count: self.total_records_count,
            }
        }
    }
}

/// <p>The batch import job details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchImport {
    /// <p>The ID of the batch import job. </p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The status of the batch import job.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::AsyncJobStatus>,
    /// <p>The reason batch import job failed.</p>
    #[doc(hidden)]
    pub failure_reason: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the batch import job started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<std::string::String>,
    /// <p>Timestamp of when batch import job completed.</p>
    #[doc(hidden)]
    pub completion_time: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location of your data file for batch import.</p>
    #[doc(hidden)]
    pub input_path: std::option::Option<std::string::String>,
    /// <p>The Amazon S3 location of your output file.</p>
    #[doc(hidden)]
    pub output_path: std::option::Option<std::string::String>,
    /// <p>The name of the event type.</p>
    #[doc(hidden)]
    pub event_type_name: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role to use for this job request.</p>
    #[doc(hidden)]
    pub iam_role_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the batch import job.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The number of records processed by batch import job.</p>
    #[doc(hidden)]
    pub processed_records_count: std::option::Option<i32>,
    /// <p>The number of records that failed to import. </p>
    #[doc(hidden)]
    pub failed_records_count: std::option::Option<i32>,
    /// <p>The total number of records in the batch import job.</p>
    #[doc(hidden)]
    pub total_records_count: std::option::Option<i32>,
}
impl BatchImport {
    /// <p>The ID of the batch import job. </p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The status of the batch import job.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::AsyncJobStatus> {
        self.status.as_ref()
    }
    /// <p>The reason batch import job failed.</p>
    pub fn failure_reason(&self) -> std::option::Option<&str> {
        self.failure_reason.as_deref()
    }
    /// <p>Timestamp of when the batch import job started.</p>
    pub fn start_time(&self) -> std::option::Option<&str> {
        self.start_time.as_deref()
    }
    /// <p>Timestamp of when batch import job completed.</p>
    pub fn completion_time(&self) -> std::option::Option<&str> {
        self.completion_time.as_deref()
    }
    /// <p>The Amazon S3 location of your data file for batch import.</p>
    pub fn input_path(&self) -> std::option::Option<&str> {
        self.input_path.as_deref()
    }
    /// <p>The Amazon S3 location of your output file.</p>
    pub fn output_path(&self) -> std::option::Option<&str> {
        self.output_path.as_deref()
    }
    /// <p>The name of the event type.</p>
    pub fn event_type_name(&self) -> std::option::Option<&str> {
        self.event_type_name.as_deref()
    }
    /// <p>The ARN of the IAM role to use for this job request.</p>
    pub fn iam_role_arn(&self) -> std::option::Option<&str> {
        self.iam_role_arn.as_deref()
    }
    /// <p>The ARN of the batch import job.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The number of records processed by batch import job.</p>
    pub fn processed_records_count(&self) -> std::option::Option<i32> {
        self.processed_records_count
    }
    /// <p>The number of records that failed to import. </p>
    pub fn failed_records_count(&self) -> std::option::Option<i32> {
        self.failed_records_count
    }
    /// <p>The total number of records in the batch import job.</p>
    pub fn total_records_count(&self) -> std::option::Option<i32> {
        self.total_records_count
    }
}
impl BatchImport {
    /// Creates a new builder-style object to manufacture [`BatchImport`](crate::model::BatchImport).
    pub fn builder() -> crate::model::batch_import::Builder {
        crate::model::batch_import::Builder::default()
    }
}

/// See [`BatchImport`](crate::model::BatchImport).
pub mod batch_import {

    /// A builder for [`BatchImport`](crate::model::BatchImport).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::AsyncJobStatus>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<std::string::String>,
        pub(crate) completion_time: std::option::Option<std::string::String>,
        pub(crate) input_path: std::option::Option<std::string::String>,
        pub(crate) output_path: std::option::Option<std::string::String>,
        pub(crate) event_type_name: std::option::Option<std::string::String>,
        pub(crate) iam_role_arn: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) processed_records_count: std::option::Option<i32>,
        pub(crate) failed_records_count: std::option::Option<i32>,
        pub(crate) total_records_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the batch import job. </p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The ID of the batch import job. </p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The status of the batch import job.</p>
        pub fn status(mut self, input: crate::model::AsyncJobStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the batch import job.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::AsyncJobStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The reason batch import job failed.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        /// <p>The reason batch import job failed.</p>
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// <p>Timestamp of when the batch import job started.</p>
        pub fn start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the batch import job started.</p>
        pub fn set_start_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>Timestamp of when batch import job completed.</p>
        pub fn completion_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.completion_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when batch import job completed.</p>
        pub fn set_completion_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.completion_time = input;
            self
        }
        /// <p>The Amazon S3 location of your data file for batch import.</p>
        pub fn input_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.input_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of your data file for batch import.</p>
        pub fn set_input_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input_path = input;
            self
        }
        /// <p>The Amazon S3 location of your output file.</p>
        pub fn output_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.output_path = Some(input.into());
            self
        }
        /// <p>The Amazon S3 location of your output file.</p>
        pub fn set_output_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.output_path = input;
            self
        }
        /// <p>The name of the event type.</p>
        pub fn event_type_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type_name = Some(input.into());
            self
        }
        /// <p>The name of the event type.</p>
        pub fn set_event_type_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.event_type_name = input;
            self
        }
        /// <p>The ARN of the IAM role to use for this job request.</p>
        pub fn iam_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM role to use for this job request.</p>
        pub fn set_iam_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_arn = input;
            self
        }
        /// <p>The ARN of the batch import job.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the batch import job.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The number of records processed by batch import job.</p>
        pub fn processed_records_count(mut self, input: i32) -> Self {
            self.processed_records_count = Some(input);
            self
        }
        /// <p>The number of records processed by batch import job.</p>
        pub fn set_processed_records_count(mut self, input: std::option::Option<i32>) -> Self {
            self.processed_records_count = input;
            self
        }
        /// <p>The number of records that failed to import. </p>
        pub fn failed_records_count(mut self, input: i32) -> Self {
            self.failed_records_count = Some(input);
            self
        }
        /// <p>The number of records that failed to import. </p>
        pub fn set_failed_records_count(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_records_count = input;
            self
        }
        /// <p>The total number of records in the batch import job.</p>
        pub fn total_records_count(mut self, input: i32) -> Self {
            self.total_records_count = Some(input);
            self
        }
        /// <p>The total number of records in the batch import job.</p>
        pub fn set_total_records_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_records_count = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchImport`](crate::model::BatchImport).
        pub fn build(self) -> crate::model::BatchImport {
            crate::model::BatchImport {
                job_id: self.job_id,
                status: self.status,
                failure_reason: self.failure_reason,
                start_time: self.start_time,
                completion_time: self.completion_time,
                input_path: self.input_path,
                output_path: self.output_path,
                event_type_name: self.event_type_name,
                iam_role_arn: self.iam_role_arn,
                arn: self.arn,
                processed_records_count: self.processed_records_count,
                failed_records_count: self.failed_records_count,
                total_records_count: self.total_records_count,
            }
        }
    }
}

/// <p>The details of the model version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModelVersionDetail {
    /// <p>The model ID.</p>
    #[doc(hidden)]
    pub model_id: std::option::Option<std::string::String>,
    /// <p>The model type.</p>
    #[doc(hidden)]
    pub model_type: std::option::Option<crate::model::ModelTypeEnum>,
    /// <p>The model version number.</p>
    #[doc(hidden)]
    pub model_version_number: std::option::Option<std::string::String>,
    /// <p>The status of the model version.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::string::String>,
    /// <p>The model version training data source.</p>
    #[doc(hidden)]
    pub training_data_source: std::option::Option<crate::model::TrainingDataSourceEnum>,
    /// <p>The training data schema.</p>
    #[doc(hidden)]
    pub training_data_schema: std::option::Option<crate::model::TrainingDataSchema>,
    /// <p>The external events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>EXTERNAL_EVENTS</code>.</p>
    #[doc(hidden)]
    pub external_events_detail: std::option::Option<crate::model::ExternalEventsDetail>,
    /// <p>The ingested events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>INGESTED_EVENTS</code>.</p>
    #[doc(hidden)]
    pub ingested_events_detail: std::option::Option<crate::model::IngestedEventsDetail>,
    /// <p>The training results.</p>
    #[doc(hidden)]
    pub training_result: std::option::Option<crate::model::TrainingResult>,
    /// <p>The timestamp when the model was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
    /// <p>The timestamp when the model was created.</p>
    #[doc(hidden)]
    pub created_time: std::option::Option<std::string::String>,
    /// <p>The model version ARN.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p> The training result details. The details include the relative importance of the variables. </p>
    #[doc(hidden)]
    pub training_result_v2: std::option::Option<crate::model::TrainingResultV2>,
}
impl ModelVersionDetail {
    /// <p>The model ID.</p>
    pub fn model_id(&self) -> std::option::Option<&str> {
        self.model_id.as_deref()
    }
    /// <p>The model type.</p>
    pub fn model_type(&self) -> std::option::Option<&crate::model::ModelTypeEnum> {
        self.model_type.as_ref()
    }
    /// <p>The model version number.</p>
    pub fn model_version_number(&self) -> std::option::Option<&str> {
        self.model_version_number.as_deref()
    }
    /// <p>The status of the model version.</p>
    pub fn status(&self) -> std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>The model version training data source.</p>
    pub fn training_data_source(
        &self,
    ) -> std::option::Option<&crate::model::TrainingDataSourceEnum> {
        self.training_data_source.as_ref()
    }
    /// <p>The training data schema.</p>
    pub fn training_data_schema(&self) -> std::option::Option<&crate::model::TrainingDataSchema> {
        self.training_data_schema.as_ref()
    }
    /// <p>The external events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>EXTERNAL_EVENTS</code>.</p>
    pub fn external_events_detail(
        &self,
    ) -> std::option::Option<&crate::model::ExternalEventsDetail> {
        self.external_events_detail.as_ref()
    }
    /// <p>The ingested events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>INGESTED_EVENTS</code>.</p>
    pub fn ingested_events_detail(
        &self,
    ) -> std::option::Option<&crate::model::IngestedEventsDetail> {
        self.ingested_events_detail.as_ref()
    }
    /// <p>The training results.</p>
    pub fn training_result(&self) -> std::option::Option<&crate::model::TrainingResult> {
        self.training_result.as_ref()
    }
    /// <p>The timestamp when the model was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
    /// <p>The timestamp when the model was created.</p>
    pub fn created_time(&self) -> std::option::Option<&str> {
        self.created_time.as_deref()
    }
    /// <p>The model version ARN.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p> The training result details. The details include the relative importance of the variables. </p>
    pub fn training_result_v2(&self) -> std::option::Option<&crate::model::TrainingResultV2> {
        self.training_result_v2.as_ref()
    }
}
impl ModelVersionDetail {
    /// Creates a new builder-style object to manufacture [`ModelVersionDetail`](crate::model::ModelVersionDetail).
    pub fn builder() -> crate::model::model_version_detail::Builder {
        crate::model::model_version_detail::Builder::default()
    }
}

/// See [`ModelVersionDetail`](crate::model::ModelVersionDetail).
pub mod model_version_detail {

    /// A builder for [`ModelVersionDetail`](crate::model::ModelVersionDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) model_id: std::option::Option<std::string::String>,
        pub(crate) model_type: std::option::Option<crate::model::ModelTypeEnum>,
        pub(crate) model_version_number: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) training_data_source: std::option::Option<crate::model::TrainingDataSourceEnum>,
        pub(crate) training_data_schema: std::option::Option<crate::model::TrainingDataSchema>,
        pub(crate) external_events_detail: std::option::Option<crate::model::ExternalEventsDetail>,
        pub(crate) ingested_events_detail: std::option::Option<crate::model::IngestedEventsDetail>,
        pub(crate) training_result: std::option::Option<crate::model::TrainingResult>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) training_result_v2: std::option::Option<crate::model::TrainingResultV2>,
    }
    impl Builder {
        /// <p>The model ID.</p>
        pub fn model_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_id = Some(input.into());
            self
        }
        /// <p>The model ID.</p>
        pub fn set_model_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model_id = input;
            self
        }
        /// <p>The model type.</p>
        pub fn model_type(mut self, input: crate::model::ModelTypeEnum) -> Self {
            self.model_type = Some(input);
            self
        }
        /// <p>The model type.</p>
        pub fn set_model_type(
            mut self,
            input: std::option::Option<crate::model::ModelTypeEnum>,
        ) -> Self {
            self.model_type = input;
            self
        }
        /// <p>The model version number.</p>
        pub fn model_version_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version_number = Some(input.into());
            self
        }
        /// <p>The model version number.</p>
        pub fn set_model_version_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version_number = input;
            self
        }
        /// <p>The status of the model version.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        /// <p>The status of the model version.</p>
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        /// <p>The model version training data source.</p>
        pub fn training_data_source(mut self, input: crate::model::TrainingDataSourceEnum) -> Self {
            self.training_data_source = Some(input);
            self
        }
        /// <p>The model version training data source.</p>
        pub fn set_training_data_source(
            mut self,
            input: std::option::Option<crate::model::TrainingDataSourceEnum>,
        ) -> Self {
            self.training_data_source = input;
            self
        }
        /// <p>The training data schema.</p>
        pub fn training_data_schema(mut self, input: crate::model::TrainingDataSchema) -> Self {
            self.training_data_schema = Some(input);
            self
        }
        /// <p>The training data schema.</p>
        pub fn set_training_data_schema(
            mut self,
            input: std::option::Option<crate::model::TrainingDataSchema>,
        ) -> Self {
            self.training_data_schema = input;
            self
        }
        /// <p>The external events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>EXTERNAL_EVENTS</code>.</p>
        pub fn external_events_detail(mut self, input: crate::model::ExternalEventsDetail) -> Self {
            self.external_events_detail = Some(input);
            self
        }
        /// <p>The external events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>EXTERNAL_EVENTS</code>.</p>
        pub fn set_external_events_detail(
            mut self,
            input: std::option::Option<crate::model::ExternalEventsDetail>,
        ) -> Self {
            self.external_events_detail = input;
            self
        }
        /// <p>The ingested events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>INGESTED_EVENTS</code>.</p>
        pub fn ingested_events_detail(mut self, input: crate::model::IngestedEventsDetail) -> Self {
            self.ingested_events_detail = Some(input);
            self
        }
        /// <p>The ingested events data details. This will be populated if the <code>trainingDataSource</code> for the model version is specified as <code>INGESTED_EVENTS</code>.</p>
        pub fn set_ingested_events_detail(
            mut self,
            input: std::option::Option<crate::model::IngestedEventsDetail>,
        ) -> Self {
            self.ingested_events_detail = input;
            self
        }
        /// <p>The training results.</p>
        pub fn training_result(mut self, input: crate::model::TrainingResult) -> Self {
            self.training_result = Some(input);
            self
        }
        /// <p>The training results.</p>
        pub fn set_training_result(
            mut self,
            input: std::option::Option<crate::model::TrainingResult>,
        ) -> Self {
            self.training_result = input;
            self
        }
        /// <p>The timestamp when the model was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>The timestamp when the model was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The timestamp when the model was created.</p>
        pub fn created_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_time = Some(input.into());
            self
        }
        /// <p>The timestamp when the model was created.</p>
        pub fn set_created_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_time = input;
            self
        }
        /// <p>The model version ARN.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The model version ARN.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p> The training result details. The details include the relative importance of the variables. </p>
        pub fn training_result_v2(mut self, input: crate::model::TrainingResultV2) -> Self {
            self.training_result_v2 = Some(input);
            self
        }
        /// <p> The training result details. The details include the relative importance of the variables. </p>
        pub fn set_training_result_v2(
            mut self,
            input: std::option::Option<crate::model::TrainingResultV2>,
        ) -> Self {
            self.training_result_v2 = input;
            self
        }
        /// Consumes the builder and constructs a [`ModelVersionDetail`](crate::model::ModelVersionDetail).
        pub fn build(self) -> crate::model::ModelVersionDetail {
            crate::model::ModelVersionDetail {
                model_id: self.model_id,
                model_type: self.model_type,
                model_version_number: self.model_version_number,
                status: self.status,
                training_data_source: self.training_data_source,
                training_data_schema: self.training_data_schema,
                external_events_detail: self.external_events_detail,
                ingested_events_detail: self.ingested_events_detail,
                training_result: self.training_result,
                last_updated_time: self.last_updated_time,
                created_time: self.created_time,
                arn: self.arn,
                training_result_v2: self.training_result_v2,
            }
        }
    }
}

/// <p> The training result details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrainingResultV2 {
    /// <p>The model training data validation metrics.</p>
    #[doc(hidden)]
    pub data_validation_metrics: std::option::Option<crate::model::DataValidationMetrics>,
    /// <p> The training metric details. </p>
    #[doc(hidden)]
    pub training_metrics_v2: std::option::Option<crate::model::TrainingMetricsV2>,
    /// <p>The variable importance metrics details.</p>
    #[doc(hidden)]
    pub variable_importance_metrics: std::option::Option<crate::model::VariableImportanceMetrics>,
    /// <p> The variable importance metrics of the aggregated variables. </p>
    /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
    #[doc(hidden)]
    pub aggregated_variables_importance_metrics:
        std::option::Option<crate::model::AggregatedVariablesImportanceMetrics>,
}
impl TrainingResultV2 {
    /// <p>The model training data validation metrics.</p>
    pub fn data_validation_metrics(
        &self,
    ) -> std::option::Option<&crate::model::DataValidationMetrics> {
        self.data_validation_metrics.as_ref()
    }
    /// <p> The training metric details. </p>
    pub fn training_metrics_v2(&self) -> std::option::Option<&crate::model::TrainingMetricsV2> {
        self.training_metrics_v2.as_ref()
    }
    /// <p>The variable importance metrics details.</p>
    pub fn variable_importance_metrics(
        &self,
    ) -> std::option::Option<&crate::model::VariableImportanceMetrics> {
        self.variable_importance_metrics.as_ref()
    }
    /// <p> The variable importance metrics of the aggregated variables. </p>
    /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
    pub fn aggregated_variables_importance_metrics(
        &self,
    ) -> std::option::Option<&crate::model::AggregatedVariablesImportanceMetrics> {
        self.aggregated_variables_importance_metrics.as_ref()
    }
}
impl TrainingResultV2 {
    /// Creates a new builder-style object to manufacture [`TrainingResultV2`](crate::model::TrainingResultV2).
    pub fn builder() -> crate::model::training_result_v2::Builder {
        crate::model::training_result_v2::Builder::default()
    }
}

/// See [`TrainingResultV2`](crate::model::TrainingResultV2).
pub mod training_result_v2 {

    /// A builder for [`TrainingResultV2`](crate::model::TrainingResultV2).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_validation_metrics:
            std::option::Option<crate::model::DataValidationMetrics>,
        pub(crate) training_metrics_v2: std::option::Option<crate::model::TrainingMetricsV2>,
        pub(crate) variable_importance_metrics:
            std::option::Option<crate::model::VariableImportanceMetrics>,
        pub(crate) aggregated_variables_importance_metrics:
            std::option::Option<crate::model::AggregatedVariablesImportanceMetrics>,
    }
    impl Builder {
        /// <p>The model training data validation metrics.</p>
        pub fn data_validation_metrics(
            mut self,
            input: crate::model::DataValidationMetrics,
        ) -> Self {
            self.data_validation_metrics = Some(input);
            self
        }
        /// <p>The model training data validation metrics.</p>
        pub fn set_data_validation_metrics(
            mut self,
            input: std::option::Option<crate::model::DataValidationMetrics>,
        ) -> Self {
            self.data_validation_metrics = input;
            self
        }
        /// <p> The training metric details. </p>
        pub fn training_metrics_v2(mut self, input: crate::model::TrainingMetricsV2) -> Self {
            self.training_metrics_v2 = Some(input);
            self
        }
        /// <p> The training metric details. </p>
        pub fn set_training_metrics_v2(
            mut self,
            input: std::option::Option<crate::model::TrainingMetricsV2>,
        ) -> Self {
            self.training_metrics_v2 = input;
            self
        }
        /// <p>The variable importance metrics details.</p>
        pub fn variable_importance_metrics(
            mut self,
            input: crate::model::VariableImportanceMetrics,
        ) -> Self {
            self.variable_importance_metrics = Some(input);
            self
        }
        /// <p>The variable importance metrics details.</p>
        pub fn set_variable_importance_metrics(
            mut self,
            input: std::option::Option<crate::model::VariableImportanceMetrics>,
        ) -> Self {
            self.variable_importance_metrics = input;
            self
        }
        /// <p> The variable importance metrics of the aggregated variables. </p>
        /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
        pub fn aggregated_variables_importance_metrics(
            mut self,
            input: crate::model::AggregatedVariablesImportanceMetrics,
        ) -> Self {
            self.aggregated_variables_importance_metrics = Some(input);
            self
        }
        /// <p> The variable importance metrics of the aggregated variables. </p>
        /// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
        pub fn set_aggregated_variables_importance_metrics(
            mut self,
            input: std::option::Option<crate::model::AggregatedVariablesImportanceMetrics>,
        ) -> Self {
            self.aggregated_variables_importance_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingResultV2`](crate::model::TrainingResultV2).
        pub fn build(self) -> crate::model::TrainingResultV2 {
            crate::model::TrainingResultV2 {
                data_validation_metrics: self.data_validation_metrics,
                training_metrics_v2: self.training_metrics_v2,
                variable_importance_metrics: self.variable_importance_metrics,
                aggregated_variables_importance_metrics: self
                    .aggregated_variables_importance_metrics,
            }
        }
    }
}

/// <p>The details of the relative importance of the aggregated variables.</p>
/// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregatedVariablesImportanceMetrics {
    /// <p> List of variables' metrics. </p>
    #[doc(hidden)]
    pub log_odds_metrics: std::option::Option<std::vec::Vec<crate::model::AggregatedLogOddsMetric>>,
}
impl AggregatedVariablesImportanceMetrics {
    /// <p> List of variables' metrics. </p>
    pub fn log_odds_metrics(
        &self,
    ) -> std::option::Option<&[crate::model::AggregatedLogOddsMetric]> {
        self.log_odds_metrics.as_deref()
    }
}
impl AggregatedVariablesImportanceMetrics {
    /// Creates a new builder-style object to manufacture [`AggregatedVariablesImportanceMetrics`](crate::model::AggregatedVariablesImportanceMetrics).
    pub fn builder() -> crate::model::aggregated_variables_importance_metrics::Builder {
        crate::model::aggregated_variables_importance_metrics::Builder::default()
    }
}

/// See [`AggregatedVariablesImportanceMetrics`](crate::model::AggregatedVariablesImportanceMetrics).
pub mod aggregated_variables_importance_metrics {

    /// A builder for [`AggregatedVariablesImportanceMetrics`](crate::model::AggregatedVariablesImportanceMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_odds_metrics:
            std::option::Option<std::vec::Vec<crate::model::AggregatedLogOddsMetric>>,
    }
    impl Builder {
        /// Appends an item to `log_odds_metrics`.
        ///
        /// To override the contents of this collection use [`set_log_odds_metrics`](Self::set_log_odds_metrics).
        ///
        /// <p> List of variables' metrics. </p>
        pub fn log_odds_metrics(mut self, input: crate::model::AggregatedLogOddsMetric) -> Self {
            let mut v = self.log_odds_metrics.unwrap_or_default();
            v.push(input);
            self.log_odds_metrics = Some(v);
            self
        }
        /// <p> List of variables' metrics. </p>
        pub fn set_log_odds_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AggregatedLogOddsMetric>>,
        ) -> Self {
            self.log_odds_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregatedVariablesImportanceMetrics`](crate::model::AggregatedVariablesImportanceMetrics).
        pub fn build(self) -> crate::model::AggregatedVariablesImportanceMetrics {
            crate::model::AggregatedVariablesImportanceMetrics {
                log_odds_metrics: self.log_odds_metrics,
            }
        }
    }
}

/// <p>The log odds metric details.</p>
/// <p>Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are <code>IP address</code> and <code>user</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AggregatedLogOddsMetric {
    /// <p> The names of all the variables. </p>
    #[doc(hidden)]
    pub variable_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p> The relative importance of the variables in the list to the other event variable. </p>
    #[doc(hidden)]
    pub aggregated_variables_importance: std::option::Option<f32>,
}
impl AggregatedLogOddsMetric {
    /// <p> The names of all the variables. </p>
    pub fn variable_names(&self) -> std::option::Option<&[std::string::String]> {
        self.variable_names.as_deref()
    }
    /// <p> The relative importance of the variables in the list to the other event variable. </p>
    pub fn aggregated_variables_importance(&self) -> std::option::Option<f32> {
        self.aggregated_variables_importance
    }
}
impl AggregatedLogOddsMetric {
    /// Creates a new builder-style object to manufacture [`AggregatedLogOddsMetric`](crate::model::AggregatedLogOddsMetric).
    pub fn builder() -> crate::model::aggregated_log_odds_metric::Builder {
        crate::model::aggregated_log_odds_metric::Builder::default()
    }
}

/// See [`AggregatedLogOddsMetric`](crate::model::AggregatedLogOddsMetric).
pub mod aggregated_log_odds_metric {

    /// A builder for [`AggregatedLogOddsMetric`](crate::model::AggregatedLogOddsMetric).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variable_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) aggregated_variables_importance: std::option::Option<f32>,
    }
    impl Builder {
        /// Appends an item to `variable_names`.
        ///
        /// To override the contents of this collection use [`set_variable_names`](Self::set_variable_names).
        ///
        /// <p> The names of all the variables. </p>
        pub fn variable_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.variable_names.unwrap_or_default();
            v.push(input.into());
            self.variable_names = Some(v);
            self
        }
        /// <p> The names of all the variables. </p>
        pub fn set_variable_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.variable_names = input;
            self
        }
        /// <p> The relative importance of the variables in the list to the other event variable. </p>
        pub fn aggregated_variables_importance(mut self, input: f32) -> Self {
            self.aggregated_variables_importance = Some(input);
            self
        }
        /// <p> The relative importance of the variables in the list to the other event variable. </p>
        pub fn set_aggregated_variables_importance(
            mut self,
            input: std::option::Option<f32>,
        ) -> Self {
            self.aggregated_variables_importance = input;
            self
        }
        /// Consumes the builder and constructs a [`AggregatedLogOddsMetric`](crate::model::AggregatedLogOddsMetric).
        pub fn build(self) -> crate::model::AggregatedLogOddsMetric {
            crate::model::AggregatedLogOddsMetric {
                variable_names: self.variable_names,
                aggregated_variables_importance: self.aggregated_variables_importance,
            }
        }
    }
}

/// <p>The variable importance metrics details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariableImportanceMetrics {
    /// <p>List of variable metrics.</p>
    #[doc(hidden)]
    pub log_odds_metrics: std::option::Option<std::vec::Vec<crate::model::LogOddsMetric>>,
}
impl VariableImportanceMetrics {
    /// <p>List of variable metrics.</p>
    pub fn log_odds_metrics(&self) -> std::option::Option<&[crate::model::LogOddsMetric]> {
        self.log_odds_metrics.as_deref()
    }
}
impl VariableImportanceMetrics {
    /// Creates a new builder-style object to manufacture [`VariableImportanceMetrics`](crate::model::VariableImportanceMetrics).
    pub fn builder() -> crate::model::variable_importance_metrics::Builder {
        crate::model::variable_importance_metrics::Builder::default()
    }
}

/// See [`VariableImportanceMetrics`](crate::model::VariableImportanceMetrics).
pub mod variable_importance_metrics {

    /// A builder for [`VariableImportanceMetrics`](crate::model::VariableImportanceMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_odds_metrics:
            std::option::Option<std::vec::Vec<crate::model::LogOddsMetric>>,
    }
    impl Builder {
        /// Appends an item to `log_odds_metrics`.
        ///
        /// To override the contents of this collection use [`set_log_odds_metrics`](Self::set_log_odds_metrics).
        ///
        /// <p>List of variable metrics.</p>
        pub fn log_odds_metrics(mut self, input: crate::model::LogOddsMetric) -> Self {
            let mut v = self.log_odds_metrics.unwrap_or_default();
            v.push(input);
            self.log_odds_metrics = Some(v);
            self
        }
        /// <p>List of variable metrics.</p>
        pub fn set_log_odds_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LogOddsMetric>>,
        ) -> Self {
            self.log_odds_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`VariableImportanceMetrics`](crate::model::VariableImportanceMetrics).
        pub fn build(self) -> crate::model::VariableImportanceMetrics {
            crate::model::VariableImportanceMetrics {
                log_odds_metrics: self.log_odds_metrics,
            }
        }
    }
}

/// <p>The log odds metric details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LogOddsMetric {
    /// <p>The name of the variable.</p>
    #[doc(hidden)]
    pub variable_name: std::option::Option<std::string::String>,
    /// <p>The type of variable.</p>
    #[doc(hidden)]
    pub variable_type: std::option::Option<std::string::String>,
    /// <p>The relative importance of the variable. For more information, see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/model-variable-importance.html">Model variable importance</a>.</p>
    #[doc(hidden)]
    pub variable_importance: std::option::Option<f32>,
}
impl LogOddsMetric {
    /// <p>The name of the variable.</p>
    pub fn variable_name(&self) -> std::option::Option<&str> {
        self.variable_name.as_deref()
    }
    /// <p>The type of variable.</p>
    pub fn variable_type(&self) -> std::option::Option<&str> {
        self.variable_type.as_deref()
    }
    /// <p>The relative importance of the variable. For more information, see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/model-variable-importance.html">Model variable importance</a>.</p>
    pub fn variable_importance(&self) -> std::option::Option<f32> {
        self.variable_importance
    }
}
impl LogOddsMetric {
    /// Creates a new builder-style object to manufacture [`LogOddsMetric`](crate::model::LogOddsMetric).
    pub fn builder() -> crate::model::log_odds_metric::Builder {
        crate::model::log_odds_metric::Builder::default()
    }
}

/// See [`LogOddsMetric`](crate::model::LogOddsMetric).
pub mod log_odds_metric {

    /// A builder for [`LogOddsMetric`](crate::model::LogOddsMetric).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) variable_name: std::option::Option<std::string::String>,
        pub(crate) variable_type: std::option::Option<std::string::String>,
        pub(crate) variable_importance: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The name of the variable.</p>
        pub fn variable_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.variable_name = Some(input.into());
            self
        }
        /// <p>The name of the variable.</p>
        pub fn set_variable_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.variable_name = input;
            self
        }
        /// <p>The type of variable.</p>
        pub fn variable_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.variable_type = Some(input.into());
            self
        }
        /// <p>The type of variable.</p>
        pub fn set_variable_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.variable_type = input;
            self
        }
        /// <p>The relative importance of the variable. For more information, see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/model-variable-importance.html">Model variable importance</a>.</p>
        pub fn variable_importance(mut self, input: f32) -> Self {
            self.variable_importance = Some(input);
            self
        }
        /// <p>The relative importance of the variable. For more information, see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/model-variable-importance.html">Model variable importance</a>.</p>
        pub fn set_variable_importance(mut self, input: std::option::Option<f32>) -> Self {
            self.variable_importance = input;
            self
        }
        /// Consumes the builder and constructs a [`LogOddsMetric`](crate::model::LogOddsMetric).
        pub fn build(self) -> crate::model::LogOddsMetric {
            crate::model::LogOddsMetric {
                variable_name: self.variable_name,
                variable_type: self.variable_type,
                variable_importance: self.variable_importance,
            }
        }
    }
}

/// <p> The training metrics details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrainingMetricsV2 {
    /// <p> The Online Fraud Insights (OFI) model training metric details. </p>
    #[doc(hidden)]
    pub ofi: std::option::Option<crate::model::OfiTrainingMetricsValue>,
    /// <p> The Transaction Fraud Insights (TFI) model training metric details. </p>
    #[doc(hidden)]
    pub tfi: std::option::Option<crate::model::TfiTrainingMetricsValue>,
    /// <p> The Account Takeover Insights (ATI) model training metric details. </p>
    #[doc(hidden)]
    pub ati: std::option::Option<crate::model::AtiTrainingMetricsValue>,
}
impl TrainingMetricsV2 {
    /// <p> The Online Fraud Insights (OFI) model training metric details. </p>
    pub fn ofi(&self) -> std::option::Option<&crate::model::OfiTrainingMetricsValue> {
        self.ofi.as_ref()
    }
    /// <p> The Transaction Fraud Insights (TFI) model training metric details. </p>
    pub fn tfi(&self) -> std::option::Option<&crate::model::TfiTrainingMetricsValue> {
        self.tfi.as_ref()
    }
    /// <p> The Account Takeover Insights (ATI) model training metric details. </p>
    pub fn ati(&self) -> std::option::Option<&crate::model::AtiTrainingMetricsValue> {
        self.ati.as_ref()
    }
}
impl TrainingMetricsV2 {
    /// Creates a new builder-style object to manufacture [`TrainingMetricsV2`](crate::model::TrainingMetricsV2).
    pub fn builder() -> crate::model::training_metrics_v2::Builder {
        crate::model::training_metrics_v2::Builder::default()
    }
}

/// See [`TrainingMetricsV2`](crate::model::TrainingMetricsV2).
pub mod training_metrics_v2 {

    /// A builder for [`TrainingMetricsV2`](crate::model::TrainingMetricsV2).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ofi: std::option::Option<crate::model::OfiTrainingMetricsValue>,
        pub(crate) tfi: std::option::Option<crate::model::TfiTrainingMetricsValue>,
        pub(crate) ati: std::option::Option<crate::model::AtiTrainingMetricsValue>,
    }
    impl Builder {
        /// <p> The Online Fraud Insights (OFI) model training metric details. </p>
        pub fn ofi(mut self, input: crate::model::OfiTrainingMetricsValue) -> Self {
            self.ofi = Some(input);
            self
        }
        /// <p> The Online Fraud Insights (OFI) model training metric details. </p>
        pub fn set_ofi(
            mut self,
            input: std::option::Option<crate::model::OfiTrainingMetricsValue>,
        ) -> Self {
            self.ofi = input;
            self
        }
        /// <p> The Transaction Fraud Insights (TFI) model training metric details. </p>
        pub fn tfi(mut self, input: crate::model::TfiTrainingMetricsValue) -> Self {
            self.tfi = Some(input);
            self
        }
        /// <p> The Transaction Fraud Insights (TFI) model training metric details. </p>
        pub fn set_tfi(
            mut self,
            input: std::option::Option<crate::model::TfiTrainingMetricsValue>,
        ) -> Self {
            self.tfi = input;
            self
        }
        /// <p> The Account Takeover Insights (ATI) model training metric details. </p>
        pub fn ati(mut self, input: crate::model::AtiTrainingMetricsValue) -> Self {
            self.ati = Some(input);
            self
        }
        /// <p> The Account Takeover Insights (ATI) model training metric details. </p>
        pub fn set_ati(
            mut self,
            input: std::option::Option<crate::model::AtiTrainingMetricsValue>,
        ) -> Self {
            self.ati = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingMetricsV2`](crate::model::TrainingMetricsV2).
        pub fn build(self) -> crate::model::TrainingMetricsV2 {
            crate::model::TrainingMetricsV2 {
                ofi: self.ofi,
                tfi: self.tfi,
                ati: self.ati,
            }
        }
    }
}

/// <p> The Account Takeover Insights (ATI) model training metric details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AtiTrainingMetricsValue {
    /// <p> The model's performance metrics data points. </p>
    #[doc(hidden)]
    pub metric_data_points: std::option::Option<std::vec::Vec<crate::model::AtiMetricDataPoint>>,
    /// <p> The model's overall performance scores. </p>
    #[doc(hidden)]
    pub model_performance: std::option::Option<crate::model::AtiModelPerformance>,
}
impl AtiTrainingMetricsValue {
    /// <p> The model's performance metrics data points. </p>
    pub fn metric_data_points(&self) -> std::option::Option<&[crate::model::AtiMetricDataPoint]> {
        self.metric_data_points.as_deref()
    }
    /// <p> The model's overall performance scores. </p>
    pub fn model_performance(&self) -> std::option::Option<&crate::model::AtiModelPerformance> {
        self.model_performance.as_ref()
    }
}
impl AtiTrainingMetricsValue {
    /// Creates a new builder-style object to manufacture [`AtiTrainingMetricsValue`](crate::model::AtiTrainingMetricsValue).
    pub fn builder() -> crate::model::ati_training_metrics_value::Builder {
        crate::model::ati_training_metrics_value::Builder::default()
    }
}

/// See [`AtiTrainingMetricsValue`](crate::model::AtiTrainingMetricsValue).
pub mod ati_training_metrics_value {

    /// A builder for [`AtiTrainingMetricsValue`](crate::model::AtiTrainingMetricsValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_data_points:
            std::option::Option<std::vec::Vec<crate::model::AtiMetricDataPoint>>,
        pub(crate) model_performance: std::option::Option<crate::model::AtiModelPerformance>,
    }
    impl Builder {
        /// Appends an item to `metric_data_points`.
        ///
        /// To override the contents of this collection use [`set_metric_data_points`](Self::set_metric_data_points).
        ///
        /// <p> The model's performance metrics data points. </p>
        pub fn metric_data_points(mut self, input: crate::model::AtiMetricDataPoint) -> Self {
            let mut v = self.metric_data_points.unwrap_or_default();
            v.push(input);
            self.metric_data_points = Some(v);
            self
        }
        /// <p> The model's performance metrics data points. </p>
        pub fn set_metric_data_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::AtiMetricDataPoint>>,
        ) -> Self {
            self.metric_data_points = input;
            self
        }
        /// <p> The model's overall performance scores. </p>
        pub fn model_performance(mut self, input: crate::model::AtiModelPerformance) -> Self {
            self.model_performance = Some(input);
            self
        }
        /// <p> The model's overall performance scores. </p>
        pub fn set_model_performance(
            mut self,
            input: std::option::Option<crate::model::AtiModelPerformance>,
        ) -> Self {
            self.model_performance = input;
            self
        }
        /// Consumes the builder and constructs a [`AtiTrainingMetricsValue`](crate::model::AtiTrainingMetricsValue).
        pub fn build(self) -> crate::model::AtiTrainingMetricsValue {
            crate::model::AtiTrainingMetricsValue {
                metric_data_points: self.metric_data_points,
                model_performance: self.model_performance,
            }
        }
    }
}

/// <p> The Account Takeover Insights (ATI) model performance score. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AtiModelPerformance {
    /// <p> The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0 </p>
    #[doc(hidden)]
    pub asi: std::option::Option<f32>,
}
impl AtiModelPerformance {
    /// <p> The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0 </p>
    pub fn asi(&self) -> std::option::Option<f32> {
        self.asi
    }
}
impl AtiModelPerformance {
    /// Creates a new builder-style object to manufacture [`AtiModelPerformance`](crate::model::AtiModelPerformance).
    pub fn builder() -> crate::model::ati_model_performance::Builder {
        crate::model::ati_model_performance::Builder::default()
    }
}

/// See [`AtiModelPerformance`](crate::model::AtiModelPerformance).
pub mod ati_model_performance {

    /// A builder for [`AtiModelPerformance`](crate::model::AtiModelPerformance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) asi: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0 </p>
        pub fn asi(mut self, input: f32) -> Self {
            self.asi = Some(input);
            self
        }
        /// <p> The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0 </p>
        pub fn set_asi(mut self, input: std::option::Option<f32>) -> Self {
            self.asi = input;
            self
        }
        /// Consumes the builder and constructs a [`AtiModelPerformance`](crate::model::AtiModelPerformance).
        pub fn build(self) -> crate::model::AtiModelPerformance {
            crate::model::AtiModelPerformance { asi: self.asi }
        }
    }
}

/// <p> The Account Takeover Insights (ATI) model performance metrics data points. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AtiMetricDataPoint {
    /// <p> The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as one-time password, multi-factor authentication, and investigations. </p>
    #[doc(hidden)]
    pub cr: std::option::Option<f32>,
    /// <p> The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold. A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of login events, leading to a higher customer friction. </p>
    #[doc(hidden)]
    pub adr: std::option::Option<f32>,
    /// <p> The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
    #[doc(hidden)]
    pub threshold: std::option::Option<f32>,
    /// <p> The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset. </p>
    #[doc(hidden)]
    pub atodr: std::option::Option<f32>,
}
impl AtiMetricDataPoint {
    /// <p> The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as one-time password, multi-factor authentication, and investigations. </p>
    pub fn cr(&self) -> std::option::Option<f32> {
        self.cr
    }
    /// <p> The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold. A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of login events, leading to a higher customer friction. </p>
    pub fn adr(&self) -> std::option::Option<f32> {
        self.adr
    }
    /// <p> The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
    pub fn threshold(&self) -> std::option::Option<f32> {
        self.threshold
    }
    /// <p> The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset. </p>
    pub fn atodr(&self) -> std::option::Option<f32> {
        self.atodr
    }
}
impl AtiMetricDataPoint {
    /// Creates a new builder-style object to manufacture [`AtiMetricDataPoint`](crate::model::AtiMetricDataPoint).
    pub fn builder() -> crate::model::ati_metric_data_point::Builder {
        crate::model::ati_metric_data_point::Builder::default()
    }
}

/// See [`AtiMetricDataPoint`](crate::model::AtiMetricDataPoint).
pub mod ati_metric_data_point {

    /// A builder for [`AtiMetricDataPoint`](crate::model::AtiMetricDataPoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cr: std::option::Option<f32>,
        pub(crate) adr: std::option::Option<f32>,
        pub(crate) threshold: std::option::Option<f32>,
        pub(crate) atodr: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as one-time password, multi-factor authentication, and investigations. </p>
        pub fn cr(mut self, input: f32) -> Self {
            self.cr = Some(input);
            self
        }
        /// <p> The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as one-time password, multi-factor authentication, and investigations. </p>
        pub fn set_cr(mut self, input: std::option::Option<f32>) -> Self {
            self.cr = input;
            self
        }
        /// <p> The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold. A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of login events, leading to a higher customer friction. </p>
        pub fn adr(mut self, input: f32) -> Self {
            self.adr = Some(input);
            self
        }
        /// <p> The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold. A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of login events, leading to a higher customer friction. </p>
        pub fn set_adr(mut self, input: std::option::Option<f32>) -> Self {
            self.adr = input;
            self
        }
        /// <p> The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
        pub fn threshold(mut self, input: f32) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p> The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
        pub fn set_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.threshold = input;
            self
        }
        /// <p> The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset. </p>
        pub fn atodr(mut self, input: f32) -> Self {
            self.atodr = Some(input);
            self
        }
        /// <p> The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset. </p>
        pub fn set_atodr(mut self, input: std::option::Option<f32>) -> Self {
            self.atodr = input;
            self
        }
        /// Consumes the builder and constructs a [`AtiMetricDataPoint`](crate::model::AtiMetricDataPoint).
        pub fn build(self) -> crate::model::AtiMetricDataPoint {
            crate::model::AtiMetricDataPoint {
                cr: self.cr,
                adr: self.adr,
                threshold: self.threshold,
                atodr: self.atodr,
            }
        }
    }
}

/// <p> The Transaction Fraud Insights (TFI) model training metric details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TfiTrainingMetricsValue {
    /// <p> The model's performance metrics data points. </p>
    #[doc(hidden)]
    pub metric_data_points: std::option::Option<std::vec::Vec<crate::model::TfiMetricDataPoint>>,
    /// <p> The model performance score. </p>
    #[doc(hidden)]
    pub model_performance: std::option::Option<crate::model::TfiModelPerformance>,
}
impl TfiTrainingMetricsValue {
    /// <p> The model's performance metrics data points. </p>
    pub fn metric_data_points(&self) -> std::option::Option<&[crate::model::TfiMetricDataPoint]> {
        self.metric_data_points.as_deref()
    }
    /// <p> The model performance score. </p>
    pub fn model_performance(&self) -> std::option::Option<&crate::model::TfiModelPerformance> {
        self.model_performance.as_ref()
    }
}
impl TfiTrainingMetricsValue {
    /// Creates a new builder-style object to manufacture [`TfiTrainingMetricsValue`](crate::model::TfiTrainingMetricsValue).
    pub fn builder() -> crate::model::tfi_training_metrics_value::Builder {
        crate::model::tfi_training_metrics_value::Builder::default()
    }
}

/// See [`TfiTrainingMetricsValue`](crate::model::TfiTrainingMetricsValue).
pub mod tfi_training_metrics_value {

    /// A builder for [`TfiTrainingMetricsValue`](crate::model::TfiTrainingMetricsValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_data_points:
            std::option::Option<std::vec::Vec<crate::model::TfiMetricDataPoint>>,
        pub(crate) model_performance: std::option::Option<crate::model::TfiModelPerformance>,
    }
    impl Builder {
        /// Appends an item to `metric_data_points`.
        ///
        /// To override the contents of this collection use [`set_metric_data_points`](Self::set_metric_data_points).
        ///
        /// <p> The model's performance metrics data points. </p>
        pub fn metric_data_points(mut self, input: crate::model::TfiMetricDataPoint) -> Self {
            let mut v = self.metric_data_points.unwrap_or_default();
            v.push(input);
            self.metric_data_points = Some(v);
            self
        }
        /// <p> The model's performance metrics data points. </p>
        pub fn set_metric_data_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TfiMetricDataPoint>>,
        ) -> Self {
            self.metric_data_points = input;
            self
        }
        /// <p> The model performance score. </p>
        pub fn model_performance(mut self, input: crate::model::TfiModelPerformance) -> Self {
            self.model_performance = Some(input);
            self
        }
        /// <p> The model performance score. </p>
        pub fn set_model_performance(
            mut self,
            input: std::option::Option<crate::model::TfiModelPerformance>,
        ) -> Self {
            self.model_performance = input;
            self
        }
        /// Consumes the builder and constructs a [`TfiTrainingMetricsValue`](crate::model::TfiTrainingMetricsValue).
        pub fn build(self) -> crate::model::TfiTrainingMetricsValue {
            crate::model::TfiTrainingMetricsValue {
                metric_data_points: self.metric_data_points,
                model_performance: self.model_performance,
            }
        }
    }
}

/// <p> The Transaction Fraud Insights (TFI) model performance score. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TfiModelPerformance {
    /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
    #[doc(hidden)]
    pub auc: std::option::Option<f32>,
}
impl TfiModelPerformance {
    /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
    pub fn auc(&self) -> std::option::Option<f32> {
        self.auc
    }
}
impl TfiModelPerformance {
    /// Creates a new builder-style object to manufacture [`TfiModelPerformance`](crate::model::TfiModelPerformance).
    pub fn builder() -> crate::model::tfi_model_performance::Builder {
        crate::model::tfi_model_performance::Builder::default()
    }
}

/// See [`TfiModelPerformance`](crate::model::TfiModelPerformance).
pub mod tfi_model_performance {

    /// A builder for [`TfiModelPerformance`](crate::model::TfiModelPerformance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auc: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
        pub fn auc(mut self, input: f32) -> Self {
            self.auc = Some(input);
            self
        }
        /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
        pub fn set_auc(mut self, input: std::option::Option<f32>) -> Self {
            self.auc = input;
            self
        }
        /// Consumes the builder and constructs a [`TfiModelPerformance`](crate::model::TfiModelPerformance).
        pub fn build(self) -> crate::model::TfiModelPerformance {
            crate::model::TfiModelPerformance { auc: self.auc }
        }
    }
}

/// <p> The performance metrics data points for Transaction Fraud Insights (TFI) model. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TfiMetricDataPoint {
    /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
    #[doc(hidden)]
    pub fpr: std::option::Option<f32>,
    /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
    #[doc(hidden)]
    pub precision: std::option::Option<f32>,
    /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
    #[doc(hidden)]
    pub tpr: std::option::Option<f32>,
    /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
    #[doc(hidden)]
    pub threshold: std::option::Option<f32>,
}
impl TfiMetricDataPoint {
    /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
    pub fn fpr(&self) -> std::option::Option<f32> {
        self.fpr
    }
    /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
    pub fn precision(&self) -> std::option::Option<f32> {
        self.precision
    }
    /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
    pub fn tpr(&self) -> std::option::Option<f32> {
        self.tpr
    }
    /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
    pub fn threshold(&self) -> std::option::Option<f32> {
        self.threshold
    }
}
impl TfiMetricDataPoint {
    /// Creates a new builder-style object to manufacture [`TfiMetricDataPoint`](crate::model::TfiMetricDataPoint).
    pub fn builder() -> crate::model::tfi_metric_data_point::Builder {
        crate::model::tfi_metric_data_point::Builder::default()
    }
}

/// See [`TfiMetricDataPoint`](crate::model::TfiMetricDataPoint).
pub mod tfi_metric_data_point {

    /// A builder for [`TfiMetricDataPoint`](crate::model::TfiMetricDataPoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fpr: std::option::Option<f32>,
        pub(crate) precision: std::option::Option<f32>,
        pub(crate) tpr: std::option::Option<f32>,
        pub(crate) threshold: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
        pub fn fpr(mut self, input: f32) -> Self {
            self.fpr = Some(input);
            self
        }
        /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
        pub fn set_fpr(mut self, input: std::option::Option<f32>) -> Self {
            self.fpr = input;
            self
        }
        /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
        pub fn precision(mut self, input: f32) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
        pub fn set_precision(mut self, input: std::option::Option<f32>) -> Self {
            self.precision = input;
            self
        }
        /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
        pub fn tpr(mut self, input: f32) -> Self {
            self.tpr = Some(input);
            self
        }
        /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
        pub fn set_tpr(mut self, input: std::option::Option<f32>) -> Self {
            self.tpr = input;
            self
        }
        /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
        pub fn threshold(mut self, input: f32) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
        pub fn set_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`TfiMetricDataPoint`](crate::model::TfiMetricDataPoint).
        pub fn build(self) -> crate::model::TfiMetricDataPoint {
            crate::model::TfiMetricDataPoint {
                fpr: self.fpr,
                precision: self.precision,
                tpr: self.tpr,
                threshold: self.threshold,
            }
        }
    }
}

/// <p> The Online Fraud Insights (OFI) model training metric details. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OfiTrainingMetricsValue {
    /// <p> The model's performance metrics data points. </p>
    #[doc(hidden)]
    pub metric_data_points: std::option::Option<std::vec::Vec<crate::model::OfiMetricDataPoint>>,
    /// <p> The model's overall performance score. </p>
    #[doc(hidden)]
    pub model_performance: std::option::Option<crate::model::OfiModelPerformance>,
}
impl OfiTrainingMetricsValue {
    /// <p> The model's performance metrics data points. </p>
    pub fn metric_data_points(&self) -> std::option::Option<&[crate::model::OfiMetricDataPoint]> {
        self.metric_data_points.as_deref()
    }
    /// <p> The model's overall performance score. </p>
    pub fn model_performance(&self) -> std::option::Option<&crate::model::OfiModelPerformance> {
        self.model_performance.as_ref()
    }
}
impl OfiTrainingMetricsValue {
    /// Creates a new builder-style object to manufacture [`OfiTrainingMetricsValue`](crate::model::OfiTrainingMetricsValue).
    pub fn builder() -> crate::model::ofi_training_metrics_value::Builder {
        crate::model::ofi_training_metrics_value::Builder::default()
    }
}

/// See [`OfiTrainingMetricsValue`](crate::model::OfiTrainingMetricsValue).
pub mod ofi_training_metrics_value {

    /// A builder for [`OfiTrainingMetricsValue`](crate::model::OfiTrainingMetricsValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_data_points:
            std::option::Option<std::vec::Vec<crate::model::OfiMetricDataPoint>>,
        pub(crate) model_performance: std::option::Option<crate::model::OfiModelPerformance>,
    }
    impl Builder {
        /// Appends an item to `metric_data_points`.
        ///
        /// To override the contents of this collection use [`set_metric_data_points`](Self::set_metric_data_points).
        ///
        /// <p> The model's performance metrics data points. </p>
        pub fn metric_data_points(mut self, input: crate::model::OfiMetricDataPoint) -> Self {
            let mut v = self.metric_data_points.unwrap_or_default();
            v.push(input);
            self.metric_data_points = Some(v);
            self
        }
        /// <p> The model's performance metrics data points. </p>
        pub fn set_metric_data_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::OfiMetricDataPoint>>,
        ) -> Self {
            self.metric_data_points = input;
            self
        }
        /// <p> The model's overall performance score. </p>
        pub fn model_performance(mut self, input: crate::model::OfiModelPerformance) -> Self {
            self.model_performance = Some(input);
            self
        }
        /// <p> The model's overall performance score. </p>
        pub fn set_model_performance(
            mut self,
            input: std::option::Option<crate::model::OfiModelPerformance>,
        ) -> Self {
            self.model_performance = input;
            self
        }
        /// Consumes the builder and constructs a [`OfiTrainingMetricsValue`](crate::model::OfiTrainingMetricsValue).
        pub fn build(self) -> crate::model::OfiTrainingMetricsValue {
            crate::model::OfiTrainingMetricsValue {
                metric_data_points: self.metric_data_points,
                model_performance: self.model_performance,
            }
        }
    }
}

/// <p> The Online Fraud Insights (OFI) model performance score. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OfiModelPerformance {
    /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
    #[doc(hidden)]
    pub auc: std::option::Option<f32>,
}
impl OfiModelPerformance {
    /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
    pub fn auc(&self) -> std::option::Option<f32> {
        self.auc
    }
}
impl OfiModelPerformance {
    /// Creates a new builder-style object to manufacture [`OfiModelPerformance`](crate::model::OfiModelPerformance).
    pub fn builder() -> crate::model::ofi_model_performance::Builder {
        crate::model::ofi_model_performance::Builder::default()
    }
}

/// See [`OfiModelPerformance`](crate::model::OfiModelPerformance).
pub mod ofi_model_performance {

    /// A builder for [`OfiModelPerformance`](crate::model::OfiModelPerformance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auc: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
        pub fn auc(mut self, input: f32) -> Self {
            self.auc = Some(input);
            self
        }
        /// <p> The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds. </p>
        pub fn set_auc(mut self, input: std::option::Option<f32>) -> Self {
            self.auc = input;
            self
        }
        /// Consumes the builder and constructs a [`OfiModelPerformance`](crate::model::OfiModelPerformance).
        pub fn build(self) -> crate::model::OfiModelPerformance {
            crate::model::OfiModelPerformance { auc: self.auc }
        }
    }
}

/// <p> The Online Fraud Insights (OFI) model performance metrics data points. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OfiMetricDataPoint {
    /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
    #[doc(hidden)]
    pub fpr: std::option::Option<f32>,
    /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
    #[doc(hidden)]
    pub precision: std::option::Option<f32>,
    /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
    #[doc(hidden)]
    pub tpr: std::option::Option<f32>,
    /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
    #[doc(hidden)]
    pub threshold: std::option::Option<f32>,
}
impl OfiMetricDataPoint {
    /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
    pub fn fpr(&self) -> std::option::Option<f32> {
        self.fpr
    }
    /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
    pub fn precision(&self) -> std::option::Option<f32> {
        self.precision
    }
    /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
    pub fn tpr(&self) -> std::option::Option<f32> {
        self.tpr
    }
    /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
    pub fn threshold(&self) -> std::option::Option<f32> {
        self.threshold
    }
}
impl OfiMetricDataPoint {
    /// Creates a new builder-style object to manufacture [`OfiMetricDataPoint`](crate::model::OfiMetricDataPoint).
    pub fn builder() -> crate::model::ofi_metric_data_point::Builder {
        crate::model::ofi_metric_data_point::Builder::default()
    }
}

/// See [`OfiMetricDataPoint`](crate::model::OfiMetricDataPoint).
pub mod ofi_metric_data_point {

    /// A builder for [`OfiMetricDataPoint`](crate::model::OfiMetricDataPoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fpr: std::option::Option<f32>,
        pub(crate) precision: std::option::Option<f32>,
        pub(crate) tpr: std::option::Option<f32>,
        pub(crate) threshold: std::option::Option<f32>,
    }
    impl Builder {
        /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
        pub fn fpr(mut self, input: f32) -> Self {
            self.fpr = Some(input);
            self
        }
        /// <p> The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud. </p>
        pub fn set_fpr(mut self, input: std::option::Option<f32>) -> Self {
            self.fpr = input;
            self
        }
        /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
        pub fn precision(mut self, input: f32) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p> The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent. </p>
        pub fn set_precision(mut self, input: std::option::Option<f32>) -> Self {
            self.precision = input;
            self
        }
        /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
        pub fn tpr(mut self, input: f32) -> Self {
            self.tpr = Some(input);
            self
        }
        /// <p> The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate. </p>
        pub fn set_tpr(mut self, input: std::option::Option<f32>) -> Self {
            self.tpr = input;
            self
        }
        /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
        pub fn threshold(mut self, input: f32) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p> The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud. </p>
        pub fn set_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`OfiMetricDataPoint`](crate::model::OfiMetricDataPoint).
        pub fn build(self) -> crate::model::OfiMetricDataPoint {
            crate::model::OfiMetricDataPoint {
                fpr: self.fpr,
                precision: self.precision,
                tpr: self.tpr,
                threshold: self.threshold,
            }
        }
    }
}

/// <p>The model training data validation metrics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataValidationMetrics {
    /// <p>The file-specific model training data validation messages.</p>
    #[doc(hidden)]
    pub file_level_messages:
        std::option::Option<std::vec::Vec<crate::model::FileValidationMessage>>,
    /// <p>The field-specific model training validation messages.</p>
    #[doc(hidden)]
    pub field_level_messages:
        std::option::Option<std::vec::Vec<crate::model::FieldValidationMessage>>,
}
impl DataValidationMetrics {
    /// <p>The file-specific model training data validation messages.</p>
    pub fn file_level_messages(
        &self,
    ) -> std::option::Option<&[crate::model::FileValidationMessage]> {
        self.file_level_messages.as_deref()
    }
    /// <p>The field-specific model training validation messages.</p>
    pub fn field_level_messages(
        &self,
    ) -> std::option::Option<&[crate::model::FieldValidationMessage]> {
        self.field_level_messages.as_deref()
    }
}
impl DataValidationMetrics {
    /// Creates a new builder-style object to manufacture [`DataValidationMetrics`](crate::model::DataValidationMetrics).
    pub fn builder() -> crate::model::data_validation_metrics::Builder {
        crate::model::data_validation_metrics::Builder::default()
    }
}

/// See [`DataValidationMetrics`](crate::model::DataValidationMetrics).
pub mod data_validation_metrics {

    /// A builder for [`DataValidationMetrics`](crate::model::DataValidationMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) file_level_messages:
            std::option::Option<std::vec::Vec<crate::model::FileValidationMessage>>,
        pub(crate) field_level_messages:
            std::option::Option<std::vec::Vec<crate::model::FieldValidationMessage>>,
    }
    impl Builder {
        /// Appends an item to `file_level_messages`.
        ///
        /// To override the contents of this collection use [`set_file_level_messages`](Self::set_file_level_messages).
        ///
        /// <p>The file-specific model training data validation messages.</p>
        pub fn file_level_messages(mut self, input: crate::model::FileValidationMessage) -> Self {
            let mut v = self.file_level_messages.unwrap_or_default();
            v.push(input);
            self.file_level_messages = Some(v);
            self
        }
        /// <p>The file-specific model training data validation messages.</p>
        pub fn set_file_level_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FileValidationMessage>>,
        ) -> Self {
            self.file_level_messages = input;
            self
        }
        /// Appends an item to `field_level_messages`.
        ///
        /// To override the contents of this collection use [`set_field_level_messages`](Self::set_field_level_messages).
        ///
        /// <p>The field-specific model training validation messages.</p>
        pub fn field_level_messages(mut self, input: crate::model::FieldValidationMessage) -> Self {
            let mut v = self.field_level_messages.unwrap_or_default();
            v.push(input);
            self.field_level_messages = Some(v);
            self
        }
        /// <p>The field-specific model training validation messages.</p>
        pub fn set_field_level_messages(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldValidationMessage>>,
        ) -> Self {
            self.field_level_messages = input;
            self
        }
        /// Consumes the builder and constructs a [`DataValidationMetrics`](crate::model::DataValidationMetrics).
        pub fn build(self) -> crate::model::DataValidationMetrics {
            crate::model::DataValidationMetrics {
                file_level_messages: self.file_level_messages,
                field_level_messages: self.field_level_messages,
            }
        }
    }
}

/// <p>The message details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldValidationMessage {
    /// <p>The field name.</p>
    #[doc(hidden)]
    pub field_name: std::option::Option<std::string::String>,
    /// <p>The message ID.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>The message title.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The message content.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The message type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl FieldValidationMessage {
    /// <p>The field name.</p>
    pub fn field_name(&self) -> std::option::Option<&str> {
        self.field_name.as_deref()
    }
    /// <p>The message ID.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>The message title.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The message content.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The message type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl FieldValidationMessage {
    /// Creates a new builder-style object to manufacture [`FieldValidationMessage`](crate::model::FieldValidationMessage).
    pub fn builder() -> crate::model::field_validation_message::Builder {
        crate::model::field_validation_message::Builder::default()
    }
}

/// See [`FieldValidationMessage`](crate::model::FieldValidationMessage).
pub mod field_validation_message {

    /// A builder for [`FieldValidationMessage`](crate::model::FieldValidationMessage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_name: std::option::Option<std::string::String>,
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field name.</p>
        pub fn field_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_name = Some(input.into());
            self
        }
        /// <p>The field name.</p>
        pub fn set_field_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_name = input;
            self
        }
        /// <p>The message ID.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>The message ID.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>The message title.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The message title.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The message content.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The message content.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The message type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The message type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldValidationMessage`](crate::model::FieldValidationMessage).
        pub fn build(self) -> crate::model::FieldValidationMessage {
            crate::model::FieldValidationMessage {
                field_name: self.field_name,
                identifier: self.identifier,
                title: self.title,
                content: self.content,
                r#type: self.r#type,
            }
        }
    }
}

/// <p>The message details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileValidationMessage {
    /// <p>The message title.</p>
    #[doc(hidden)]
    pub title: std::option::Option<std::string::String>,
    /// <p>The message content.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The message type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl FileValidationMessage {
    /// <p>The message title.</p>
    pub fn title(&self) -> std::option::Option<&str> {
        self.title.as_deref()
    }
    /// <p>The message content.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The message type.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl FileValidationMessage {
    /// Creates a new builder-style object to manufacture [`FileValidationMessage`](crate::model::FileValidationMessage).
    pub fn builder() -> crate::model::file_validation_message::Builder {
        crate::model::file_validation_message::Builder::default()
    }
}

/// See [`FileValidationMessage`](crate::model::FileValidationMessage).
pub mod file_validation_message {

    /// A builder for [`FileValidationMessage`](crate::model::FileValidationMessage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message title.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The message title.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The message content.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The message content.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The message type.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The message type.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`FileValidationMessage`](crate::model::FileValidationMessage).
        pub fn build(self) -> crate::model::FileValidationMessage {
            crate::model::FileValidationMessage {
                title: self.title,
                content: self.content,
                r#type: self.r#type,
            }
        }
    }
}

/// <p>The training result details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrainingResult {
    /// <p>The validation metrics.</p>
    #[doc(hidden)]
    pub data_validation_metrics: std::option::Option<crate::model::DataValidationMetrics>,
    /// <p>The training metric details.</p>
    #[doc(hidden)]
    pub training_metrics: std::option::Option<crate::model::TrainingMetrics>,
    /// <p>The variable importance metrics.</p>
    #[doc(hidden)]
    pub variable_importance_metrics: std::option::Option<crate::model::VariableImportanceMetrics>,
}
impl TrainingResult {
    /// <p>The validation metrics.</p>
    pub fn data_validation_metrics(
        &self,
    ) -> std::option::Option<&crate::model::DataValidationMetrics> {
        self.data_validation_metrics.as_ref()
    }
    /// <p>The training metric details.</p>
    pub fn training_metrics(&self) -> std::option::Option<&crate::model::TrainingMetrics> {
        self.training_metrics.as_ref()
    }
    /// <p>The variable importance metrics.</p>
    pub fn variable_importance_metrics(
        &self,
    ) -> std::option::Option<&crate::model::VariableImportanceMetrics> {
        self.variable_importance_metrics.as_ref()
    }
}
impl TrainingResult {
    /// Creates a new builder-style object to manufacture [`TrainingResult`](crate::model::TrainingResult).
    pub fn builder() -> crate::model::training_result::Builder {
        crate::model::training_result::Builder::default()
    }
}

/// See [`TrainingResult`](crate::model::TrainingResult).
pub mod training_result {

    /// A builder for [`TrainingResult`](crate::model::TrainingResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_validation_metrics:
            std::option::Option<crate::model::DataValidationMetrics>,
        pub(crate) training_metrics: std::option::Option<crate::model::TrainingMetrics>,
        pub(crate) variable_importance_metrics:
            std::option::Option<crate::model::VariableImportanceMetrics>,
    }
    impl Builder {
        /// <p>The validation metrics.</p>
        pub fn data_validation_metrics(
            mut self,
            input: crate::model::DataValidationMetrics,
        ) -> Self {
            self.data_validation_metrics = Some(input);
            self
        }
        /// <p>The validation metrics.</p>
        pub fn set_data_validation_metrics(
            mut self,
            input: std::option::Option<crate::model::DataValidationMetrics>,
        ) -> Self {
            self.data_validation_metrics = input;
            self
        }
        /// <p>The training metric details.</p>
        pub fn training_metrics(mut self, input: crate::model::TrainingMetrics) -> Self {
            self.training_metrics = Some(input);
            self
        }
        /// <p>The training metric details.</p>
        pub fn set_training_metrics(
            mut self,
            input: std::option::Option<crate::model::TrainingMetrics>,
        ) -> Self {
            self.training_metrics = input;
            self
        }
        /// <p>The variable importance metrics.</p>
        pub fn variable_importance_metrics(
            mut self,
            input: crate::model::VariableImportanceMetrics,
        ) -> Self {
            self.variable_importance_metrics = Some(input);
            self
        }
        /// <p>The variable importance metrics.</p>
        pub fn set_variable_importance_metrics(
            mut self,
            input: std::option::Option<crate::model::VariableImportanceMetrics>,
        ) -> Self {
            self.variable_importance_metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingResult`](crate::model::TrainingResult).
        pub fn build(self) -> crate::model::TrainingResult {
            crate::model::TrainingResult {
                data_validation_metrics: self.data_validation_metrics,
                training_metrics: self.training_metrics,
                variable_importance_metrics: self.variable_importance_metrics,
            }
        }
    }
}

/// <p>The training metric details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TrainingMetrics {
    /// <p>The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.</p>
    #[doc(hidden)]
    pub auc: std::option::Option<f32>,
    /// <p>The data points details.</p>
    #[doc(hidden)]
    pub metric_data_points: std::option::Option<std::vec::Vec<crate::model::MetricDataPoint>>,
}
impl TrainingMetrics {
    /// <p>The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.</p>
    pub fn auc(&self) -> std::option::Option<f32> {
        self.auc
    }
    /// <p>The data points details.</p>
    pub fn metric_data_points(&self) -> std::option::Option<&[crate::model::MetricDataPoint]> {
        self.metric_data_points.as_deref()
    }
}
impl TrainingMetrics {
    /// Creates a new builder-style object to manufacture [`TrainingMetrics`](crate::model::TrainingMetrics).
    pub fn builder() -> crate::model::training_metrics::Builder {
        crate::model::training_metrics::Builder::default()
    }
}

/// See [`TrainingMetrics`](crate::model::TrainingMetrics).
pub mod training_metrics {

    /// A builder for [`TrainingMetrics`](crate::model::TrainingMetrics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auc: std::option::Option<f32>,
        pub(crate) metric_data_points:
            std::option::Option<std::vec::Vec<crate::model::MetricDataPoint>>,
    }
    impl Builder {
        /// <p>The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.</p>
        pub fn auc(mut self, input: f32) -> Self {
            self.auc = Some(input);
            self
        }
        /// <p>The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.</p>
        pub fn set_auc(mut self, input: std::option::Option<f32>) -> Self {
            self.auc = input;
            self
        }
        /// Appends an item to `metric_data_points`.
        ///
        /// To override the contents of this collection use [`set_metric_data_points`](Self::set_metric_data_points).
        ///
        /// <p>The data points details.</p>
        pub fn metric_data_points(mut self, input: crate::model::MetricDataPoint) -> Self {
            let mut v = self.metric_data_points.unwrap_or_default();
            v.push(input);
            self.metric_data_points = Some(v);
            self
        }
        /// <p>The data points details.</p>
        pub fn set_metric_data_points(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDataPoint>>,
        ) -> Self {
            self.metric_data_points = input;
            self
        }
        /// Consumes the builder and constructs a [`TrainingMetrics`](crate::model::TrainingMetrics).
        pub fn build(self) -> crate::model::TrainingMetrics {
            crate::model::TrainingMetrics {
                auc: self.auc,
                metric_data_points: self.metric_data_points,
            }
        }
    }
}

/// <p>Model performance metrics data points.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MetricDataPoint {
    /// <p>The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.</p>
    #[doc(hidden)]
    pub fpr: std::option::Option<f32>,
    /// <p>The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.</p>
    #[doc(hidden)]
    pub precision: std::option::Option<f32>,
    /// <p>The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.</p>
    #[doc(hidden)]
    pub tpr: std::option::Option<f32>,
    /// <p>The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.</p>
    #[doc(hidden)]
    pub threshold: std::option::Option<f32>,
}
impl MetricDataPoint {
    /// <p>The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.</p>
    pub fn fpr(&self) -> std::option::Option<f32> {
        self.fpr
    }
    /// <p>The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.</p>
    pub fn precision(&self) -> std::option::Option<f32> {
        self.precision
    }
    /// <p>The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.</p>
    pub fn tpr(&self) -> std::option::Option<f32> {
        self.tpr
    }
    /// <p>The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.</p>
    pub fn threshold(&self) -> std::option::Option<f32> {
        self.threshold
    }
}
impl MetricDataPoint {
    /// Creates a new builder-style object to manufacture [`MetricDataPoint`](crate::model::MetricDataPoint).
    pub fn builder() -> crate::model::metric_data_point::Builder {
        crate::model::metric_data_point::Builder::default()
    }
}

/// See [`MetricDataPoint`](crate::model::MetricDataPoint).
pub mod metric_data_point {

    /// A builder for [`MetricDataPoint`](crate::model::MetricDataPoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fpr: std::option::Option<f32>,
        pub(crate) precision: std::option::Option<f32>,
        pub(crate) tpr: std::option::Option<f32>,
        pub(crate) threshold: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.</p>
        pub fn fpr(mut self, input: f32) -> Self {
            self.fpr = Some(input);
            self
        }
        /// <p>The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.</p>
        pub fn set_fpr(mut self, input: std::option::Option<f32>) -> Self {
            self.fpr = input;
            self
        }
        /// <p>The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.</p>
        pub fn precision(mut self, input: f32) -> Self {
            self.precision = Some(input);
            self
        }
        /// <p>The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.</p>
        pub fn set_precision(mut self, input: std::option::Option<f32>) -> Self {
            self.precision = input;
            self
        }
        /// <p>The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.</p>
        pub fn tpr(mut self, input: f32) -> Self {
            self.tpr = Some(input);
            self
        }
        /// <p>The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.</p>
        pub fn set_tpr(mut self, input: std::option::Option<f32>) -> Self {
            self.tpr = input;
            self
        }
        /// <p>The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.</p>
        pub fn threshold(mut self, input: f32) -> Self {
            self.threshold = Some(input);
            self
        }
        /// <p>The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.</p>
        pub fn set_threshold(mut self, input: std::option::Option<f32>) -> Self {
            self.threshold = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDataPoint`](crate::model::MetricDataPoint).
        pub fn build(self) -> crate::model::MetricDataPoint {
            crate::model::MetricDataPoint {
                fpr: self.fpr,
                precision: self.precision,
                tpr: self.tpr,
                threshold: self.threshold,
            }
        }
    }
}

/// <p>The summary of the detector version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DetectorVersionSummary {
    /// <p>The detector version ID. </p>
    #[doc(hidden)]
    pub detector_version_id: std::option::Option<std::string::String>,
    /// <p>The detector version status. </p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DetectorVersionStatus>,
    /// <p>The detector version description. </p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Timestamp of when the detector version was last updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<std::string::String>,
}
impl DetectorVersionSummary {
    /// <p>The detector version ID. </p>
    pub fn detector_version_id(&self) -> std::option::Option<&str> {
        self.detector_version_id.as_deref()
    }
    /// <p>The detector version status. </p>
    pub fn status(&self) -> std::option::Option<&crate::model::DetectorVersionStatus> {
        self.status.as_ref()
    }
    /// <p>The detector version description. </p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Timestamp of when the detector version was last updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&str> {
        self.last_updated_time.as_deref()
    }
}
impl DetectorVersionSummary {
    /// Creates a new builder-style object to manufacture [`DetectorVersionSummary`](crate::model::DetectorVersionSummary).
    pub fn builder() -> crate::model::detector_version_summary::Builder {
        crate::model::detector_version_summary::Builder::default()
    }
}

/// See [`DetectorVersionSummary`](crate::model::DetectorVersionSummary).
pub mod detector_version_summary {

    /// A builder for [`DetectorVersionSummary`](crate::model::DetectorVersionSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detector_version_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::DetectorVersionStatus>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) last_updated_time: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The detector version ID. </p>
        pub fn detector_version_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.detector_version_id = Some(input.into());
            self
        }
        /// <p>The detector version ID. </p>
        pub fn set_detector_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.detector_version_id = input;
            self
        }
        /// <p>The detector version status. </p>
        pub fn status(mut self, input: crate::model::DetectorVersionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The detector version status. </p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DetectorVersionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The detector version description. </p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The detector version description. </p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Timestamp of when the detector version was last updated.</p>
        pub fn last_updated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_time = Some(input.into());
            self
        }
        /// <p>Timestamp of when the detector version was last updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectorVersionSummary`](crate::model::DetectorVersionSummary).
        pub fn build(self) -> crate::model::DetectorVersionSummary {
            crate::model::DetectorVersionSummary {
                detector_version_id: self.detector_version_id,
                status: self.status,
                description: self.description,
                last_updated_time: self.last_updated_time,
            }
        }
    }
}

/// <p>Provides the error of the batch get variable API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetVariableError {
    /// <p>The error name. </p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The error code. </p>
    #[doc(hidden)]
    pub code: i32,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl BatchGetVariableError {
    /// <p>The error name. </p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The error code. </p>
    pub fn code(&self) -> i32 {
        self.code
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl BatchGetVariableError {
    /// Creates a new builder-style object to manufacture [`BatchGetVariableError`](crate::model::BatchGetVariableError).
    pub fn builder() -> crate::model::batch_get_variable_error::Builder {
        crate::model::batch_get_variable_error::Builder::default()
    }
}

/// See [`BatchGetVariableError`](crate::model::BatchGetVariableError).
pub mod batch_get_variable_error {

    /// A builder for [`BatchGetVariableError`](crate::model::BatchGetVariableError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<i32>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The error name. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The error name. </p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The error code. </p>
        pub fn code(mut self, input: i32) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code. </p>
        pub fn set_code(mut self, input: std::option::Option<i32>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetVariableError`](crate::model::BatchGetVariableError).
        pub fn build(self) -> crate::model::BatchGetVariableError {
            crate::model::BatchGetVariableError {
                name: self.name,
                code: self.code.unwrap_or_default(),
                message: self.message,
            }
        }
    }
}

/// <p>Provides the error of the batch create variable API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchCreateVariableError {
    /// <p>The name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The error code. </p>
    #[doc(hidden)]
    pub code: i32,
    /// <p>The error message.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl BatchCreateVariableError {
    /// <p>The name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The error code. </p>
    pub fn code(&self) -> i32 {
        self.code
    }
    /// <p>The error message.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl BatchCreateVariableError {
    /// Creates a new builder-style object to manufacture [`BatchCreateVariableError`](crate::model::BatchCreateVariableError).
    pub fn builder() -> crate::model::batch_create_variable_error::Builder {
        crate::model::batch_create_variable_error::Builder::default()
    }
}

/// See [`BatchCreateVariableError`](crate::model::BatchCreateVariableError).
pub mod batch_create_variable_error {

    /// A builder for [`BatchCreateVariableError`](crate::model::BatchCreateVariableError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<i32>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The error code. </p>
        pub fn code(mut self, input: i32) -> Self {
            self.code = Some(input);
            self
        }
        /// <p>The error code. </p>
        pub fn set_code(mut self, input: std::option::Option<i32>) -> Self {
            self.code = input;
            self
        }
        /// <p>The error message.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchCreateVariableError`](crate::model::BatchCreateVariableError).
        pub fn build(self) -> crate::model::BatchCreateVariableError {
            crate::model::BatchCreateVariableError {
                name: self.name,
                code: self.code.unwrap_or_default(),
                message: self.message,
            }
        }
    }
}

/// <p>A variable in the list of variables for the batch create variable request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VariableEntry {
    /// <p>The name of the variable.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The data type of the variable.</p>
    #[doc(hidden)]
    pub data_type: std::option::Option<std::string::String>,
    /// <p>The data source of the variable.</p>
    #[doc(hidden)]
    pub data_source: std::option::Option<std::string::String>,
    /// <p>The default value of the variable.</p>
    #[doc(hidden)]
    pub default_value: std::option::Option<std::string::String>,
    /// <p>The description of the variable.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
    #[doc(hidden)]
    pub variable_type: std::option::Option<std::string::String>,
}
impl VariableEntry {
    /// <p>The name of the variable.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The data type of the variable.</p>
    pub fn data_type(&self) -> std::option::Option<&str> {
        self.data_type.as_deref()
    }
    /// <p>The data source of the variable.</p>
    pub fn data_source(&self) -> std::option::Option<&str> {
        self.data_source.as_deref()
    }
    /// <p>The default value of the variable.</p>
    pub fn default_value(&self) -> std::option::Option<&str> {
        self.default_value.as_deref()
    }
    /// <p>The description of the variable.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
    /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
    pub fn variable_type(&self) -> std::option::Option<&str> {
        self.variable_type.as_deref()
    }
}
impl VariableEntry {
    /// Creates a new builder-style object to manufacture [`VariableEntry`](crate::model::VariableEntry).
    pub fn builder() -> crate::model::variable_entry::Builder {
        crate::model::variable_entry::Builder::default()
    }
}

/// See [`VariableEntry`](crate::model::VariableEntry).
pub mod variable_entry {

    /// A builder for [`VariableEntry`](crate::model::VariableEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) data_type: std::option::Option<std::string::String>,
        pub(crate) data_source: std::option::Option<std::string::String>,
        pub(crate) default_value: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) variable_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the variable.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the variable.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The data type of the variable.</p>
        pub fn data_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_type = Some(input.into());
            self
        }
        /// <p>The data type of the variable.</p>
        pub fn set_data_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The data source of the variable.</p>
        pub fn data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_source = Some(input.into());
            self
        }
        /// <p>The data source of the variable.</p>
        pub fn set_data_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_source = input;
            self
        }
        /// <p>The default value of the variable.</p>
        pub fn default_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_value = Some(input.into());
            self
        }
        /// <p>The default value of the variable.</p>
        pub fn set_default_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The description of the variable.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the variable.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
        /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
        pub fn variable_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.variable_type = Some(input.into());
            self
        }
        /// <p>The type of the variable. For more information see <a href="https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types">Variable types</a>.</p>
        /// <p>Valid Values: <code>AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT </code> </p>
        pub fn set_variable_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.variable_type = input;
            self
        }
        /// Consumes the builder and constructs a [`VariableEntry`](crate::model::VariableEntry).
        pub fn build(self) -> crate::model::VariableEntry {
            crate::model::VariableEntry {
                name: self.name,
                data_type: self.data_type,
                data_source: self.data_source,
                default_value: self.default_value,
                description: self.description,
                variable_type: self.variable_type,
            }
        }
    }
}
