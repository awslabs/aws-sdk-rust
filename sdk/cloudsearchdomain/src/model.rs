// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A warning returned by the document service when an issue is discovered while processing an upload request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DocumentServiceWarning  {
    /// <p>The description for a warning returned by the document service.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl DocumentServiceWarning {
    /// <p>The description for a warning returned by the document service.</p>
    pub fn message(&self) -> std::option::Option<& str> {
        self.message.as_deref()
    }
}
/// See [`DocumentServiceWarning`](crate::model::DocumentServiceWarning).
pub mod document_service_warning {
    
    /// A builder for [`DocumentServiceWarning`](crate::model::DocumentServiceWarning).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The description for a warning returned by the document service.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The description for a warning returned by the document service.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`DocumentServiceWarning`](crate::model::DocumentServiceWarning).
        pub fn build(self) -> crate::model::DocumentServiceWarning {
            crate::model::DocumentServiceWarning {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl DocumentServiceWarning {
    /// Creates a new builder-style object to manufacture [`DocumentServiceWarning`](crate::model::DocumentServiceWarning).
    pub fn builder() -> crate::model::document_service_warning::Builder {
        crate::model::document_service_warning::Builder::default()
    }
}

/// When writing a match expression against `ContentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let contenttype = unimplemented!();
/// match contenttype {
///     ContentType::ApplicationJson => { /* ... */ },
///     ContentType::ApplicationXml => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `contenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ContentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ContentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ContentType::NewFeature` is defined.
/// Specifically, when `contenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ContentType::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum ContentType {
    #[allow(missing_docs)] // documentation missing in model
    ApplicationJson,
    #[allow(missing_docs)] // documentation missing in model
    ApplicationXml,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for ContentType {
    fn from(s: &str) -> Self {
        match s {
            "application/json" => ContentType::ApplicationJson,
            "application/xml" => ContentType::ApplicationXml,
            other => ContentType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for ContentType {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(ContentType::from(s))
                }
            }
impl ContentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ContentType::ApplicationJson => "application/json",
            ContentType::ApplicationXml => "application/xml",
            ContentType::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "application/json", "application/xml"
        ]
    }
}
impl AsRef<str> for ContentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Container for the suggestion information returned in a <code>SuggestResponse</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuggestModel  {
    /// <p>The query string specified in the suggest request.</p>
    #[doc(hidden)]
    pub query: std::option::Option<std::string::String>,
    /// <p>The number of documents that were found to match the query string.</p>
    #[doc(hidden)]
    pub found: i64,
    /// <p>The documents that match the query string.</p>
    #[doc(hidden)]
    pub suggestions: std::option::Option<std::vec::Vec<crate::model::SuggestionMatch>>,
}
impl SuggestModel {
    /// <p>The query string specified in the suggest request.</p>
    pub fn query(&self) -> std::option::Option<& str> {
        self.query.as_deref()
    }
    /// <p>The number of documents that were found to match the query string.</p>
    pub fn found(&self) -> i64 {
        self.found
    }
    /// <p>The documents that match the query string.</p>
    pub fn suggestions(&self) -> std::option::Option<& [crate::model::SuggestionMatch]> {
        self.suggestions.as_deref()
    }
}
/// See [`SuggestModel`](crate::model::SuggestModel).
pub mod suggest_model {
    
    /// A builder for [`SuggestModel`](crate::model::SuggestModel).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) found: std::option::Option<i64>,
        pub(crate) suggestions: std::option::Option<std::vec::Vec<crate::model::SuggestionMatch>>,
    }
    impl Builder {
        /// <p>The query string specified in the suggest request.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The query string specified in the suggest request.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input; self
        }
        /// <p>The number of documents that were found to match the query string.</p>
        pub fn found(mut self, input: i64) -> Self {
            self.found = Some(input);
            self
        }
        /// <p>The number of documents that were found to match the query string.</p>
        pub fn set_found(mut self, input: std::option::Option<i64>) -> Self {
            self.found = input; self
        }
        /// Appends an item to `suggestions`.
        ///
        /// To override the contents of this collection use [`set_suggestions`](Self::set_suggestions).
        ///
        /// <p>The documents that match the query string.</p>
        pub fn suggestions(mut self, input: crate::model::SuggestionMatch) -> Self {
            let mut v = self.suggestions.unwrap_or_default();
                            v.push(input);
                            self.suggestions = Some(v);
                            self
        }
        /// <p>The documents that match the query string.</p>
        pub fn set_suggestions(mut self, input: std::option::Option<std::vec::Vec<crate::model::SuggestionMatch>>) -> Self {
            self.suggestions = input; self
        }
        /// Consumes the builder and constructs a [`SuggestModel`](crate::model::SuggestModel).
        pub fn build(self) -> crate::model::SuggestModel {
            crate::model::SuggestModel {
                query: self.query
                ,
                found: self.found
                    .unwrap_or_default()
                ,
                suggestions: self.suggestions
                ,
            }
        }
    }
    
    
}
impl SuggestModel {
    /// Creates a new builder-style object to manufacture [`SuggestModel`](crate::model::SuggestModel).
    pub fn builder() -> crate::model::suggest_model::Builder {
        crate::model::suggest_model::Builder::default()
    }
}

/// <p>An autocomplete suggestion that matches the query string specified in a <code>SuggestRequest</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuggestionMatch  {
    /// <p>The string that matches the query string specified in the <code>SuggestRequest</code>. </p>
    #[doc(hidden)]
    pub suggestion: std::option::Option<std::string::String>,
    /// <p>The relevance score of a suggested match.</p>
    #[doc(hidden)]
    pub score: i64,
    /// <p>The document ID of the suggested document.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl SuggestionMatch {
    /// <p>The string that matches the query string specified in the <code>SuggestRequest</code>. </p>
    pub fn suggestion(&self) -> std::option::Option<& str> {
        self.suggestion.as_deref()
    }
    /// <p>The relevance score of a suggested match.</p>
    pub fn score(&self) -> i64 {
        self.score
    }
    /// <p>The document ID of the suggested document.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
}
/// See [`SuggestionMatch`](crate::model::SuggestionMatch).
pub mod suggestion_match {
    
    /// A builder for [`SuggestionMatch`](crate::model::SuggestionMatch).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) suggestion: std::option::Option<std::string::String>,
        pub(crate) score: std::option::Option<i64>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The string that matches the query string specified in the <code>SuggestRequest</code>. </p>
        pub fn suggestion(mut self, input: impl Into<std::string::String>) -> Self {
            self.suggestion = Some(input.into());
            self
        }
        /// <p>The string that matches the query string specified in the <code>SuggestRequest</code>. </p>
        pub fn set_suggestion(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.suggestion = input; self
        }
        /// <p>The relevance score of a suggested match.</p>
        pub fn score(mut self, input: i64) -> Self {
            self.score = Some(input);
            self
        }
        /// <p>The relevance score of a suggested match.</p>
        pub fn set_score(mut self, input: std::option::Option<i64>) -> Self {
            self.score = input; self
        }
        /// <p>The document ID of the suggested document.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The document ID of the suggested document.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Consumes the builder and constructs a [`SuggestionMatch`](crate::model::SuggestionMatch).
        pub fn build(self) -> crate::model::SuggestionMatch {
            crate::model::SuggestionMatch {
                suggestion: self.suggestion
                ,
                score: self.score
                    .unwrap_or_default()
                ,
                id: self.id
                ,
            }
        }
    }
    
    
}
impl SuggestionMatch {
    /// Creates a new builder-style object to manufacture [`SuggestionMatch`](crate::model::SuggestionMatch).
    pub fn builder() -> crate::model::suggestion_match::Builder {
        crate::model::suggestion_match::Builder::default()
    }
}

/// <p>Contains the resource id (<code>rid</code>) and the time it took to process the request (<code>timems</code>).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SuggestStatus  {
    /// <p>How long it took to process the request, in milliseconds.</p>
    #[doc(hidden)]
    pub timems: i64,
    /// <p>The encrypted resource ID for the request.</p>
    #[doc(hidden)]
    pub rid: std::option::Option<std::string::String>,
}
impl SuggestStatus {
    /// <p>How long it took to process the request, in milliseconds.</p>
    pub fn timems(&self) -> i64 {
        self.timems
    }
    /// <p>The encrypted resource ID for the request.</p>
    pub fn rid(&self) -> std::option::Option<& str> {
        self.rid.as_deref()
    }
}
/// See [`SuggestStatus`](crate::model::SuggestStatus).
pub mod suggest_status {
    
    /// A builder for [`SuggestStatus`](crate::model::SuggestStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timems: std::option::Option<i64>,
        pub(crate) rid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>How long it took to process the request, in milliseconds.</p>
        pub fn timems(mut self, input: i64) -> Self {
            self.timems = Some(input);
            self
        }
        /// <p>How long it took to process the request, in milliseconds.</p>
        pub fn set_timems(mut self, input: std::option::Option<i64>) -> Self {
            self.timems = input; self
        }
        /// <p>The encrypted resource ID for the request.</p>
        pub fn rid(mut self, input: impl Into<std::string::String>) -> Self {
            self.rid = Some(input.into());
            self
        }
        /// <p>The encrypted resource ID for the request.</p>
        pub fn set_rid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rid = input; self
        }
        /// Consumes the builder and constructs a [`SuggestStatus`](crate::model::SuggestStatus).
        pub fn build(self) -> crate::model::SuggestStatus {
            crate::model::SuggestStatus {
                timems: self.timems
                    .unwrap_or_default()
                ,
                rid: self.rid
                ,
            }
        }
    }
    
    
}
impl SuggestStatus {
    /// Creates a new builder-style object to manufacture [`SuggestStatus`](crate::model::SuggestStatus).
    pub fn builder() -> crate::model::suggest_status::Builder {
        crate::model::suggest_status::Builder::default()
    }
}

/// <p>The statistics for a field calculated in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldStats  {
    /// <p>The minimum value found in the specified field in the result set.</p> 
    /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>min</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>min</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
    #[doc(hidden)]
    pub min: std::option::Option<std::string::String>,
    /// <p>The maximum value found in the specified field in the result set.</p> 
    /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>max</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>max</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
    #[doc(hidden)]
    pub max: std::option::Option<std::string::String>,
    /// <p>The number of documents that contain a value in the specified field in the result set.</p>
    #[doc(hidden)]
    pub count: i64,
    /// <p>The number of documents that do not contain a value in the specified field in the result set.</p>
    #[doc(hidden)]
    pub missing: i64,
    /// <p>The sum of the field values across the documents in the result set. <code>null</code> for date fields.</p>
    #[doc(hidden)]
    pub sum: f64,
    /// <p>The sum of all field values in the result set squared.</p>
    #[doc(hidden)]
    pub sum_of_squares: f64,
    /// <p>The average of the values found in the specified field in the result set.</p> 
    /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>mean</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>mean</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
    #[doc(hidden)]
    pub mean: std::option::Option<std::string::String>,
    /// <p>The standard deviation of the values in the specified field in the result set.</p>
    #[doc(hidden)]
    pub stddev: f64,
}
impl FieldStats {
    /// <p>The minimum value found in the specified field in the result set.</p> 
    /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>min</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>min</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
    pub fn min(&self) -> std::option::Option<& str> {
        self.min.as_deref()
    }
    /// <p>The maximum value found in the specified field in the result set.</p> 
    /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>max</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>max</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
    pub fn max(&self) -> std::option::Option<& str> {
        self.max.as_deref()
    }
    /// <p>The number of documents that contain a value in the specified field in the result set.</p>
    pub fn count(&self) -> i64 {
        self.count
    }
    /// <p>The number of documents that do not contain a value in the specified field in the result set.</p>
    pub fn missing(&self) -> i64 {
        self.missing
    }
    /// <p>The sum of the field values across the documents in the result set. <code>null</code> for date fields.</p>
    pub fn sum(&self) -> f64 {
        self.sum
    }
    /// <p>The sum of all field values in the result set squared.</p>
    pub fn sum_of_squares(&self) -> f64 {
        self.sum_of_squares
    }
    /// <p>The average of the values found in the specified field in the result set.</p> 
    /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>mean</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>mean</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
    pub fn mean(&self) -> std::option::Option<& str> {
        self.mean.as_deref()
    }
    /// <p>The standard deviation of the values in the specified field in the result set.</p>
    pub fn stddev(&self) -> f64 {
        self.stddev
    }
}
/// See [`FieldStats`](crate::model::FieldStats).
pub mod field_stats {
    
    /// A builder for [`FieldStats`](crate::model::FieldStats).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min: std::option::Option<std::string::String>,
        pub(crate) max: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i64>,
        pub(crate) missing: std::option::Option<i64>,
        pub(crate) sum: std::option::Option<f64>,
        pub(crate) sum_of_squares: std::option::Option<f64>,
        pub(crate) mean: std::option::Option<std::string::String>,
        pub(crate) stddev: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The minimum value found in the specified field in the result set.</p> 
        /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>min</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>min</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
        pub fn min(mut self, input: impl Into<std::string::String>) -> Self {
            self.min = Some(input.into());
            self
        }
        /// <p>The minimum value found in the specified field in the result set.</p> 
        /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>min</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>min</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
        pub fn set_min(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.min = input; self
        }
        /// <p>The maximum value found in the specified field in the result set.</p> 
        /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>max</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>max</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
        pub fn max(mut self, input: impl Into<std::string::String>) -> Self {
            self.max = Some(input.into());
            self
        }
        /// <p>The maximum value found in the specified field in the result set.</p> 
        /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>max</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>max</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
        pub fn set_max(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.max = input; self
        }
        /// <p>The number of documents that contain a value in the specified field in the result set.</p>
        pub fn count(mut self, input: i64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of documents that contain a value in the specified field in the result set.</p>
        pub fn set_count(mut self, input: std::option::Option<i64>) -> Self {
            self.count = input; self
        }
        /// <p>The number of documents that do not contain a value in the specified field in the result set.</p>
        pub fn missing(mut self, input: i64) -> Self {
            self.missing = Some(input);
            self
        }
        /// <p>The number of documents that do not contain a value in the specified field in the result set.</p>
        pub fn set_missing(mut self, input: std::option::Option<i64>) -> Self {
            self.missing = input; self
        }
        /// <p>The sum of the field values across the documents in the result set. <code>null</code> for date fields.</p>
        pub fn sum(mut self, input: f64) -> Self {
            self.sum = Some(input);
            self
        }
        /// <p>The sum of the field values across the documents in the result set. <code>null</code> for date fields.</p>
        pub fn set_sum(mut self, input: std::option::Option<f64>) -> Self {
            self.sum = input; self
        }
        /// <p>The sum of all field values in the result set squared.</p>
        pub fn sum_of_squares(mut self, input: f64) -> Self {
            self.sum_of_squares = Some(input);
            self
        }
        /// <p>The sum of all field values in the result set squared.</p>
        pub fn set_sum_of_squares(mut self, input: std::option::Option<f64>) -> Self {
            self.sum_of_squares = input; self
        }
        /// <p>The average of the values found in the specified field in the result set.</p> 
        /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>mean</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>mean</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
        pub fn mean(mut self, input: impl Into<std::string::String>) -> Self {
            self.mean = Some(input.into());
            self
        }
        /// <p>The average of the values found in the specified field in the result set.</p> 
        /// <p>If the field is numeric (<code>int</code>, <code>int-array</code>, <code>double</code>, or <code>double-array</code>), <code>mean</code> is the string representation of a double-precision 64-bit floating point value. If the field is <code>date</code> or <code>date-array</code>, <code>mean</code> is the string representation of a date with the format specified in <a href="http://tools.ietf.org/html/rfc3339">IETF RFC3339</a>: yyyy-mm-ddTHH:mm:ss.SSSZ.</p>
        pub fn set_mean(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mean = input; self
        }
        /// <p>The standard deviation of the values in the specified field in the result set.</p>
        pub fn stddev(mut self, input: f64) -> Self {
            self.stddev = Some(input);
            self
        }
        /// <p>The standard deviation of the values in the specified field in the result set.</p>
        pub fn set_stddev(mut self, input: std::option::Option<f64>) -> Self {
            self.stddev = input; self
        }
        /// Consumes the builder and constructs a [`FieldStats`](crate::model::FieldStats).
        pub fn build(self) -> crate::model::FieldStats {
            crate::model::FieldStats {
                min: self.min
                ,
                max: self.max
                ,
                count: self.count
                    .unwrap_or_default()
                ,
                missing: self.missing
                    .unwrap_or_default()
                ,
                sum: self.sum
                    .unwrap_or_default()
                ,
                sum_of_squares: self.sum_of_squares
                    .unwrap_or_default()
                ,
                mean: self.mean
                ,
                stddev: self.stddev
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl FieldStats {
    /// Creates a new builder-style object to manufacture [`FieldStats`](crate::model::FieldStats).
    pub fn builder() -> crate::model::field_stats::Builder {
        crate::model::field_stats::Builder::default()
    }
}

/// <p>A container for the calculated facet values and counts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BucketInfo  {
    /// <p>A list of the calculated facet values and counts.</p>
    #[doc(hidden)]
    pub buckets: std::option::Option<std::vec::Vec<crate::model::Bucket>>,
}
impl BucketInfo {
    /// <p>A list of the calculated facet values and counts.</p>
    pub fn buckets(&self) -> std::option::Option<& [crate::model::Bucket]> {
        self.buckets.as_deref()
    }
}
/// See [`BucketInfo`](crate::model::BucketInfo).
pub mod bucket_info {
    
    /// A builder for [`BucketInfo`](crate::model::BucketInfo).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) buckets: std::option::Option<std::vec::Vec<crate::model::Bucket>>,
    }
    impl Builder {
        /// Appends an item to `buckets`.
        ///
        /// To override the contents of this collection use [`set_buckets`](Self::set_buckets).
        ///
        /// <p>A list of the calculated facet values and counts.</p>
        pub fn buckets(mut self, input: crate::model::Bucket) -> Self {
            let mut v = self.buckets.unwrap_or_default();
                            v.push(input);
                            self.buckets = Some(v);
                            self
        }
        /// <p>A list of the calculated facet values and counts.</p>
        pub fn set_buckets(mut self, input: std::option::Option<std::vec::Vec<crate::model::Bucket>>) -> Self {
            self.buckets = input; self
        }
        /// Consumes the builder and constructs a [`BucketInfo`](crate::model::BucketInfo).
        pub fn build(self) -> crate::model::BucketInfo {
            crate::model::BucketInfo {
                buckets: self.buckets
                ,
            }
        }
    }
    
    
}
impl BucketInfo {
    /// Creates a new builder-style object to manufacture [`BucketInfo`](crate::model::BucketInfo).
    pub fn builder() -> crate::model::bucket_info::Builder {
        crate::model::bucket_info::Builder::default()
    }
}

/// <p>A container for facet information. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Bucket  {
    /// <p>The facet value being counted.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>The number of hits that contain the facet value in the specified facet field.</p>
    #[doc(hidden)]
    pub count: i64,
}
impl Bucket {
    /// <p>The facet value being counted.</p>
    pub fn value(&self) -> std::option::Option<& str> {
        self.value.as_deref()
    }
    /// <p>The number of hits that contain the facet value in the specified facet field.</p>
    pub fn count(&self) -> i64 {
        self.count
    }
}
/// See [`Bucket`](crate::model::Bucket).
pub mod bucket {
    
    /// A builder for [`Bucket`](crate::model::Bucket).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) count: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The facet value being counted.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The facet value being counted.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input; self
        }
        /// <p>The number of hits that contain the facet value in the specified facet field.</p>
        pub fn count(mut self, input: i64) -> Self {
            self.count = Some(input);
            self
        }
        /// <p>The number of hits that contain the facet value in the specified facet field.</p>
        pub fn set_count(mut self, input: std::option::Option<i64>) -> Self {
            self.count = input; self
        }
        /// Consumes the builder and constructs a [`Bucket`](crate::model::Bucket).
        pub fn build(self) -> crate::model::Bucket {
            crate::model::Bucket {
                value: self.value
                ,
                count: self.count
                    .unwrap_or_default()
                ,
            }
        }
    }
    
    
}
impl Bucket {
    /// Creates a new builder-style object to manufacture [`Bucket`](crate::model::Bucket).
    pub fn builder() -> crate::model::bucket::Builder {
        crate::model::bucket::Builder::default()
    }
}

/// <p>The collection of documents that match the search request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Hits  {
    /// <p>The total number of documents that match the search request.</p>
    #[doc(hidden)]
    pub found: i64,
    /// <p>The index of the first matching document.</p>
    #[doc(hidden)]
    pub start: i64,
    /// <p>A cursor that can be used to retrieve the next set of matching documents when you want to page through a large result set.</p>
    #[doc(hidden)]
    pub cursor: std::option::Option<std::string::String>,
    /// <p>A document that matches the search request.</p>
    #[doc(hidden)]
    pub hit: std::option::Option<std::vec::Vec<crate::model::Hit>>,
}
impl Hits {
    /// <p>The total number of documents that match the search request.</p>
    pub fn found(&self) -> i64 {
        self.found
    }
    /// <p>The index of the first matching document.</p>
    pub fn start(&self) -> i64 {
        self.start
    }
    /// <p>A cursor that can be used to retrieve the next set of matching documents when you want to page through a large result set.</p>
    pub fn cursor(&self) -> std::option::Option<& str> {
        self.cursor.as_deref()
    }
    /// <p>A document that matches the search request.</p>
    pub fn hit(&self) -> std::option::Option<& [crate::model::Hit]> {
        self.hit.as_deref()
    }
}
/// See [`Hits`](crate::model::Hits).
pub mod hits {
    
    /// A builder for [`Hits`](crate::model::Hits).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) found: std::option::Option<i64>,
        pub(crate) start: std::option::Option<i64>,
        pub(crate) cursor: std::option::Option<std::string::String>,
        pub(crate) hit: std::option::Option<std::vec::Vec<crate::model::Hit>>,
    }
    impl Builder {
        /// <p>The total number of documents that match the search request.</p>
        pub fn found(mut self, input: i64) -> Self {
            self.found = Some(input);
            self
        }
        /// <p>The total number of documents that match the search request.</p>
        pub fn set_found(mut self, input: std::option::Option<i64>) -> Self {
            self.found = input; self
        }
        /// <p>The index of the first matching document.</p>
        pub fn start(mut self, input: i64) -> Self {
            self.start = Some(input);
            self
        }
        /// <p>The index of the first matching document.</p>
        pub fn set_start(mut self, input: std::option::Option<i64>) -> Self {
            self.start = input; self
        }
        /// <p>A cursor that can be used to retrieve the next set of matching documents when you want to page through a large result set.</p>
        pub fn cursor(mut self, input: impl Into<std::string::String>) -> Self {
            self.cursor = Some(input.into());
            self
        }
        /// <p>A cursor that can be used to retrieve the next set of matching documents when you want to page through a large result set.</p>
        pub fn set_cursor(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cursor = input; self
        }
        /// Appends an item to `hit`.
        ///
        /// To override the contents of this collection use [`set_hit`](Self::set_hit).
        ///
        /// <p>A document that matches the search request.</p>
        pub fn hit(mut self, input: crate::model::Hit) -> Self {
            let mut v = self.hit.unwrap_or_default();
                            v.push(input);
                            self.hit = Some(v);
                            self
        }
        /// <p>A document that matches the search request.</p>
        pub fn set_hit(mut self, input: std::option::Option<std::vec::Vec<crate::model::Hit>>) -> Self {
            self.hit = input; self
        }
        /// Consumes the builder and constructs a [`Hits`](crate::model::Hits).
        pub fn build(self) -> crate::model::Hits {
            crate::model::Hits {
                found: self.found
                    .unwrap_or_default()
                ,
                start: self.start
                    .unwrap_or_default()
                ,
                cursor: self.cursor
                ,
                hit: self.hit
                ,
            }
        }
    }
    
    
}
impl Hits {
    /// Creates a new builder-style object to manufacture [`Hits`](crate::model::Hits).
    pub fn builder() -> crate::model::hits::Builder {
        crate::model::hits::Builder::default()
    }
}

/// <p>Information about a document that matches the search request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Hit  {
    /// <p>The document ID of a document that matches the search request.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The fields returned from a document that matches the search request.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
    /// <p>The expressions returned from a document that matches the search request.</p>
    #[doc(hidden)]
    pub exprs: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The highlights returned from a document that matches the search request.</p>
    #[doc(hidden)]
    pub highlights: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl Hit {
    /// <p>The document ID of a document that matches the search request.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>The fields returned from a document that matches the search request.</p>
    pub fn fields(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>> {
        self.fields.as_ref()
    }
    /// <p>The expressions returned from a document that matches the search request.</p>
    pub fn exprs(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.exprs.as_ref()
    }
    /// <p>The highlights returned from a document that matches the search request.</p>
    pub fn highlights(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.highlights.as_ref()
    }
}
/// See [`Hit`](crate::model::Hit).
pub mod hit {
    
    /// A builder for [`Hit`](crate::model::Hit).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>,
        pub(crate) exprs: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
        pub(crate) highlights: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    }
    impl Builder {
        /// <p>The document ID of a document that matches the search request.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The document ID of a document that matches the search request.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input; self
        }
        /// Adds a key-value pair to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>The fields returned from a document that matches the search request.</p>
        pub fn fields(mut self, k: impl Into<std::string::String>, v: std::vec::Vec<std::string::String>) -> Self {
            let mut hash_map = self.fields.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.fields = Some(hash_map);
                            self
        }
        /// <p>The fields returned from a document that matches the search request.</p>
        pub fn set_fields(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>>) -> Self {
            self.fields = input; self
        }
        /// Adds a key-value pair to `exprs`.
        ///
        /// To override the contents of this collection use [`set_exprs`](Self::set_exprs).
        ///
        /// <p>The expressions returned from a document that matches the search request.</p>
        pub fn exprs(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.exprs.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.exprs = Some(hash_map);
                            self
        }
        /// <p>The expressions returned from a document that matches the search request.</p>
        pub fn set_exprs(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.exprs = input; self
        }
        /// Adds a key-value pair to `highlights`.
        ///
        /// To override the contents of this collection use [`set_highlights`](Self::set_highlights).
        ///
        /// <p>The highlights returned from a document that matches the search request.</p>
        pub fn highlights(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
            let mut hash_map = self.highlights.unwrap_or_default();
                            hash_map.insert(k.into(), v.into());
                            self.highlights = Some(hash_map);
                            self
        }
        /// <p>The highlights returned from a document that matches the search request.</p>
        pub fn set_highlights(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
            self.highlights = input; self
        }
        /// Consumes the builder and constructs a [`Hit`](crate::model::Hit).
        pub fn build(self) -> crate::model::Hit {
            crate::model::Hit {
                id: self.id
                ,
                fields: self.fields
                ,
                exprs: self.exprs
                ,
                highlights: self.highlights
                ,
            }
        }
    }
    
    
}
impl Hit {
    /// Creates a new builder-style object to manufacture [`Hit`](crate::model::Hit).
    pub fn builder() -> crate::model::hit::Builder {
        crate::model::hit::Builder::default()
    }
}

/// <p>Contains the resource id (<code>rid</code>) and the time it took to process the request (<code>timems</code>).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchStatus  {
    /// <p>How long it took to process the request, in milliseconds.</p>
    #[doc(hidden)]
    pub timems: i64,
    /// <p>The encrypted resource ID for the request.</p>
    #[doc(hidden)]
    pub rid: std::option::Option<std::string::String>,
}
impl SearchStatus {
    /// <p>How long it took to process the request, in milliseconds.</p>
    pub fn timems(&self) -> i64 {
        self.timems
    }
    /// <p>The encrypted resource ID for the request.</p>
    pub fn rid(&self) -> std::option::Option<& str> {
        self.rid.as_deref()
    }
}
/// See [`SearchStatus`](crate::model::SearchStatus).
pub mod search_status {
    
    /// A builder for [`SearchStatus`](crate::model::SearchStatus).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timems: std::option::Option<i64>,
        pub(crate) rid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>How long it took to process the request, in milliseconds.</p>
        pub fn timems(mut self, input: i64) -> Self {
            self.timems = Some(input);
            self
        }
        /// <p>How long it took to process the request, in milliseconds.</p>
        pub fn set_timems(mut self, input: std::option::Option<i64>) -> Self {
            self.timems = input; self
        }
        /// <p>The encrypted resource ID for the request.</p>
        pub fn rid(mut self, input: impl Into<std::string::String>) -> Self {
            self.rid = Some(input.into());
            self
        }
        /// <p>The encrypted resource ID for the request.</p>
        pub fn set_rid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rid = input; self
        }
        /// Consumes the builder and constructs a [`SearchStatus`](crate::model::SearchStatus).
        pub fn build(self) -> crate::model::SearchStatus {
            crate::model::SearchStatus {
                timems: self.timems
                    .unwrap_or_default()
                ,
                rid: self.rid
                ,
            }
        }
    }
    
    
}
impl SearchStatus {
    /// Creates a new builder-style object to manufacture [`SearchStatus`](crate::model::SearchStatus).
    pub fn builder() -> crate::model::search_status::Builder {
        crate::model::search_status::Builder::default()
    }
}

/// When writing a match expression against `QueryParser`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
/// 
/// Here is an example of how you can make a match expression forward-compatible:
/// 
/// ```text
/// # let queryparser = unimplemented!();
/// match queryparser {
///     QueryParser::Dismax => { /* ... */ },
///     QueryParser::Lucene => { /* ... */ },
///     QueryParser::Simple => { /* ... */ },
///     QueryParser::Structured => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `queryparser` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `QueryParser::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `QueryParser::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `QueryParser::NewFeature` is defined.
/// Specifically, when `queryparser` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `QueryParser::NewFeature` also yielding `"NewFeature"`.
/// 
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::Eq, std::cmp::Ord, std::cmp::PartialEq, std::cmp::PartialOrd, std::fmt::Debug, std::hash::Hash)]
pub enum QueryParser {
    #[allow(missing_docs)] // documentation missing in model
    Dismax,
    #[allow(missing_docs)] // documentation missing in model
    Lucene,
    #[allow(missing_docs)] // documentation missing in model
    Simple,
    #[allow(missing_docs)] // documentation missing in model
    Structured,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue)
}
impl std::convert::From<&str> for QueryParser {
    fn from(s: &str) -> Self {
        match s {
            "dismax" => QueryParser::Dismax,
            "lucene" => QueryParser::Lucene,
            "simple" => QueryParser::Simple,
            "structured" => QueryParser::Structured,
            other => QueryParser::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
        }
    }
}
impl std::str::FromStr for QueryParser {
                type Err = std::convert::Infallible;

                fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
                    Ok(QueryParser::from(s))
                }
            }
impl QueryParser {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            QueryParser::Dismax => "dismax",
            QueryParser::Lucene => "lucene",
            QueryParser::Simple => "simple",
            QueryParser::Structured => "structured",
            QueryParser::Unknown(value) => value.as_str()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "dismax", "lucene", "simple", "structured"
        ]
    }
}
impl AsRef<str> for QueryParser {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

