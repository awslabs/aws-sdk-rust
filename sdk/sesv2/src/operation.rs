// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Create a configuration set. <i>Configuration sets</i> are groups of
/// rules that you can apply to the emails that you send. You apply a configuration set to
/// an email by specifying the name of the configuration set when you call the Amazon SES API v2. When
/// you apply a configuration set to an email, all of the rules in that configuration set
/// are applied to the email. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConfigurationSet {
    _private: (),
}
impl CreateConfigurationSet {
    /// Creates a new builder-style object to manufacture [`CreateConfigurationSetInput`](crate::input::CreateConfigurationSetInput)
    pub fn builder() -> crate::input::create_configuration_set_input::Builder {
        crate::input::create_configuration_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConfigurationSet {
    type Output = std::result::Result<
        crate::output::CreateConfigurationSetOutput,
        crate::error::CreateConfigurationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_configuration_set_error(response)
        } else {
            crate::operation_deser::parse_create_configuration_set_response(response)
        }
    }
}

/// <p>Create an event destination. <i>Events</i> include message sends,
/// deliveries, opens, clicks, bounces, and complaints. <i>Event
/// destinations</i> are places that you can send information about these events
/// to. For example, you can send event data to Amazon SNS to receive notifications when you
/// receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to stream data to Amazon S3 for long-term
/// storage.</p>
/// <p>A single configuration set can include more than one event destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConfigurationSetEventDestination {
    _private: (),
}
impl CreateConfigurationSetEventDestination {
    /// Creates a new builder-style object to manufacture [`CreateConfigurationSetEventDestinationInput`](crate::input::CreateConfigurationSetEventDestinationInput)
    pub fn builder() -> crate::input::create_configuration_set_event_destination_input::Builder {
        crate::input::create_configuration_set_event_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConfigurationSetEventDestination {
    type Output = std::result::Result<
        crate::output::CreateConfigurationSetEventDestinationOutput,
        crate::error::CreateConfigurationSetEventDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_configuration_set_event_destination_error(response)
        } else {
            crate::operation_deser::parse_create_configuration_set_event_destination_response(
                response,
            )
        }
    }
}

/// <p>Creates a contact, which is an end-user who is receiving the email, and adds them to a
/// contact list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContact {
    _private: (),
}
impl CreateContact {
    /// Creates a new builder-style object to manufacture [`CreateContactInput`](crate::input::CreateContactInput)
    pub fn builder() -> crate::input::create_contact_input::Builder {
        crate::input::create_contact_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContact {
    type Output =
        std::result::Result<crate::output::CreateContactOutput, crate::error::CreateContactError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_contact_error(response)
        } else {
            crate::operation_deser::parse_create_contact_response(response)
        }
    }
}

/// <p>Creates a contact list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateContactList {
    _private: (),
}
impl CreateContactList {
    /// Creates a new builder-style object to manufacture [`CreateContactListInput`](crate::input::CreateContactListInput)
    pub fn builder() -> crate::input::create_contact_list_input::Builder {
        crate::input::create_contact_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateContactList {
    type Output = std::result::Result<
        crate::output::CreateContactListOutput,
        crate::error::CreateContactListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_contact_list_error(response)
        } else {
            crate::operation_deser::parse_create_contact_list_response(response)
        }
    }
}

/// <p>Creates a new custom verification email template.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCustomVerificationEmailTemplate {
    _private: (),
}
impl CreateCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`CreateCustomVerificationEmailTemplateInput`](crate::input::CreateCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::create_custom_verification_email_template_input::Builder {
        crate::input::create_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::CreateCustomVerificationEmailTemplateOutput,
        crate::error::CreateCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_custom_verification_email_template_error(response)
        } else {
            crate::operation_deser::parse_create_custom_verification_email_template_response(
                response,
            )
        }
    }
}

/// <p>Create a new pool of dedicated IP addresses. A pool can include one or more dedicated
/// IP addresses that are associated with your Amazon Web Services account. You can associate a pool with
/// a configuration set. When you send an email that uses that configuration set, the
/// message is sent from one of the addresses in the associated pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDedicatedIpPool {
    _private: (),
}
impl CreateDedicatedIpPool {
    /// Creates a new builder-style object to manufacture [`CreateDedicatedIpPoolInput`](crate::input::CreateDedicatedIpPoolInput)
    pub fn builder() -> crate::input::create_dedicated_ip_pool_input::Builder {
        crate::input::create_dedicated_ip_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDedicatedIpPool {
    type Output = std::result::Result<
        crate::output::CreateDedicatedIpPoolOutput,
        crate::error::CreateDedicatedIpPoolError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_dedicated_ip_pool_error(response)
        } else {
            crate::operation_deser::parse_create_dedicated_ip_pool_response(response)
        }
    }
}

/// <p>Create a new predictive inbox placement test. Predictive inbox placement tests can help you predict how your messages will be handled
/// by various email providers around the world. When you perform a predictive inbox placement test, you provide a
/// sample message that contains the content that you plan to send to your customers. Amazon SES
/// then sends that message to special email addresses spread across several major email
/// providers. After about 24 hours, the test is complete, and you can use the
/// <code>GetDeliverabilityTestReport</code> operation to view the results of the
/// test.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDeliverabilityTestReport {
    _private: (),
}
impl CreateDeliverabilityTestReport {
    /// Creates a new builder-style object to manufacture [`CreateDeliverabilityTestReportInput`](crate::input::CreateDeliverabilityTestReportInput)
    pub fn builder() -> crate::input::create_deliverability_test_report_input::Builder {
        crate::input::create_deliverability_test_report_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDeliverabilityTestReport {
    type Output = std::result::Result<
        crate::output::CreateDeliverabilityTestReportOutput,
        crate::error::CreateDeliverabilityTestReportError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_deliverability_test_report_error(response)
        } else {
            crate::operation_deser::parse_create_deliverability_test_report_response(response)
        }
    }
}

/// <p>Starts the process of verifying an email identity. An <i>identity</i> is
/// an email address or domain that you use when you send email. Before you can use an
/// identity to send email, you first have to verify it. By verifying an identity, you
/// demonstrate that you're the owner of the identity, and that you've given Amazon SES API v2
/// permission to send email from the identity.</p>
/// <p>When you verify an email address, Amazon SES sends an email to the address. Your email
/// address is verified as soon as you follow the link in the verification email.
/// </p>
/// <p>When you verify a domain without specifying the <code>DkimSigningAttributes</code>
/// object, this operation provides a set of DKIM tokens. You can convert these tokens into
/// CNAME records, which you then add to the DNS configuration for your domain. Your domain
/// is verified when Amazon SES detects these records in the DNS configuration for your domain.
/// This verification method is known as <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a>.</p>
/// <p>Alternatively, you can perform the verification process by providing your own
/// public-private key pair. This verification method is known as Bring Your Own DKIM
/// (BYODKIM). To use BYODKIM, your call to the <code>CreateEmailIdentity</code> operation
/// has to include the <code>DkimSigningAttributes</code> object. When you specify this
/// object, you provide a selector (a component of the DNS record name that identifies the
/// public key to use for DKIM authentication) and a private key.</p>
/// <p>When you verify a domain, this operation provides a set of DKIM tokens, which you can
/// convert into CNAME tokens. You add these CNAME tokens to the DNS configuration for your
/// domain. Your domain is verified when Amazon SES detects these records in the DNS
/// configuration for your domain. For some DNS providers, it can take 72 hours or more to
/// complete the domain verification process.</p>
/// <p>Additionally, you can associate an existing configuration set with the email identity that you're verifying.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEmailIdentity {
    _private: (),
}
impl CreateEmailIdentity {
    /// Creates a new builder-style object to manufacture [`CreateEmailIdentityInput`](crate::input::CreateEmailIdentityInput)
    pub fn builder() -> crate::input::create_email_identity_input::Builder {
        crate::input::create_email_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEmailIdentity {
    type Output = std::result::Result<
        crate::output::CreateEmailIdentityOutput,
        crate::error::CreateEmailIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_email_identity_error(response)
        } else {
            crate::operation_deser::parse_create_email_identity_response(response)
        }
    }
}

/// <p>Creates the specified sending authorization policy for the given identity (an email
/// address or a domain).</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEmailIdentityPolicy {
    _private: (),
}
impl CreateEmailIdentityPolicy {
    /// Creates a new builder-style object to manufacture [`CreateEmailIdentityPolicyInput`](crate::input::CreateEmailIdentityPolicyInput)
    pub fn builder() -> crate::input::create_email_identity_policy_input::Builder {
        crate::input::create_email_identity_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEmailIdentityPolicy {
    type Output = std::result::Result<
        crate::output::CreateEmailIdentityPolicyOutput,
        crate::error::CreateEmailIdentityPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_email_identity_policy_error(response)
        } else {
            crate::operation_deser::parse_create_email_identity_policy_response(response)
        }
    }
}

/// <p>Creates an email template. Email templates enable you to send personalized email to
/// one or more destinations in a single API operation. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateEmailTemplate {
    _private: (),
}
impl CreateEmailTemplate {
    /// Creates a new builder-style object to manufacture [`CreateEmailTemplateInput`](crate::input::CreateEmailTemplateInput)
    pub fn builder() -> crate::input::create_email_template_input::Builder {
        crate::input::create_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateEmailTemplate {
    type Output = std::result::Result<
        crate::output::CreateEmailTemplateOutput,
        crate::error::CreateEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_email_template_error(response)
        } else {
            crate::operation_deser::parse_create_email_template_response(response)
        }
    }
}

/// <p>Creates an import job for a data destination.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateImportJob {
    _private: (),
}
impl CreateImportJob {
    /// Creates a new builder-style object to manufacture [`CreateImportJobInput`](crate::input::CreateImportJobInput)
    pub fn builder() -> crate::input::create_import_job_input::Builder {
        crate::input::create_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateImportJob {
    type Output = std::result::Result<
        crate::output::CreateImportJobOutput,
        crate::error::CreateImportJobError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_import_job_error(response)
        } else {
            crate::operation_deser::parse_create_import_job_response(response)
        }
    }
}

/// <p>Delete an existing configuration set.</p>
/// <p>
/// <i>Configuration sets</i> are groups of rules that you can apply to the
/// emails you send. You apply a configuration set to an email by including a reference to
/// the configuration set in the headers of the email. When you apply a configuration set to
/// an email, all of the rules in that configuration set are applied to the email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationSet {
    _private: (),
}
impl DeleteConfigurationSet {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationSetInput`](crate::input::DeleteConfigurationSetInput)
    pub fn builder() -> crate::input::delete_configuration_set_input::Builder {
        crate::input::delete_configuration_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationSet {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationSetOutput,
        crate::error::DeleteConfigurationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_configuration_set_error(response)
        } else {
            crate::operation_deser::parse_delete_configuration_set_response(response)
        }
    }
}

/// <p>Delete an event destination.</p>
/// <p>
/// <i>Events</i> include message sends, deliveries, opens, clicks, bounces,
/// and complaints. <i>Event destinations</i> are places that you can send
/// information about these events to. For example, you can send event data to Amazon SNS to
/// receive notifications when you receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to
/// stream data to Amazon S3 for long-term storage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConfigurationSetEventDestination {
    _private: (),
}
impl DeleteConfigurationSetEventDestination {
    /// Creates a new builder-style object to manufacture [`DeleteConfigurationSetEventDestinationInput`](crate::input::DeleteConfigurationSetEventDestinationInput)
    pub fn builder() -> crate::input::delete_configuration_set_event_destination_input::Builder {
        crate::input::delete_configuration_set_event_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConfigurationSetEventDestination {
    type Output = std::result::Result<
        crate::output::DeleteConfigurationSetEventDestinationOutput,
        crate::error::DeleteConfigurationSetEventDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_configuration_set_event_destination_error(response)
        } else {
            crate::operation_deser::parse_delete_configuration_set_event_destination_response(
                response,
            )
        }
    }
}

/// <p>Removes a contact from a contact list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContact {
    _private: (),
}
impl DeleteContact {
    /// Creates a new builder-style object to manufacture [`DeleteContactInput`](crate::input::DeleteContactInput)
    pub fn builder() -> crate::input::delete_contact_input::Builder {
        crate::input::delete_contact_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContact {
    type Output =
        std::result::Result<crate::output::DeleteContactOutput, crate::error::DeleteContactError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_contact_error(response)
        } else {
            crate::operation_deser::parse_delete_contact_response(response)
        }
    }
}

/// <p>Deletes a contact list and all of the contacts on that list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteContactList {
    _private: (),
}
impl DeleteContactList {
    /// Creates a new builder-style object to manufacture [`DeleteContactListInput`](crate::input::DeleteContactListInput)
    pub fn builder() -> crate::input::delete_contact_list_input::Builder {
        crate::input::delete_contact_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteContactList {
    type Output = std::result::Result<
        crate::output::DeleteContactListOutput,
        crate::error::DeleteContactListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_contact_list_error(response)
        } else {
            crate::operation_deser::parse_delete_contact_list_response(response)
        }
    }
}

/// <p>Deletes an existing custom verification email template.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCustomVerificationEmailTemplate {
    _private: (),
}
impl DeleteCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`DeleteCustomVerificationEmailTemplateInput`](crate::input::DeleteCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::delete_custom_verification_email_template_input::Builder {
        crate::input::delete_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::DeleteCustomVerificationEmailTemplateOutput,
        crate::error::DeleteCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_custom_verification_email_template_error(response)
        } else {
            crate::operation_deser::parse_delete_custom_verification_email_template_response(
                response,
            )
        }
    }
}

/// <p>Delete a dedicated IP pool.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDedicatedIpPool {
    _private: (),
}
impl DeleteDedicatedIpPool {
    /// Creates a new builder-style object to manufacture [`DeleteDedicatedIpPoolInput`](crate::input::DeleteDedicatedIpPoolInput)
    pub fn builder() -> crate::input::delete_dedicated_ip_pool_input::Builder {
        crate::input::delete_dedicated_ip_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDedicatedIpPool {
    type Output = std::result::Result<
        crate::output::DeleteDedicatedIpPoolOutput,
        crate::error::DeleteDedicatedIpPoolError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_dedicated_ip_pool_error(response)
        } else {
            crate::operation_deser::parse_delete_dedicated_ip_pool_response(response)
        }
    }
}

/// <p>Deletes an email identity. An identity can be either an email address or a domain
/// name.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEmailIdentity {
    _private: (),
}
impl DeleteEmailIdentity {
    /// Creates a new builder-style object to manufacture [`DeleteEmailIdentityInput`](crate::input::DeleteEmailIdentityInput)
    pub fn builder() -> crate::input::delete_email_identity_input::Builder {
        crate::input::delete_email_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEmailIdentity {
    type Output = std::result::Result<
        crate::output::DeleteEmailIdentityOutput,
        crate::error::DeleteEmailIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_email_identity_error(response)
        } else {
            crate::operation_deser::parse_delete_email_identity_response(response)
        }
    }
}

/// <p>Deletes the specified sending authorization policy for the given identity (an email
/// address or a domain). This API returns successfully even if a policy with the specified
/// name does not exist.</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEmailIdentityPolicy {
    _private: (),
}
impl DeleteEmailIdentityPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteEmailIdentityPolicyInput`](crate::input::DeleteEmailIdentityPolicyInput)
    pub fn builder() -> crate::input::delete_email_identity_policy_input::Builder {
        crate::input::delete_email_identity_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEmailIdentityPolicy {
    type Output = std::result::Result<
        crate::output::DeleteEmailIdentityPolicyOutput,
        crate::error::DeleteEmailIdentityPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_email_identity_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_email_identity_policy_response(response)
        }
    }
}

/// <p>Deletes an email template.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteEmailTemplate {
    _private: (),
}
impl DeleteEmailTemplate {
    /// Creates a new builder-style object to manufacture [`DeleteEmailTemplateInput`](crate::input::DeleteEmailTemplateInput)
    pub fn builder() -> crate::input::delete_email_template_input::Builder {
        crate::input::delete_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteEmailTemplate {
    type Output = std::result::Result<
        crate::output::DeleteEmailTemplateOutput,
        crate::error::DeleteEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_email_template_error(response)
        } else {
            crate::operation_deser::parse_delete_email_template_response(response)
        }
    }
}

/// <p>Removes an email address from the suppression list for your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSuppressedDestination {
    _private: (),
}
impl DeleteSuppressedDestination {
    /// Creates a new builder-style object to manufacture [`DeleteSuppressedDestinationInput`](crate::input::DeleteSuppressedDestinationInput)
    pub fn builder() -> crate::input::delete_suppressed_destination_input::Builder {
        crate::input::delete_suppressed_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSuppressedDestination {
    type Output = std::result::Result<
        crate::output::DeleteSuppressedDestinationOutput,
        crate::error::DeleteSuppressedDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_suppressed_destination_error(response)
        } else {
            crate::operation_deser::parse_delete_suppressed_destination_response(response)
        }
    }
}

/// <p>Obtain information about the email-sending status and capabilities of your Amazon SES
/// account in the current Amazon Web Services Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAccount {
    _private: (),
}
impl GetAccount {
    /// Creates a new builder-style object to manufacture [`GetAccountInput`](crate::input::GetAccountInput)
    pub fn builder() -> crate::input::get_account_input::Builder {
        crate::input::get_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAccount {
    type Output =
        std::result::Result<crate::output::GetAccountOutput, crate::error::GetAccountError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_account_error(response)
        } else {
            crate::operation_deser::parse_get_account_response(response)
        }
    }
}

/// <p>Retrieve a list of the blacklists that your dedicated IP addresses appear on.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBlacklistReports {
    _private: (),
}
impl GetBlacklistReports {
    /// Creates a new builder-style object to manufacture [`GetBlacklistReportsInput`](crate::input::GetBlacklistReportsInput)
    pub fn builder() -> crate::input::get_blacklist_reports_input::Builder {
        crate::input::get_blacklist_reports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBlacklistReports {
    type Output = std::result::Result<
        crate::output::GetBlacklistReportsOutput,
        crate::error::GetBlacklistReportsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_blacklist_reports_error(response)
        } else {
            crate::operation_deser::parse_get_blacklist_reports_response(response)
        }
    }
}

/// <p>Get information about an existing configuration set, including the dedicated IP pool
/// that it's associated with, whether or not it's enabled for sending email, and
/// more.</p>
/// <p>
/// <i>Configuration sets</i> are groups of rules that you can apply to the
/// emails you send. You apply a configuration set to an email by including a reference to
/// the configuration set in the headers of the email. When you apply a configuration set to
/// an email, all of the rules in that configuration set are applied to the email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetConfigurationSet {
    _private: (),
}
impl GetConfigurationSet {
    /// Creates a new builder-style object to manufacture [`GetConfigurationSetInput`](crate::input::GetConfigurationSetInput)
    pub fn builder() -> crate::input::get_configuration_set_input::Builder {
        crate::input::get_configuration_set_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetConfigurationSet {
    type Output = std::result::Result<
        crate::output::GetConfigurationSetOutput,
        crate::error::GetConfigurationSetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_configuration_set_error(response)
        } else {
            crate::operation_deser::parse_get_configuration_set_response(response)
        }
    }
}

/// <p>Retrieve a list of event destinations that are associated with a configuration
/// set.</p>
/// <p>
/// <i>Events</i> include message sends, deliveries, opens, clicks, bounces,
/// and complaints. <i>Event destinations</i> are places that you can send
/// information about these events to. For example, you can send event data to Amazon SNS to
/// receive notifications when you receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to
/// stream data to Amazon S3 for long-term storage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetConfigurationSetEventDestinations {
    _private: (),
}
impl GetConfigurationSetEventDestinations {
    /// Creates a new builder-style object to manufacture [`GetConfigurationSetEventDestinationsInput`](crate::input::GetConfigurationSetEventDestinationsInput)
    pub fn builder() -> crate::input::get_configuration_set_event_destinations_input::Builder {
        crate::input::get_configuration_set_event_destinations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetConfigurationSetEventDestinations {
    type Output = std::result::Result<
        crate::output::GetConfigurationSetEventDestinationsOutput,
        crate::error::GetConfigurationSetEventDestinationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_configuration_set_event_destinations_error(response)
        } else {
            crate::operation_deser::parse_get_configuration_set_event_destinations_response(
                response,
            )
        }
    }
}

/// <p>Returns a contact from a contact list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContact {
    _private: (),
}
impl GetContact {
    /// Creates a new builder-style object to manufacture [`GetContactInput`](crate::input::GetContactInput)
    pub fn builder() -> crate::input::get_contact_input::Builder {
        crate::input::get_contact_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContact {
    type Output =
        std::result::Result<crate::output::GetContactOutput, crate::error::GetContactError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_contact_error(response)
        } else {
            crate::operation_deser::parse_get_contact_response(response)
        }
    }
}

/// <p>Returns contact list metadata. It does not return any information about the contacts
/// present in the list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetContactList {
    _private: (),
}
impl GetContactList {
    /// Creates a new builder-style object to manufacture [`GetContactListInput`](crate::input::GetContactListInput)
    pub fn builder() -> crate::input::get_contact_list_input::Builder {
        crate::input::get_contact_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetContactList {
    type Output =
        std::result::Result<crate::output::GetContactListOutput, crate::error::GetContactListError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_contact_list_error(response)
        } else {
            crate::operation_deser::parse_get_contact_list_response(response)
        }
    }
}

/// <p>Returns the custom email verification template for the template name you
/// specify.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCustomVerificationEmailTemplate {
    _private: (),
}
impl GetCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`GetCustomVerificationEmailTemplateInput`](crate::input::GetCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::get_custom_verification_email_template_input::Builder {
        crate::input::get_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::GetCustomVerificationEmailTemplateOutput,
        crate::error::GetCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_custom_verification_email_template_error(response)
        } else {
            crate::operation_deser::parse_get_custom_verification_email_template_response(response)
        }
    }
}

/// <p>Get information about a dedicated IP address, including the name of the dedicated IP
/// pool that it's associated with, as well information about the automatic warm-up process
/// for the address.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDedicatedIp {
    _private: (),
}
impl GetDedicatedIp {
    /// Creates a new builder-style object to manufacture [`GetDedicatedIpInput`](crate::input::GetDedicatedIpInput)
    pub fn builder() -> crate::input::get_dedicated_ip_input::Builder {
        crate::input::get_dedicated_ip_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDedicatedIp {
    type Output =
        std::result::Result<crate::output::GetDedicatedIpOutput, crate::error::GetDedicatedIpError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dedicated_ip_error(response)
        } else {
            crate::operation_deser::parse_get_dedicated_ip_response(response)
        }
    }
}

/// <p>List the dedicated IP addresses that are associated with your Amazon Web Services
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDedicatedIps {
    _private: (),
}
impl GetDedicatedIps {
    /// Creates a new builder-style object to manufacture [`GetDedicatedIpsInput`](crate::input::GetDedicatedIpsInput)
    pub fn builder() -> crate::input::get_dedicated_ips_input::Builder {
        crate::input::get_dedicated_ips_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDedicatedIps {
    type Output = std::result::Result<
        crate::output::GetDedicatedIpsOutput,
        crate::error::GetDedicatedIpsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_dedicated_ips_error(response)
        } else {
            crate::operation_deser::parse_get_dedicated_ips_response(response)
        }
    }
}

/// <p>Retrieve information about the status of the Deliverability dashboard for your account. When
/// the Deliverability dashboard is enabled, you gain access to reputation, deliverability, and other
/// metrics for the domains that you use to send email. You also gain the ability to perform
/// predictive inbox placement tests.</p>
/// <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
/// to any other fees that you accrue by using Amazon SES and other Amazon Web Services services. For more
/// information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/ses/pricing/">Amazon SES Pricing</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeliverabilityDashboardOptions {
    _private: (),
}
impl GetDeliverabilityDashboardOptions {
    /// Creates a new builder-style object to manufacture [`GetDeliverabilityDashboardOptionsInput`](crate::input::GetDeliverabilityDashboardOptionsInput)
    pub fn builder() -> crate::input::get_deliverability_dashboard_options_input::Builder {
        crate::input::get_deliverability_dashboard_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeliverabilityDashboardOptions {
    type Output = std::result::Result<
        crate::output::GetDeliverabilityDashboardOptionsOutput,
        crate::error::GetDeliverabilityDashboardOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deliverability_dashboard_options_error(response)
        } else {
            crate::operation_deser::parse_get_deliverability_dashboard_options_response(response)
        }
    }
}

/// <p>Retrieve the results of a predictive inbox placement test.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeliverabilityTestReport {
    _private: (),
}
impl GetDeliverabilityTestReport {
    /// Creates a new builder-style object to manufacture [`GetDeliverabilityTestReportInput`](crate::input::GetDeliverabilityTestReportInput)
    pub fn builder() -> crate::input::get_deliverability_test_report_input::Builder {
        crate::input::get_deliverability_test_report_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeliverabilityTestReport {
    type Output = std::result::Result<
        crate::output::GetDeliverabilityTestReportOutput,
        crate::error::GetDeliverabilityTestReportError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deliverability_test_report_error(response)
        } else {
            crate::operation_deser::parse_get_deliverability_test_report_response(response)
        }
    }
}

/// <p>Retrieve all the deliverability data for a specific campaign. This data is available
/// for a campaign only if the campaign sent email by using a domain that the
/// Deliverability dashboard is enabled for.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomainDeliverabilityCampaign {
    _private: (),
}
impl GetDomainDeliverabilityCampaign {
    /// Creates a new builder-style object to manufacture [`GetDomainDeliverabilityCampaignInput`](crate::input::GetDomainDeliverabilityCampaignInput)
    pub fn builder() -> crate::input::get_domain_deliverability_campaign_input::Builder {
        crate::input::get_domain_deliverability_campaign_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomainDeliverabilityCampaign {
    type Output = std::result::Result<
        crate::output::GetDomainDeliverabilityCampaignOutput,
        crate::error::GetDomainDeliverabilityCampaignError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_deliverability_campaign_error(response)
        } else {
            crate::operation_deser::parse_get_domain_deliverability_campaign_response(response)
        }
    }
}

/// <p>Retrieve inbox placement and engagement rates for the domains that you use to send
/// email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDomainStatisticsReport {
    _private: (),
}
impl GetDomainStatisticsReport {
    /// Creates a new builder-style object to manufacture [`GetDomainStatisticsReportInput`](crate::input::GetDomainStatisticsReportInput)
    pub fn builder() -> crate::input::get_domain_statistics_report_input::Builder {
        crate::input::get_domain_statistics_report_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDomainStatisticsReport {
    type Output = std::result::Result<
        crate::output::GetDomainStatisticsReportOutput,
        crate::error::GetDomainStatisticsReportError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_domain_statistics_report_error(response)
        } else {
            crate::operation_deser::parse_get_domain_statistics_report_response(response)
        }
    }
}

/// <p>Provides information about a specific identity, including the identity's verification
/// status, sending authorization policies, its DKIM authentication status, and its custom
/// Mail-From settings.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEmailIdentity {
    _private: (),
}
impl GetEmailIdentity {
    /// Creates a new builder-style object to manufacture [`GetEmailIdentityInput`](crate::input::GetEmailIdentityInput)
    pub fn builder() -> crate::input::get_email_identity_input::Builder {
        crate::input::get_email_identity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEmailIdentity {
    type Output = std::result::Result<
        crate::output::GetEmailIdentityOutput,
        crate::error::GetEmailIdentityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_email_identity_error(response)
        } else {
            crate::operation_deser::parse_get_email_identity_response(response)
        }
    }
}

/// <p>Returns the requested sending authorization policies for the given identity (an email
/// address or a domain). The policies are returned as a map of policy names to policy
/// contents. You can retrieve a maximum of 20 policies at a time.</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEmailIdentityPolicies {
    _private: (),
}
impl GetEmailIdentityPolicies {
    /// Creates a new builder-style object to manufacture [`GetEmailIdentityPoliciesInput`](crate::input::GetEmailIdentityPoliciesInput)
    pub fn builder() -> crate::input::get_email_identity_policies_input::Builder {
        crate::input::get_email_identity_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEmailIdentityPolicies {
    type Output = std::result::Result<
        crate::output::GetEmailIdentityPoliciesOutput,
        crate::error::GetEmailIdentityPoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_email_identity_policies_error(response)
        } else {
            crate::operation_deser::parse_get_email_identity_policies_response(response)
        }
    }
}

/// <p>Displays the template object (which includes the subject line, HTML part and text
/// part) for the template you specify.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetEmailTemplate {
    _private: (),
}
impl GetEmailTemplate {
    /// Creates a new builder-style object to manufacture [`GetEmailTemplateInput`](crate::input::GetEmailTemplateInput)
    pub fn builder() -> crate::input::get_email_template_input::Builder {
        crate::input::get_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetEmailTemplate {
    type Output = std::result::Result<
        crate::output::GetEmailTemplateOutput,
        crate::error::GetEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_email_template_error(response)
        } else {
            crate::operation_deser::parse_get_email_template_response(response)
        }
    }
}

/// <p>Provides information about an import job.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetImportJob {
    _private: (),
}
impl GetImportJob {
    /// Creates a new builder-style object to manufacture [`GetImportJobInput`](crate::input::GetImportJobInput)
    pub fn builder() -> crate::input::get_import_job_input::Builder {
        crate::input::get_import_job_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetImportJob {
    type Output =
        std::result::Result<crate::output::GetImportJobOutput, crate::error::GetImportJobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_import_job_error(response)
        } else {
            crate::operation_deser::parse_get_import_job_response(response)
        }
    }
}

/// <p>Retrieves information about a specific email address that's on the suppression list
/// for your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSuppressedDestination {
    _private: (),
}
impl GetSuppressedDestination {
    /// Creates a new builder-style object to manufacture [`GetSuppressedDestinationInput`](crate::input::GetSuppressedDestinationInput)
    pub fn builder() -> crate::input::get_suppressed_destination_input::Builder {
        crate::input::get_suppressed_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSuppressedDestination {
    type Output = std::result::Result<
        crate::output::GetSuppressedDestinationOutput,
        crate::error::GetSuppressedDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_suppressed_destination_error(response)
        } else {
            crate::operation_deser::parse_get_suppressed_destination_response(response)
        }
    }
}

/// <p>List all of the configuration sets associated with your account in the current
/// region.</p>
/// <p>
/// <i>Configuration sets</i> are groups of rules that you can apply to the
/// emails you send. You apply a configuration set to an email by including a reference to
/// the configuration set in the headers of the email. When you apply a configuration set to
/// an email, all of the rules in that configuration set are applied to the email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListConfigurationSets {
    _private: (),
}
impl ListConfigurationSets {
    /// Creates a new builder-style object to manufacture [`ListConfigurationSetsInput`](crate::input::ListConfigurationSetsInput)
    pub fn builder() -> crate::input::list_configuration_sets_input::Builder {
        crate::input::list_configuration_sets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListConfigurationSets {
    type Output = std::result::Result<
        crate::output::ListConfigurationSetsOutput,
        crate::error::ListConfigurationSetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_configuration_sets_error(response)
        } else {
            crate::operation_deser::parse_list_configuration_sets_response(response)
        }
    }
}

/// <p>Lists all of the contact lists available.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListContactLists {
    _private: (),
}
impl ListContactLists {
    /// Creates a new builder-style object to manufacture [`ListContactListsInput`](crate::input::ListContactListsInput)
    pub fn builder() -> crate::input::list_contact_lists_input::Builder {
        crate::input::list_contact_lists_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListContactLists {
    type Output = std::result::Result<
        crate::output::ListContactListsOutput,
        crate::error::ListContactListsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_contact_lists_error(response)
        } else {
            crate::operation_deser::parse_list_contact_lists_response(response)
        }
    }
}

/// <p>Lists the contacts present in a specific contact list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListContacts {
    _private: (),
}
impl ListContacts {
    /// Creates a new builder-style object to manufacture [`ListContactsInput`](crate::input::ListContactsInput)
    pub fn builder() -> crate::input::list_contacts_input::Builder {
        crate::input::list_contacts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListContacts {
    type Output =
        std::result::Result<crate::output::ListContactsOutput, crate::error::ListContactsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_contacts_error(response)
        } else {
            crate::operation_deser::parse_list_contacts_response(response)
        }
    }
}

/// <p>Lists the existing custom verification email templates for your account in the current
/// Amazon Web Services Region.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListCustomVerificationEmailTemplates {
    _private: (),
}
impl ListCustomVerificationEmailTemplates {
    /// Creates a new builder-style object to manufacture [`ListCustomVerificationEmailTemplatesInput`](crate::input::ListCustomVerificationEmailTemplatesInput)
    pub fn builder() -> crate::input::list_custom_verification_email_templates_input::Builder {
        crate::input::list_custom_verification_email_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListCustomVerificationEmailTemplates {
    type Output = std::result::Result<
        crate::output::ListCustomVerificationEmailTemplatesOutput,
        crate::error::ListCustomVerificationEmailTemplatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_custom_verification_email_templates_error(response)
        } else {
            crate::operation_deser::parse_list_custom_verification_email_templates_response(
                response,
            )
        }
    }
}

/// <p>List all of the dedicated IP pools that exist in your Amazon Web Services account in the current
/// Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDedicatedIpPools {
    _private: (),
}
impl ListDedicatedIpPools {
    /// Creates a new builder-style object to manufacture [`ListDedicatedIpPoolsInput`](crate::input::ListDedicatedIpPoolsInput)
    pub fn builder() -> crate::input::list_dedicated_ip_pools_input::Builder {
        crate::input::list_dedicated_ip_pools_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDedicatedIpPools {
    type Output = std::result::Result<
        crate::output::ListDedicatedIpPoolsOutput,
        crate::error::ListDedicatedIpPoolsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_dedicated_ip_pools_error(response)
        } else {
            crate::operation_deser::parse_list_dedicated_ip_pools_response(response)
        }
    }
}

/// <p>Show a list of the predictive inbox placement tests that you've performed, regardless of their statuses. For
/// predictive inbox placement tests that are complete, you can use the <code>GetDeliverabilityTestReport</code>
/// operation to view the results.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeliverabilityTestReports {
    _private: (),
}
impl ListDeliverabilityTestReports {
    /// Creates a new builder-style object to manufacture [`ListDeliverabilityTestReportsInput`](crate::input::ListDeliverabilityTestReportsInput)
    pub fn builder() -> crate::input::list_deliverability_test_reports_input::Builder {
        crate::input::list_deliverability_test_reports_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeliverabilityTestReports {
    type Output = std::result::Result<
        crate::output::ListDeliverabilityTestReportsOutput,
        crate::error::ListDeliverabilityTestReportsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deliverability_test_reports_error(response)
        } else {
            crate::operation_deser::parse_list_deliverability_test_reports_response(response)
        }
    }
}

/// <p>Retrieve deliverability data for all the campaigns that used a specific domain to send
/// email during a specified time range. This data is available for a domain only if you
/// enabled the Deliverability dashboard for the domain.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDomainDeliverabilityCampaigns {
    _private: (),
}
impl ListDomainDeliverabilityCampaigns {
    /// Creates a new builder-style object to manufacture [`ListDomainDeliverabilityCampaignsInput`](crate::input::ListDomainDeliverabilityCampaignsInput)
    pub fn builder() -> crate::input::list_domain_deliverability_campaigns_input::Builder {
        crate::input::list_domain_deliverability_campaigns_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDomainDeliverabilityCampaigns {
    type Output = std::result::Result<
        crate::output::ListDomainDeliverabilityCampaignsOutput,
        crate::error::ListDomainDeliverabilityCampaignsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_domain_deliverability_campaigns_error(response)
        } else {
            crate::operation_deser::parse_list_domain_deliverability_campaigns_response(response)
        }
    }
}

/// <p>Returns a list of all of the email identities that are associated with your Amazon Web Services
/// account. An identity can be either an email address or a domain. This operation returns
/// identities that are verified as well as those that aren't. This operation returns
/// identities that are associated with Amazon SES and Amazon Pinpoint.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEmailIdentities {
    _private: (),
}
impl ListEmailIdentities {
    /// Creates a new builder-style object to manufacture [`ListEmailIdentitiesInput`](crate::input::ListEmailIdentitiesInput)
    pub fn builder() -> crate::input::list_email_identities_input::Builder {
        crate::input::list_email_identities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEmailIdentities {
    type Output = std::result::Result<
        crate::output::ListEmailIdentitiesOutput,
        crate::error::ListEmailIdentitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_email_identities_error(response)
        } else {
            crate::operation_deser::parse_list_email_identities_response(response)
        }
    }
}

/// <p>Lists the email templates present in your Amazon SES account in the current Amazon Web Services
/// Region.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListEmailTemplates {
    _private: (),
}
impl ListEmailTemplates {
    /// Creates a new builder-style object to manufacture [`ListEmailTemplatesInput`](crate::input::ListEmailTemplatesInput)
    pub fn builder() -> crate::input::list_email_templates_input::Builder {
        crate::input::list_email_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListEmailTemplates {
    type Output = std::result::Result<
        crate::output::ListEmailTemplatesOutput,
        crate::error::ListEmailTemplatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_email_templates_error(response)
        } else {
            crate::operation_deser::parse_list_email_templates_response(response)
        }
    }
}

/// <p>Lists all of the import jobs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImportJobs {
    _private: (),
}
impl ListImportJobs {
    /// Creates a new builder-style object to manufacture [`ListImportJobsInput`](crate::input::ListImportJobsInput)
    pub fn builder() -> crate::input::list_import_jobs_input::Builder {
        crate::input::list_import_jobs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImportJobs {
    type Output =
        std::result::Result<crate::output::ListImportJobsOutput, crate::error::ListImportJobsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_import_jobs_error(response)
        } else {
            crate::operation_deser::parse_list_import_jobs_response(response)
        }
    }
}

/// <p>Retrieves a list of email addresses that are on the suppression list for your
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSuppressedDestinations {
    _private: (),
}
impl ListSuppressedDestinations {
    /// Creates a new builder-style object to manufacture [`ListSuppressedDestinationsInput`](crate::input::ListSuppressedDestinationsInput)
    pub fn builder() -> crate::input::list_suppressed_destinations_input::Builder {
        crate::input::list_suppressed_destinations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSuppressedDestinations {
    type Output = std::result::Result<
        crate::output::ListSuppressedDestinationsOutput,
        crate::error::ListSuppressedDestinationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_suppressed_destinations_error(response)
        } else {
            crate::operation_deser::parse_list_suppressed_destinations_response(response)
        }
    }
}

/// <p>Retrieve a list of the tags (keys and values) that are associated with a specified
/// resource. A <i>tag</i> is a label that you optionally define and associate
/// with a resource. Each tag consists of a required <i>tag key</i> and an
/// optional associated <i>tag value</i>. A tag key is a general label that
/// acts as a category for more specific tag values. A tag value acts as a descriptor within
/// a tag key.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Enable or disable the automatic warm-up feature for dedicated IP addresses.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAccountDedicatedIpWarmupAttributes {
    _private: (),
}
impl PutAccountDedicatedIpWarmupAttributes {
    /// Creates a new builder-style object to manufacture [`PutAccountDedicatedIpWarmupAttributesInput`](crate::input::PutAccountDedicatedIpWarmupAttributesInput)
    pub fn builder() -> crate::input::put_account_dedicated_ip_warmup_attributes_input::Builder {
        crate::input::put_account_dedicated_ip_warmup_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAccountDedicatedIpWarmupAttributes {
    type Output = std::result::Result<
        crate::output::PutAccountDedicatedIpWarmupAttributesOutput,
        crate::error::PutAccountDedicatedIpWarmupAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_account_dedicated_ip_warmup_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_account_dedicated_ip_warmup_attributes_response(
                response,
            )
        }
    }
}

/// <p>Update your Amazon SES account details.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAccountDetails {
    _private: (),
}
impl PutAccountDetails {
    /// Creates a new builder-style object to manufacture [`PutAccountDetailsInput`](crate::input::PutAccountDetailsInput)
    pub fn builder() -> crate::input::put_account_details_input::Builder {
        crate::input::put_account_details_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAccountDetails {
    type Output = std::result::Result<
        crate::output::PutAccountDetailsOutput,
        crate::error::PutAccountDetailsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_account_details_error(response)
        } else {
            crate::operation_deser::parse_put_account_details_response(response)
        }
    }
}

/// <p>Enable or disable the ability of your account to send email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAccountSendingAttributes {
    _private: (),
}
impl PutAccountSendingAttributes {
    /// Creates a new builder-style object to manufacture [`PutAccountSendingAttributesInput`](crate::input::PutAccountSendingAttributesInput)
    pub fn builder() -> crate::input::put_account_sending_attributes_input::Builder {
        crate::input::put_account_sending_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAccountSendingAttributes {
    type Output = std::result::Result<
        crate::output::PutAccountSendingAttributesOutput,
        crate::error::PutAccountSendingAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_account_sending_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_account_sending_attributes_response(response)
        }
    }
}

/// <p>Change the settings for the account-level suppression list.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutAccountSuppressionAttributes {
    _private: (),
}
impl PutAccountSuppressionAttributes {
    /// Creates a new builder-style object to manufacture [`PutAccountSuppressionAttributesInput`](crate::input::PutAccountSuppressionAttributesInput)
    pub fn builder() -> crate::input::put_account_suppression_attributes_input::Builder {
        crate::input::put_account_suppression_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutAccountSuppressionAttributes {
    type Output = std::result::Result<
        crate::output::PutAccountSuppressionAttributesOutput,
        crate::error::PutAccountSuppressionAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_account_suppression_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_account_suppression_attributes_response(response)
        }
    }
}

/// <p>Associate a configuration set with a dedicated IP pool. You can use dedicated IP pools
/// to create groups of dedicated IP addresses for sending specific types of email.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationSetDeliveryOptions {
    _private: (),
}
impl PutConfigurationSetDeliveryOptions {
    /// Creates a new builder-style object to manufacture [`PutConfigurationSetDeliveryOptionsInput`](crate::input::PutConfigurationSetDeliveryOptionsInput)
    pub fn builder() -> crate::input::put_configuration_set_delivery_options_input::Builder {
        crate::input::put_configuration_set_delivery_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationSetDeliveryOptions {
    type Output = std::result::Result<
        crate::output::PutConfigurationSetDeliveryOptionsOutput,
        crate::error::PutConfigurationSetDeliveryOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_set_delivery_options_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_set_delivery_options_response(response)
        }
    }
}

/// <p>Enable or disable collection of reputation metrics for emails that you send using a
/// particular configuration set in a specific Amazon Web Services Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationSetReputationOptions {
    _private: (),
}
impl PutConfigurationSetReputationOptions {
    /// Creates a new builder-style object to manufacture [`PutConfigurationSetReputationOptionsInput`](crate::input::PutConfigurationSetReputationOptionsInput)
    pub fn builder() -> crate::input::put_configuration_set_reputation_options_input::Builder {
        crate::input::put_configuration_set_reputation_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationSetReputationOptions {
    type Output = std::result::Result<
        crate::output::PutConfigurationSetReputationOptionsOutput,
        crate::error::PutConfigurationSetReputationOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_set_reputation_options_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_set_reputation_options_response(
                response,
            )
        }
    }
}

/// <p>Enable or disable email sending for messages that use a particular configuration set
/// in a specific Amazon Web Services Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationSetSendingOptions {
    _private: (),
}
impl PutConfigurationSetSendingOptions {
    /// Creates a new builder-style object to manufacture [`PutConfigurationSetSendingOptionsInput`](crate::input::PutConfigurationSetSendingOptionsInput)
    pub fn builder() -> crate::input::put_configuration_set_sending_options_input::Builder {
        crate::input::put_configuration_set_sending_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationSetSendingOptions {
    type Output = std::result::Result<
        crate::output::PutConfigurationSetSendingOptionsOutput,
        crate::error::PutConfigurationSetSendingOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_set_sending_options_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_set_sending_options_response(response)
        }
    }
}

/// <p>Specify the account suppression list preferences for a configuration set.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationSetSuppressionOptions {
    _private: (),
}
impl PutConfigurationSetSuppressionOptions {
    /// Creates a new builder-style object to manufacture [`PutConfigurationSetSuppressionOptionsInput`](crate::input::PutConfigurationSetSuppressionOptionsInput)
    pub fn builder() -> crate::input::put_configuration_set_suppression_options_input::Builder {
        crate::input::put_configuration_set_suppression_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationSetSuppressionOptions {
    type Output = std::result::Result<
        crate::output::PutConfigurationSetSuppressionOptionsOutput,
        crate::error::PutConfigurationSetSuppressionOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_set_suppression_options_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_set_suppression_options_response(
                response,
            )
        }
    }
}

/// <p>Specify a custom domain to use for open and click tracking elements in email that you
/// send.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutConfigurationSetTrackingOptions {
    _private: (),
}
impl PutConfigurationSetTrackingOptions {
    /// Creates a new builder-style object to manufacture [`PutConfigurationSetTrackingOptionsInput`](crate::input::PutConfigurationSetTrackingOptionsInput)
    pub fn builder() -> crate::input::put_configuration_set_tracking_options_input::Builder {
        crate::input::put_configuration_set_tracking_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutConfigurationSetTrackingOptions {
    type Output = std::result::Result<
        crate::output::PutConfigurationSetTrackingOptionsOutput,
        crate::error::PutConfigurationSetTrackingOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_configuration_set_tracking_options_error(response)
        } else {
            crate::operation_deser::parse_put_configuration_set_tracking_options_response(response)
        }
    }
}

/// <p>Move a dedicated IP address to an existing dedicated IP pool.</p>
/// <note>
/// <p>The dedicated IP address that you specify must already exist, and must be
/// associated with your Amazon Web Services account.
/// </p>
/// <p>The dedicated IP pool you specify must already exist. You can create a new pool by
/// using the <code>CreateDedicatedIpPool</code> operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDedicatedIpInPool {
    _private: (),
}
impl PutDedicatedIpInPool {
    /// Creates a new builder-style object to manufacture [`PutDedicatedIpInPoolInput`](crate::input::PutDedicatedIpInPoolInput)
    pub fn builder() -> crate::input::put_dedicated_ip_in_pool_input::Builder {
        crate::input::put_dedicated_ip_in_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDedicatedIpInPool {
    type Output = std::result::Result<
        crate::output::PutDedicatedIpInPoolOutput,
        crate::error::PutDedicatedIpInPoolError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_dedicated_ip_in_pool_error(response)
        } else {
            crate::operation_deser::parse_put_dedicated_ip_in_pool_response(response)
        }
    }
}

/// <p></p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDedicatedIpWarmupAttributes {
    _private: (),
}
impl PutDedicatedIpWarmupAttributes {
    /// Creates a new builder-style object to manufacture [`PutDedicatedIpWarmupAttributesInput`](crate::input::PutDedicatedIpWarmupAttributesInput)
    pub fn builder() -> crate::input::put_dedicated_ip_warmup_attributes_input::Builder {
        crate::input::put_dedicated_ip_warmup_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDedicatedIpWarmupAttributes {
    type Output = std::result::Result<
        crate::output::PutDedicatedIpWarmupAttributesOutput,
        crate::error::PutDedicatedIpWarmupAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_dedicated_ip_warmup_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_dedicated_ip_warmup_attributes_response(response)
        }
    }
}

/// <p>Enable or disable the Deliverability dashboard. When you enable the Deliverability dashboard, you gain
/// access to reputation, deliverability, and other metrics for the domains that you use to
/// send email. You also gain the ability to perform predictive inbox placement tests.</p>
/// <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
/// to any other fees that you accrue by using Amazon SES and other Amazon Web Services services. For more
/// information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/ses/pricing/">Amazon SES Pricing</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutDeliverabilityDashboardOption {
    _private: (),
}
impl PutDeliverabilityDashboardOption {
    /// Creates a new builder-style object to manufacture [`PutDeliverabilityDashboardOptionInput`](crate::input::PutDeliverabilityDashboardOptionInput)
    pub fn builder() -> crate::input::put_deliverability_dashboard_option_input::Builder {
        crate::input::put_deliverability_dashboard_option_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutDeliverabilityDashboardOption {
    type Output = std::result::Result<
        crate::output::PutDeliverabilityDashboardOptionOutput,
        crate::error::PutDeliverabilityDashboardOptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_deliverability_dashboard_option_error(response)
        } else {
            crate::operation_deser::parse_put_deliverability_dashboard_option_response(response)
        }
    }
}

/// <p>Used to associate a configuration set with an email identity.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEmailIdentityConfigurationSetAttributes {
    _private: (),
}
impl PutEmailIdentityConfigurationSetAttributes {
    /// Creates a new builder-style object to manufacture [`PutEmailIdentityConfigurationSetAttributesInput`](crate::input::PutEmailIdentityConfigurationSetAttributesInput)
    pub fn builder() -> crate::input::put_email_identity_configuration_set_attributes_input::Builder
    {
        crate::input::put_email_identity_configuration_set_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEmailIdentityConfigurationSetAttributes {
    type Output = std::result::Result<
        crate::output::PutEmailIdentityConfigurationSetAttributesOutput,
        crate::error::PutEmailIdentityConfigurationSetAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_email_identity_configuration_set_attributes_error(
                response,
            )
        } else {
            crate::operation_deser::parse_put_email_identity_configuration_set_attributes_response(
                response,
            )
        }
    }
}

/// <p>Used to enable or disable DKIM authentication for an email identity.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEmailIdentityDkimAttributes {
    _private: (),
}
impl PutEmailIdentityDkimAttributes {
    /// Creates a new builder-style object to manufacture [`PutEmailIdentityDkimAttributesInput`](crate::input::PutEmailIdentityDkimAttributesInput)
    pub fn builder() -> crate::input::put_email_identity_dkim_attributes_input::Builder {
        crate::input::put_email_identity_dkim_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEmailIdentityDkimAttributes {
    type Output = std::result::Result<
        crate::output::PutEmailIdentityDkimAttributesOutput,
        crate::error::PutEmailIdentityDkimAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_email_identity_dkim_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_email_identity_dkim_attributes_response(response)
        }
    }
}

/// <p>Used to configure or change the DKIM authentication settings for an email domain
/// identity. You can use this operation to do any of the following:</p>
/// <ul>
/// <li>
/// <p>Update the signing attributes for an identity that uses Bring Your Own DKIM
/// (BYODKIM).</p>
/// </li>
/// <li>
/// <p>Update the key length that should be used for Easy DKIM.</p>
/// </li>
/// <li>
/// <p>Change from using no DKIM authentication to using Easy DKIM.</p>
/// </li>
/// <li>
/// <p>Change from using no DKIM authentication to using BYODKIM.</p>
/// </li>
/// <li>
/// <p>Change from using Easy DKIM to using BYODKIM.</p>
/// </li>
/// <li>
/// <p>Change from using BYODKIM to using Easy DKIM.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEmailIdentityDkimSigningAttributes {
    _private: (),
}
impl PutEmailIdentityDkimSigningAttributes {
    /// Creates a new builder-style object to manufacture [`PutEmailIdentityDkimSigningAttributesInput`](crate::input::PutEmailIdentityDkimSigningAttributesInput)
    pub fn builder() -> crate::input::put_email_identity_dkim_signing_attributes_input::Builder {
        crate::input::put_email_identity_dkim_signing_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEmailIdentityDkimSigningAttributes {
    type Output = std::result::Result<
        crate::output::PutEmailIdentityDkimSigningAttributesOutput,
        crate::error::PutEmailIdentityDkimSigningAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_email_identity_dkim_signing_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_email_identity_dkim_signing_attributes_response(
                response,
            )
        }
    }
}

/// <p>Used to enable or disable feedback forwarding for an identity. This setting determines
/// what happens when an identity is used to send an email that results in a bounce or
/// complaint event.</p>
/// <p>If the value is <code>true</code>, you receive email notifications when bounce or
/// complaint events occur. These notifications are sent to the address that you specified
/// in the <code>Return-Path</code> header of the original email.</p>
/// <p>You're required to have a method of tracking bounces and complaints. If you haven't
/// set up another mechanism for receiving bounce or complaint notifications (for example,
/// by setting up an event destination), you receive an email notification when these events
/// occur (even if this setting is disabled).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEmailIdentityFeedbackAttributes {
    _private: (),
}
impl PutEmailIdentityFeedbackAttributes {
    /// Creates a new builder-style object to manufacture [`PutEmailIdentityFeedbackAttributesInput`](crate::input::PutEmailIdentityFeedbackAttributesInput)
    pub fn builder() -> crate::input::put_email_identity_feedback_attributes_input::Builder {
        crate::input::put_email_identity_feedback_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEmailIdentityFeedbackAttributes {
    type Output = std::result::Result<
        crate::output::PutEmailIdentityFeedbackAttributesOutput,
        crate::error::PutEmailIdentityFeedbackAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_email_identity_feedback_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_email_identity_feedback_attributes_response(response)
        }
    }
}

/// <p>Used to enable or disable the custom Mail-From domain configuration for an email
/// identity.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutEmailIdentityMailFromAttributes {
    _private: (),
}
impl PutEmailIdentityMailFromAttributes {
    /// Creates a new builder-style object to manufacture [`PutEmailIdentityMailFromAttributesInput`](crate::input::PutEmailIdentityMailFromAttributesInput)
    pub fn builder() -> crate::input::put_email_identity_mail_from_attributes_input::Builder {
        crate::input::put_email_identity_mail_from_attributes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutEmailIdentityMailFromAttributes {
    type Output = std::result::Result<
        crate::output::PutEmailIdentityMailFromAttributesOutput,
        crate::error::PutEmailIdentityMailFromAttributesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_email_identity_mail_from_attributes_error(response)
        } else {
            crate::operation_deser::parse_put_email_identity_mail_from_attributes_response(response)
        }
    }
}

/// <p>Adds an email address to the suppression list for your account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSuppressedDestination {
    _private: (),
}
impl PutSuppressedDestination {
    /// Creates a new builder-style object to manufacture [`PutSuppressedDestinationInput`](crate::input::PutSuppressedDestinationInput)
    pub fn builder() -> crate::input::put_suppressed_destination_input::Builder {
        crate::input::put_suppressed_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSuppressedDestination {
    type Output = std::result::Result<
        crate::output::PutSuppressedDestinationOutput,
        crate::error::PutSuppressedDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_suppressed_destination_error(response)
        } else {
            crate::operation_deser::parse_put_suppressed_destination_response(response)
        }
    }
}

/// <p>Composes an email message to multiple destinations.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendBulkEmail {
    _private: (),
}
impl SendBulkEmail {
    /// Creates a new builder-style object to manufacture [`SendBulkEmailInput`](crate::input::SendBulkEmailInput)
    pub fn builder() -> crate::input::send_bulk_email_input::Builder {
        crate::input::send_bulk_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendBulkEmail {
    type Output =
        std::result::Result<crate::output::SendBulkEmailOutput, crate::error::SendBulkEmailError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_send_bulk_email_error(response)
        } else {
            crate::operation_deser::parse_send_bulk_email_response(response)
        }
    }
}

/// <p>Adds an email address to the list of identities for your Amazon SES account in the current
/// Amazon Web Services Region and attempts to verify it. As a result of executing this operation, a
/// customized verification email is sent to the specified address.</p>
/// <p>To use this operation, you must first create a custom verification email template. For
/// more information about creating and using custom verification email templates, see
/// <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendCustomVerificationEmail {
    _private: (),
}
impl SendCustomVerificationEmail {
    /// Creates a new builder-style object to manufacture [`SendCustomVerificationEmailInput`](crate::input::SendCustomVerificationEmailInput)
    pub fn builder() -> crate::input::send_custom_verification_email_input::Builder {
        crate::input::send_custom_verification_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendCustomVerificationEmail {
    type Output = std::result::Result<
        crate::output::SendCustomVerificationEmailOutput,
        crate::error::SendCustomVerificationEmailError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_send_custom_verification_email_error(response)
        } else {
            crate::operation_deser::parse_send_custom_verification_email_response(response)
        }
    }
}

/// <p>Sends an email message. You can use the Amazon SES API v2 to send the following types of
/// messages:</p>
/// <ul>
/// <li>
/// <p>
/// <b>Simple</b> – A standard email message. When
/// you create this type of message, you specify the sender, the recipient, and the
/// message body, and Amazon SES assembles the message for you.</p>
/// </li>
/// <li>
/// <p>
/// <b>Raw</b> – A raw, MIME-formatted email
/// message. When you send this type of email, you have to specify all of the
/// message headers, as well as the message body. You can use this message type to
/// send messages that contain attachments. The message that you specify has to be a
/// valid MIME message.</p>
/// </li>
/// <li>
/// <p>
/// <b>Templated</b> – A message that contains
/// personalization tags. When you send this type of email, Amazon SES API v2 automatically
/// replaces the tags with values that you specify.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SendEmail {
    _private: (),
}
impl SendEmail {
    /// Creates a new builder-style object to manufacture [`SendEmailInput`](crate::input::SendEmailInput)
    pub fn builder() -> crate::input::send_email_input::Builder {
        crate::input::send_email_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SendEmail {
    type Output = std::result::Result<crate::output::SendEmailOutput, crate::error::SendEmailError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_send_email_error(response)
        } else {
            crate::operation_deser::parse_send_email_response(response)
        }
    }
}

/// <p>Add one or more tags (keys and values) to a specified resource. A
/// <i>tag</i> is a label that you optionally define and associate with a
/// resource. Tags can help you categorize and manage resources in different ways, such as
/// by purpose, owner, environment, or other criteria. A resource can have as many as 50
/// tags.</p>
/// <p>Each tag consists of a required <i>tag key</i> and an
/// associated <i>tag value</i>, both of which you define. A tag key is a
/// general label that acts as a category for more specific tag values. A tag value acts as
/// a descriptor within a tag key.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Creates a preview of the MIME content of an email when provided with a template and a
/// set of replacement data.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestRenderEmailTemplate {
    _private: (),
}
impl TestRenderEmailTemplate {
    /// Creates a new builder-style object to manufacture [`TestRenderEmailTemplateInput`](crate::input::TestRenderEmailTemplateInput)
    pub fn builder() -> crate::input::test_render_email_template_input::Builder {
        crate::input::test_render_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestRenderEmailTemplate {
    type Output = std::result::Result<
        crate::output::TestRenderEmailTemplateOutput,
        crate::error::TestRenderEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_render_email_template_error(response)
        } else {
            crate::operation_deser::parse_test_render_email_template_response(response)
        }
    }
}

/// <p>Remove one or more tags (keys and values) from a specified resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Update the configuration of an event destination for a configuration set.</p>
/// <p>
/// <i>Events</i> include message sends, deliveries, opens, clicks, bounces,
/// and complaints. <i>Event destinations</i> are places that you can send
/// information about these events to. For example, you can send event data to Amazon SNS to
/// receive notifications when you receive bounces or complaints, or you can use Amazon Kinesis Data Firehose to
/// stream data to Amazon S3 for long-term storage.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConfigurationSetEventDestination {
    _private: (),
}
impl UpdateConfigurationSetEventDestination {
    /// Creates a new builder-style object to manufacture [`UpdateConfigurationSetEventDestinationInput`](crate::input::UpdateConfigurationSetEventDestinationInput)
    pub fn builder() -> crate::input::update_configuration_set_event_destination_input::Builder {
        crate::input::update_configuration_set_event_destination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConfigurationSetEventDestination {
    type Output = std::result::Result<
        crate::output::UpdateConfigurationSetEventDestinationOutput,
        crate::error::UpdateConfigurationSetEventDestinationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_configuration_set_event_destination_error(response)
        } else {
            crate::operation_deser::parse_update_configuration_set_event_destination_response(
                response,
            )
        }
    }
}

/// <p>Updates a contact's preferences for a list. It is not necessary to specify all
/// existing topic preferences in the TopicPreferences object, just the ones that need
/// updating.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateContact {
    _private: (),
}
impl UpdateContact {
    /// Creates a new builder-style object to manufacture [`UpdateContactInput`](crate::input::UpdateContactInput)
    pub fn builder() -> crate::input::update_contact_input::Builder {
        crate::input::update_contact_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateContact {
    type Output =
        std::result::Result<crate::output::UpdateContactOutput, crate::error::UpdateContactError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_contact_error(response)
        } else {
            crate::operation_deser::parse_update_contact_response(response)
        }
    }
}

/// <p>Updates contact list metadata. This operation does a complete replacement.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateContactList {
    _private: (),
}
impl UpdateContactList {
    /// Creates a new builder-style object to manufacture [`UpdateContactListInput`](crate::input::UpdateContactListInput)
    pub fn builder() -> crate::input::update_contact_list_input::Builder {
        crate::input::update_contact_list_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateContactList {
    type Output = std::result::Result<
        crate::output::UpdateContactListOutput,
        crate::error::UpdateContactListError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_contact_list_error(response)
        } else {
            crate::operation_deser::parse_update_contact_list_response(response)
        }
    }
}

/// <p>Updates an existing custom verification email template.</p>
/// <p>For more information about custom verification email templates, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html">Using Custom Verification Email Templates</a> in the <i>Amazon SES Developer
/// Guide</i>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateCustomVerificationEmailTemplate {
    _private: (),
}
impl UpdateCustomVerificationEmailTemplate {
    /// Creates a new builder-style object to manufacture [`UpdateCustomVerificationEmailTemplateInput`](crate::input::UpdateCustomVerificationEmailTemplateInput)
    pub fn builder() -> crate::input::update_custom_verification_email_template_input::Builder {
        crate::input::update_custom_verification_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateCustomVerificationEmailTemplate {
    type Output = std::result::Result<
        crate::output::UpdateCustomVerificationEmailTemplateOutput,
        crate::error::UpdateCustomVerificationEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_custom_verification_email_template_error(response)
        } else {
            crate::operation_deser::parse_update_custom_verification_email_template_response(
                response,
            )
        }
    }
}

/// <p>Updates the specified sending authorization policy for the given identity (an email
/// address or a domain). This API returns successfully even if a policy with the specified
/// name does not exist.</p>
/// <note>
/// <p>This API is for the identity owner only. If you have not verified the identity,
/// this API will return an error.</p>
/// </note>
/// <p>Sending authorization is a feature that enables an identity owner to authorize other
/// senders to use its identities. For information about using sending authorization, see
/// the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateEmailIdentityPolicy {
    _private: (),
}
impl UpdateEmailIdentityPolicy {
    /// Creates a new builder-style object to manufacture [`UpdateEmailIdentityPolicyInput`](crate::input::UpdateEmailIdentityPolicyInput)
    pub fn builder() -> crate::input::update_email_identity_policy_input::Builder {
        crate::input::update_email_identity_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateEmailIdentityPolicy {
    type Output = std::result::Result<
        crate::output::UpdateEmailIdentityPolicyOutput,
        crate::error::UpdateEmailIdentityPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_email_identity_policy_error(response)
        } else {
            crate::operation_deser::parse_update_email_identity_policy_response(response)
        }
    }
}

/// <p>Updates an email template. Email templates enable you to send personalized email to
/// one or more destinations in a single API operation. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
/// Guide</a>.</p>
/// <p>You can execute this operation no more than once per second.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateEmailTemplate {
    _private: (),
}
impl UpdateEmailTemplate {
    /// Creates a new builder-style object to manufacture [`UpdateEmailTemplateInput`](crate::input::UpdateEmailTemplateInput)
    pub fn builder() -> crate::input::update_email_template_input::Builder {
        crate::input::update_email_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateEmailTemplate {
    type Output = std::result::Result<
        crate::output::UpdateEmailTemplateOutput,
        crate::error::UpdateEmailTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_email_template_error(response)
        } else {
            crate::operation_deser::parse_update_email_template_response(response)
        }
    }
}
