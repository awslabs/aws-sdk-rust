// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfigurationSetError {
    pub kind: CreateConfigurationSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfigurationSetErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConfigurationSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfigurationSetErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConfigurationSetError {
    fn code(&self) -> Option<&str> {
        CreateConfigurationSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfigurationSetError {
    pub fn new(kind: CreateConfigurationSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConfigurationSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConfigurationSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateConfigurationSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfigurationSetErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfigurationSetEventDestinationError {
    pub kind: CreateConfigurationSetEventDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfigurationSetEventDestinationErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConfigurationSetEventDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConfigurationSetEventDestinationError {
    fn code(&self) -> Option<&str> {
        CreateConfigurationSetEventDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfigurationSetEventDestinationError {
    pub fn new(
        kind: CreateConfigurationSetEventDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateConfigurationSetEventDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContactError {
    pub kind: CreateContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContactErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContactErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateContactErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateContactErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateContactErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContactError {
    fn code(&self) -> Option<&str> {
        CreateContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContactError {
    pub fn new(kind: CreateContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateContactErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateContactErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContactErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateContactErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateContactErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateContactErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContactListError {
    pub kind: CreateContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContactListErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContactListErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContactListError {
    fn code(&self) -> Option<&str> {
        CreateContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContactListError {
    pub fn new(kind: CreateContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContactListErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateContactListErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateContactListErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateContactListErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomVerificationEmailTemplateError {
    pub kind: CreateCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomVerificationEmailTemplateErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        CreateCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomVerificationEmailTemplateError {
    pub fn new(
        kind: CreateCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDedicatedIpPoolError {
    pub kind: CreateDedicatedIpPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDedicatedIpPoolErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDedicatedIpPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDedicatedIpPoolErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreateDedicatedIpPoolErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDedicatedIpPoolError {
    fn code(&self) -> Option<&str> {
        CreateDedicatedIpPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDedicatedIpPoolError {
    pub fn new(kind: CreateDedicatedIpPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDedicatedIpPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDedicatedIpPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateDedicatedIpPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDedicatedIpPoolErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDeliverabilityTestReportError {
    pub kind: CreateDeliverabilityTestReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeliverabilityTestReportErrorKind {
    AccountSuspendedException(crate::error::AccountSuspendedException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    LimitExceededException(crate::error::LimitExceededException),
    MailFromDomainNotVerifiedException(crate::error::MailFromDomainNotVerifiedException),
    MessageRejected(crate::error::MessageRejected),
    NotFoundException(crate::error::NotFoundException),
    SendingPausedException(crate::error::SendingPausedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDeliverabilityTestReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDeliverabilityTestReportErrorKind::AccountSuspendedException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::SendingPausedException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDeliverabilityTestReportError {
    fn code(&self) -> Option<&str> {
        CreateDeliverabilityTestReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeliverabilityTestReportError {
    pub fn new(kind: CreateDeliverabilityTestReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDeliverabilityTestReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDeliverabilityTestReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_account_suspended_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::AccountSuspendedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_mail_from_domain_not_verified_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedException(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::MessageRejected(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::NotFoundException(_)
        )
    }
    pub fn is_sending_paused_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::SendingPausedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateDeliverabilityTestReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDeliverabilityTestReportErrorKind::AccountSuspendedException(_inner) => {
                Some(_inner)
            }
            CreateDeliverabilityTestReportErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            CreateDeliverabilityTestReportErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedException(_inner) => {
                Some(_inner)
            }
            CreateDeliverabilityTestReportErrorKind::MessageRejected(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::SendingPausedException(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            CreateDeliverabilityTestReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailIdentityError {
    pub kind: CreateEmailIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailIdentityErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailIdentityErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailIdentityError {
    fn code(&self) -> Option<&str> {
        CreateEmailIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailIdentityError {
    pub fn new(kind: CreateEmailIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateEmailIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailIdentityErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailIdentityPolicyError {
    pub kind: CreateEmailIdentityPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailIdentityPolicyErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailIdentityPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailIdentityPolicyErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailIdentityPolicyError {
    fn code(&self) -> Option<&str> {
        CreateEmailIdentityPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailIdentityPolicyError {
    pub fn new(kind: CreateEmailIdentityPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateEmailIdentityPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailIdentityPolicyErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailTemplateError {
    pub kind: CreateEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailTemplateErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailTemplateErrorKind::AlreadyExistsException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailTemplateError {
    fn code(&self) -> Option<&str> {
        CreateEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailTemplateError {
    pub fn new(kind: CreateEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailTemplateErrorKind::AlreadyExistsException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateImportJobError {
    pub kind: CreateImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateImportJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateImportJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateImportJobError {
    fn code(&self) -> Option<&str> {
        CreateImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateImportJobError {
    pub fn new(kind: CreateImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateImportJobErrorKind::BadRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateImportJobErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateImportJobErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationSetError {
    pub kind: DeleteConfigurationSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationSetErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationSetErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationSetErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigurationSetError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationSetError {
    pub fn new(kind: DeleteConfigurationSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationSetErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationSetErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationSetEventDestinationError {
    pub kind: DeleteConfigurationSetEventDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationSetEventDestinationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationSetEventDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationSetEventDestinationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationSetEventDestinationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigurationSetEventDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationSetEventDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationSetEventDestinationError {
    pub fn new(
        kind: DeleteConfigurationSetEventDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetEventDestinationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetEventDestinationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationSetEventDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationSetEventDestinationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationSetEventDestinationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContactError {
    pub kind: DeleteContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContactErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContactErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteContactErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteContactErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContactError {
    fn code(&self) -> Option<&str> {
        DeleteContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContactError {
    pub fn new(kind: DeleteContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteContactErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteContactErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContactErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteContactErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteContactErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContactListError {
    pub kind: DeleteContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContactListErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContactListErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContactListError {
    fn code(&self) -> Option<&str> {
        DeleteContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContactListError {
    pub fn new(kind: DeleteContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactListErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactListErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteContactListErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactListErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContactListErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteContactListErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteContactListErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteContactListErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomVerificationEmailTemplateError {
    pub kind: DeleteCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomVerificationEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomVerificationEmailTemplateError {
    pub fn new(
        kind: DeleteCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomVerificationEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomVerificationEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDedicatedIpPoolError {
    pub kind: DeleteDedicatedIpPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDedicatedIpPoolErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDedicatedIpPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDedicatedIpPoolErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteDedicatedIpPoolErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDedicatedIpPoolError {
    fn code(&self) -> Option<&str> {
        DeleteDedicatedIpPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDedicatedIpPoolError {
    pub fn new(kind: DeleteDedicatedIpPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDedicatedIpPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDedicatedIpPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteDedicatedIpPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDedicatedIpPoolErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailIdentityError {
    pub kind: DeleteEmailIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailIdentityErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailIdentityErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailIdentityError {
    fn code(&self) -> Option<&str> {
        DeleteEmailIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailIdentityError {
    pub fn new(kind: DeleteEmailIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEmailIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailIdentityErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailIdentityPolicyError {
    pub kind: DeleteEmailIdentityPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailIdentityPolicyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailIdentityPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailIdentityPolicyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityPolicyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityPolicyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEmailIdentityPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailIdentityPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteEmailIdentityPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailIdentityPolicyError {
    pub fn new(kind: DeleteEmailIdentityPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailIdentityPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailIdentityPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityPolicyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityPolicyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityPolicyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEmailIdentityPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailIdentityPolicyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEmailIdentityPolicyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEmailIdentityPolicyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEmailIdentityPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailTemplateError {
    pub kind: DeleteEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailTemplateError {
    pub fn new(kind: DeleteEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSuppressedDestinationError {
    pub kind: DeleteSuppressedDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSuppressedDestinationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSuppressedDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSuppressedDestinationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSuppressedDestinationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSuppressedDestinationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteSuppressedDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSuppressedDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteSuppressedDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSuppressedDestinationError {
    pub fn new(kind: DeleteSuppressedDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSuppressedDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSuppressedDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSuppressedDestinationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSuppressedDestinationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSuppressedDestinationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteSuppressedDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSuppressedDestinationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSuppressedDestinationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSuppressedDestinationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteSuppressedDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountError {
    pub kind: GetAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountError {
    fn code(&self) -> Option<&str> {
        GetAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountError {
    pub fn new(kind: GetAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::BadRequestException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAccountErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlacklistReportsError {
    pub kind: GetBlacklistReportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlacklistReportsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlacklistReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlacklistReportsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBlacklistReportsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBlacklistReportsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetBlacklistReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlacklistReportsError {
    fn code(&self) -> Option<&str> {
        GetBlacklistReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlacklistReportsError {
    pub fn new(kind: GetBlacklistReportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlacklistReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlacklistReportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlacklistReportsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlacklistReportsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlacklistReportsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetBlacklistReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlacklistReportsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBlacklistReportsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBlacklistReportsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetBlacklistReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfigurationSetError {
    pub kind: GetConfigurationSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfigurationSetErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConfigurationSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfigurationSetErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetConfigurationSetErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetConfigurationSetErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetConfigurationSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConfigurationSetError {
    fn code(&self) -> Option<&str> {
        GetConfigurationSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfigurationSetError {
    pub fn new(kind: GetConfigurationSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConfigurationSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConfigurationSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetConfigurationSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfigurationSetErrorKind::BadRequestException(_inner) => Some(_inner),
            GetConfigurationSetErrorKind::NotFoundException(_inner) => Some(_inner),
            GetConfigurationSetErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetConfigurationSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfigurationSetEventDestinationsError {
    pub kind: GetConfigurationSetEventDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfigurationSetEventDestinationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConfigurationSetEventDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfigurationSetEventDestinationsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetConfigurationSetEventDestinationsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetConfigurationSetEventDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConfigurationSetEventDestinationsError {
    fn code(&self) -> Option<&str> {
        GetConfigurationSetEventDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfigurationSetEventDestinationsError {
    pub fn new(
        kind: GetConfigurationSetEventDestinationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConfigurationSetEventDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConfigurationSetEventDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetEventDestinationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetEventDestinationsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetConfigurationSetEventDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfigurationSetEventDestinationsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetConfigurationSetEventDestinationsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetConfigurationSetEventDestinationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactError {
    pub kind: GetContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetContactErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContactErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactError {
    fn code(&self) -> Option<&str> {
        GetContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactError {
    pub fn new(kind: GetContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetContactErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetContactErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetContactErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactErrorKind::BadRequestException(_inner) => Some(_inner),
            GetContactErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContactErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactListError {
    pub kind: GetContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactListErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactListErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetContactListErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetContactListErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactListError {
    fn code(&self) -> Option<&str> {
        GetContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactListError {
    pub fn new(kind: GetContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetContactListErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetContactListErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetContactListErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactListErrorKind::BadRequestException(_inner) => Some(_inner),
            GetContactListErrorKind::NotFoundException(_inner) => Some(_inner),
            GetContactListErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCustomVerificationEmailTemplateError {
    pub kind: GetCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCustomVerificationEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        GetCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCustomVerificationEmailTemplateError {
    pub fn new(
        kind: GetCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCustomVerificationEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCustomVerificationEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDedicatedIpError {
    pub kind: GetDedicatedIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDedicatedIpErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDedicatedIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDedicatedIpErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDedicatedIpErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDedicatedIpErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDedicatedIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDedicatedIpError {
    fn code(&self) -> Option<&str> {
        GetDedicatedIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDedicatedIpError {
    pub fn new(kind: GetDedicatedIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDedicatedIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDedicatedIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDedicatedIpErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetDedicatedIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDedicatedIpErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDedicatedIpErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDedicatedIpErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDedicatedIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDedicatedIpsError {
    pub kind: GetDedicatedIpsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDedicatedIpsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDedicatedIpsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDedicatedIpsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDedicatedIpsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDedicatedIpsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDedicatedIpsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDedicatedIpsError {
    fn code(&self) -> Option<&str> {
        GetDedicatedIpsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDedicatedIpsError {
    pub fn new(kind: GetDedicatedIpsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDedicatedIpsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDedicatedIpsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpsErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpsErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDedicatedIpsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetDedicatedIpsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDedicatedIpsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDedicatedIpsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDedicatedIpsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDedicatedIpsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeliverabilityDashboardOptionsError {
    pub kind: GetDeliverabilityDashboardOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeliverabilityDashboardOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeliverabilityDashboardOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeliverabilityDashboardOptionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetDeliverabilityDashboardOptionsErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetDeliverabilityDashboardOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeliverabilityDashboardOptionsError {
    fn code(&self) -> Option<&str> {
        GetDeliverabilityDashboardOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeliverabilityDashboardOptionsError {
    pub fn new(
        kind: GetDeliverabilityDashboardOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeliverabilityDashboardOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeliverabilityDashboardOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityDashboardOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityDashboardOptionsErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetDeliverabilityDashboardOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeliverabilityDashboardOptionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDeliverabilityDashboardOptionsErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetDeliverabilityDashboardOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeliverabilityTestReportError {
    pub kind: GetDeliverabilityTestReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeliverabilityTestReportErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeliverabilityTestReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeliverabilityTestReportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDeliverabilityTestReportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDeliverabilityTestReportErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDeliverabilityTestReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeliverabilityTestReportError {
    fn code(&self) -> Option<&str> {
        GetDeliverabilityTestReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeliverabilityTestReportError {
    pub fn new(kind: GetDeliverabilityTestReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeliverabilityTestReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeliverabilityTestReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityTestReportErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityTestReportErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityTestReportErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetDeliverabilityTestReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeliverabilityTestReportErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDeliverabilityTestReportErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDeliverabilityTestReportErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDeliverabilityTestReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainDeliverabilityCampaignError {
    pub kind: GetDomainDeliverabilityCampaignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainDeliverabilityCampaignErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainDeliverabilityCampaignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainDeliverabilityCampaignErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDomainDeliverabilityCampaignErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetDomainDeliverabilityCampaignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainDeliverabilityCampaignError {
    fn code(&self) -> Option<&str> {
        GetDomainDeliverabilityCampaignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainDeliverabilityCampaignError {
    pub fn new(kind: GetDomainDeliverabilityCampaignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainDeliverabilityCampaignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainDeliverabilityCampaignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainDeliverabilityCampaignErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainDeliverabilityCampaignErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetDomainDeliverabilityCampaignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainDeliverabilityCampaignErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDomainDeliverabilityCampaignErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetDomainDeliverabilityCampaignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainStatisticsReportError {
    pub kind: GetDomainStatisticsReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainStatisticsReportErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainStatisticsReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainStatisticsReportErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetDomainStatisticsReportErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetDomainStatisticsReportErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetDomainStatisticsReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainStatisticsReportError {
    fn code(&self) -> Option<&str> {
        GetDomainStatisticsReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainStatisticsReportError {
    pub fn new(kind: GetDomainStatisticsReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainStatisticsReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainStatisticsReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainStatisticsReportErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainStatisticsReportErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainStatisticsReportErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetDomainStatisticsReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainStatisticsReportErrorKind::BadRequestException(_inner) => Some(_inner),
            GetDomainStatisticsReportErrorKind::NotFoundException(_inner) => Some(_inner),
            GetDomainStatisticsReportErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetDomainStatisticsReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailIdentityError {
    pub kind: GetEmailIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailIdentityErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailIdentityErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEmailIdentityErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEmailIdentityErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEmailIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailIdentityError {
    fn code(&self) -> Option<&str> {
        GetEmailIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailIdentityError {
    pub fn new(kind: GetEmailIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetEmailIdentityErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEmailIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailIdentityErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEmailIdentityErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEmailIdentityErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEmailIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailIdentityPoliciesError {
    pub kind: GetEmailIdentityPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailIdentityPoliciesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailIdentityPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailIdentityPoliciesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEmailIdentityPoliciesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEmailIdentityPoliciesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEmailIdentityPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailIdentityPoliciesError {
    fn code(&self) -> Option<&str> {
        GetEmailIdentityPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailIdentityPoliciesError {
    pub fn new(kind: GetEmailIdentityPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailIdentityPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailIdentityPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityPoliciesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityPoliciesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityPoliciesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEmailIdentityPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailIdentityPoliciesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEmailIdentityPoliciesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEmailIdentityPoliciesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEmailIdentityPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailTemplateError {
    pub kind: GetEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailTemplateError {
    fn code(&self) -> Option<&str> {
        GetEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailTemplateError {
    pub fn new(kind: GetEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetEmailTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetImportJobError {
    pub kind: GetImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetImportJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetImportJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetImportJobError {
    fn code(&self) -> Option<&str> {
        GetImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetImportJobError {
    pub fn new(kind: GetImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetImportJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetImportJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSuppressedDestinationError {
    pub kind: GetSuppressedDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSuppressedDestinationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSuppressedDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSuppressedDestinationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSuppressedDestinationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSuppressedDestinationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSuppressedDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSuppressedDestinationError {
    fn code(&self) -> Option<&str> {
        GetSuppressedDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSuppressedDestinationError {
    pub fn new(kind: GetSuppressedDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSuppressedDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSuppressedDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSuppressedDestinationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSuppressedDestinationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSuppressedDestinationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSuppressedDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSuppressedDestinationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSuppressedDestinationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSuppressedDestinationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSuppressedDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfigurationSetsError {
    pub kind: ListConfigurationSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfigurationSetsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConfigurationSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfigurationSetsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListConfigurationSetsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListConfigurationSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListConfigurationSetsError {
    fn code(&self) -> Option<&str> {
        ListConfigurationSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfigurationSetsError {
    pub fn new(kind: ListConfigurationSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConfigurationSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConfigurationSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationSetsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationSetsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListConfigurationSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfigurationSetsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListConfigurationSetsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListConfigurationSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContactListsError {
    pub kind: ListContactListsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContactListsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContactListsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContactListsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListContactListsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListContactListsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContactListsError {
    fn code(&self) -> Option<&str> {
        ListContactListsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContactListsError {
    pub fn new(kind: ListContactListsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContactListsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContactListsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactListsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactListsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListContactListsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContactListsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListContactListsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListContactListsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContactsError {
    pub kind: ListContactsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContactsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContactsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContactsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListContactsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListContactsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListContactsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContactsError {
    fn code(&self) -> Option<&str> {
        ListContactsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContactsError {
    pub fn new(kind: ListContactsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContactsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContactsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListContactsErrorKind::BadRequestException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListContactsErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListContactsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListContactsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContactsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListContactsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListContactsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListContactsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCustomVerificationEmailTemplatesError {
    pub kind: ListCustomVerificationEmailTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCustomVerificationEmailTemplatesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCustomVerificationEmailTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCustomVerificationEmailTemplatesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListCustomVerificationEmailTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCustomVerificationEmailTemplatesError {
    fn code(&self) -> Option<&str> {
        ListCustomVerificationEmailTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCustomVerificationEmailTemplatesError {
    pub fn new(
        kind: ListCustomVerificationEmailTemplatesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCustomVerificationEmailTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCustomVerificationEmailTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomVerificationEmailTemplatesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListCustomVerificationEmailTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCustomVerificationEmailTemplatesErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListCustomVerificationEmailTemplatesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDedicatedIpPoolsError {
    pub kind: ListDedicatedIpPoolsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDedicatedIpPoolsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDedicatedIpPoolsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDedicatedIpPoolsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListDedicatedIpPoolsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListDedicatedIpPoolsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDedicatedIpPoolsError {
    fn code(&self) -> Option<&str> {
        ListDedicatedIpPoolsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDedicatedIpPoolsError {
    pub fn new(kind: ListDedicatedIpPoolsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDedicatedIpPoolsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDedicatedIpPoolsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDedicatedIpPoolsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDedicatedIpPoolsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListDedicatedIpPoolsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDedicatedIpPoolsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListDedicatedIpPoolsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListDedicatedIpPoolsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDeliverabilityTestReportsError {
    pub kind: ListDeliverabilityTestReportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeliverabilityTestReportsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDeliverabilityTestReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDeliverabilityTestReportsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListDeliverabilityTestReportsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListDeliverabilityTestReportsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListDeliverabilityTestReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDeliverabilityTestReportsError {
    fn code(&self) -> Option<&str> {
        ListDeliverabilityTestReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeliverabilityTestReportsError {
    pub fn new(kind: ListDeliverabilityTestReportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDeliverabilityTestReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDeliverabilityTestReportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeliverabilityTestReportsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeliverabilityTestReportsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeliverabilityTestReportsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListDeliverabilityTestReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDeliverabilityTestReportsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListDeliverabilityTestReportsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListDeliverabilityTestReportsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListDeliverabilityTestReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainDeliverabilityCampaignsError {
    pub kind: ListDomainDeliverabilityCampaignsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainDeliverabilityCampaignsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainDeliverabilityCampaignsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainDeliverabilityCampaignsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            ListDomainDeliverabilityCampaignsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            ListDomainDeliverabilityCampaignsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDomainDeliverabilityCampaignsError {
    fn code(&self) -> Option<&str> {
        ListDomainDeliverabilityCampaignsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainDeliverabilityCampaignsError {
    pub fn new(
        kind: ListDomainDeliverabilityCampaignsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainDeliverabilityCampaignsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainDeliverabilityCampaignsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainDeliverabilityCampaignsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainDeliverabilityCampaignsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListDomainDeliverabilityCampaignsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainDeliverabilityCampaignsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListDomainDeliverabilityCampaignsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            ListDomainDeliverabilityCampaignsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEmailIdentitiesError {
    pub kind: ListEmailIdentitiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEmailIdentitiesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEmailIdentitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEmailIdentitiesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListEmailIdentitiesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListEmailIdentitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEmailIdentitiesError {
    fn code(&self) -> Option<&str> {
        ListEmailIdentitiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEmailIdentitiesError {
    pub fn new(kind: ListEmailIdentitiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEmailIdentitiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEmailIdentitiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEmailIdentitiesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEmailIdentitiesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListEmailIdentitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEmailIdentitiesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListEmailIdentitiesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListEmailIdentitiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEmailTemplatesError {
    pub kind: ListEmailTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEmailTemplatesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEmailTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEmailTemplatesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListEmailTemplatesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListEmailTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEmailTemplatesError {
    fn code(&self) -> Option<&str> {
        ListEmailTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEmailTemplatesError {
    pub fn new(kind: ListEmailTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEmailTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEmailTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEmailTemplatesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEmailTemplatesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListEmailTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEmailTemplatesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListEmailTemplatesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListEmailTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListImportJobsError {
    pub kind: ListImportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListImportJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListImportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListImportJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListImportJobsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListImportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListImportJobsError {
    fn code(&self) -> Option<&str> {
        ListImportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListImportJobsError {
    pub fn new(kind: ListImportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListImportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListImportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListImportJobsErrorKind::BadRequestException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListImportJobsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListImportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListImportJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListImportJobsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListImportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSuppressedDestinationsError {
    pub kind: ListSuppressedDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSuppressedDestinationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSuppressedDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSuppressedDestinationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListSuppressedDestinationsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListSuppressedDestinationsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListSuppressedDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSuppressedDestinationsError {
    fn code(&self) -> Option<&str> {
        ListSuppressedDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSuppressedDestinationsError {
    pub fn new(kind: ListSuppressedDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSuppressedDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSuppressedDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuppressedDestinationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuppressedDestinationsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListSuppressedDestinationsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListSuppressedDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSuppressedDestinationsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListSuppressedDestinationsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListSuppressedDestinationsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListSuppressedDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountDedicatedIpWarmupAttributesError {
    pub kind: PutAccountDedicatedIpWarmupAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountDedicatedIpWarmupAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountDedicatedIpWarmupAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountDedicatedIpWarmupAttributesError {
    fn code(&self) -> Option<&str> {
        PutAccountDedicatedIpWarmupAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountDedicatedIpWarmupAttributesError {
    pub fn new(
        kind: PutAccountDedicatedIpWarmupAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutAccountDedicatedIpWarmupAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountDetailsError {
    pub kind: PutAccountDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountDetailsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountDetailsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutAccountDetailsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            PutAccountDetailsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutAccountDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountDetailsError {
    fn code(&self) -> Option<&str> {
        PutAccountDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountDetailsError {
    pub fn new(kind: PutAccountDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDetailsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, PutAccountDetailsErrorKind::ConflictException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDetailsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutAccountDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountDetailsErrorKind::BadRequestException(_inner) => Some(_inner),
            PutAccountDetailsErrorKind::ConflictException(_inner) => Some(_inner),
            PutAccountDetailsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutAccountDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSendingAttributesError {
    pub kind: PutAccountSendingAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSendingAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSendingAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSendingAttributesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutAccountSendingAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutAccountSendingAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSendingAttributesError {
    fn code(&self) -> Option<&str> {
        PutAccountSendingAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSendingAttributesError {
    pub fn new(kind: PutAccountSendingAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSendingAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSendingAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSendingAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSendingAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutAccountSendingAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSendingAttributesErrorKind::BadRequestException(_inner) => Some(_inner),
            PutAccountSendingAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutAccountSendingAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSuppressionAttributesError {
    pub kind: PutAccountSuppressionAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSuppressionAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSuppressionAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSuppressionAttributesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutAccountSuppressionAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutAccountSuppressionAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSuppressionAttributesError {
    fn code(&self) -> Option<&str> {
        PutAccountSuppressionAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSuppressionAttributesError {
    pub fn new(kind: PutAccountSuppressionAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSuppressionAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSuppressionAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSuppressionAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSuppressionAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutAccountSuppressionAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSuppressionAttributesErrorKind::BadRequestException(_inner) => Some(_inner),
            PutAccountSuppressionAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutAccountSuppressionAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetDeliveryOptionsError {
    pub kind: PutConfigurationSetDeliveryOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetDeliveryOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetDeliveryOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetDeliveryOptionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetDeliveryOptionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetDeliveryOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetDeliveryOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetDeliveryOptionsError {
    pub fn new(
        kind: PutConfigurationSetDeliveryOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetDeliveryOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetDeliveryOptionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetDeliveryOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetDeliveryOptionsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetDeliveryOptionsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetReputationOptionsError {
    pub kind: PutConfigurationSetReputationOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetReputationOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetReputationOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetReputationOptionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetReputationOptionsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetReputationOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetReputationOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetReputationOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetReputationOptionsError {
    pub fn new(
        kind: PutConfigurationSetReputationOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetReputationOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetReputationOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetReputationOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetReputationOptionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetReputationOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetReputationOptionsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetReputationOptionsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetReputationOptionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetSendingOptionsError {
    pub kind: PutConfigurationSetSendingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetSendingOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetSendingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetSendingOptionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSendingOptionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSendingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetSendingOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetSendingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetSendingOptionsError {
    pub fn new(
        kind: PutConfigurationSetSendingOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetSendingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetSendingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSendingOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSendingOptionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetSendingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetSendingOptionsErrorKind::BadRequestException(_inner) => Some(_inner),
            PutConfigurationSetSendingOptionsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetSendingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetSuppressionOptionsError {
    pub kind: PutConfigurationSetSuppressionOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetSuppressionOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetSuppressionOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetSuppressionOptionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetSuppressionOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetSuppressionOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetSuppressionOptionsError {
    pub fn new(
        kind: PutConfigurationSetSuppressionOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSuppressionOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSuppressionOptionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetSuppressionOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetSuppressionOptionsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetTrackingOptionsError {
    pub kind: PutConfigurationSetTrackingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetTrackingOptionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetTrackingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetTrackingOptionsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetTrackingOptionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetTrackingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetTrackingOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetTrackingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetTrackingOptionsError {
    pub fn new(
        kind: PutConfigurationSetTrackingOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetTrackingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetTrackingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetTrackingOptionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetTrackingOptionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetTrackingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetTrackingOptionsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetTrackingOptionsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetTrackingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDedicatedIpInPoolError {
    pub kind: PutDedicatedIpInPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDedicatedIpInPoolErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDedicatedIpInPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDedicatedIpInPoolErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutDedicatedIpInPoolErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutDedicatedIpInPoolErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutDedicatedIpInPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDedicatedIpInPoolError {
    fn code(&self) -> Option<&str> {
        PutDedicatedIpInPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDedicatedIpInPoolError {
    pub fn new(kind: PutDedicatedIpInPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDedicatedIpInPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDedicatedIpInPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpInPoolErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpInPoolErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpInPoolErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutDedicatedIpInPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDedicatedIpInPoolErrorKind::BadRequestException(_inner) => Some(_inner),
            PutDedicatedIpInPoolErrorKind::NotFoundException(_inner) => Some(_inner),
            PutDedicatedIpInPoolErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutDedicatedIpInPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDedicatedIpWarmupAttributesError {
    pub kind: PutDedicatedIpWarmupAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDedicatedIpWarmupAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDedicatedIpWarmupAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDedicatedIpWarmupAttributesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutDedicatedIpWarmupAttributesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDedicatedIpWarmupAttributesError {
    fn code(&self) -> Option<&str> {
        PutDedicatedIpWarmupAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDedicatedIpWarmupAttributesError {
    pub fn new(kind: PutDedicatedIpWarmupAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpWarmupAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpWarmupAttributesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutDedicatedIpWarmupAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDedicatedIpWarmupAttributesErrorKind::BadRequestException(_inner) => Some(_inner),
            PutDedicatedIpWarmupAttributesErrorKind::NotFoundException(_inner) => Some(_inner),
            PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDeliverabilityDashboardOptionError {
    pub kind: PutDeliverabilityDashboardOptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDeliverabilityDashboardOptionErrorKind {
    AlreadyExistsException(crate::error::AlreadyExistsException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDeliverabilityDashboardOptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliverabilityDashboardOptionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutDeliverabilityDashboardOptionErrorKind::LimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliverabilityDashboardOptionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutDeliverabilityDashboardOptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDeliverabilityDashboardOptionError {
    fn code(&self) -> Option<&str> {
        PutDeliverabilityDashboardOptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDeliverabilityDashboardOptionError {
    pub fn new(kind: PutDeliverabilityDashboardOptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDeliverabilityDashboardOptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDeliverabilityDashboardOptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutDeliverabilityDashboardOptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsException(_inner) => {
                Some(_inner)
            }
            PutDeliverabilityDashboardOptionErrorKind::BadRequestException(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::LimitExceededException(_inner) => {
                Some(_inner)
            }
            PutDeliverabilityDashboardOptionErrorKind::NotFoundException(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutDeliverabilityDashboardOptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityConfigurationSetAttributesError {
    pub kind: PutEmailIdentityConfigurationSetAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityConfigurationSetAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityConfigurationSetAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsException(
                _inner,
            ) => _inner.fmt(f),
            PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityConfigurationSetAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityConfigurationSetAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityConfigurationSetAttributesError {
    pub fn new(
        kind: PutEmailIdentityConfigurationSetAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityConfigurationSetAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsException(
                _inner,
            ) => Some(_inner),
            PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityDkimAttributesError {
    pub kind: PutEmailIdentityDkimAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityDkimAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityDkimAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityDkimAttributesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutEmailIdentityDkimAttributesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityDkimAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityDkimAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityDkimAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityDkimAttributesError {
    pub fn new(kind: PutEmailIdentityDkimAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityDkimAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityDkimAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimAttributesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityDkimAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityDkimAttributesErrorKind::BadRequestException(_inner) => Some(_inner),
            PutEmailIdentityDkimAttributesErrorKind::NotFoundException(_inner) => Some(_inner),
            PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityDkimAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityDkimSigningAttributesError {
    pub kind: PutEmailIdentityDkimSigningAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityDkimSigningAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityDkimSigningAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityDkimSigningAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityDkimSigningAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityDkimSigningAttributesError {
    pub fn new(
        kind: PutEmailIdentityDkimSigningAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityDkimSigningAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityFeedbackAttributesError {
    pub kind: PutEmailIdentityFeedbackAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityFeedbackAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityFeedbackAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityFeedbackAttributesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityFeedbackAttributesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityFeedbackAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityFeedbackAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityFeedbackAttributesError {
    pub fn new(
        kind: PutEmailIdentityFeedbackAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityFeedbackAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityFeedbackAttributesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityFeedbackAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityFeedbackAttributesErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityFeedbackAttributesErrorKind::NotFoundException(_inner) => Some(_inner),
            PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityMailFromAttributesError {
    pub kind: PutEmailIdentityMailFromAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityMailFromAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityMailFromAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityMailFromAttributesErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityMailFromAttributesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityMailFromAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityMailFromAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityMailFromAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityMailFromAttributesError {
    pub fn new(
        kind: PutEmailIdentityMailFromAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityMailFromAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityMailFromAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityMailFromAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityMailFromAttributesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityMailFromAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityMailFromAttributesErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityMailFromAttributesErrorKind::NotFoundException(_inner) => Some(_inner),
            PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityMailFromAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSuppressedDestinationError {
    pub kind: PutSuppressedDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSuppressedDestinationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSuppressedDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSuppressedDestinationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutSuppressedDestinationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutSuppressedDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSuppressedDestinationError {
    fn code(&self) -> Option<&str> {
        PutSuppressedDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSuppressedDestinationError {
    pub fn new(kind: PutSuppressedDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSuppressedDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSuppressedDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSuppressedDestinationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutSuppressedDestinationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutSuppressedDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSuppressedDestinationErrorKind::BadRequestException(_inner) => Some(_inner),
            PutSuppressedDestinationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutSuppressedDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendBulkEmailError {
    pub kind: SendBulkEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendBulkEmailErrorKind {
    AccountSuspendedException(crate::error::AccountSuspendedException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    MailFromDomainNotVerifiedException(crate::error::MailFromDomainNotVerifiedException),
    MessageRejected(crate::error::MessageRejected),
    NotFoundException(crate::error::NotFoundException),
    SendingPausedException(crate::error::SendingPausedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendBulkEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendBulkEmailErrorKind::AccountSuspendedException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::MailFromDomainNotVerifiedException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::SendingPausedException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendBulkEmailError {
    fn code(&self) -> Option<&str> {
        SendBulkEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendBulkEmailError {
    pub fn new(kind: SendBulkEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendBulkEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendBulkEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_account_suspended_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendBulkEmailErrorKind::AccountSuspendedException(_)
        )
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::BadRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendBulkEmailErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_mail_from_domain_not_verified_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendBulkEmailErrorKind::MailFromDomainNotVerifiedException(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::MessageRejected(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::NotFoundException(_))
    }
    pub fn is_sending_paused_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendBulkEmailErrorKind::SendingPausedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendBulkEmailErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for SendBulkEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendBulkEmailErrorKind::AccountSuspendedException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::BadRequestException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::LimitExceededException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::MailFromDomainNotVerifiedException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::MessageRejected(_inner) => Some(_inner),
            SendBulkEmailErrorKind::NotFoundException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::SendingPausedException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SendBulkEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendCustomVerificationEmailError {
    pub kind: SendCustomVerificationEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendCustomVerificationEmailErrorKind {
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    MailFromDomainNotVerifiedException(crate::error::MailFromDomainNotVerifiedException),
    MessageRejected(crate::error::MessageRejected),
    NotFoundException(crate::error::NotFoundException),
    SendingPausedException(crate::error::SendingPausedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendCustomVerificationEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendCustomVerificationEmailErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedException(_inner) => {
                _inner.fmt(f)
            }
            SendCustomVerificationEmailErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::SendingPausedException(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendCustomVerificationEmailError {
    fn code(&self) -> Option<&str> {
        SendCustomVerificationEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendCustomVerificationEmailError {
    pub fn new(kind: SendCustomVerificationEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendCustomVerificationEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendCustomVerificationEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::BadRequestException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_mail_from_domain_not_verified_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedException(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::MessageRejected(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::NotFoundException(_)
        )
    }
    pub fn is_sending_paused_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::SendingPausedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for SendCustomVerificationEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendCustomVerificationEmailErrorKind::BadRequestException(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::LimitExceededException(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedException(_inner) => {
                Some(_inner)
            }
            SendCustomVerificationEmailErrorKind::MessageRejected(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::NotFoundException(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::SendingPausedException(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendEmailError {
    pub kind: SendEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendEmailErrorKind {
    AccountSuspendedException(crate::error::AccountSuspendedException),
    BadRequestException(crate::error::BadRequestException),
    LimitExceededException(crate::error::LimitExceededException),
    MailFromDomainNotVerifiedException(crate::error::MailFromDomainNotVerifiedException),
    MessageRejected(crate::error::MessageRejected),
    NotFoundException(crate::error::NotFoundException),
    SendingPausedException(crate::error::SendingPausedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendEmailErrorKind::AccountSuspendedException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::MailFromDomainNotVerifiedException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            SendEmailErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::SendingPausedException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SendEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendEmailError {
    fn code(&self) -> Option<&str> {
        SendEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendEmailError {
    pub fn new(kind: SendEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_account_suspended_exception(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::AccountSuspendedException(_))
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::BadRequestException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::LimitExceededException(_))
    }
    pub fn is_mail_from_domain_not_verified_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendEmailErrorKind::MailFromDomainNotVerifiedException(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::MessageRejected(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::NotFoundException(_))
    }
    pub fn is_sending_paused_exception(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::SendingPausedException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for SendEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendEmailErrorKind::AccountSuspendedException(_inner) => Some(_inner),
            SendEmailErrorKind::BadRequestException(_inner) => Some(_inner),
            SendEmailErrorKind::LimitExceededException(_inner) => Some(_inner),
            SendEmailErrorKind::MailFromDomainNotVerifiedException(_inner) => Some(_inner),
            SendEmailErrorKind::MessageRejected(_inner) => Some(_inner),
            SendEmailErrorKind::NotFoundException(_inner) => Some(_inner),
            SendEmailErrorKind::SendingPausedException(_inner) => Some(_inner),
            SendEmailErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SendEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            TagResourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestRenderEmailTemplateError {
    pub kind: TestRenderEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestRenderEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestRenderEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestRenderEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            TestRenderEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            TestRenderEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            TestRenderEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestRenderEmailTemplateError {
    fn code(&self) -> Option<&str> {
        TestRenderEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestRenderEmailTemplateError {
    pub fn new(kind: TestRenderEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestRenderEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestRenderEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRenderEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRenderEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRenderEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for TestRenderEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestRenderEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            TestRenderEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            TestRenderEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            TestRenderEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestException(_inner) => Some(_inner),
            UntagResourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfigurationSetEventDestinationError {
    pub kind: UpdateConfigurationSetEventDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfigurationSetEventDestinationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConfigurationSetEventDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfigurationSetEventDestinationErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConfigurationSetEventDestinationErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConfigurationSetEventDestinationError {
    fn code(&self) -> Option<&str> {
        UpdateConfigurationSetEventDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfigurationSetEventDestinationError {
    pub fn new(
        kind: UpdateConfigurationSetEventDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationSetEventDestinationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationSetEventDestinationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateConfigurationSetEventDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfigurationSetEventDestinationErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            UpdateConfigurationSetEventDestinationErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactError {
    pub kind: UpdateContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactError {
    fn code(&self) -> Option<&str> {
        UpdateContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactError {
    pub fn new(kind: UpdateContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateContactErrorKind::BadRequestException(_))
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateContactErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateContactErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateContactErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateContactErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactListError {
    pub kind: UpdateContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactListErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactListErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactListError {
    fn code(&self) -> Option<&str> {
        UpdateContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactListError {
    pub fn new(kind: UpdateContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactListErrorKind::BadRequestException(_)
        )
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactListErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateContactListErrorKind::NotFoundException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactListErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactListErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateContactListErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateContactListErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateContactListErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCustomVerificationEmailTemplateError {
    pub kind: UpdateCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCustomVerificationEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCustomVerificationEmailTemplateError {
    pub fn new(
        kind: UpdateCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomVerificationEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomVerificationEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCustomVerificationEmailTemplateErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::NotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEmailIdentityPolicyError {
    pub kind: UpdateEmailIdentityPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEmailIdentityPolicyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEmailIdentityPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEmailIdentityPolicyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateEmailIdentityPolicyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateEmailIdentityPolicyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEmailIdentityPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEmailIdentityPolicyError {
    fn code(&self) -> Option<&str> {
        UpdateEmailIdentityPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEmailIdentityPolicyError {
    pub fn new(kind: UpdateEmailIdentityPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailIdentityPolicyErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailIdentityPolicyErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailIdentityPolicyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEmailIdentityPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEmailIdentityPolicyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateEmailIdentityPolicyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateEmailIdentityPolicyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEmailIdentityPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEmailTemplateError {
    pub kind: UpdateEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    NotFoundException(crate::error::NotFoundException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEmailTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEmailTemplateError {
    pub fn new(kind: UpdateEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Too many requests have been made to the operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>The resource you attempted to access doesn't exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>The input you provided is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>The resource is being modified by another operation or thread.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>The message can't be sent because the account's ability to send email is currently
/// paused.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendingPausedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendingPausedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendingPausedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SendingPausedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SendingPausedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SendingPausedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for SendingPausedException {}
/// See [`SendingPausedException`](crate::error::SendingPausedException)
pub mod sending_paused_exception {
    /// A builder for [`SendingPausedException`](crate::error::SendingPausedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SendingPausedException`](crate::error::SendingPausedException)
        pub fn build(self) -> crate::error::SendingPausedException {
            crate::error::SendingPausedException {
                message: self.message,
            }
        }
    }
}
impl SendingPausedException {
    /// Creates a new builder-style object to manufacture [`SendingPausedException`](crate::error::SendingPausedException)
    pub fn builder() -> crate::error::sending_paused_exception::Builder {
        crate::error::sending_paused_exception::Builder::default()
    }
}

/// <p>The message can't be sent because it contains invalid content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageRejected {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageRejected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageRejected");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MessageRejected {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MessageRejected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MessageRejected")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for MessageRejected {}
/// See [`MessageRejected`](crate::error::MessageRejected)
pub mod message_rejected {
    /// A builder for [`MessageRejected`](crate::error::MessageRejected)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageRejected`](crate::error::MessageRejected)
        pub fn build(self) -> crate::error::MessageRejected {
            crate::error::MessageRejected {
                message: self.message,
            }
        }
    }
}
impl MessageRejected {
    /// Creates a new builder-style object to manufacture [`MessageRejected`](crate::error::MessageRejected)
    pub fn builder() -> crate::error::message_rejected::Builder {
        crate::error::message_rejected::Builder::default()
    }
}

/// <p>The message can't be sent because the sending domain isn't verified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MailFromDomainNotVerifiedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MailFromDomainNotVerifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MailFromDomainNotVerifiedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MailFromDomainNotVerifiedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MailFromDomainNotVerifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MailFromDomainNotVerifiedException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for MailFromDomainNotVerifiedException {}
/// See [`MailFromDomainNotVerifiedException`](crate::error::MailFromDomainNotVerifiedException)
pub mod mail_from_domain_not_verified_exception {
    /// A builder for [`MailFromDomainNotVerifiedException`](crate::error::MailFromDomainNotVerifiedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MailFromDomainNotVerifiedException`](crate::error::MailFromDomainNotVerifiedException)
        pub fn build(self) -> crate::error::MailFromDomainNotVerifiedException {
            crate::error::MailFromDomainNotVerifiedException {
                message: self.message,
            }
        }
    }
}
impl MailFromDomainNotVerifiedException {
    /// Creates a new builder-style object to manufacture [`MailFromDomainNotVerifiedException`](crate::error::MailFromDomainNotVerifiedException)
    pub fn builder() -> crate::error::mail_from_domain_not_verified_exception::Builder {
        crate::error::mail_from_domain_not_verified_exception::Builder::default()
    }
}

/// <p>There are too many instances of the specified resource type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The message can't be sent because the account's ability to send email has been
/// permanently restricted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountSuspendedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountSuspendedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountSuspendedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccountSuspendedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccountSuspendedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccountSuspendedException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccountSuspendedException {}
/// See [`AccountSuspendedException`](crate::error::AccountSuspendedException)
pub mod account_suspended_exception {
    /// A builder for [`AccountSuspendedException`](crate::error::AccountSuspendedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSuspendedException`](crate::error::AccountSuspendedException)
        pub fn build(self) -> crate::error::AccountSuspendedException {
            crate::error::AccountSuspendedException {
                message: self.message,
            }
        }
    }
}
impl AccountSuspendedException {
    /// Creates a new builder-style object to manufacture [`AccountSuspendedException`](crate::error::AccountSuspendedException)
    pub fn builder() -> crate::error::account_suspended_exception::Builder {
        crate::error::account_suspended_exception::Builder::default()
    }
}

/// <p>The resource specified in your request already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsException {}
/// See [`AlreadyExistsException`](crate::error::AlreadyExistsException)
pub mod already_exists_exception {
    /// A builder for [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsException`](crate::error::AlreadyExistsException)
        pub fn build(self) -> crate::error::AlreadyExistsException {
            crate::error::AlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsException`](crate::error::AlreadyExistsException)
    pub fn builder() -> crate::error::already_exists_exception::Builder {
        crate::error::already_exists_exception::Builder::default()
    }
}

/// <p>If there is already an ongoing account details update under review.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The specified request includes an invalid or expired token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}
