// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfigurationSetError {
    pub kind: CreateConfigurationSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfigurationSetErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConfigurationSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfigurationSetErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateConfigurationSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConfigurationSetError {
    fn code(&self) -> Option<&str> {
        CreateConfigurationSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfigurationSetError {
    pub fn new(kind: CreateConfigurationSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConfigurationSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConfigurationSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::BadRequestError(_)
        )
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateConfigurationSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfigurationSetErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateConfigurationSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConfigurationSetEventDestinationError {
    pub kind: CreateConfigurationSetEventDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConfigurationSetEventDestinationErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConfigurationSetEventDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsError(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::LimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            CreateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConfigurationSetEventDestinationError {
    fn code(&self) -> Option<&str> {
        CreateConfigurationSetEventDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConfigurationSetEventDestinationError {
    pub fn new(
        kind: CreateConfigurationSetEventDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::BadRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateConfigurationSetEventDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsError(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::BadRequestError(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::LimitExceededError(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            CreateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContactError {
    pub kind: CreateContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContactErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContactErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateContactErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateContactErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateContactErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContactError {
    fn code(&self) -> Option<&str> {
        CreateContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContactError {
    pub fn new(kind: CreateContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(&self.kind, CreateContactErrorKind::AlreadyExistsError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateContactErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateContactErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, CreateContactErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for CreateContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContactErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateContactErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateContactErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateContactErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateContactListError {
    pub kind: CreateContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateContactListErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateContactListErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateContactListError {
    fn code(&self) -> Option<&str> {
        CreateContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateContactListError {
    pub fn new(kind: CreateContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateContactListErrorKind::BadRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateContactListErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateContactListErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateContactListErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateContactListErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateContactListErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCustomVerificationEmailTemplateError {
    pub kind: CreateCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCustomVerificationEmailTemplateErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsError(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::LimitExceededError(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            CreateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        CreateCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCustomVerificationEmailTemplateError {
    pub fn new(
        kind: CreateCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::BadRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsError(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateCustomVerificationEmailTemplateErrorKind::LimitExceededError(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            CreateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDedicatedIpPoolError {
    pub kind: CreateDedicatedIpPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDedicatedIpPoolErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDedicatedIpPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDedicatedIpPoolErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateDedicatedIpPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDedicatedIpPoolError {
    fn code(&self) -> Option<&str> {
        CreateDedicatedIpPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDedicatedIpPoolError {
    pub fn new(kind: CreateDedicatedIpPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDedicatedIpPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDedicatedIpPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::BadRequestError(_)
        )
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDedicatedIpPoolErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateDedicatedIpPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDedicatedIpPoolErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateDedicatedIpPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDeliverabilityTestReportError {
    pub kind: CreateDeliverabilityTestReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeliverabilityTestReportErrorKind {
    AccountSuspendedError(crate::error::AccountSuspendedError),
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    LimitExceededError(crate::error::LimitExceededError),
    MailFromDomainNotVerifiedError(crate::error::MailFromDomainNotVerifiedError),
    MessageRejected(crate::error::MessageRejected),
    NotFoundError(crate::error::NotFoundError),
    SendingPausedError(crate::error::SendingPausedError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDeliverabilityTestReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDeliverabilityTestReportErrorKind::AccountSuspendedError(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::ConcurrentModificationError(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedError(_inner) => {
                _inner.fmt(f)
            }
            CreateDeliverabilityTestReportErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::SendingPausedError(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateDeliverabilityTestReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDeliverabilityTestReportError {
    fn code(&self) -> Option<&str> {
        CreateDeliverabilityTestReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeliverabilityTestReportError {
    pub fn new(kind: CreateDeliverabilityTestReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDeliverabilityTestReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDeliverabilityTestReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_account_suspended_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::AccountSuspendedError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::BadRequestError(_)
        )
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_mail_from_domain_not_verified_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedError(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::MessageRejected(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::NotFoundError(_)
        )
    }
    pub fn is_sending_paused_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::SendingPausedError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeliverabilityTestReportErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateDeliverabilityTestReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDeliverabilityTestReportErrorKind::AccountSuspendedError(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::ConcurrentModificationError(_inner) => {
                Some(_inner)
            }
            CreateDeliverabilityTestReportErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedError(_inner) => {
                Some(_inner)
            }
            CreateDeliverabilityTestReportErrorKind::MessageRejected(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::SendingPausedError(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateDeliverabilityTestReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailIdentityError {
    pub kind: CreateEmailIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailIdentityErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailIdentityErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateEmailIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailIdentityError {
    fn code(&self) -> Option<&str> {
        CreateEmailIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailIdentityError {
    pub fn new(kind: CreateEmailIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateEmailIdentityErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateEmailIdentityErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateEmailIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailIdentityErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateEmailIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailIdentityPolicyError {
    pub kind: CreateEmailIdentityPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailIdentityPolicyErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailIdentityPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailIdentityPolicyErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateEmailIdentityPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailIdentityPolicyError {
    fn code(&self) -> Option<&str> {
        CreateEmailIdentityPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailIdentityPolicyError {
    pub fn new(kind: CreateEmailIdentityPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::BadRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailIdentityPolicyErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateEmailIdentityPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailIdentityPolicyErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::NotFoundError(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateEmailIdentityPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailTemplateError {
    pub kind: CreateEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailTemplateErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailTemplateErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailTemplateError {
    fn code(&self) -> Option<&str> {
        CreateEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailTemplateError {
    pub fn new(kind: CreateEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateEmailTemplateErrorKind::BadRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailTemplateErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateImportJobError {
    pub kind: CreateImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateImportJobErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateImportJobErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateImportJobError {
    fn code(&self) -> Option<&str> {
        CreateImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateImportJobError {
    pub fn new(kind: CreateImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, CreateImportJobErrorKind::BadRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateImportJobErrorKind::LimitExceededError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for CreateImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateImportJobErrorKind::BadRequestError(_inner) => Some(_inner),
            CreateImportJobErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateImportJobErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            CreateImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationSetError {
    pub kind: DeleteConfigurationSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationSetErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationSetErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteConfigurationSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigurationSetError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationSetError {
    pub fn new(kind: DeleteConfigurationSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::BadRequestError(_)
        )
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationSetErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteConfigurationSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConfigurationSetEventDestinationError {
    pub kind: DeleteConfigurationSetEventDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConfigurationSetEventDestinationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConfigurationSetEventDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConfigurationSetEventDestinationErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationSetEventDestinationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            DeleteConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConfigurationSetEventDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteConfigurationSetEventDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConfigurationSetEventDestinationError {
    pub fn new(
        kind: DeleteConfigurationSetEventDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetEventDestinationErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetEventDestinationErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteConfigurationSetEventDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConfigurationSetEventDestinationErrorKind::BadRequestError(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationSetEventDestinationErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            DeleteConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContactError {
    pub kind: DeleteContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContactErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContactErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteContactErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteContactErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContactError {
    fn code(&self) -> Option<&str> {
        DeleteContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContactError {
    pub fn new(kind: DeleteContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteContactErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteContactErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, DeleteContactErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for DeleteContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContactErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteContactErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteContactErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteContactListError {
    pub kind: DeleteContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteContactListErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteContactListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteContactListError {
    fn code(&self) -> Option<&str> {
        DeleteContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteContactListError {
    pub fn new(kind: DeleteContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteContactListErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactListErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteContactListErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteContactListErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteContactListErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteContactListErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            DeleteContactListErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteContactListErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCustomVerificationEmailTemplateError {
    pub kind: DeleteCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCustomVerificationEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCustomVerificationEmailTemplateError {
    pub fn new(
        kind: DeleteCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomVerificationEmailTemplateErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomVerificationEmailTemplateErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            DeleteCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDedicatedIpPoolError {
    pub kind: DeleteDedicatedIpPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDedicatedIpPoolErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDedicatedIpPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDedicatedIpPoolErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteDedicatedIpPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDedicatedIpPoolError {
    fn code(&self) -> Option<&str> {
        DeleteDedicatedIpPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDedicatedIpPoolError {
    pub fn new(kind: DeleteDedicatedIpPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDedicatedIpPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDedicatedIpPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::BadRequestError(_)
        )
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteDedicatedIpPoolErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDedicatedIpPoolErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteDedicatedIpPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDedicatedIpPoolErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteDedicatedIpPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailIdentityError {
    pub kind: DeleteEmailIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailIdentityErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailIdentityError {
    fn code(&self) -> Option<&str> {
        DeleteEmailIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailIdentityError {
    pub fn new(kind: DeleteEmailIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteEmailIdentityErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteEmailIdentityErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteEmailIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteEmailIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailIdentityPolicyError {
    pub kind: DeleteEmailIdentityPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailIdentityPolicyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailIdentityPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailIdentityPolicyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityPolicyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityPolicyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteEmailIdentityPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailIdentityPolicyError {
    fn code(&self) -> Option<&str> {
        DeleteEmailIdentityPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailIdentityPolicyError {
    pub fn new(kind: DeleteEmailIdentityPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailIdentityPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailIdentityPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityPolicyErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityPolicyErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailIdentityPolicyErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteEmailIdentityPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailIdentityPolicyErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteEmailIdentityPolicyErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteEmailIdentityPolicyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteEmailIdentityPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailTemplateError {
    pub kind: DeleteEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailTemplateError {
    pub fn new(kind: DeleteEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, DeleteEmailTemplateErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteEmailTemplateErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSuppressedDestinationError {
    pub kind: DeleteSuppressedDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSuppressedDestinationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSuppressedDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSuppressedDestinationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            DeleteSuppressedDestinationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            DeleteSuppressedDestinationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            DeleteSuppressedDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSuppressedDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteSuppressedDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSuppressedDestinationError {
    pub fn new(kind: DeleteSuppressedDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSuppressedDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSuppressedDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSuppressedDestinationErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSuppressedDestinationErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSuppressedDestinationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for DeleteSuppressedDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSuppressedDestinationErrorKind::BadRequestError(_inner) => Some(_inner),
            DeleteSuppressedDestinationErrorKind::NotFoundError(_inner) => Some(_inner),
            DeleteSuppressedDestinationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            DeleteSuppressedDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountError {
    pub kind: GetAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetAccountErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountError {
    fn code(&self) -> Option<&str> {
        GetAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAccountError {
    pub fn new(kind: GetAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::BadRequestError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, GetAccountErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for GetAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountErrorKind::BadRequestError(_inner) => Some(_inner),
            GetAccountErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlacklistReportsError {
    pub kind: GetBlacklistReportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlacklistReportsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlacklistReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlacklistReportsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetBlacklistReportsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetBlacklistReportsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetBlacklistReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlacklistReportsError {
    fn code(&self) -> Option<&str> {
        GetBlacklistReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlacklistReportsError {
    pub fn new(kind: GetBlacklistReportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlacklistReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlacklistReportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetBlacklistReportsErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetBlacklistReportsErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetBlacklistReportsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetBlacklistReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlacklistReportsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetBlacklistReportsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetBlacklistReportsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetBlacklistReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfigurationSetError {
    pub kind: GetConfigurationSetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfigurationSetErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConfigurationSetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfigurationSetErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetConfigurationSetErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetConfigurationSetErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetConfigurationSetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConfigurationSetError {
    fn code(&self) -> Option<&str> {
        GetConfigurationSetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfigurationSetError {
    pub fn new(kind: GetConfigurationSetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConfigurationSetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConfigurationSetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetConfigurationSetErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetConfigurationSetErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetConfigurationSetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfigurationSetErrorKind::BadRequestError(_inner) => Some(_inner),
            GetConfigurationSetErrorKind::NotFoundError(_inner) => Some(_inner),
            GetConfigurationSetErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetConfigurationSetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetConfigurationSetEventDestinationsError {
    pub kind: GetConfigurationSetEventDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetConfigurationSetEventDestinationsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetConfigurationSetEventDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetConfigurationSetEventDestinationsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetConfigurationSetEventDestinationsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            GetConfigurationSetEventDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetConfigurationSetEventDestinationsError {
    fn code(&self) -> Option<&str> {
        GetConfigurationSetEventDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetConfigurationSetEventDestinationsError {
    pub fn new(
        kind: GetConfigurationSetEventDestinationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetConfigurationSetEventDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetConfigurationSetEventDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetEventDestinationsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetEventDestinationsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetConfigurationSetEventDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetConfigurationSetEventDestinationsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetConfigurationSetEventDestinationsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            GetConfigurationSetEventDestinationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactError {
    pub kind: GetContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetContactErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetContactErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactError {
    fn code(&self) -> Option<&str> {
        GetContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactError {
    pub fn new(kind: GetContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetContactErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetContactErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, GetContactErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for GetContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactErrorKind::BadRequestError(_inner) => Some(_inner),
            GetContactErrorKind::NotFoundError(_inner) => Some(_inner),
            GetContactErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetContactListError {
    pub kind: GetContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetContactListErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetContactListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetContactListErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetContactListErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetContactListError {
    fn code(&self) -> Option<&str> {
        GetContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetContactListError {
    pub fn new(kind: GetContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetContactListErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetContactListErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, GetContactListErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for GetContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetContactListErrorKind::BadRequestError(_inner) => Some(_inner),
            GetContactListErrorKind::NotFoundError(_inner) => Some(_inner),
            GetContactListErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCustomVerificationEmailTemplateError {
    pub kind: GetCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCustomVerificationEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            GetCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        GetCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCustomVerificationEmailTemplateError {
    pub fn new(
        kind: GetCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCustomVerificationEmailTemplateErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCustomVerificationEmailTemplateErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            GetCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            GetCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDedicatedIpError {
    pub kind: GetDedicatedIpErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDedicatedIpErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDedicatedIpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDedicatedIpErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDedicatedIpErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDedicatedIpErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDedicatedIpErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDedicatedIpError {
    fn code(&self) -> Option<&str> {
        GetDedicatedIpError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDedicatedIpError {
    pub fn new(kind: GetDedicatedIpErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDedicatedIpErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDedicatedIpErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for GetDedicatedIpError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDedicatedIpErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDedicatedIpErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDedicatedIpErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDedicatedIpErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDedicatedIpsError {
    pub kind: GetDedicatedIpsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDedicatedIpsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDedicatedIpsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDedicatedIpsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDedicatedIpsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDedicatedIpsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDedicatedIpsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDedicatedIpsError {
    fn code(&self) -> Option<&str> {
        GetDedicatedIpsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDedicatedIpsError {
    pub fn new(kind: GetDedicatedIpsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDedicatedIpsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDedicatedIpsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpsErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetDedicatedIpsErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDedicatedIpsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetDedicatedIpsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDedicatedIpsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDedicatedIpsErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDedicatedIpsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDedicatedIpsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeliverabilityDashboardOptionsError {
    pub kind: GetDeliverabilityDashboardOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeliverabilityDashboardOptionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeliverabilityDashboardOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeliverabilityDashboardOptionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDeliverabilityDashboardOptionsErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            GetDeliverabilityDashboardOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeliverabilityDashboardOptionsError {
    fn code(&self) -> Option<&str> {
        GetDeliverabilityDashboardOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeliverabilityDashboardOptionsError {
    pub fn new(
        kind: GetDeliverabilityDashboardOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeliverabilityDashboardOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeliverabilityDashboardOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityDashboardOptionsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityDashboardOptionsErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetDeliverabilityDashboardOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeliverabilityDashboardOptionsErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDeliverabilityDashboardOptionsErrorKind::LimitExceededError(_inner) => Some(_inner),
            GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            GetDeliverabilityDashboardOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeliverabilityTestReportError {
    pub kind: GetDeliverabilityTestReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeliverabilityTestReportErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeliverabilityTestReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeliverabilityTestReportErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDeliverabilityTestReportErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDeliverabilityTestReportErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDeliverabilityTestReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeliverabilityTestReportError {
    fn code(&self) -> Option<&str> {
        GetDeliverabilityTestReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeliverabilityTestReportError {
    pub fn new(kind: GetDeliverabilityTestReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeliverabilityTestReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeliverabilityTestReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityTestReportErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityTestReportErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDeliverabilityTestReportErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetDeliverabilityTestReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeliverabilityTestReportErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDeliverabilityTestReportErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDeliverabilityTestReportErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDeliverabilityTestReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainDeliverabilityCampaignError {
    pub kind: GetDomainDeliverabilityCampaignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainDeliverabilityCampaignErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainDeliverabilityCampaignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainDeliverabilityCampaignErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDomainDeliverabilityCampaignErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDomainDeliverabilityCampaignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainDeliverabilityCampaignError {
    fn code(&self) -> Option<&str> {
        GetDomainDeliverabilityCampaignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainDeliverabilityCampaignError {
    pub fn new(kind: GetDomainDeliverabilityCampaignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainDeliverabilityCampaignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainDeliverabilityCampaignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainDeliverabilityCampaignErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainDeliverabilityCampaignErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetDomainDeliverabilityCampaignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainDeliverabilityCampaignErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDomainDeliverabilityCampaignErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDomainDeliverabilityCampaignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainStatisticsReportError {
    pub kind: GetDomainStatisticsReportErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainStatisticsReportErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDomainStatisticsReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainStatisticsReportErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetDomainStatisticsReportErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetDomainStatisticsReportErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetDomainStatisticsReportErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDomainStatisticsReportError {
    fn code(&self) -> Option<&str> {
        GetDomainStatisticsReportError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDomainStatisticsReportError {
    pub fn new(kind: GetDomainStatisticsReportErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDomainStatisticsReportErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDomainStatisticsReportErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainStatisticsReportErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainStatisticsReportErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetDomainStatisticsReportErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetDomainStatisticsReportError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainStatisticsReportErrorKind::BadRequestError(_inner) => Some(_inner),
            GetDomainStatisticsReportErrorKind::NotFoundError(_inner) => Some(_inner),
            GetDomainStatisticsReportErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetDomainStatisticsReportErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailIdentityError {
    pub kind: GetEmailIdentityErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailIdentityErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailIdentityError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailIdentityErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetEmailIdentityErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetEmailIdentityErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetEmailIdentityErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailIdentityError {
    fn code(&self) -> Option<&str> {
        GetEmailIdentityError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailIdentityError {
    pub fn new(kind: GetEmailIdentityErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailIdentityErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailIdentityErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetEmailIdentityErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetEmailIdentityErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetEmailIdentityError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailIdentityErrorKind::BadRequestError(_inner) => Some(_inner),
            GetEmailIdentityErrorKind::NotFoundError(_inner) => Some(_inner),
            GetEmailIdentityErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetEmailIdentityErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailIdentityPoliciesError {
    pub kind: GetEmailIdentityPoliciesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailIdentityPoliciesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailIdentityPoliciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailIdentityPoliciesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetEmailIdentityPoliciesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetEmailIdentityPoliciesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetEmailIdentityPoliciesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailIdentityPoliciesError {
    fn code(&self) -> Option<&str> {
        GetEmailIdentityPoliciesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailIdentityPoliciesError {
    pub fn new(kind: GetEmailIdentityPoliciesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailIdentityPoliciesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailIdentityPoliciesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityPoliciesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityPoliciesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailIdentityPoliciesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetEmailIdentityPoliciesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailIdentityPoliciesErrorKind::BadRequestError(_inner) => Some(_inner),
            GetEmailIdentityPoliciesErrorKind::NotFoundError(_inner) => Some(_inner),
            GetEmailIdentityPoliciesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetEmailIdentityPoliciesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailTemplateError {
    pub kind: GetEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailTemplateError {
    fn code(&self) -> Option<&str> {
        GetEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailTemplateError {
    pub fn new(kind: GetEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetEmailTemplateErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetEmailTemplateErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetImportJobError {
    pub kind: GetImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetImportJobErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetImportJobErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetImportJobError {
    fn code(&self) -> Option<&str> {
        GetImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetImportJobError {
    pub fn new(kind: GetImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for GetImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetImportJobErrorKind::BadRequestError(_inner) => Some(_inner),
            GetImportJobErrorKind::NotFoundError(_inner) => Some(_inner),
            GetImportJobErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSuppressedDestinationError {
    pub kind: GetSuppressedDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSuppressedDestinationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSuppressedDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSuppressedDestinationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            GetSuppressedDestinationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            GetSuppressedDestinationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            GetSuppressedDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSuppressedDestinationError {
    fn code(&self) -> Option<&str> {
        GetSuppressedDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSuppressedDestinationError {
    pub fn new(kind: GetSuppressedDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSuppressedDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSuppressedDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSuppressedDestinationErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSuppressedDestinationErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSuppressedDestinationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for GetSuppressedDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSuppressedDestinationErrorKind::BadRequestError(_inner) => Some(_inner),
            GetSuppressedDestinationErrorKind::NotFoundError(_inner) => Some(_inner),
            GetSuppressedDestinationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            GetSuppressedDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConfigurationSetsError {
    pub kind: ListConfigurationSetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConfigurationSetsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConfigurationSetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConfigurationSetsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListConfigurationSetsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListConfigurationSetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListConfigurationSetsError {
    fn code(&self) -> Option<&str> {
        ListConfigurationSetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConfigurationSetsError {
    pub fn new(kind: ListConfigurationSetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConfigurationSetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConfigurationSetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationSetsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListConfigurationSetsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListConfigurationSetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConfigurationSetsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListConfigurationSetsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListConfigurationSetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContactListsError {
    pub kind: ListContactListsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContactListsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContactListsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContactListsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListContactListsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListContactListsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContactListsError {
    fn code(&self) -> Option<&str> {
        ListContactListsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContactListsError {
    pub fn new(kind: ListContactListsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContactListsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContactListsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListContactListsErrorKind::BadRequestError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListContactListsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListContactListsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContactListsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListContactListsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListContactListsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListContactsError {
    pub kind: ListContactsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListContactsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListContactsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListContactsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListContactsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListContactsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListContactsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListContactsError {
    fn code(&self) -> Option<&str> {
        ListContactsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListContactsError {
    pub fn new(kind: ListContactsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListContactsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListContactsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListContactsErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListContactsErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ListContactsErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for ListContactsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListContactsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListContactsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListContactsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListContactsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCustomVerificationEmailTemplatesError {
    pub kind: ListCustomVerificationEmailTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCustomVerificationEmailTemplatesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListCustomVerificationEmailTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCustomVerificationEmailTemplatesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            ListCustomVerificationEmailTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListCustomVerificationEmailTemplatesError {
    fn code(&self) -> Option<&str> {
        ListCustomVerificationEmailTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListCustomVerificationEmailTemplatesError {
    pub fn new(
        kind: ListCustomVerificationEmailTemplatesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListCustomVerificationEmailTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListCustomVerificationEmailTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomVerificationEmailTemplatesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListCustomVerificationEmailTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCustomVerificationEmailTemplatesErrorKind::BadRequestError(_inner) => Some(_inner),
            ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            ListCustomVerificationEmailTemplatesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDedicatedIpPoolsError {
    pub kind: ListDedicatedIpPoolsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDedicatedIpPoolsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDedicatedIpPoolsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDedicatedIpPoolsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListDedicatedIpPoolsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListDedicatedIpPoolsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDedicatedIpPoolsError {
    fn code(&self) -> Option<&str> {
        ListDedicatedIpPoolsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDedicatedIpPoolsError {
    pub fn new(kind: ListDedicatedIpPoolsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDedicatedIpPoolsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDedicatedIpPoolsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDedicatedIpPoolsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDedicatedIpPoolsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListDedicatedIpPoolsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDedicatedIpPoolsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListDedicatedIpPoolsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListDedicatedIpPoolsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDeliverabilityTestReportsError {
    pub kind: ListDeliverabilityTestReportsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeliverabilityTestReportsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDeliverabilityTestReportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDeliverabilityTestReportsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListDeliverabilityTestReportsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListDeliverabilityTestReportsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListDeliverabilityTestReportsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDeliverabilityTestReportsError {
    fn code(&self) -> Option<&str> {
        ListDeliverabilityTestReportsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeliverabilityTestReportsError {
    pub fn new(kind: ListDeliverabilityTestReportsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDeliverabilityTestReportsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDeliverabilityTestReportsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDeliverabilityTestReportsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDeliverabilityTestReportsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDeliverabilityTestReportsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListDeliverabilityTestReportsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDeliverabilityTestReportsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListDeliverabilityTestReportsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListDeliverabilityTestReportsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListDeliverabilityTestReportsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainDeliverabilityCampaignsError {
    pub kind: ListDomainDeliverabilityCampaignsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainDeliverabilityCampaignsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDomainDeliverabilityCampaignsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainDeliverabilityCampaignsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListDomainDeliverabilityCampaignsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            ListDomainDeliverabilityCampaignsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDomainDeliverabilityCampaignsError {
    fn code(&self) -> Option<&str> {
        ListDomainDeliverabilityCampaignsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDomainDeliverabilityCampaignsError {
    pub fn new(
        kind: ListDomainDeliverabilityCampaignsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDomainDeliverabilityCampaignsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDomainDeliverabilityCampaignsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainDeliverabilityCampaignsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainDeliverabilityCampaignsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListDomainDeliverabilityCampaignsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainDeliverabilityCampaignsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListDomainDeliverabilityCampaignsErrorKind::NotFoundError(_inner) => Some(_inner),
            ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            ListDomainDeliverabilityCampaignsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEmailIdentitiesError {
    pub kind: ListEmailIdentitiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEmailIdentitiesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEmailIdentitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEmailIdentitiesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListEmailIdentitiesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListEmailIdentitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEmailIdentitiesError {
    fn code(&self) -> Option<&str> {
        ListEmailIdentitiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEmailIdentitiesError {
    pub fn new(kind: ListEmailIdentitiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEmailIdentitiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEmailIdentitiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListEmailIdentitiesErrorKind::BadRequestError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListEmailIdentitiesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListEmailIdentitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEmailIdentitiesErrorKind::BadRequestError(_inner) => Some(_inner),
            ListEmailIdentitiesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListEmailIdentitiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEmailTemplatesError {
    pub kind: ListEmailTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEmailTemplatesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEmailTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEmailTemplatesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListEmailTemplatesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListEmailTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEmailTemplatesError {
    fn code(&self) -> Option<&str> {
        ListEmailTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEmailTemplatesError {
    pub fn new(kind: ListEmailTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEmailTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEmailTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListEmailTemplatesErrorKind::BadRequestError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListEmailTemplatesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListEmailTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEmailTemplatesErrorKind::BadRequestError(_inner) => Some(_inner),
            ListEmailTemplatesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListEmailTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListImportJobsError {
    pub kind: ListImportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListImportJobsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListImportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListImportJobsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListImportJobsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListImportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListImportJobsError {
    fn code(&self) -> Option<&str> {
        ListImportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListImportJobsError {
    pub fn new(kind: ListImportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListImportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListImportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListImportJobsErrorKind::BadRequestError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, ListImportJobsErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for ListImportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListImportJobsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListImportJobsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListImportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSuppressedDestinationsError {
    pub kind: ListSuppressedDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSuppressedDestinationsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSuppressedDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSuppressedDestinationsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListSuppressedDestinationsErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListSuppressedDestinationsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListSuppressedDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSuppressedDestinationsError {
    fn code(&self) -> Option<&str> {
        ListSuppressedDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSuppressedDestinationsError {
    pub fn new(kind: ListSuppressedDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSuppressedDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSuppressedDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSuppressedDestinationsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_invalid_next_token_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSuppressedDestinationsErrorKind::InvalidNextTokenError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSuppressedDestinationsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListSuppressedDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSuppressedDestinationsErrorKind::BadRequestError(_inner) => Some(_inner),
            ListSuppressedDestinationsErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListSuppressedDestinationsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListSuppressedDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountDedicatedIpWarmupAttributesError {
    pub kind: PutAccountDedicatedIpWarmupAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountDedicatedIpWarmupAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountDedicatedIpWarmupAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountDedicatedIpWarmupAttributesError {
    fn code(&self) -> Option<&str> {
        PutAccountDedicatedIpWarmupAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountDedicatedIpWarmupAttributesError {
    pub fn new(
        kind: PutAccountDedicatedIpWarmupAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutAccountDedicatedIpWarmupAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutAccountDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountDetailsError {
    pub kind: PutAccountDetailsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountDetailsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConflictError(crate::error::ConflictError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountDetailsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutAccountDetailsErrorKind::ConflictError(_inner) => _inner.fmt(f),
            PutAccountDetailsErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutAccountDetailsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountDetailsError {
    fn code(&self) -> Option<&str> {
        PutAccountDetailsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountDetailsError {
    pub fn new(kind: PutAccountDetailsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountDetailsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountDetailsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, PutAccountDetailsErrorKind::BadRequestError(_))
    }
    pub fn is_conflict_error(&self) -> bool {
        matches!(&self.kind, PutAccountDetailsErrorKind::ConflictError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountDetailsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutAccountDetailsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountDetailsErrorKind::BadRequestError(_inner) => Some(_inner),
            PutAccountDetailsErrorKind::ConflictError(_inner) => Some(_inner),
            PutAccountDetailsErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutAccountDetailsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSendingAttributesError {
    pub kind: PutAccountSendingAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSendingAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSendingAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSendingAttributesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutAccountSendingAttributesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutAccountSendingAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSendingAttributesError {
    fn code(&self) -> Option<&str> {
        PutAccountSendingAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSendingAttributesError {
    pub fn new(kind: PutAccountSendingAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSendingAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSendingAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSendingAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSendingAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutAccountSendingAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSendingAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutAccountSendingAttributesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutAccountSendingAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutAccountSuppressionAttributesError {
    pub kind: PutAccountSuppressionAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutAccountSuppressionAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutAccountSuppressionAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutAccountSuppressionAttributesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutAccountSuppressionAttributesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutAccountSuppressionAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutAccountSuppressionAttributesError {
    fn code(&self) -> Option<&str> {
        PutAccountSuppressionAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutAccountSuppressionAttributesError {
    pub fn new(kind: PutAccountSuppressionAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutAccountSuppressionAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutAccountSuppressionAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSuppressionAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutAccountSuppressionAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutAccountSuppressionAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutAccountSuppressionAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutAccountSuppressionAttributesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutAccountSuppressionAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetDeliveryOptionsError {
    pub kind: PutConfigurationSetDeliveryOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetDeliveryOptionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetDeliveryOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetDeliveryOptionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutConfigurationSetDeliveryOptionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetDeliveryOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetDeliveryOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetDeliveryOptionsError {
    pub fn new(
        kind: PutConfigurationSetDeliveryOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetDeliveryOptionsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetDeliveryOptionsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetDeliveryOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetDeliveryOptionsErrorKind::BadRequestError(_inner) => Some(_inner),
            PutConfigurationSetDeliveryOptionsErrorKind::NotFoundError(_inner) => Some(_inner),
            PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetDeliveryOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetReputationOptionsError {
    pub kind: PutConfigurationSetReputationOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetReputationOptionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetReputationOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetReputationOptionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutConfigurationSetReputationOptionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetReputationOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetReputationOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetReputationOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetReputationOptionsError {
    pub fn new(
        kind: PutConfigurationSetReputationOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetReputationOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetReputationOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetReputationOptionsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetReputationOptionsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetReputationOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetReputationOptionsErrorKind::BadRequestError(_inner) => Some(_inner),
            PutConfigurationSetReputationOptionsErrorKind::NotFoundError(_inner) => Some(_inner),
            PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetReputationOptionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetSendingOptionsError {
    pub kind: PutConfigurationSetSendingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetSendingOptionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetSendingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetSendingOptionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutConfigurationSetSendingOptionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSendingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetSendingOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetSendingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetSendingOptionsError {
    pub fn new(
        kind: PutConfigurationSetSendingOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetSendingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetSendingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSendingOptionsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSendingOptionsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetSendingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetSendingOptionsErrorKind::BadRequestError(_inner) => Some(_inner),
            PutConfigurationSetSendingOptionsErrorKind::NotFoundError(_inner) => Some(_inner),
            PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetSendingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetSuppressionOptionsError {
    pub kind: PutConfigurationSetSuppressionOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetSuppressionOptionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetSuppressionOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetSuppressionOptionsErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetSuppressionOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetSuppressionOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetSuppressionOptionsError {
    pub fn new(
        kind: PutConfigurationSetSuppressionOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSuppressionOptionsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSuppressionOptionsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetSuppressionOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetSuppressionOptionsErrorKind::BadRequestError(_inner) => Some(_inner),
            PutConfigurationSetSuppressionOptionsErrorKind::NotFoundError(_inner) => Some(_inner),
            PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetSuppressionOptionsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutConfigurationSetTrackingOptionsError {
    pub kind: PutConfigurationSetTrackingOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutConfigurationSetTrackingOptionsErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutConfigurationSetTrackingOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutConfigurationSetTrackingOptionsErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutConfigurationSetTrackingOptionsErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutConfigurationSetTrackingOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutConfigurationSetTrackingOptionsError {
    fn code(&self) -> Option<&str> {
        PutConfigurationSetTrackingOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutConfigurationSetTrackingOptionsError {
    pub fn new(
        kind: PutConfigurationSetTrackingOptionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutConfigurationSetTrackingOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutConfigurationSetTrackingOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetTrackingOptionsErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetTrackingOptionsErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutConfigurationSetTrackingOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutConfigurationSetTrackingOptionsErrorKind::BadRequestError(_inner) => Some(_inner),
            PutConfigurationSetTrackingOptionsErrorKind::NotFoundError(_inner) => Some(_inner),
            PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutConfigurationSetTrackingOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDedicatedIpInPoolError {
    pub kind: PutDedicatedIpInPoolErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDedicatedIpInPoolErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDedicatedIpInPoolError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDedicatedIpInPoolErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutDedicatedIpInPoolErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutDedicatedIpInPoolErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutDedicatedIpInPoolErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDedicatedIpInPoolError {
    fn code(&self) -> Option<&str> {
        PutDedicatedIpInPoolError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDedicatedIpInPoolError {
    pub fn new(kind: PutDedicatedIpInPoolErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDedicatedIpInPoolErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDedicatedIpInPoolErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpInPoolErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, PutDedicatedIpInPoolErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpInPoolErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutDedicatedIpInPoolError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDedicatedIpInPoolErrorKind::BadRequestError(_inner) => Some(_inner),
            PutDedicatedIpInPoolErrorKind::NotFoundError(_inner) => Some(_inner),
            PutDedicatedIpInPoolErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutDedicatedIpInPoolErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDedicatedIpWarmupAttributesError {
    pub kind: PutDedicatedIpWarmupAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDedicatedIpWarmupAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDedicatedIpWarmupAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDedicatedIpWarmupAttributesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutDedicatedIpWarmupAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDedicatedIpWarmupAttributesError {
    fn code(&self) -> Option<&str> {
        PutDedicatedIpWarmupAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDedicatedIpWarmupAttributesError {
    pub fn new(kind: PutDedicatedIpWarmupAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDedicatedIpWarmupAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpWarmupAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpWarmupAttributesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutDedicatedIpWarmupAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDedicatedIpWarmupAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutDedicatedIpWarmupAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutDedicatedIpWarmupAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutDeliverabilityDashboardOptionError {
    pub kind: PutDeliverabilityDashboardOptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutDeliverabilityDashboardOptionErrorKind {
    AlreadyExistsError(crate::error::AlreadyExistsError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutDeliverabilityDashboardOptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsError(_inner) => _inner.fmt(f),
            PutDeliverabilityDashboardOptionErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutDeliverabilityDashboardOptionErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutDeliverabilityDashboardOptionErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutDeliverabilityDashboardOptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutDeliverabilityDashboardOptionError {
    fn code(&self) -> Option<&str> {
        PutDeliverabilityDashboardOptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutDeliverabilityDashboardOptionError {
    pub fn new(kind: PutDeliverabilityDashboardOptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutDeliverabilityDashboardOptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutDeliverabilityDashboardOptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_already_exists_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsError(_)
        )
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::BadRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutDeliverabilityDashboardOptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsError(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::BadRequestError(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::NotFoundError(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutDeliverabilityDashboardOptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityConfigurationSetAttributesError {
    pub kind: PutEmailIdentityConfigurationSetAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityConfigurationSetAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityConfigurationSetAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityConfigurationSetAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityConfigurationSetAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityConfigurationSetAttributesError {
    pub fn new(
        kind: PutEmailIdentityConfigurationSetAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityConfigurationSetAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestError(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundError(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityConfigurationSetAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityDkimAttributesError {
    pub kind: PutEmailIdentityDkimAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityDkimAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityDkimAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityDkimAttributesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutEmailIdentityDkimAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutEmailIdentityDkimAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityDkimAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityDkimAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityDkimAttributesError {
    pub fn new(kind: PutEmailIdentityDkimAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityDkimAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityDkimAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimAttributesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityDkimAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityDkimAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutEmailIdentityDkimAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutEmailIdentityDkimAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityDkimSigningAttributesError {
    pub kind: PutEmailIdentityDkimSigningAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityDkimSigningAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityDkimSigningAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityDkimSigningAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityDkimSigningAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityDkimSigningAttributesError {
    pub fn new(
        kind: PutEmailIdentityDkimSigningAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityDkimSigningAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityDkimSigningAttributesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityFeedbackAttributesError {
    pub kind: PutEmailIdentityFeedbackAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityFeedbackAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityFeedbackAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityFeedbackAttributesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutEmailIdentityFeedbackAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityFeedbackAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityFeedbackAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityFeedbackAttributesError {
    pub fn new(
        kind: PutEmailIdentityFeedbackAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityFeedbackAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityFeedbackAttributesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityFeedbackAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityFeedbackAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutEmailIdentityFeedbackAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityFeedbackAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEmailIdentityMailFromAttributesError {
    pub kind: PutEmailIdentityMailFromAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEmailIdentityMailFromAttributesErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEmailIdentityMailFromAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEmailIdentityMailFromAttributesErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutEmailIdentityMailFromAttributesErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            PutEmailIdentityMailFromAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEmailIdentityMailFromAttributesError {
    fn code(&self) -> Option<&str> {
        PutEmailIdentityMailFromAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEmailIdentityMailFromAttributesError {
    pub fn new(
        kind: PutEmailIdentityMailFromAttributesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEmailIdentityMailFromAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEmailIdentityMailFromAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityMailFromAttributesErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityMailFromAttributesErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutEmailIdentityMailFromAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEmailIdentityMailFromAttributesErrorKind::BadRequestError(_inner) => Some(_inner),
            PutEmailIdentityMailFromAttributesErrorKind::NotFoundError(_inner) => Some(_inner),
            PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            PutEmailIdentityMailFromAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSuppressedDestinationError {
    pub kind: PutSuppressedDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSuppressedDestinationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSuppressedDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSuppressedDestinationErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            PutSuppressedDestinationErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            PutSuppressedDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSuppressedDestinationError {
    fn code(&self) -> Option<&str> {
        PutSuppressedDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSuppressedDestinationError {
    pub fn new(kind: PutSuppressedDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSuppressedDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSuppressedDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSuppressedDestinationErrorKind::BadRequestError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSuppressedDestinationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for PutSuppressedDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSuppressedDestinationErrorKind::BadRequestError(_inner) => Some(_inner),
            PutSuppressedDestinationErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            PutSuppressedDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendBulkEmailError {
    pub kind: SendBulkEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendBulkEmailErrorKind {
    AccountSuspendedError(crate::error::AccountSuspendedError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MailFromDomainNotVerifiedError(crate::error::MailFromDomainNotVerifiedError),
    MessageRejected(crate::error::MessageRejected),
    NotFoundError(crate::error::NotFoundError),
    SendingPausedError(crate::error::SendingPausedError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendBulkEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendBulkEmailErrorKind::AccountSuspendedError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::MailFromDomainNotVerifiedError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::SendingPausedError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            SendBulkEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendBulkEmailError {
    fn code(&self) -> Option<&str> {
        SendBulkEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendBulkEmailError {
    pub fn new(kind: SendBulkEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendBulkEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendBulkEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_account_suspended_error(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::AccountSuspendedError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::BadRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::LimitExceededError(_))
    }
    pub fn is_mail_from_domain_not_verified_error(&self) -> bool {
        matches!(
            &self.kind,
            SendBulkEmailErrorKind::MailFromDomainNotVerifiedError(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::MessageRejected(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::NotFoundError(_))
    }
    pub fn is_sending_paused_error(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::SendingPausedError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, SendBulkEmailErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for SendBulkEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendBulkEmailErrorKind::AccountSuspendedError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::BadRequestError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::LimitExceededError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::MailFromDomainNotVerifiedError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::MessageRejected(_inner) => Some(_inner),
            SendBulkEmailErrorKind::NotFoundError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::SendingPausedError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            SendBulkEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendCustomVerificationEmailError {
    pub kind: SendCustomVerificationEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendCustomVerificationEmailErrorKind {
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MailFromDomainNotVerifiedError(crate::error::MailFromDomainNotVerifiedError),
    MessageRejected(crate::error::MessageRejected),
    NotFoundError(crate::error::NotFoundError),
    SendingPausedError(crate::error::SendingPausedError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendCustomVerificationEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendCustomVerificationEmailErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedError(_inner) => {
                _inner.fmt(f)
            }
            SendCustomVerificationEmailErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::SendingPausedError(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            SendCustomVerificationEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendCustomVerificationEmailError {
    fn code(&self) -> Option<&str> {
        SendCustomVerificationEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendCustomVerificationEmailError {
    pub fn new(kind: SendCustomVerificationEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendCustomVerificationEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendCustomVerificationEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::BadRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_mail_from_domain_not_verified_error(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedError(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::MessageRejected(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::NotFoundError(_)
        )
    }
    pub fn is_sending_paused_error(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::SendingPausedError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            SendCustomVerificationEmailErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for SendCustomVerificationEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendCustomVerificationEmailErrorKind::BadRequestError(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::LimitExceededError(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedError(_inner) => {
                Some(_inner)
            }
            SendCustomVerificationEmailErrorKind::MessageRejected(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::NotFoundError(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::SendingPausedError(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            SendCustomVerificationEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendEmailError {
    pub kind: SendEmailErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendEmailErrorKind {
    AccountSuspendedError(crate::error::AccountSuspendedError),
    BadRequestError(crate::error::BadRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MailFromDomainNotVerifiedError(crate::error::MailFromDomainNotVerifiedError),
    MessageRejected(crate::error::MessageRejected),
    NotFoundError(crate::error::NotFoundError),
    SendingPausedError(crate::error::SendingPausedError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendEmailError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendEmailErrorKind::AccountSuspendedError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::MailFromDomainNotVerifiedError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::MessageRejected(_inner) => _inner.fmt(f),
            SendEmailErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::SendingPausedError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            SendEmailErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendEmailError {
    fn code(&self) -> Option<&str> {
        SendEmailError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendEmailError {
    pub fn new(kind: SendEmailErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendEmailErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendEmailErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_account_suspended_error(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::AccountSuspendedError(_))
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::BadRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::LimitExceededError(_))
    }
    pub fn is_mail_from_domain_not_verified_error(&self) -> bool {
        matches!(
            &self.kind,
            SendEmailErrorKind::MailFromDomainNotVerifiedError(_)
        )
    }
    pub fn is_message_rejected(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::MessageRejected(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::NotFoundError(_))
    }
    pub fn is_sending_paused_error(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::SendingPausedError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, SendEmailErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for SendEmailError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendEmailErrorKind::AccountSuspendedError(_inner) => Some(_inner),
            SendEmailErrorKind::BadRequestError(_inner) => Some(_inner),
            SendEmailErrorKind::LimitExceededError(_inner) => Some(_inner),
            SendEmailErrorKind::MailFromDomainNotVerifiedError(_inner) => Some(_inner),
            SendEmailErrorKind::MessageRejected(_inner) => Some(_inner),
            SendEmailErrorKind::NotFoundError(_inner) => Some(_inner),
            SendEmailErrorKind::SendingPausedError(_inner) => Some(_inner),
            SendEmailErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            SendEmailErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            TagResourceErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            TagResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestRenderEmailTemplateError {
    pub kind: TestRenderEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestRenderEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestRenderEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestRenderEmailTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            TestRenderEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            TestRenderEmailTemplateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            TestRenderEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestRenderEmailTemplateError {
    fn code(&self) -> Option<&str> {
        TestRenderEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestRenderEmailTemplateError {
    pub fn new(kind: TestRenderEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestRenderEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestRenderEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            TestRenderEmailTemplateErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            TestRenderEmailTemplateErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            TestRenderEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for TestRenderEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestRenderEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            TestRenderEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            TestRenderEmailTemplateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            TestRenderEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::BadRequestError(_inner) => Some(_inner),
            UntagResourceErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UntagResourceErrorKind::NotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConfigurationSetEventDestinationError {
    pub kind: UpdateConfigurationSetEventDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConfigurationSetEventDestinationErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConfigurationSetEventDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConfigurationSetEventDestinationErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            UpdateConfigurationSetEventDestinationErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            UpdateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConfigurationSetEventDestinationError {
    fn code(&self) -> Option<&str> {
        UpdateConfigurationSetEventDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConfigurationSetEventDestinationError {
    pub fn new(
        kind: UpdateConfigurationSetEventDestinationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConfigurationSetEventDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationSetEventDestinationErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationSetEventDestinationErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for UpdateConfigurationSetEventDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConfigurationSetEventDestinationErrorKind::BadRequestError(_inner) => {
                Some(_inner)
            }
            UpdateConfigurationSetEventDestinationErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            UpdateConfigurationSetEventDestinationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactError {
    pub kind: UpdateContactErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateContactErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactError {
    fn code(&self) -> Option<&str> {
        UpdateContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactError {
    pub fn new(kind: UpdateContactErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateContactErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateContactErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(&self.kind, UpdateContactErrorKind::TooManyRequestsError(_))
    }
}
impl std::error::Error for UpdateContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateContactErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UpdateContactErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateContactErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateContactErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateContactListError {
    pub kind: UpdateContactListErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateContactListErrorKind {
    BadRequestError(crate::error::BadRequestError),
    ConcurrentModificationError(crate::error::ConcurrentModificationError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateContactListError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateContactListErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::ConcurrentModificationError(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateContactListErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateContactListError {
    fn code(&self) -> Option<&str> {
        UpdateContactListError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateContactListError {
    pub fn new(kind: UpdateContactListErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateContactListErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateContactListErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateContactListErrorKind::BadRequestError(_))
    }
    pub fn is_concurrent_modification_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactListErrorKind::ConcurrentModificationError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateContactListErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateContactListErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for UpdateContactListError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateContactListErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateContactListErrorKind::ConcurrentModificationError(_inner) => Some(_inner),
            UpdateContactListErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateContactListErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateContactListErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCustomVerificationEmailTemplateError {
    pub kind: UpdateCustomVerificationEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCustomVerificationEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCustomVerificationEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                _inner.fmt(f)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCustomVerificationEmailTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateCustomVerificationEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCustomVerificationEmailTemplateError {
    pub fn new(
        kind: UpdateCustomVerificationEmailTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomVerificationEmailTemplateErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomVerificationEmailTemplateErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for UpdateCustomVerificationEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCustomVerificationEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateCustomVerificationEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(_inner) => {
                Some(_inner)
            }
            UpdateCustomVerificationEmailTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEmailIdentityPolicyError {
    pub kind: UpdateEmailIdentityPolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEmailIdentityPolicyErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEmailIdentityPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEmailIdentityPolicyErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateEmailIdentityPolicyErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateEmailIdentityPolicyErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateEmailIdentityPolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEmailIdentityPolicyError {
    fn code(&self) -> Option<&str> {
        UpdateEmailIdentityPolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEmailIdentityPolicyError {
    pub fn new(kind: UpdateEmailIdentityPolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEmailIdentityPolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailIdentityPolicyErrorKind::BadRequestError(_)
        )
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailIdentityPolicyErrorKind::NotFoundError(_)
        )
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailIdentityPolicyErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for UpdateEmailIdentityPolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEmailIdentityPolicyErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateEmailIdentityPolicyErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateEmailIdentityPolicyErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateEmailIdentityPolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEmailTemplateError {
    pub kind: UpdateEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEmailTemplateErrorKind {
    BadRequestError(crate::error::BadRequestError),
    NotFoundError(crate::error::NotFoundError),
    TooManyRequestsError(crate::error::TooManyRequestsError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEmailTemplateErrorKind::BadRequestError(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::NotFoundError(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::TooManyRequestsError(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEmailTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEmailTemplateError {
    pub fn new(kind: UpdateEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_error(&self) -> bool {
        matches!(&self.kind, UpdateEmailTemplateErrorKind::BadRequestError(_))
    }
    pub fn is_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateEmailTemplateErrorKind::NotFoundError(_))
    }
    pub fn is_too_many_requests_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::TooManyRequestsError(_)
        )
    }
}
impl std::error::Error for UpdateEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEmailTemplateErrorKind::BadRequestError(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::NotFoundError(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::TooManyRequestsError(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Too many requests have been made to the operation.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyRequestsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsError [TooManyRequestsException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsError {}
/// See [`TooManyRequestsError`](crate::error::TooManyRequestsError)
pub mod too_many_requests_error {
    /// A builder for [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsError`](crate::error::TooManyRequestsError)
        pub fn build(self) -> crate::error::TooManyRequestsError {
            crate::error::TooManyRequestsError {
                message: self.message,
            }
        }
    }
}
impl TooManyRequestsError {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsError`](crate::error::TooManyRequestsError)
    pub fn builder() -> crate::error::too_many_requests_error::Builder {
        crate::error::too_many_requests_error::Builder::default()
    }
}

/// <p>The resource you attempted to access doesn't exist.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundError [NotFoundException]")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundError {}
/// See [`NotFoundError`](crate::error::NotFoundError)
pub mod not_found_error {
    /// A builder for [`NotFoundError`](crate::error::NotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundError`](crate::error::NotFoundError)
        pub fn build(self) -> crate::error::NotFoundError {
            crate::error::NotFoundError {
                message: self.message,
            }
        }
    }
}
impl NotFoundError {
    /// Creates a new builder-style object to manufacture [`NotFoundError`](crate::error::NotFoundError)
    pub fn builder() -> crate::error::not_found_error::Builder {
        crate::error::not_found_error::Builder::default()
    }
}

/// <p>The input you provided is invalid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BadRequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestError [BadRequestException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestError {}
/// See [`BadRequestError`](crate::error::BadRequestError)
pub mod bad_request_error {
    /// A builder for [`BadRequestError`](crate::error::BadRequestError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestError`](crate::error::BadRequestError)
        pub fn build(self) -> crate::error::BadRequestError {
            crate::error::BadRequestError {
                message: self.message,
            }
        }
    }
}
impl BadRequestError {
    /// Creates a new builder-style object to manufacture [`BadRequestError`](crate::error::BadRequestError)
    pub fn builder() -> crate::error::bad_request_error::Builder {
        crate::error::bad_request_error::Builder::default()
    }
}

/// <p>The resource is being modified by another operation or thread.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ConcurrentModificationError [ConcurrentModificationException]"
        )?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationError {}
/// See [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
pub mod concurrent_modification_error {
    /// A builder for [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
        pub fn build(self) -> crate::error::ConcurrentModificationError {
            crate::error::ConcurrentModificationError {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationError {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationError`](crate::error::ConcurrentModificationError)
    pub fn builder() -> crate::error::concurrent_modification_error::Builder {
        crate::error::concurrent_modification_error::Builder::default()
    }
}

/// <p>The message can't be sent because the account's ability to send email is currently
/// paused.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendingPausedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendingPausedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendingPausedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SendingPausedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SendingPausedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SendingPausedError [SendingPausedException]")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for SendingPausedError {}
/// See [`SendingPausedError`](crate::error::SendingPausedError)
pub mod sending_paused_error {
    /// A builder for [`SendingPausedError`](crate::error::SendingPausedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SendingPausedError`](crate::error::SendingPausedError)
        pub fn build(self) -> crate::error::SendingPausedError {
            crate::error::SendingPausedError {
                message: self.message,
            }
        }
    }
}
impl SendingPausedError {
    /// Creates a new builder-style object to manufacture [`SendingPausedError`](crate::error::SendingPausedError)
    pub fn builder() -> crate::error::sending_paused_error::Builder {
        crate::error::sending_paused_error::Builder::default()
    }
}

/// <p>The message can't be sent because it contains invalid content.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageRejected {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageRejected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageRejected");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MessageRejected {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MessageRejected {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MessageRejected")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for MessageRejected {}
/// See [`MessageRejected`](crate::error::MessageRejected)
pub mod message_rejected {
    /// A builder for [`MessageRejected`](crate::error::MessageRejected)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageRejected`](crate::error::MessageRejected)
        pub fn build(self) -> crate::error::MessageRejected {
            crate::error::MessageRejected {
                message: self.message,
            }
        }
    }
}
impl MessageRejected {
    /// Creates a new builder-style object to manufacture [`MessageRejected`](crate::error::MessageRejected)
    pub fn builder() -> crate::error::message_rejected::Builder {
        crate::error::message_rejected::Builder::default()
    }
}

/// <p>The message can't be sent because the sending domain isn't verified.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MailFromDomainNotVerifiedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MailFromDomainNotVerifiedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MailFromDomainNotVerifiedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MailFromDomainNotVerifiedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MailFromDomainNotVerifiedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MailFromDomainNotVerifiedError [MailFromDomainNotVerifiedException]"
        )?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for MailFromDomainNotVerifiedError {}
/// See [`MailFromDomainNotVerifiedError`](crate::error::MailFromDomainNotVerifiedError)
pub mod mail_from_domain_not_verified_error {
    /// A builder for [`MailFromDomainNotVerifiedError`](crate::error::MailFromDomainNotVerifiedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MailFromDomainNotVerifiedError`](crate::error::MailFromDomainNotVerifiedError)
        pub fn build(self) -> crate::error::MailFromDomainNotVerifiedError {
            crate::error::MailFromDomainNotVerifiedError {
                message: self.message,
            }
        }
    }
}
impl MailFromDomainNotVerifiedError {
    /// Creates a new builder-style object to manufacture [`MailFromDomainNotVerifiedError`](crate::error::MailFromDomainNotVerifiedError)
    pub fn builder() -> crate::error::mail_from_domain_not_verified_error::Builder {
        crate::error::mail_from_domain_not_verified_error::Builder::default()
    }
}

/// <p>There are too many instances of the specified resource type.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>The message can't be sent because the account's ability to send email has been
/// permanently restricted.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AccountSuspendedError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccountSuspendedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccountSuspendedError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccountSuspendedError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccountSuspendedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccountSuspendedError [AccountSuspendedException]")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccountSuspendedError {}
/// See [`AccountSuspendedError`](crate::error::AccountSuspendedError)
pub mod account_suspended_error {
    /// A builder for [`AccountSuspendedError`](crate::error::AccountSuspendedError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountSuspendedError`](crate::error::AccountSuspendedError)
        pub fn build(self) -> crate::error::AccountSuspendedError {
            crate::error::AccountSuspendedError {
                message: self.message,
            }
        }
    }
}
impl AccountSuspendedError {
    /// Creates a new builder-style object to manufacture [`AccountSuspendedError`](crate::error::AccountSuspendedError)
    pub fn builder() -> crate::error::account_suspended_error::Builder {
        crate::error::account_suspended_error::Builder::default()
    }
}

/// <p>The resource specified in your request already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct AlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AlreadyExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AlreadyExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlreadyExistsError [AlreadyExistsException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for AlreadyExistsError {}
/// See [`AlreadyExistsError`](crate::error::AlreadyExistsError)
pub mod already_exists_error {
    /// A builder for [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AlreadyExistsError`](crate::error::AlreadyExistsError)
        pub fn build(self) -> crate::error::AlreadyExistsError {
            crate::error::AlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl AlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`AlreadyExistsError`](crate::error::AlreadyExistsError)
    pub fn builder() -> crate::error::already_exists_error::Builder {
        crate::error::already_exists_error::Builder::default()
    }
}

/// <p>If there is already an ongoing account details update under review.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConflictError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictError [ConflictException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictError {}
/// See [`ConflictError`](crate::error::ConflictError)
pub mod conflict_error {
    /// A builder for [`ConflictError`](crate::error::ConflictError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictError`](crate::error::ConflictError)
        pub fn build(self) -> crate::error::ConflictError {
            crate::error::ConflictError {
                message: self.message,
            }
        }
    }
}
impl ConflictError {
    /// Creates a new builder-style object to manufacture [`ConflictError`](crate::error::ConflictError)
    pub fn builder() -> crate::error::conflict_error::Builder {
        crate::error::conflict_error::Builder::default()
    }
}

/// <p>The specified request includes an invalid or expired token.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenError {
    #[serde(rename = "message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenError [InvalidNextTokenException]")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenError {}
/// See [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
pub mod invalid_next_token_error {
    /// A builder for [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
        pub fn build(self) -> crate::error::InvalidNextTokenError {
            crate::error::InvalidNextTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    pub fn builder() -> crate::error::invalid_next_token_error::Builder {
        crate::error::invalid_next_token_error::Builder::default()
    }
}
