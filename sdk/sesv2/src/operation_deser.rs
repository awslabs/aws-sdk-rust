// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetOutput,
    crate::error::CreateConfigurationSetError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateConfigurationSetError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateConfigurationSetError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateConfigurationSetError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::CreateConfigurationSetError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateConfigurationSetError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateConfigurationSetError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateConfigurationSetError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateConfigurationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetOutput,
    crate::error::CreateConfigurationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_configuration_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_event_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetEventDestinationOutput,
    crate::error::CreateConfigurationSetEventDestinationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateConfigurationSetEventDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateConfigurationSetEventDestinationError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::AlreadyExistsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::already_exists_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(
                        crate::error::CreateConfigurationSetEventDestinationError::unhandled,
                    )?;
                    output.build()
                },
            ),
        },
        "BadRequestException" => crate::error::CreateConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(
                        crate::error::CreateConfigurationSetEventDestinationError::unhandled,
                    )?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::LimitExceededError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(
                        crate::error::CreateConfigurationSetEventDestinationError::unhandled,
                    )?;
                    output.build()
                },
            ),
        },
        "NotFoundException" => crate::error::CreateConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::CreateConfigurationSetEventDestinationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::CreateConfigurationSetEventDestinationError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateConfigurationSetEventDestinationError {
            meta: generic,
            kind:
                crate::error::CreateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::CreateConfigurationSetEventDestinationError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::CreateConfigurationSetEventDestinationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_configuration_set_event_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateConfigurationSetEventDestinationOutput,
    crate::error::CreateConfigurationSetEventDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_configuration_set_event_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_contact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateContactOutput, crate::error::CreateContactError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateContactError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateContactError::unhandled(generic)),
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateContactError {
            meta: generic,
            kind: crate::error::CreateContactErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateContactError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateContactError {
            meta: generic,
            kind: crate::error::CreateContactErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateContactError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateContactError {
            meta: generic,
            kind: crate::error::CreateContactErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateContactError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateContactError {
            meta: generic,
            kind: crate::error::CreateContactErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateContactError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateContactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_contact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateContactOutput, crate::error::CreateContactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_contact_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_contact_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateContactListOutput, crate::error::CreateContactListError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateContactListError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateContactListError::unhandled(generic)),
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateContactListError {
            meta: generic,
            kind: crate::error::CreateContactListErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateContactListError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateContactListError {
            meta: generic,
            kind: crate::error::CreateContactListErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateContactListError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateContactListError {
            meta: generic,
            kind: crate::error::CreateContactListErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateContactListError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateContactListError {
            meta: generic,
            kind: crate::error::CreateContactListErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateContactListError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateContactListError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_contact_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateContactListOutput, crate::error::CreateContactListError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_contact_list_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomVerificationEmailTemplateOutput,
    crate::error::CreateCustomVerificationEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateCustomVerificationEmailTemplateError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::AlreadyExistsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::already_exists_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::already_exists_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                },
            ),
        },
        "BadRequestException" => crate::error::CreateCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::LimitExceededError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::limit_exceeded_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                },
            ),
        },
        "NotFoundException" => crate::error::CreateCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateCustomVerificationEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::CreateCustomVerificationEmailTemplateError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateCustomVerificationEmailTemplateError {
            meta: generic,
            kind:
                crate::error::CreateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::CreateCustomVerificationEmailTemplateError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::CreateCustomVerificationEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateCustomVerificationEmailTemplateOutput,
    crate::error::CreateCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_dedicated_ip_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDedicatedIpPoolOutput,
    crate::error::CreateDedicatedIpPoolError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDedicatedIpPoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDedicatedIpPoolError::unhandled(generic)),
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::CreateDedicatedIpPoolErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::CreateDedicatedIpPoolErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::CreateDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::CreateDedicatedIpPoolErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::CreateDedicatedIpPoolErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::CreateDedicatedIpPoolErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateDedicatedIpPoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_dedicated_ip_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDedicatedIpPoolOutput,
    crate::error::CreateDedicatedIpPoolError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_dedicated_ip_pool_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deliverability_test_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDeliverabilityTestReportOutput,
    crate::error::CreateDeliverabilityTestReportError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateDeliverabilityTestReportError::unhandled(generic)),
    };
    Err(match error_code {
        "AccountSuspendedException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::AccountSuspendedError({
            #[allow(unused_mut)]let mut output = crate::error::account_suspended_error::Builder::default();
            let _ = response;
            output = crate::json_deser::account_suspended_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "BadRequestException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::BadRequestError({
            #[allow(unused_mut)]let mut output = crate::error::bad_request_error::Builder::default();
            let _ = response;
            output = crate::json_deser::bad_request_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "ConcurrentModificationException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::ConcurrentModificationError({
            #[allow(unused_mut)]let mut output = crate::error::concurrent_modification_error::Builder::default();
            let _ = response;
            output = crate::json_deser::concurrent_modification_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "LimitExceededException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::LimitExceededError({
            #[allow(unused_mut)]let mut output = crate::error::limit_exceeded_error::Builder::default();
            let _ = response;
            output = crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "MailFromDomainNotVerifiedException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::MailFromDomainNotVerifiedError({
            #[allow(unused_mut)]let mut output = crate::error::mail_from_domain_not_verified_error::Builder::default();
            let _ = response;
            output = crate::json_deser::mail_from_domain_not_verified_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "MessageRejected" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::MessageRejected({
            #[allow(unused_mut)]let mut output = crate::error::message_rejected::Builder::default();
            let _ = response;
            output = crate::json_deser::message_rejected(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "NotFoundException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::NotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::not_found_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "SendingPausedException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::SendingPausedError({
            #[allow(unused_mut)]let mut output = crate::error::sending_paused_error::Builder::default();
            let _ = response;
            output = crate::json_deser::sending_paused_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        "TooManyRequestsException" => crate::error::CreateDeliverabilityTestReportError { meta: generic, kind: crate::error::CreateDeliverabilityTestReportErrorKind::TooManyRequestsError({
            #[allow(unused_mut)]let mut output = crate::error::too_many_requests_error::Builder::default();
            let _ = response;
            output = crate::json_deser::too_many_requests_exception(response.body().as_ref(), output).map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
            output.build()
        })},
        _ => crate::error::CreateDeliverabilityTestReportError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deliverability_test_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDeliverabilityTestReportOutput,
    crate::error::CreateDeliverabilityTestReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_deliverability_test_report_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_deliverability_test_report_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDeliverabilityTestReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_email_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEmailIdentityOutput,
    crate::error::CreateEmailIdentityError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateEmailIdentityError::unhandled(generic)),
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateEmailIdentityError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateEmailIdentityError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::CreateEmailIdentityError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateEmailIdentityError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateEmailIdentityError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateEmailIdentityError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateEmailIdentityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_email_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEmailIdentityOutput,
    crate::error::CreateEmailIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_email_identity_output::Builder::default();
        let _ = response;
        output = crate::json_deser::create_email_identity_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateEmailIdentityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_email_identity_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEmailIdentityPolicyOutput,
    crate::error::CreateEmailIdentityPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateEmailIdentityPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateEmailIdentityPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityPolicyErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityPolicyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityPolicyErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::CreateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityPolicyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::CreateEmailIdentityPolicyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateEmailIdentityPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_email_identity_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEmailIdentityPolicyOutput,
    crate::error::CreateEmailIdentityPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_email_identity_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEmailTemplateOutput,
    crate::error::CreateEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateEmailTemplateError::unhandled(generic)),
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::CreateEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateEmailTemplateErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::CreateEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateEmailTemplateErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateEmailTemplateError {
            meta: generic,
            kind: crate::error::CreateEmailTemplateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateEmailTemplateOutput,
    crate::error::CreateEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_import_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateImportJobOutput, crate::error::CreateImportJobError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::CreateImportJobError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateImportJobError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::CreateImportJobError {
            meta: generic,
            kind: crate::error::CreateImportJobErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::CreateImportJobError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::CreateImportJobError {
            meta: generic,
            kind: crate::error::CreateImportJobErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::CreateImportJobError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::CreateImportJobError {
            meta: generic,
            kind: crate::error::CreateImportJobErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::CreateImportJobError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::CreateImportJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_import_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateImportJobOutput, crate::error::CreateImportJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_import_job_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::create_import_job_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::CreateImportJobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetOutput,
    crate::error::DeleteConfigurationSetError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteConfigurationSetError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteConfigurationSetError {
            meta: generic,
            kind: crate::error::DeleteConfigurationSetErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::DeleteConfigurationSetError {
            meta: generic,
            kind: crate::error::DeleteConfigurationSetErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteConfigurationSetError {
            meta: generic,
            kind: crate::error::DeleteConfigurationSetErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteConfigurationSetError {
            meta: generic,
            kind: crate::error::DeleteConfigurationSetErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteConfigurationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetOutput,
    crate::error::DeleteConfigurationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_configuration_set_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_event_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetEventDestinationOutput,
    crate::error::DeleteConfigurationSetEventDestinationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteConfigurationSetEventDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteConfigurationSetEventDestinationError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::DeleteConfigurationSetEventDestinationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(
                        crate::error::DeleteConfigurationSetEventDestinationError::unhandled,
                    )?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::DeleteConfigurationSetEventDestinationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::DeleteConfigurationSetEventDestinationError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteConfigurationSetEventDestinationError {
            meta: generic,
            kind:
                crate::error::DeleteConfigurationSetEventDestinationErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DeleteConfigurationSetEventDestinationError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::DeleteConfigurationSetEventDestinationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_configuration_set_event_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteConfigurationSetEventDestinationOutput,
    crate::error::DeleteConfigurationSetEventDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_configuration_set_event_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_contact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteContactOutput, crate::error::DeleteContactError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteContactError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteContactError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteContactError {
            meta: generic,
            kind: crate::error::DeleteContactErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteContactError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteContactError {
            meta: generic,
            kind: crate::error::DeleteContactErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteContactError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteContactError {
            meta: generic,
            kind: crate::error::DeleteContactErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteContactError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteContactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_contact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteContactOutput, crate::error::DeleteContactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_contact_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_contact_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteContactListOutput, crate::error::DeleteContactListError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteContactListError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteContactListError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteContactListError {
            meta: generic,
            kind: crate::error::DeleteContactListErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteContactListError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::DeleteContactListError {
            meta: generic,
            kind: crate::error::DeleteContactListErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteContactListError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteContactListError {
            meta: generic,
            kind: crate::error::DeleteContactListErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteContactListError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteContactListError {
            meta: generic,
            kind: crate::error::DeleteContactListErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteContactListError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteContactListError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_contact_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteContactListOutput, crate::error::DeleteContactListError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_contact_list_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomVerificationEmailTemplateOutput,
    crate::error::DeleteCustomVerificationEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteCustomVerificationEmailTemplateError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::DeleteCustomVerificationEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteCustomVerificationEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::DeleteCustomVerificationEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::DeleteCustomVerificationEmailTemplateError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteCustomVerificationEmailTemplateError {
            meta: generic,
            kind:
                crate::error::DeleteCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::DeleteCustomVerificationEmailTemplateError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::DeleteCustomVerificationEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCustomVerificationEmailTemplateOutput,
    crate::error::DeleteCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_dedicated_ip_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDedicatedIpPoolOutput,
    crate::error::DeleteDedicatedIpPoolError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteDedicatedIpPoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteDedicatedIpPoolError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::DeleteDedicatedIpPoolErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::DeleteDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::DeleteDedicatedIpPoolErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::DeleteDedicatedIpPoolErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteDedicatedIpPoolError {
            meta: generic,
            kind: crate::error::DeleteDedicatedIpPoolErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteDedicatedIpPoolError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteDedicatedIpPoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_dedicated_ip_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDedicatedIpPoolOutput,
    crate::error::DeleteDedicatedIpPoolError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_dedicated_ip_pool_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_email_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEmailIdentityOutput,
    crate::error::DeleteEmailIdentityError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteEmailIdentityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteEmailIdentityError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteEmailIdentityError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::DeleteEmailIdentityError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteEmailIdentityError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteEmailIdentityError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteEmailIdentityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_email_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEmailIdentityOutput,
    crate::error::DeleteEmailIdentityError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_email_identity_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_email_identity_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEmailIdentityPolicyOutput,
    crate::error::DeleteEmailIdentityPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteEmailIdentityPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteEmailIdentityPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityPolicyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityPolicyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::DeleteEmailIdentityPolicyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteEmailIdentityPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_email_identity_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEmailIdentityPolicyOutput,
    crate::error::DeleteEmailIdentityPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_email_identity_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEmailTemplateOutput,
    crate::error::DeleteEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteEmailTemplateError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteEmailTemplateError {
            meta: generic,
            kind: crate::error::DeleteEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteEmailTemplateError {
            meta: generic,
            kind: crate::error::DeleteEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteEmailTemplateError {
            meta: generic,
            kind: crate::error::DeleteEmailTemplateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteEmailTemplateOutput,
    crate::error::DeleteEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_suppressed_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSuppressedDestinationOutput,
    crate::error::DeleteSuppressedDestinationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::DeleteSuppressedDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteSuppressedDestinationError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::DeleteSuppressedDestinationError {
            meta: generic,
            kind: crate::error::DeleteSuppressedDestinationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::DeleteSuppressedDestinationError {
            meta: generic,
            kind: crate::error::DeleteSuppressedDestinationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::DeleteSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::DeleteSuppressedDestinationError {
            meta: generic,
            kind: crate::error::DeleteSuppressedDestinationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::DeleteSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::DeleteSuppressedDestinationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_suppressed_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteSuppressedDestinationOutput,
    crate::error::DeleteSuppressedDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_suppressed_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountOutput, crate::error::GetAccountError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetAccountError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetAccountError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetAccountError {
            meta: generic,
            kind: crate::error::GetAccountErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetAccountError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetAccountError {
            meta: generic,
            kind: crate::error::GetAccountErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetAccountError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetAccountError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_account_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetAccountOutput, crate::error::GetAccountError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_account_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_account_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetAccountError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blacklist_reports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBlacklistReportsOutput,
    crate::error::GetBlacklistReportsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetBlacklistReportsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBlacklistReportsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetBlacklistReportsError {
            meta: generic,
            kind: crate::error::GetBlacklistReportsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetBlacklistReportsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetBlacklistReportsError {
            meta: generic,
            kind: crate::error::GetBlacklistReportsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetBlacklistReportsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetBlacklistReportsError {
            meta: generic,
            kind: crate::error::GetBlacklistReportsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetBlacklistReportsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetBlacklistReportsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blacklist_reports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetBlacklistReportsOutput,
    crate::error::GetBlacklistReportsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_blacklist_reports_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_blacklist_reports_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBlacklistReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_configuration_set_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConfigurationSetOutput,
    crate::error::GetConfigurationSetError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetConfigurationSetError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetConfigurationSetError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetConfigurationSetError {
            meta: generic,
            kind: crate::error::GetConfigurationSetErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetConfigurationSetError {
            meta: generic,
            kind: crate::error::GetConfigurationSetErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetConfigurationSetError {
            meta: generic,
            kind: crate::error::GetConfigurationSetErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetConfigurationSetError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetConfigurationSetError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_configuration_set_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConfigurationSetOutput,
    crate::error::GetConfigurationSetError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_configuration_set_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_configuration_set_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConfigurationSetError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_configuration_set_event_destinations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConfigurationSetEventDestinationsOutput,
    crate::error::GetConfigurationSetEventDestinationsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetConfigurationSetEventDestinationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetConfigurationSetEventDestinationsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetConfigurationSetEventDestinationsError {
            meta: generic,
            kind: crate::error::GetConfigurationSetEventDestinationsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetConfigurationSetEventDestinationsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetConfigurationSetEventDestinationsError {
            meta: generic,
            kind: crate::error::GetConfigurationSetEventDestinationsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::GetConfigurationSetEventDestinationsError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetConfigurationSetEventDestinationsError {
            meta: generic,
            kind: crate::error::GetConfigurationSetEventDestinationsErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetConfigurationSetEventDestinationsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::GetConfigurationSetEventDestinationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_configuration_set_event_destinations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetConfigurationSetEventDestinationsOutput,
    crate::error::GetConfigurationSetEventDestinationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_configuration_set_event_destinations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_configuration_set_event_destinations_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetConfigurationSetEventDestinationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_contact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetContactOutput, crate::error::GetContactError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetContactError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetContactError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetContactError {
            meta: generic,
            kind: crate::error::GetContactErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetContactError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetContactError {
            meta: generic,
            kind: crate::error::GetContactErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetContactError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetContactError {
            meta: generic,
            kind: crate::error::GetContactErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContactError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetContactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_contact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetContactOutput, crate::error::GetContactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_contact_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_contact_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::GetContactError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_contact_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetContactListOutput, crate::error::GetContactListError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetContactListError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetContactListError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetContactListError {
            meta: generic,
            kind: crate::error::GetContactListErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetContactListError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetContactListError {
            meta: generic,
            kind: crate::error::GetContactListErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetContactListError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetContactListError {
            meta: generic,
            kind: crate::error::GetContactListErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetContactListError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetContactListError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_contact_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetContactListOutput, crate::error::GetContactListError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_contact_list_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_contact_list_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetContactListError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCustomVerificationEmailTemplateOutput,
    crate::error::GetCustomVerificationEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCustomVerificationEmailTemplateError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::GetCustomVerificationEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::GetCustomVerificationEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::GetCustomVerificationEmailTemplateError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::GetCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::GetCustomVerificationEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCustomVerificationEmailTemplateOutput,
    crate::error::GetCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_custom_verification_email_template_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCustomVerificationEmailTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_dedicated_ip_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDedicatedIpOutput, crate::error::GetDedicatedIpError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDedicatedIpError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDedicatedIpError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDedicatedIpError {
            meta: generic,
            kind: crate::error::GetDedicatedIpErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDedicatedIpError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDedicatedIpError {
            meta: generic,
            kind: crate::error::GetDedicatedIpErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDedicatedIpError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDedicatedIpError {
            meta: generic,
            kind: crate::error::GetDedicatedIpErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDedicatedIpError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDedicatedIpError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_dedicated_ip_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDedicatedIpOutput, crate::error::GetDedicatedIpError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_dedicated_ip_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_dedicated_ip_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetDedicatedIpError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_dedicated_ips_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDedicatedIpsOutput, crate::error::GetDedicatedIpsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDedicatedIpsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDedicatedIpsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDedicatedIpsError {
            meta: generic,
            kind: crate::error::GetDedicatedIpsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDedicatedIpsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDedicatedIpsError {
            meta: generic,
            kind: crate::error::GetDedicatedIpsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDedicatedIpsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDedicatedIpsError {
            meta: generic,
            kind: crate::error::GetDedicatedIpsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDedicatedIpsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDedicatedIpsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_dedicated_ips_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDedicatedIpsOutput, crate::error::GetDedicatedIpsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_dedicated_ips_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_dedicated_ips_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetDedicatedIpsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deliverability_dashboard_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeliverabilityDashboardOptionsOutput,
    crate::error::GetDeliverabilityDashboardOptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeliverabilityDashboardOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDeliverabilityDashboardOptionsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDeliverabilityDashboardOptionsError {
            meta: generic,
            kind: crate::error::GetDeliverabilityDashboardOptionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDeliverabilityDashboardOptionsError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::GetDeliverabilityDashboardOptionsError {
            meta: generic,
            kind: crate::error::GetDeliverabilityDashboardOptionsErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::GetDeliverabilityDashboardOptionsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDeliverabilityDashboardOptionsError {
            meta: generic,
            kind: crate::error::GetDeliverabilityDashboardOptionsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDeliverabilityDashboardOptionsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDeliverabilityDashboardOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deliverability_dashboard_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeliverabilityDashboardOptionsOutput,
    crate::error::GetDeliverabilityDashboardOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_deliverability_dashboard_options_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_deliverability_dashboard_options_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeliverabilityDashboardOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deliverability_test_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeliverabilityTestReportOutput,
    crate::error::GetDeliverabilityTestReportError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDeliverabilityTestReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDeliverabilityTestReportError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDeliverabilityTestReportError {
            meta: generic,
            kind: crate::error::GetDeliverabilityTestReportErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDeliverabilityTestReportError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDeliverabilityTestReportError {
            meta: generic,
            kind: crate::error::GetDeliverabilityTestReportErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDeliverabilityTestReportError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDeliverabilityTestReportError {
            meta: generic,
            kind: crate::error::GetDeliverabilityTestReportErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDeliverabilityTestReportError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDeliverabilityTestReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_deliverability_test_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDeliverabilityTestReportOutput,
    crate::error::GetDeliverabilityTestReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_deliverability_test_report_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_deliverability_test_report_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDeliverabilityTestReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_deliverability_campaign_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDomainDeliverabilityCampaignOutput,
    crate::error::GetDomainDeliverabilityCampaignError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDomainDeliverabilityCampaignError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDomainDeliverabilityCampaignError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDomainDeliverabilityCampaignError {
            meta: generic,
            kind: crate::error::GetDomainDeliverabilityCampaignErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDomainDeliverabilityCampaignError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDomainDeliverabilityCampaignError {
            meta: generic,
            kind: crate::error::GetDomainDeliverabilityCampaignErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDomainDeliverabilityCampaignError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDomainDeliverabilityCampaignError {
            meta: generic,
            kind: crate::error::GetDomainDeliverabilityCampaignErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDomainDeliverabilityCampaignError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDomainDeliverabilityCampaignError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_deliverability_campaign_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDomainDeliverabilityCampaignOutput,
    crate::error::GetDomainDeliverabilityCampaignError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::get_domain_deliverability_campaign_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_domain_deliverability_campaign_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDomainDeliverabilityCampaignError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_statistics_report_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDomainStatisticsReportOutput,
    crate::error::GetDomainStatisticsReportError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetDomainStatisticsReportError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetDomainStatisticsReportError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetDomainStatisticsReportError {
            meta: generic,
            kind: crate::error::GetDomainStatisticsReportErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDomainStatisticsReportError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetDomainStatisticsReportError {
            meta: generic,
            kind: crate::error::GetDomainStatisticsReportErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetDomainStatisticsReportError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetDomainStatisticsReportError {
            meta: generic,
            kind: crate::error::GetDomainStatisticsReportErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetDomainStatisticsReportError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetDomainStatisticsReportError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_domain_statistics_report_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetDomainStatisticsReportOutput,
    crate::error::GetDomainStatisticsReportError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_domain_statistics_report_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_domain_statistics_report_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDomainStatisticsReportError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_email_identity_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetEmailIdentityOutput, crate::error::GetEmailIdentityError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetEmailIdentityError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetEmailIdentityError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetEmailIdentityError {
            meta: generic,
            kind: crate::error::GetEmailIdentityErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetEmailIdentityError {
            meta: generic,
            kind: crate::error::GetEmailIdentityErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetEmailIdentityError {
            meta: generic,
            kind: crate::error::GetEmailIdentityErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetEmailIdentityError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetEmailIdentityError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_email_identity_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetEmailIdentityOutput, crate::error::GetEmailIdentityError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_email_identity_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_email_identity_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetEmailIdentityError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_email_identity_policies_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetEmailIdentityPoliciesOutput,
    crate::error::GetEmailIdentityPoliciesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetEmailIdentityPoliciesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetEmailIdentityPoliciesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetEmailIdentityPoliciesError {
            meta: generic,
            kind: crate::error::GetEmailIdentityPoliciesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEmailIdentityPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetEmailIdentityPoliciesError {
            meta: generic,
            kind: crate::error::GetEmailIdentityPoliciesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEmailIdentityPoliciesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetEmailIdentityPoliciesError {
            meta: generic,
            kind: crate::error::GetEmailIdentityPoliciesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetEmailIdentityPoliciesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetEmailIdentityPoliciesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_email_identity_policies_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetEmailIdentityPoliciesOutput,
    crate::error::GetEmailIdentityPoliciesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_email_identity_policies_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_email_identity_policies_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetEmailIdentityPoliciesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetEmailTemplateOutput, crate::error::GetEmailTemplateError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetEmailTemplateError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetEmailTemplateError {
            meta: generic,
            kind: crate::error::GetEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetEmailTemplateError {
            meta: generic,
            kind: crate::error::GetEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetEmailTemplateError {
            meta: generic,
            kind: crate::error::GetEmailTemplateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetEmailTemplateOutput, crate::error::GetEmailTemplateError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_email_template_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_email_template_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetEmailTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_import_job_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetImportJobOutput, crate::error::GetImportJobError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetImportJobError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetImportJobError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetImportJobError {
            meta: generic,
            kind: crate::error::GetImportJobErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetImportJobError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetImportJobError {
            meta: generic,
            kind: crate::error::GetImportJobErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetImportJobError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetImportJobError {
            meta: generic,
            kind: crate::error::GetImportJobErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetImportJobError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetImportJobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_import_job_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetImportJobOutput, crate::error::GetImportJobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_import_job_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::get_import_job_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::GetImportJobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_suppressed_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSuppressedDestinationOutput,
    crate::error::GetSuppressedDestinationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::GetSuppressedDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetSuppressedDestinationError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::GetSuppressedDestinationError {
            meta: generic,
            kind: crate::error::GetSuppressedDestinationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::GetSuppressedDestinationError {
            meta: generic,
            kind: crate::error::GetSuppressedDestinationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::GetSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::GetSuppressedDestinationError {
            meta: generic,
            kind: crate::error::GetSuppressedDestinationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::GetSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::GetSuppressedDestinationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_suppressed_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetSuppressedDestinationOutput,
    crate::error::GetSuppressedDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_suppressed_destination_output::Builder::default();
        let _ = response;
        output = crate::json_deser::get_suppressed_destination_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetSuppressedDestinationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_configuration_sets_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConfigurationSetsOutput,
    crate::error::ListConfigurationSetsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListConfigurationSetsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListConfigurationSetsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListConfigurationSetsError {
            meta: generic,
            kind: crate::error::ListConfigurationSetsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListConfigurationSetsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListConfigurationSetsError {
            meta: generic,
            kind: crate::error::ListConfigurationSetsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListConfigurationSetsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListConfigurationSetsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_configuration_sets_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListConfigurationSetsOutput,
    crate::error::ListConfigurationSetsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_configuration_sets_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_configuration_sets_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListConfigurationSetsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_contact_lists_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListContactListsOutput, crate::error::ListContactListsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListContactListsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListContactListsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListContactListsError {
            meta: generic,
            kind: crate::error::ListContactListsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListContactListsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListContactListsError {
            meta: generic,
            kind: crate::error::ListContactListsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListContactListsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListContactListsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_contact_lists_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListContactListsOutput, crate::error::ListContactListsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_contact_lists_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::list_contact_lists_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::ListContactListsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_contacts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListContactsOutput, crate::error::ListContactsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListContactsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListContactsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListContactsError {
            meta: generic,
            kind: crate::error::ListContactsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListContactsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::ListContactsError {
            meta: generic,
            kind: crate::error::ListContactsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListContactsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListContactsError {
            meta: generic,
            kind: crate::error::ListContactsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListContactsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListContactsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_contacts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListContactsOutput, crate::error::ListContactsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_contacts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_contacts_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::ListContactsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_custom_verification_email_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCustomVerificationEmailTemplatesOutput,
    crate::error::ListCustomVerificationEmailTemplatesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListCustomVerificationEmailTemplatesError {
            meta: generic,
            kind: crate::error::ListCustomVerificationEmailTemplatesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListCustomVerificationEmailTemplatesError {
            meta: generic,
            kind: crate::error::ListCustomVerificationEmailTemplatesErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::ListCustomVerificationEmailTemplatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_custom_verification_email_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListCustomVerificationEmailTemplatesOutput,
    crate::error::ListCustomVerificationEmailTemplatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_custom_verification_email_templates_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_custom_verification_email_templates_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListCustomVerificationEmailTemplatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_dedicated_ip_pools_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDedicatedIpPoolsOutput,
    crate::error::ListDedicatedIpPoolsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDedicatedIpPoolsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListDedicatedIpPoolsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListDedicatedIpPoolsError {
            meta: generic,
            kind: crate::error::ListDedicatedIpPoolsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListDedicatedIpPoolsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListDedicatedIpPoolsError {
            meta: generic,
            kind: crate::error::ListDedicatedIpPoolsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDedicatedIpPoolsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListDedicatedIpPoolsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_dedicated_ip_pools_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDedicatedIpPoolsOutput,
    crate::error::ListDedicatedIpPoolsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_dedicated_ip_pools_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_dedicated_ip_pools_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDedicatedIpPoolsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_deliverability_test_reports_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeliverabilityTestReportsOutput,
    crate::error::ListDeliverabilityTestReportsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDeliverabilityTestReportsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDeliverabilityTestReportsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListDeliverabilityTestReportsError {
            meta: generic,
            kind: crate::error::ListDeliverabilityTestReportsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListDeliverabilityTestReportsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::ListDeliverabilityTestReportsError {
            meta: generic,
            kind: crate::error::ListDeliverabilityTestReportsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListDeliverabilityTestReportsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListDeliverabilityTestReportsError {
            meta: generic,
            kind: crate::error::ListDeliverabilityTestReportsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDeliverabilityTestReportsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListDeliverabilityTestReportsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_deliverability_test_reports_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDeliverabilityTestReportsOutput,
    crate::error::ListDeliverabilityTestReportsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_deliverability_test_reports_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_deliverability_test_reports_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDeliverabilityTestReportsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_domain_deliverability_campaigns_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDomainDeliverabilityCampaignsOutput,
    crate::error::ListDomainDeliverabilityCampaignsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListDomainDeliverabilityCampaignsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListDomainDeliverabilityCampaignsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListDomainDeliverabilityCampaignsError {
            meta: generic,
            kind: crate::error::ListDomainDeliverabilityCampaignsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListDomainDeliverabilityCampaignsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::ListDomainDeliverabilityCampaignsError {
            meta: generic,
            kind: crate::error::ListDomainDeliverabilityCampaignsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::not_found_exception(response.body().as_ref(), output)
                        .map_err(crate::error::ListDomainDeliverabilityCampaignsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListDomainDeliverabilityCampaignsError {
            meta: generic,
            kind: crate::error::ListDomainDeliverabilityCampaignsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListDomainDeliverabilityCampaignsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListDomainDeliverabilityCampaignsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_domain_deliverability_campaigns_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListDomainDeliverabilityCampaignsOutput,
    crate::error::ListDomainDeliverabilityCampaignsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_domain_deliverability_campaigns_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_domain_deliverability_campaigns_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListDomainDeliverabilityCampaignsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_email_identities_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEmailIdentitiesOutput,
    crate::error::ListEmailIdentitiesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListEmailIdentitiesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListEmailIdentitiesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListEmailIdentitiesError {
            meta: generic,
            kind: crate::error::ListEmailIdentitiesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListEmailIdentitiesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListEmailIdentitiesError {
            meta: generic,
            kind: crate::error::ListEmailIdentitiesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEmailIdentitiesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListEmailIdentitiesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_email_identities_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEmailIdentitiesOutput,
    crate::error::ListEmailIdentitiesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_email_identities_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_email_identities_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEmailIdentitiesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_email_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEmailTemplatesOutput,
    crate::error::ListEmailTemplatesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListEmailTemplatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListEmailTemplatesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListEmailTemplatesError {
            meta: generic,
            kind: crate::error::ListEmailTemplatesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListEmailTemplatesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListEmailTemplatesError {
            meta: generic,
            kind: crate::error::ListEmailTemplatesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListEmailTemplatesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListEmailTemplatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_email_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListEmailTemplatesOutput,
    crate::error::ListEmailTemplatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_email_templates_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_email_templates_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListEmailTemplatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_import_jobs_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImportJobsOutput, crate::error::ListImportJobsError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListImportJobsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListImportJobsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListImportJobsError {
            meta: generic,
            kind: crate::error::ListImportJobsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListImportJobsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListImportJobsError {
            meta: generic,
            kind: crate::error::ListImportJobsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListImportJobsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListImportJobsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_import_jobs_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListImportJobsOutput, crate::error::ListImportJobsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_import_jobs_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::list_import_jobs_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::ListImportJobsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_suppressed_destinations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSuppressedDestinationsOutput,
    crate::error::ListSuppressedDestinationsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListSuppressedDestinationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListSuppressedDestinationsError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListSuppressedDestinationsError {
            meta: generic,
            kind: crate::error::ListSuppressedDestinationsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListSuppressedDestinationsError::unhandled)?;
                output.build()
            }),
        },
        "InvalidNextTokenException" => crate::error::ListSuppressedDestinationsError {
            meta: generic,
            kind: crate::error::ListSuppressedDestinationsErrorKind::InvalidNextTokenError({
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_next_token_error::Builder::default();
                let _ = response;
                output = crate::json_deser::invalid_next_token_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSuppressedDestinationsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListSuppressedDestinationsError {
            meta: generic,
            kind: crate::error::ListSuppressedDestinationsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListSuppressedDestinationsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListSuppressedDestinationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_suppressed_destinations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListSuppressedDestinationsOutput,
    crate::error::ListSuppressedDestinationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_suppressed_destinations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_suppressed_destinations_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListSuppressedDestinationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::ListTagsForResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::list_tags_for_resource_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_dedicated_ip_warmup_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAccountDedicatedIpWarmupAttributesOutput,
    crate::error::PutAccountDedicatedIpWarmupAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutAccountDedicatedIpWarmupAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::PutAccountDedicatedIpWarmupAttributesError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutAccountDedicatedIpWarmupAttributesError {
            meta: generic,
            kind: crate::error::PutAccountDedicatedIpWarmupAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutAccountDedicatedIpWarmupAttributesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutAccountDedicatedIpWarmupAttributesError {
            meta: generic,
            kind:
                crate::error::PutAccountDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::PutAccountDedicatedIpWarmupAttributesError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::PutAccountDedicatedIpWarmupAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_dedicated_ip_warmup_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAccountDedicatedIpWarmupAttributesOutput,
    crate::error::PutAccountDedicatedIpWarmupAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_account_dedicated_ip_warmup_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_details_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutAccountDetailsOutput, crate::error::PutAccountDetailsError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutAccountDetailsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutAccountDetailsError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutAccountDetailsError {
            meta: generic,
            kind: crate::error::PutAccountDetailsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutAccountDetailsError::unhandled)?;
                output.build()
            }),
        },
        "ConflictException" => crate::error::PutAccountDetailsError {
            meta: generic,
            kind: crate::error::PutAccountDetailsErrorKind::ConflictError({
                #[allow(unused_mut)]
                let mut output = crate::error::conflict_error::Builder::default();
                let _ = response;
                output = crate::json_deser::conflict_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutAccountDetailsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutAccountDetailsError {
            meta: generic,
            kind: crate::error::PutAccountDetailsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutAccountDetailsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutAccountDetailsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_details_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutAccountDetailsOutput, crate::error::PutAccountDetailsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_account_details_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_sending_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAccountSendingAttributesOutput,
    crate::error::PutAccountSendingAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutAccountSendingAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutAccountSendingAttributesError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutAccountSendingAttributesError {
            meta: generic,
            kind: crate::error::PutAccountSendingAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutAccountSendingAttributesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutAccountSendingAttributesError {
            meta: generic,
            kind: crate::error::PutAccountSendingAttributesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutAccountSendingAttributesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutAccountSendingAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_sending_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAccountSendingAttributesOutput,
    crate::error::PutAccountSendingAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_account_sending_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_suppression_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAccountSuppressionAttributesOutput,
    crate::error::PutAccountSuppressionAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutAccountSuppressionAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutAccountSuppressionAttributesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutAccountSuppressionAttributesError {
            meta: generic,
            kind: crate::error::PutAccountSuppressionAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutAccountSuppressionAttributesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutAccountSuppressionAttributesError {
            meta: generic,
            kind: crate::error::PutAccountSuppressionAttributesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutAccountSuppressionAttributesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutAccountSuppressionAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_account_suppression_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutAccountSuppressionAttributesOutput,
    crate::error::PutAccountSuppressionAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_account_suppression_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_delivery_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetDeliveryOptionsOutput,
    crate::error::PutConfigurationSetDeliveryOptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutConfigurationSetDeliveryOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetDeliveryOptionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutConfigurationSetDeliveryOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetDeliveryOptionsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutConfigurationSetDeliveryOptionsError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutConfigurationSetDeliveryOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetDeliveryOptionsErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutConfigurationSetDeliveryOptionsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::PutConfigurationSetDeliveryOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_delivery_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetDeliveryOptionsOutput,
    crate::error::PutConfigurationSetDeliveryOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_configuration_set_delivery_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_reputation_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetReputationOptionsOutput,
    crate::error::PutConfigurationSetReputationOptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutConfigurationSetReputationOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationSetReputationOptionsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutConfigurationSetReputationOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetReputationOptionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutConfigurationSetReputationOptionsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutConfigurationSetReputationOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetReputationOptionsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutConfigurationSetReputationOptionsError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutConfigurationSetReputationOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetReputationOptionsErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutConfigurationSetReputationOptionsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::PutConfigurationSetReputationOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_reputation_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetReputationOptionsOutput,
    crate::error::PutConfigurationSetReputationOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_configuration_set_reputation_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_sending_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetSendingOptionsOutput,
    crate::error::PutConfigurationSetSendingOptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutConfigurationSetSendingOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationSetSendingOptionsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutConfigurationSetSendingOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetSendingOptionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutConfigurationSetSendingOptionsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutConfigurationSetSendingOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetSendingOptionsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::not_found_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutConfigurationSetSendingOptionsError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutConfigurationSetSendingOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetSendingOptionsErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutConfigurationSetSendingOptionsError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutConfigurationSetSendingOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_sending_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetSendingOptionsOutput,
    crate::error::PutConfigurationSetSendingOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_configuration_set_sending_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_suppression_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetSuppressionOptionsOutput,
    crate::error::PutConfigurationSetSuppressionOptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutConfigurationSetSuppressionOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::PutConfigurationSetSuppressionOptionsError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutConfigurationSetSuppressionOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetSuppressionOptionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutConfigurationSetSuppressionOptionsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutConfigurationSetSuppressionOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetSuppressionOptionsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutConfigurationSetSuppressionOptionsError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutConfigurationSetSuppressionOptionsError {
            meta: generic,
            kind:
                crate::error::PutConfigurationSetSuppressionOptionsErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::PutConfigurationSetSuppressionOptionsError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::PutConfigurationSetSuppressionOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_suppression_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetSuppressionOptionsOutput,
    crate::error::PutConfigurationSetSuppressionOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_configuration_set_suppression_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_tracking_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetTrackingOptionsOutput,
    crate::error::PutConfigurationSetTrackingOptionsError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutConfigurationSetTrackingOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutConfigurationSetTrackingOptionsError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutConfigurationSetTrackingOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetTrackingOptionsErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutConfigurationSetTrackingOptionsError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutConfigurationSetTrackingOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetTrackingOptionsErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutConfigurationSetTrackingOptionsError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutConfigurationSetTrackingOptionsError {
            meta: generic,
            kind: crate::error::PutConfigurationSetTrackingOptionsErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutConfigurationSetTrackingOptionsError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::PutConfigurationSetTrackingOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_configuration_set_tracking_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutConfigurationSetTrackingOptionsOutput,
    crate::error::PutConfigurationSetTrackingOptionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_configuration_set_tracking_options_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_dedicated_ip_in_pool_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDedicatedIpInPoolOutput,
    crate::error::PutDedicatedIpInPoolError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutDedicatedIpInPoolError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutDedicatedIpInPoolError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutDedicatedIpInPoolError {
            meta: generic,
            kind: crate::error::PutDedicatedIpInPoolErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutDedicatedIpInPoolError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutDedicatedIpInPoolError {
            meta: generic,
            kind: crate::error::PutDedicatedIpInPoolErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutDedicatedIpInPoolError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutDedicatedIpInPoolError {
            meta: generic,
            kind: crate::error::PutDedicatedIpInPoolErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutDedicatedIpInPoolError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutDedicatedIpInPoolError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_dedicated_ip_in_pool_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDedicatedIpInPoolOutput,
    crate::error::PutDedicatedIpInPoolError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_dedicated_ip_in_pool_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_dedicated_ip_warmup_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDedicatedIpWarmupAttributesOutput,
    crate::error::PutDedicatedIpWarmupAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutDedicatedIpWarmupAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutDedicatedIpWarmupAttributesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutDedicatedIpWarmupAttributesError {
            meta: generic,
            kind: crate::error::PutDedicatedIpWarmupAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutDedicatedIpWarmupAttributesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutDedicatedIpWarmupAttributesError {
            meta: generic,
            kind: crate::error::PutDedicatedIpWarmupAttributesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutDedicatedIpWarmupAttributesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutDedicatedIpWarmupAttributesError {
            meta: generic,
            kind: crate::error::PutDedicatedIpWarmupAttributesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutDedicatedIpWarmupAttributesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutDedicatedIpWarmupAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_dedicated_ip_warmup_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDedicatedIpWarmupAttributesOutput,
    crate::error::PutDedicatedIpWarmupAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_dedicated_ip_warmup_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_deliverability_dashboard_option_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDeliverabilityDashboardOptionOutput,
    crate::error::PutDeliverabilityDashboardOptionError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutDeliverabilityDashboardOptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutDeliverabilityDashboardOptionError::unhandled(generic))
        }
    };
    Err(match error_code {
        "AlreadyExistsException" => crate::error::PutDeliverabilityDashboardOptionError {
            meta: generic,
            kind: crate::error::PutDeliverabilityDashboardOptionErrorKind::AlreadyExistsError({
                #[allow(unused_mut)]
                let mut output = crate::error::already_exists_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::already_exists_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutDeliverabilityDashboardOptionError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::PutDeliverabilityDashboardOptionError {
            meta: generic,
            kind: crate::error::PutDeliverabilityDashboardOptionErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutDeliverabilityDashboardOptionError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::PutDeliverabilityDashboardOptionError {
            meta: generic,
            kind: crate::error::PutDeliverabilityDashboardOptionErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::PutDeliverabilityDashboardOptionError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutDeliverabilityDashboardOptionError {
            meta: generic,
            kind: crate::error::PutDeliverabilityDashboardOptionErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutDeliverabilityDashboardOptionError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutDeliverabilityDashboardOptionError {
            meta: generic,
            kind: crate::error::PutDeliverabilityDashboardOptionErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutDeliverabilityDashboardOptionError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutDeliverabilityDashboardOptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_deliverability_dashboard_option_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutDeliverabilityDashboardOptionOutput,
    crate::error::PutDeliverabilityDashboardOptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_deliverability_dashboard_option_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_configuration_set_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityConfigurationSetAttributesOutput,
    crate::error::PutEmailIdentityConfigurationSetAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutEmailIdentityConfigurationSetAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::PutEmailIdentityConfigurationSetAttributesError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutEmailIdentityConfigurationSetAttributesError { meta: generic, kind: crate::error::PutEmailIdentityConfigurationSetAttributesErrorKind::BadRequestError({
            #[allow(unused_mut)]let mut output = crate::error::bad_request_error::Builder::default();
            let _ = response;
            output = crate::json_deser::bad_request_exception(response.body().as_ref(), output).map_err(crate::error::PutEmailIdentityConfigurationSetAttributesError::unhandled)?;
            output.build()
        })},
        "NotFoundException" => crate::error::PutEmailIdentityConfigurationSetAttributesError { meta: generic, kind: crate::error::PutEmailIdentityConfigurationSetAttributesErrorKind::NotFoundError({
            #[allow(unused_mut)]let mut output = crate::error::not_found_error::Builder::default();
            let _ = response;
            output = crate::json_deser::not_found_exception(response.body().as_ref(), output).map_err(crate::error::PutEmailIdentityConfigurationSetAttributesError::unhandled)?;
            output.build()
        })},
        "TooManyRequestsException" => crate::error::PutEmailIdentityConfigurationSetAttributesError { meta: generic, kind: crate::error::PutEmailIdentityConfigurationSetAttributesErrorKind::TooManyRequestsError({
            #[allow(unused_mut)]let mut output = crate::error::too_many_requests_error::Builder::default();
            let _ = response;
            output = crate::json_deser::too_many_requests_exception(response.body().as_ref(), output).map_err(crate::error::PutEmailIdentityConfigurationSetAttributesError::unhandled)?;
            output.build()
        })},
        _ => crate::error::PutEmailIdentityConfigurationSetAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_configuration_set_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityConfigurationSetAttributesOutput,
    crate::error::PutEmailIdentityConfigurationSetAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_email_identity_configuration_set_attributes_output::Builder::default(
            );
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_dkim_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityDkimAttributesOutput,
    crate::error::PutEmailIdentityDkimAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutEmailIdentityDkimAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutEmailIdentityDkimAttributesError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutEmailIdentityDkimAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityDkimAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutEmailIdentityDkimAttributesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutEmailIdentityDkimAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityDkimAttributesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutEmailIdentityDkimAttributesError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutEmailIdentityDkimAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityDkimAttributesErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutEmailIdentityDkimAttributesError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutEmailIdentityDkimAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_dkim_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityDkimAttributesOutput,
    crate::error::PutEmailIdentityDkimAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_email_identity_dkim_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_dkim_signing_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityDkimSigningAttributesOutput,
    crate::error::PutEmailIdentityDkimSigningAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutEmailIdentityDkimSigningAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::PutEmailIdentityDkimSigningAttributesError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutEmailIdentityDkimSigningAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityDkimSigningAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutEmailIdentityDkimSigningAttributesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutEmailIdentityDkimSigningAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityDkimSigningAttributesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutEmailIdentityDkimSigningAttributesError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutEmailIdentityDkimSigningAttributesError {
            meta: generic,
            kind:
                crate::error::PutEmailIdentityDkimSigningAttributesErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::PutEmailIdentityDkimSigningAttributesError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::PutEmailIdentityDkimSigningAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_dkim_signing_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityDkimSigningAttributesOutput,
    crate::error::PutEmailIdentityDkimSigningAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_email_identity_dkim_signing_attributes_output::Builder::default();
        let _ = response;
        output = crate::json_deser::put_email_identity_dkim_signing_attributes_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutEmailIdentityDkimSigningAttributesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_feedback_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityFeedbackAttributesOutput,
    crate::error::PutEmailIdentityFeedbackAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutEmailIdentityFeedbackAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutEmailIdentityFeedbackAttributesError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutEmailIdentityFeedbackAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityFeedbackAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutEmailIdentityFeedbackAttributesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutEmailIdentityFeedbackAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityFeedbackAttributesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutEmailIdentityFeedbackAttributesError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutEmailIdentityFeedbackAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityFeedbackAttributesErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutEmailIdentityFeedbackAttributesError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::PutEmailIdentityFeedbackAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_feedback_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityFeedbackAttributesOutput,
    crate::error::PutEmailIdentityFeedbackAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_email_identity_feedback_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_mail_from_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityMailFromAttributesOutput,
    crate::error::PutEmailIdentityMailFromAttributesError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutEmailIdentityMailFromAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutEmailIdentityMailFromAttributesError::unhandled(generic))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutEmailIdentityMailFromAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityMailFromAttributesErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutEmailIdentityMailFromAttributesError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::PutEmailIdentityMailFromAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityMailFromAttributesErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::PutEmailIdentityMailFromAttributesError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutEmailIdentityMailFromAttributesError {
            meta: generic,
            kind: crate::error::PutEmailIdentityMailFromAttributesErrorKind::TooManyRequestsError(
                {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_requests_error::Builder::default();
                    let _ = response;
                    output = crate::json_deser::too_many_requests_exception(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutEmailIdentityMailFromAttributesError::unhandled)?;
                    output.build()
                },
            ),
        },
        _ => crate::error::PutEmailIdentityMailFromAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_email_identity_mail_from_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutEmailIdentityMailFromAttributesOutput,
    crate::error::PutEmailIdentityMailFromAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::put_email_identity_mail_from_attributes_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_suppressed_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutSuppressedDestinationOutput,
    crate::error::PutSuppressedDestinationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::PutSuppressedDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PutSuppressedDestinationError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::PutSuppressedDestinationError {
            meta: generic,
            kind: crate::error::PutSuppressedDestinationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::PutSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::PutSuppressedDestinationError {
            meta: generic,
            kind: crate::error::PutSuppressedDestinationErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::PutSuppressedDestinationError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::PutSuppressedDestinationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_suppressed_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutSuppressedDestinationOutput,
    crate::error::PutSuppressedDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_suppressed_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_bulk_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendBulkEmailOutput, crate::error::SendBulkEmailError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::SendBulkEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendBulkEmailError::unhandled(generic)),
    };
    Err(match error_code {
        "AccountSuspendedException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::AccountSuspendedError({
                #[allow(unused_mut)]
                let mut output = crate::error::account_suspended_error::Builder::default();
                let _ = response;
                output = crate::json_deser::account_suspended_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "MailFromDomainNotVerifiedException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::MailFromDomainNotVerifiedError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::mail_from_domain_not_verified_error::Builder::default();
                let _ = response;
                output = crate::json_deser::mail_from_domain_not_verified_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "MessageRejected" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut output = crate::error::message_rejected::Builder::default();
                let _ = response;
                output = crate::json_deser::message_rejected(response.body().as_ref(), output)
                    .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "SendingPausedException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::SendingPausedError({
                #[allow(unused_mut)]
                let mut output = crate::error::sending_paused_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::sending_paused_exception(response.body().as_ref(), output)
                        .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::SendBulkEmailError {
            meta: generic,
            kind: crate::error::SendBulkEmailErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendBulkEmailError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SendBulkEmailError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_bulk_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendBulkEmailOutput, crate::error::SendBulkEmailError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_bulk_email_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::send_bulk_email_deser_operation(response.body().as_ref(), output)
                .map_err(crate::error::SendBulkEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_custom_verification_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendCustomVerificationEmailOutput,
    crate::error::SendCustomVerificationEmailError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::SendCustomVerificationEmailError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind: crate::error::SendCustomVerificationEmailErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind: crate::error::SendCustomVerificationEmailErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                output.build()
            }),
        },
        "MailFromDomainNotVerifiedException" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind:
                crate::error::SendCustomVerificationEmailErrorKind::MailFromDomainNotVerifiedError(
                    {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::mail_from_domain_not_verified_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::mail_from_domain_not_verified_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                        output.build()
                    },
                ),
        },
        "MessageRejected" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind: crate::error::SendCustomVerificationEmailErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut output = crate::error::message_rejected::Builder::default();
                let _ = response;
                output = crate::json_deser::message_rejected(response.body().as_ref(), output)
                    .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind: crate::error::SendCustomVerificationEmailErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                output.build()
            }),
        },
        "SendingPausedException" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind: crate::error::SendCustomVerificationEmailErrorKind::SendingPausedError({
                #[allow(unused_mut)]
                let mut output = crate::error::sending_paused_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::sending_paused_exception(response.body().as_ref(), output)
                        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::SendCustomVerificationEmailError {
            meta: generic,
            kind: crate::error::SendCustomVerificationEmailErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SendCustomVerificationEmailError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_custom_verification_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::SendCustomVerificationEmailOutput,
    crate::error::SendCustomVerificationEmailError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_custom_verification_email_output::Builder::default();
        let _ = response;
        output = crate::json_deser::send_custom_verification_email_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::SendCustomVerificationEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_email_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendEmailOutput, crate::error::SendEmailError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::SendEmailError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::SendEmailError::unhandled(generic)),
    };
    Err(match error_code {
        "AccountSuspendedException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::AccountSuspendedError({
                #[allow(unused_mut)]
                let mut output = crate::error::account_suspended_error::Builder::default();
                let _ = response;
                output = crate::json_deser::account_suspended_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "BadRequestException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "LimitExceededException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::LimitExceededError({
                #[allow(unused_mut)]
                let mut output = crate::error::limit_exceeded_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::limit_exceeded_exception(response.body().as_ref(), output)
                        .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "MailFromDomainNotVerifiedException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::MailFromDomainNotVerifiedError({
                #[allow(unused_mut)]
                let mut output =
                    crate::error::mail_from_domain_not_verified_error::Builder::default();
                let _ = response;
                output = crate::json_deser::mail_from_domain_not_verified_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "MessageRejected" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::MessageRejected({
                #[allow(unused_mut)]
                let mut output = crate::error::message_rejected::Builder::default();
                let _ = response;
                output = crate::json_deser::message_rejected(response.body().as_ref(), output)
                    .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "SendingPausedException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::SendingPausedError({
                #[allow(unused_mut)]
                let mut output = crate::error::sending_paused_error::Builder::default();
                let _ = response;
                output =
                    crate::json_deser::sending_paused_exception(response.body().as_ref(), output)
                        .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::SendEmailError {
            meta: generic,
            kind: crate::error::SendEmailErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::SendEmailError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::SendEmailError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_send_email_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::SendEmailOutput, crate::error::SendEmailError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::send_email_output::Builder::default();
        let _ = response;
        output = crate::json_deser::send_email_deser_operation(response.body().as_ref(), output)
            .map_err(crate::error::SendEmailError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TagResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_render_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRenderEmailTemplateOutput,
    crate::error::TestRenderEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::TestRenderEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::TestRenderEmailTemplateError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::TestRenderEmailTemplateError {
            meta: generic,
            kind: crate::error::TestRenderEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TestRenderEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::TestRenderEmailTemplateError {
            meta: generic,
            kind: crate::error::TestRenderEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::TestRenderEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::TestRenderEmailTemplateError {
            meta: generic,
            kind: crate::error::TestRenderEmailTemplateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::TestRenderEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::TestRenderEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_render_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRenderEmailTemplateOutput,
    crate::error::TestRenderEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_render_email_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::test_render_email_template_deser_operation(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestRenderEmailTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UntagResourceError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_event_destination_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetEventDestinationOutput,
    crate::error::UpdateConfigurationSetEventDestinationError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateConfigurationSetEventDestinationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateConfigurationSetEventDestinationError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(
                        crate::error::UpdateConfigurationSetEventDestinationError::unhandled,
                    )?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateConfigurationSetEventDestinationError {
            meta: generic,
            kind: crate::error::UpdateConfigurationSetEventDestinationErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::UpdateConfigurationSetEventDestinationError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateConfigurationSetEventDestinationError {
            meta: generic,
            kind:
                crate::error::UpdateConfigurationSetEventDestinationErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::UpdateConfigurationSetEventDestinationError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::UpdateConfigurationSetEventDestinationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_configuration_set_event_destination_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateConfigurationSetEventDestinationOutput,
    crate::error::UpdateConfigurationSetEventDestinationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_configuration_set_event_destination_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_contact_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateContactOutput, crate::error::UpdateContactError> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateContactError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateContactError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateContactError {
            meta: generic,
            kind: crate::error::UpdateContactErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateContactError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::UpdateContactError {
            meta: generic,
            kind: crate::error::UpdateContactErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateContactError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateContactError {
            meta: generic,
            kind: crate::error::UpdateContactErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateContactError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateContactError {
            meta: generic,
            kind: crate::error::UpdateContactErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateContactError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateContactError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_contact_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateContactOutput, crate::error::UpdateContactError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_contact_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_contact_list_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateContactListOutput, crate::error::UpdateContactListError>
{
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateContactListError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateContactListError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateContactListError {
            meta: generic,
            kind: crate::error::UpdateContactListErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateContactListError::unhandled)?;
                output.build()
            }),
        },
        "ConcurrentModificationException" => crate::error::UpdateContactListError {
            meta: generic,
            kind: crate::error::UpdateContactListErrorKind::ConcurrentModificationError({
                #[allow(unused_mut)]
                let mut output = crate::error::concurrent_modification_error::Builder::default();
                let _ = response;
                output = crate::json_deser::concurrent_modification_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateContactListError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateContactListError {
            meta: generic,
            kind: crate::error::UpdateContactListErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateContactListError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateContactListError {
            meta: generic,
            kind: crate::error::UpdateContactListErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateContactListError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateContactListError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_contact_list_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateContactListOutput, crate::error::UpdateContactListError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_contact_list_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_custom_verification_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCustomVerificationEmailTemplateOutput,
    crate::error::UpdateCustomVerificationEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateCustomVerificationEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateCustomVerificationEmailTemplateError::unhandled(generic),
            )
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::UpdateCustomVerificationEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateCustomVerificationEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateCustomVerificationEmailTemplateError {
            meta: generic,
            kind: crate::error::UpdateCustomVerificationEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(
                    crate::error::UpdateCustomVerificationEmailTemplateError::unhandled,
                )?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateCustomVerificationEmailTemplateError {
            meta: generic,
            kind:
                crate::error::UpdateCustomVerificationEmailTemplateErrorKind::TooManyRequestsError(
                    {
                        #[allow(unused_mut)]
                        let mut output = crate::error::too_many_requests_error::Builder::default();
                        let _ = response;
                        output = crate::json_deser::too_many_requests_exception(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(
                            crate::error::UpdateCustomVerificationEmailTemplateError::unhandled,
                        )?;
                        output.build()
                    },
                ),
        },
        _ => crate::error::UpdateCustomVerificationEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_custom_verification_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateCustomVerificationEmailTemplateOutput,
    crate::error::UpdateCustomVerificationEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_custom_verification_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_email_identity_policy_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateEmailIdentityPolicyOutput,
    crate::error::UpdateEmailIdentityPolicyError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateEmailIdentityPolicyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateEmailIdentityPolicyError::unhandled(
                generic,
            ))
        }
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::UpdateEmailIdentityPolicyErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::UpdateEmailIdentityPolicyErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateEmailIdentityPolicyError {
            meta: generic,
            kind: crate::error::UpdateEmailIdentityPolicyErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateEmailIdentityPolicyError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateEmailIdentityPolicyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_email_identity_policy_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateEmailIdentityPolicyOutput,
    crate::error::UpdateEmailIdentityPolicyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_email_identity_policy_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_email_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateEmailTemplateOutput,
    crate::error::UpdateEmailTemplateError,
> {
    let generic = crate::json_deser::parse_generic_error(&response)
        .map_err(crate::error::UpdateEmailTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateEmailTemplateError::unhandled(generic)),
    };
    Err(match error_code {
        "BadRequestException" => crate::error::UpdateEmailTemplateError {
            meta: generic,
            kind: crate::error::UpdateEmailTemplateErrorKind::BadRequestError({
                #[allow(unused_mut)]
                let mut output = crate::error::bad_request_error::Builder::default();
                let _ = response;
                output = crate::json_deser::bad_request_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "NotFoundException" => crate::error::UpdateEmailTemplateError {
            meta: generic,
            kind: crate::error::UpdateEmailTemplateErrorKind::NotFoundError({
                #[allow(unused_mut)]
                let mut output = crate::error::not_found_error::Builder::default();
                let _ = response;
                output = crate::json_deser::not_found_exception(response.body().as_ref(), output)
                    .map_err(crate::error::UpdateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        "TooManyRequestsException" => crate::error::UpdateEmailTemplateError {
            meta: generic,
            kind: crate::error::UpdateEmailTemplateErrorKind::TooManyRequestsError({
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_requests_error::Builder::default();
                let _ = response;
                output = crate::json_deser::too_many_requests_exception(
                    response.body().as_ref(),
                    output,
                )
                .map_err(crate::error::UpdateEmailTemplateError::unhandled)?;
                output.build()
            }),
        },
        _ => crate::error::UpdateEmailTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_email_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateEmailTemplateOutput,
    crate::error::UpdateEmailTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_email_template_output::Builder::default();
        let _ = response;
        output.build()
    })
}
