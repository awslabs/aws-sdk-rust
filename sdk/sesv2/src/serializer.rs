// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>A request to create a configuration set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateConfigurationSetInputBody<'a> {
    /// <p>The name of the configuration set.</p>
    pub configuration_set_name: &'a std::option::Option<std::string::String>,
    /// <p>An object that defines the open and click tracking options for emails that you send
    /// using the configuration set.</p>
    pub tracking_options: &'a std::option::Option<crate::model::TrackingOptions>,
    /// <p>An object that defines the dedicated IP pool that is used to send emails that you send
    /// using the configuration set.</p>
    pub delivery_options: &'a std::option::Option<crate::model::DeliveryOptions>,
    /// <p>An object that defines whether or not Amazon SES collects reputation metrics for the emails
    /// that you send that use the configuration set.</p>
    pub reputation_options: &'a std::option::Option<crate::model::ReputationOptions>,
    /// <p>An object that defines whether or not Amazon SES can send email that you send using the
    /// configuration set.</p>
    pub sending_options: &'a std::option::Option<crate::model::SendingOptions>,
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    /// with the configuration set.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An object that contains information about the suppression list preferences for your
    /// account.</p>
    pub suppression_options: &'a std::option::Option<crate::model::SuppressionOptions>,
}
impl<'a> std::fmt::Debug for CreateConfigurationSetInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateConfigurationSetInputBody");
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.field("tracking_options", &self.tracking_options);
        formatter.field("delivery_options", &self.delivery_options);
        formatter.field("reputation_options", &self.reputation_options);
        formatter.field("sending_options", &self.sending_options);
        formatter.field("tags", &self.tags);
        formatter.field("suppression_options", &self.suppression_options);
        formatter.finish()
    }
}

/// <p>A request to add an event destination to a configuration set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateConfigurationSetEventDestinationInputBody<'a> {
    /// <p>A name that identifies the event destination within the configuration set.</p>
    pub event_destination_name: &'a std::option::Option<std::string::String>,
    /// <p>An object that defines the event destination.</p>
    pub event_destination: &'a std::option::Option<crate::model::EventDestinationDefinition>,
}
impl<'a> std::fmt::Debug for CreateConfigurationSetEventDestinationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateConfigurationSetEventDestinationInputBody");
        formatter.field("event_destination_name", &self.event_destination_name);
        formatter.field("event_destination", &self.event_destination);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContactInputBody<'a> {
    /// <p>The contact's email address.</p>
    pub email_address: &'a std::option::Option<std::string::String>,
    /// <p>The contact's preferences for being opted-in to or opted-out of topics.</p>
    pub topic_preferences: &'a std::option::Option<std::vec::Vec<crate::model::TopicPreference>>,
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    /// topics.</p>
    pub unsubscribe_all: &'a bool,
    /// <p>The attribute data attached to a contact.</p>
    pub attributes_data: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateContactInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContactInputBody");
        formatter.field("email_address", &self.email_address);
        formatter.field("topic_preferences", &self.topic_preferences);
        formatter.field("unsubscribe_all", &self.unsubscribe_all);
        formatter.field("attributes_data", &self.attributes_data);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateContactListInputBody<'a> {
    /// <p>The name of the contact list.</p>
    pub contact_list_name: &'a std::option::Option<std::string::String>,
    /// <p>An interest group, theme, or label within a list. A contact list can have multiple
    /// topics.</p>
    pub topics: &'a std::option::Option<std::vec::Vec<crate::model::Topic>>,
    /// <p>A description of what the contact list is about.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>The tags associated with a contact list.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateContactListInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateContactListInputBody");
        formatter.field("contact_list_name", &self.contact_list_name);
        formatter.field("topics", &self.topics);
        formatter.field("description", &self.description);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>Represents a request to create a custom verification email template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateCustomVerificationEmailTemplateInputBody<'a> {
    /// <p>The name of the custom verification email template.</p>
    pub template_name: &'a std::option::Option<std::string::String>,
    /// <p>The email address that the custom verification email is sent from.</p>
    pub from_email_address: &'a std::option::Option<std::string::String>,
    /// <p>The subject line of the custom verification email.</p>
    pub template_subject: &'a std::option::Option<std::string::String>,
    /// <p>The content of the custom verification email. The total size of the email must be less
    /// than 10 MB. The message body may contain HTML, with some limitations. For more
    /// information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
    /// Developer Guide</i>.</p>
    pub template_content: &'a std::option::Option<std::string::String>,
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    /// is successfully verified.</p>
    pub success_redirection_url: &'a std::option::Option<std::string::String>,
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    /// is not successfully verified.</p>
    pub failure_redirection_url: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateCustomVerificationEmailTemplateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateCustomVerificationEmailTemplateInputBody");
        formatter.field("template_name", &self.template_name);
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field("template_subject", &self.template_subject);
        formatter.field("template_content", &self.template_content);
        formatter.field("success_redirection_url", &self.success_redirection_url);
        formatter.field("failure_redirection_url", &self.failure_redirection_url);
        formatter.finish()
    }
}

/// <p>A request to create a new dedicated IP pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDedicatedIpPoolInputBody<'a> {
    /// <p>The name of the dedicated IP pool.</p>
    pub pool_name: &'a std::option::Option<std::string::String>,
    /// <p>An object that defines the tags (keys and values) that you want to associate with the
    /// pool.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateDedicatedIpPoolInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDedicatedIpPoolInputBody");
        formatter.field("pool_name", &self.pool_name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>A request to perform a predictive inbox placement test. Predictive inbox placement tests can help you predict how your messages will
/// be handled by various email providers around the world. When you perform a predictive inbox placement test, you
/// provide a sample message that contains the content that you plan to send to your
/// customers. We send that message to special email addresses spread across several major
/// email providers around the world. The test takes about 24 hours to complete. When the
/// test is complete, you can use the <code>GetDeliverabilityTestReport</code> operation to
/// view the results of the test.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDeliverabilityTestReportInputBody<'a> {
    /// <p>A unique name that helps you to identify the predictive inbox placement test when you retrieve the
    /// results.</p>
    pub report_name: &'a std::option::Option<std::string::String>,
    /// <p>The email address that the predictive inbox placement test email was sent from.</p>
    pub from_email_address: &'a std::option::Option<std::string::String>,
    /// <p>The HTML body of the message that you sent when you performed the predictive inbox placement test.</p>
    pub content: &'a std::option::Option<crate::model::EmailContent>,
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    /// with the predictive inbox placement test.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for CreateDeliverabilityTestReportInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDeliverabilityTestReportInputBody");
        formatter.field("report_name", &self.report_name);
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field("content", &self.content);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>A request to begin the verification process for an email identity (an email address or
/// domain).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEmailIdentityInputBody<'a> {
    /// <p>The email address or domain that you want to verify.</p>
    pub email_identity: &'a std::option::Option<std::string::String>,
    /// <p>An array of objects that define the tags (keys and values) that you want to associate
    /// with the email identity.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>If your request includes this object, Amazon SES configures the identity to use Bring Your
    /// Own DKIM (BYODKIM) for DKIM authentication purposes, as opposed to the default method,
    /// <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy
    /// DKIM</a>.</p>
    /// <p>You can only specify this object if the email identity is a domain, as opposed to an
    /// address.</p>
    pub dkim_signing_attributes: &'a std::option::Option<crate::model::DkimSigningAttributes>,
    /// <p>The configuration set to use by default when sending from this identity.
    /// Note that any configuration set defined in the email sending request takes precedence.
    /// </p>
    pub configuration_set_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateEmailIdentityInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEmailIdentityInputBody");
        formatter.field("email_identity", &self.email_identity);
        formatter.field("tags", &self.tags);
        formatter.field("dkim_signing_attributes", &self.dkim_signing_attributes);
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.finish()
    }
}

/// <p>Represents a request to create a sending authorization policy for an identity. Sending
/// authorization is an Amazon SES feature that enables you to authorize other senders to use
/// your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-identity-owner-tasks-management.html">Amazon SES Developer Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEmailIdentityPolicyInputBody<'a> {
    /// <p>The text of the policy in JSON format. The policy cannot exceed 4 KB.</p>
    /// <p>For information about the syntax of sending authorization policies, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-policies.html">Amazon SES Developer
    /// Guide</a>.</p>
    pub policy: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CreateEmailIdentityPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEmailIdentityPolicyInputBody");
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}

/// <p>Represents a request to create an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES
/// Developer Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEmailTemplateInputBody<'a> {
    /// <p>The name of the template you want to create.</p>
    pub template_name: &'a std::option::Option<std::string::String>,
    /// <p>The content of the email template, composed of a subject line, an HTML part, and a
    /// text-only part.</p>
    pub template_content: &'a std::option::Option<crate::model::EmailTemplateContent>,
}
impl<'a> std::fmt::Debug for CreateEmailTemplateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEmailTemplateInputBody");
        formatter.field("template_name", &self.template_name);
        formatter.field("template_content", &self.template_content);
        formatter.finish()
    }
}

/// <p>Represents a request to create an import job from a data source for a data
/// destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateImportJobInputBody<'a> {
    /// <p>The destination for the import job.</p>
    pub import_destination: &'a std::option::Option<crate::model::ImportDestination>,
    /// <p>The data source for the import job.</p>
    pub import_data_source: &'a std::option::Option<crate::model::ImportDataSource>,
}
impl<'a> std::fmt::Debug for CreateImportJobInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateImportJobInputBody");
        formatter.field("import_destination", &self.import_destination);
        formatter.field("import_data_source", &self.import_data_source);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListContactsInputBody<'a> {
    /// <p>A filter that can be applied to a list of contacts.</p>
    pub filter: &'a std::option::Option<crate::model::ListContactsFilter>,
}
impl<'a> std::fmt::Debug for ListContactsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListContactsInputBody");
        formatter.field("filter", &self.filter);
        formatter.finish()
    }
}

/// <p>Represents a request to list all of the import jobs for a data destination within the
/// specified maximum number of import jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImportJobsInputBody<'a> {
    /// <p>The destination of the import job, which can be used to list import jobs that have a
    /// certain <code>ImportDestinationType</code>.</p>
    pub import_destination_type: &'a std::option::Option<crate::model::ImportDestinationType>,
}
impl<'a> std::fmt::Debug for ListImportJobsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImportJobsInputBody");
        formatter.field("import_destination_type", &self.import_destination_type);
        formatter.finish()
    }
}

/// <p>A request to enable or disable the automatic IP address warm-up feature.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAccountDedicatedIpWarmupAttributesInputBody<'a> {
    /// <p>Enables or disables the automatic warm-up feature for dedicated IP addresses that are
    /// associated with your Amazon SES account in the current AWS Region. Set to <code>true</code>
    /// to enable the automatic warm-up feature, or set to <code>false</code> to disable
    /// it.</p>
    pub auto_warmup_enabled: &'a bool,
}
impl<'a> std::fmt::Debug for PutAccountDedicatedIpWarmupAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAccountDedicatedIpWarmupAttributesInputBody");
        formatter.field("auto_warmup_enabled", &self.auto_warmup_enabled);
        formatter.finish()
    }
}

/// <p>A request to submit new account details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAccountDetailsInputBody<'a> {
    /// <p>The type of email your account will send.</p>
    pub mail_type: &'a std::option::Option<crate::model::MailType>,
    /// <p>The URL of your website. This information helps us better understand the type of
    /// content that you plan to send.</p>
    pub website_url: &'a std::option::Option<std::string::String>,
    /// <p>The language you would prefer to be contacted with.</p>
    pub contact_language: &'a std::option::Option<crate::model::ContactLanguage>,
    /// <p>A description of the types of email that you plan to send.</p>
    pub use_case_description: &'a std::option::Option<std::string::String>,
    /// <p>Additional email addresses that you would like to be notified regarding Amazon SES
    /// matters.</p>
    pub additional_contact_email_addresses:
        &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether or not your account should have production access in the current
    /// AWS Region.</p>
    /// <p>If the value is <code>false</code>, then your account is in the
    /// <i>sandbox</i>. When your account is in the sandbox, you can only send
    /// email to verified identities. Additionally, the maximum number of emails you can send in
    /// a 24-hour period (your sending quota) is 200, and the maximum number of emails you can
    /// send per second (your maximum sending rate) is 1.</p>
    /// <p>If the value is <code>true</code>, then your account has production access. When your
    /// account has production access, you can send email to any address. The sending quota and
    /// maximum sending rate for your account vary based on your specific use case.</p>
    pub production_access_enabled: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for PutAccountDetailsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAccountDetailsInputBody");
        formatter.field("mail_type", &self.mail_type);
        formatter.field("website_url", &"*** Sensitive Data Redacted ***");
        formatter.field("contact_language", &self.contact_language);
        formatter.field("use_case_description", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "additional_contact_email_addresses",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.field("production_access_enabled", &self.production_access_enabled);
        formatter.finish()
    }
}

/// <p>A request to change the ability of your account to send email.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAccountSendingAttributesInputBody<'a> {
    /// <p>Enables or disables your account's ability to send email. Set to <code>true</code> to
    /// enable email sending, or set to <code>false</code> to disable email sending.</p>
    /// <note>
    /// <p>If AWS paused your account's ability to send email, you can't use this operation
    /// to resume your account's ability to send email.</p>
    /// </note>
    pub sending_enabled: &'a bool,
}
impl<'a> std::fmt::Debug for PutAccountSendingAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAccountSendingAttributesInputBody");
        formatter.field("sending_enabled", &self.sending_enabled);
        formatter.finish()
    }
}

/// <p>A request to change your account's suppression preferences.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutAccountSuppressionAttributesInputBody<'a> {
    /// <p>A list that contains the reasons that email addresses will be automatically added to
    /// the suppression list for your account. This list can contain any or all of the
    /// following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>COMPLAINT</code> – Amazon SES adds an email address to the suppression
    /// list for your account when a message sent to that address results in a
    /// complaint.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BOUNCE</code> – Amazon SES adds an email address to the suppression
    /// list for your account when a message sent to that address results in a hard
    /// bounce.</p>
    /// </li>
    /// </ul>
    pub suppressed_reasons:
        &'a std::option::Option<std::vec::Vec<crate::model::SuppressionListReason>>,
}
impl<'a> std::fmt::Debug for PutAccountSuppressionAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutAccountSuppressionAttributesInputBody");
        formatter.field("suppressed_reasons", &self.suppressed_reasons);
        formatter.finish()
    }
}

/// <p>A request to associate a configuration set with a dedicated IP pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutConfigurationSetDeliveryOptionsInputBody<'a> {
    /// <p>Specifies whether messages that use the configuration set are required to use
    /// Transport Layer Security (TLS). If the value is <code>Require</code>, messages are only
    /// delivered if a TLS connection can be established. If the value is <code>Optional</code>,
    /// messages can be delivered in plain text if a TLS connection can't be established.</p>
    pub tls_policy: &'a std::option::Option<crate::model::TlsPolicy>,
    /// <p>The name of the dedicated IP pool that you want to associate with the configuration
    /// set.</p>
    pub sending_pool_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutConfigurationSetDeliveryOptionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutConfigurationSetDeliveryOptionsInputBody");
        formatter.field("tls_policy", &self.tls_policy);
        formatter.field("sending_pool_name", &self.sending_pool_name);
        formatter.finish()
    }
}

/// <p>A request to enable or disable tracking of reputation metrics for a configuration
/// set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutConfigurationSetReputationOptionsInputBody<'a> {
    /// <p>If <code>true</code>, tracking of reputation metrics is enabled for the configuration
    /// set. If <code>false</code>, tracking of reputation metrics is disabled for the
    /// configuration set.</p>
    pub reputation_metrics_enabled: &'a bool,
}
impl<'a> std::fmt::Debug for PutConfigurationSetReputationOptionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutConfigurationSetReputationOptionsInputBody");
        formatter.field(
            "reputation_metrics_enabled",
            &self.reputation_metrics_enabled,
        );
        formatter.finish()
    }
}

/// <p>A request to enable or disable the ability of Amazon SES to send emails that use a specific
/// configuration set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutConfigurationSetSendingOptionsInputBody<'a> {
    /// <p>If <code>true</code>, email sending is enabled for the configuration set. If
    /// <code>false</code>, email sending is disabled for the configuration set.</p>
    pub sending_enabled: &'a bool,
}
impl<'a> std::fmt::Debug for PutConfigurationSetSendingOptionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutConfigurationSetSendingOptionsInputBody");
        formatter.field("sending_enabled", &self.sending_enabled);
        formatter.finish()
    }
}

/// <p>A request to change the account suppression list preferences for a specific
/// configuration set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutConfigurationSetSuppressionOptionsInputBody<'a> {
    /// <p>A list that contains the reasons that email addresses are automatically added to the
    /// suppression list for your account. This list can contain any or all of the
    /// following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>COMPLAINT</code> – Amazon SES adds an email address to the suppression
    /// list for your account when a message sent to that address results in a
    /// complaint.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>BOUNCE</code> – Amazon SES adds an email address to the suppression
    /// list for your account when a message sent to that address results in a
    /// hard bounce.</p>
    /// </li>
    /// </ul>
    pub suppressed_reasons:
        &'a std::option::Option<std::vec::Vec<crate::model::SuppressionListReason>>,
}
impl<'a> std::fmt::Debug for PutConfigurationSetSuppressionOptionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutConfigurationSetSuppressionOptionsInputBody");
        formatter.field("suppressed_reasons", &self.suppressed_reasons);
        formatter.finish()
    }
}

/// <p>A request to add a custom domain for tracking open and click events to a configuration
/// set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutConfigurationSetTrackingOptionsInputBody<'a> {
    /// <p>The domain that you want to use to track open and click events.</p>
    pub custom_redirect_domain: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutConfigurationSetTrackingOptionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutConfigurationSetTrackingOptionsInputBody");
        formatter.field("custom_redirect_domain", &self.custom_redirect_domain);
        formatter.finish()
    }
}

/// <p>A request to move a dedicated IP address to a dedicated IP pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDedicatedIpInPoolInputBody<'a> {
    /// <p>The name of the IP pool that you want to add the dedicated IP address to. You have to
    /// specify an IP pool that already exists.</p>
    pub destination_pool_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutDedicatedIpInPoolInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDedicatedIpInPoolInputBody");
        formatter.field("destination_pool_name", &self.destination_pool_name);
        formatter.finish()
    }
}

/// <p>A request to change the warm-up attributes for a dedicated IP address. This operation
/// is useful when you want to resume the warm-up process for an existing IP address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDedicatedIpWarmupAttributesInputBody<'a> {
    /// <p>The warm-up percentage that you want to associate with the dedicated IP
    /// address.</p>
    pub warmup_percentage: &'a std::option::Option<i32>,
}
impl<'a> std::fmt::Debug for PutDedicatedIpWarmupAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDedicatedIpWarmupAttributesInputBody");
        formatter.field("warmup_percentage", &self.warmup_percentage);
        formatter.finish()
    }
}

/// <p>Enable or disable the Deliverability dashboard. When you enable the Deliverability dashboard, you gain
/// access to reputation, deliverability, and other metrics for the domains that you use to
/// send email using Amazon SES API v2. You also gain the ability to perform predictive inbox placement tests.</p>
/// <p>When you use the Deliverability dashboard, you pay a monthly subscription charge, in addition
/// to any other fees that you accrue by using Amazon SES and other AWS services. For more
/// information about the features and cost of a Deliverability dashboard subscription, see <a href="http://aws.amazon.com/pinpoint/pricing/">Amazon Pinpoint Pricing</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutDeliverabilityDashboardOptionInputBody<'a> {
    /// <p>Specifies whether to enable the Deliverability dashboard. To enable the dashboard, set this
    /// value to <code>true</code>.</p>
    pub dashboard_enabled: &'a bool,
    /// <p>An array of objects, one for each verified domain that you use to send email and
    /// enabled the Deliverability dashboard for.</p>
    pub subscribed_domains:
        &'a std::option::Option<std::vec::Vec<crate::model::DomainDeliverabilityTrackingOption>>,
}
impl<'a> std::fmt::Debug for PutDeliverabilityDashboardOptionInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutDeliverabilityDashboardOptionInputBody");
        formatter.field("dashboard_enabled", &self.dashboard_enabled);
        formatter.field("subscribed_domains", &self.subscribed_domains);
        formatter.finish()
    }
}

/// <p>A request to associate a configuration set with an email identity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEmailIdentityConfigurationSetAttributesInputBody<'a> {
    /// <p>The configuration set that you want to associate with an email identity.</p>
    pub configuration_set_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for PutEmailIdentityConfigurationSetAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEmailIdentityConfigurationSetAttributesInputBody");
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.finish()
    }
}

/// <p>A request to enable or disable DKIM signing of email that you send from an email
/// identity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEmailIdentityDkimAttributesInputBody<'a> {
    /// <p>Sets the DKIM signing configuration for the identity.</p>
    /// <p>When you set this value <code>true</code>, then the messages that are sent from the
    /// identity are signed using DKIM. If you set this value to <code>false</code>, your
    /// messages are sent without DKIM signing.</p>
    pub signing_enabled: &'a bool,
}
impl<'a> std::fmt::Debug for PutEmailIdentityDkimAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEmailIdentityDkimAttributesInputBody");
        formatter.field("signing_enabled", &self.signing_enabled);
        formatter.finish()
    }
}

/// <p>A request to change the DKIM attributes for an email identity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEmailIdentityDkimSigningAttributesInputBody<'a> {
    /// <p>The method that you want to use to configure DKIM for the identity. There are two
    /// possible values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>AWS_SES</code> – Configure DKIM for the identity by using <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy
    /// DKIM</a>.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>EXTERNAL</code> – Configure DKIM for the identity by using Bring
    /// Your Own DKIM (BYODKIM).</p>
    /// </li>
    /// </ul>
    pub signing_attributes_origin:
        &'a std::option::Option<crate::model::DkimSigningAttributesOrigin>,
    /// <p>An object that contains information about the private key and selector that you want
    /// to use to configure DKIM for the identity. This object is only required if you want to
    /// configure Bring Your Own DKIM (BYODKIM) for the identity.</p>
    pub signing_attributes: &'a std::option::Option<crate::model::DkimSigningAttributes>,
}
impl<'a> std::fmt::Debug for PutEmailIdentityDkimSigningAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEmailIdentityDkimSigningAttributesInputBody");
        formatter.field("signing_attributes_origin", &self.signing_attributes_origin);
        formatter.field("signing_attributes", &self.signing_attributes);
        formatter.finish()
    }
}

/// <p>A request to set the attributes that control how bounce and complaint events are
/// processed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEmailIdentityFeedbackAttributesInputBody<'a> {
    /// <p>Sets the feedback forwarding configuration for the identity.</p>
    /// <p>If the value is <code>true</code>, you receive email notifications when bounce or
    /// complaint events occur. These notifications are sent to the address that you specified
    /// in the <code>Return-Path</code> header of the original email.</p>
    /// <p>You're required to have a method of tracking bounces and complaints. If you haven't
    /// set up another mechanism for receiving bounce or complaint notifications (for example,
    /// by setting up an event destination), you receive an email notification when these events
    /// occur (even if this setting is disabled).</p>
    pub email_forwarding_enabled: &'a bool,
}
impl<'a> std::fmt::Debug for PutEmailIdentityFeedbackAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEmailIdentityFeedbackAttributesInputBody");
        formatter.field("email_forwarding_enabled", &self.email_forwarding_enabled);
        formatter.finish()
    }
}

/// <p>A request to configure the custom MAIL FROM domain for a verified identity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEmailIdentityMailFromAttributesInputBody<'a> {
    /// <p> The custom MAIL FROM domain that you want the verified identity to use. The MAIL FROM
    /// domain must meet the following criteria:</p>
    /// <ul>
    /// <li>
    /// <p>It has to be a subdomain of the verified identity.</p>
    /// </li>
    /// <li>
    /// <p>It can't be used to receive email.</p>
    /// </li>
    /// <li>
    /// <p>It can't be used in a "From" address if the MAIL FROM domain is a destination
    /// for feedback forwarding emails.</p>
    /// </li>
    /// </ul>
    pub mail_from_domain: &'a std::option::Option<std::string::String>,
    /// <p>The action that you want to take if the required MX record isn't found when you send
    /// an email. When you set this value to <code>UseDefaultValue</code>, the mail is sent
    /// using <i>amazonses.com</i> as the MAIL FROM domain. When you set this
    /// value to <code>RejectMessage</code>, the Amazon SES API v2 returns a
    /// <code>MailFromDomainNotVerified</code> error, and doesn't attempt to deliver the
    /// email.</p>
    /// <p>These behaviors are taken when the custom MAIL FROM domain configuration is in the
    /// <code>Pending</code>, <code>Failed</code>, and <code>TemporaryFailure</code>
    /// states.</p>
    pub behavior_on_mx_failure: &'a std::option::Option<crate::model::BehaviorOnMxFailure>,
}
impl<'a> std::fmt::Debug for PutEmailIdentityMailFromAttributesInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEmailIdentityMailFromAttributesInputBody");
        formatter.field("mail_from_domain", &self.mail_from_domain);
        formatter.field("behavior_on_mx_failure", &self.behavior_on_mx_failure);
        formatter.finish()
    }
}

/// <p>A request to add an email destination to the suppression list for your account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSuppressedDestinationInputBody<'a> {
    /// <p>The email address that should be added to the suppression list for your
    /// account.</p>
    pub email_address: &'a std::option::Option<std::string::String>,
    /// <p>The factors that should cause the email address to be added to the suppression list
    /// for your account.</p>
    pub reason: &'a std::option::Option<crate::model::SuppressionListReason>,
}
impl<'a> std::fmt::Debug for PutSuppressedDestinationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSuppressedDestinationInputBody");
        formatter.field("email_address", &self.email_address);
        formatter.field("reason", &self.reason);
        formatter.finish()
    }
}

/// <p>Represents a request to send email messages to multiple destinations using Amazon SES. For
/// more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES Developer
/// Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendBulkEmailInputBody<'a> {
    /// <p>The email address that you want to use as the "From" address for the email. The
    /// address that you specify has to be verified.</p>
    pub from_email_address: &'a std::option::Option<std::string::String>,
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    /// that is associated with the sending authorization policy that permits you to use the
    /// email address specified in the <code>FromEmailAddress</code> parameter.</p>
    /// <p>For example, if the owner of example.com (which has ARN
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    /// authorizes you to use sender@example.com, then you would specify the
    /// <code>FromEmailAddressIdentityArn</code> to be
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    /// <code>FromEmailAddress</code> to be sender@example.com.</p>
    /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    /// Guide</a>.</p>
    pub from_email_address_identity_arn: &'a std::option::Option<std::string::String>,
    /// <p>The "Reply-to" email addresses for the message. When the recipient replies to the
    /// message, each Reply-to address receives the reply.</p>
    pub reply_to_addresses: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The address that you want bounce and complaint notifications to be sent to.</p>
    pub feedback_forwarding_email_address: &'a std::option::Option<std::string::String>,
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    /// that is associated with the sending authorization policy that permits you to use the
    /// email address specified in the <code>FeedbackForwardingEmailAddress</code>
    /// parameter.</p>
    /// <p>For example, if the owner of example.com (which has ARN
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    /// authorizes you to use feedback@example.com, then you would specify the
    /// <code>FeedbackForwardingEmailAddressIdentityArn</code> to be
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    /// <code>FeedbackForwardingEmailAddress</code> to be feedback@example.com.</p>
    /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    /// Guide</a>.</p>
    pub feedback_forwarding_email_address_identity_arn:
        &'a std::option::Option<std::string::String>,
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    /// using the <code>SendEmail</code> operation. Tags correspond to characteristics of the
    /// email that you define, so that you can publish email sending events.</p>
    pub default_email_tags: &'a std::option::Option<std::vec::Vec<crate::model::MessageTag>>,
    /// <p>An object that contains the body of the message. You can specify a template
    /// message.</p>
    pub default_content: &'a std::option::Option<crate::model::BulkEmailContent>,
    /// <p>The list of bulk email entry objects.</p>
    pub bulk_email_entries: &'a std::option::Option<std::vec::Vec<crate::model::BulkEmailEntry>>,
    /// <p>The name of the configuration set that you want to use when sending the email.</p>
    pub configuration_set_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for SendBulkEmailInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendBulkEmailInputBody");
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field(
            "from_email_address_identity_arn",
            &self.from_email_address_identity_arn,
        );
        formatter.field("reply_to_addresses", &self.reply_to_addresses);
        formatter.field(
            "feedback_forwarding_email_address",
            &self.feedback_forwarding_email_address,
        );
        formatter.field(
            "feedback_forwarding_email_address_identity_arn",
            &self.feedback_forwarding_email_address_identity_arn,
        );
        formatter.field("default_email_tags", &self.default_email_tags);
        formatter.field("default_content", &self.default_content);
        formatter.field("bulk_email_entries", &self.bulk_email_entries);
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.finish()
    }
}

/// <p>Represents a request to send a custom verification email to a specified
/// recipient.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendCustomVerificationEmailInputBody<'a> {
    /// <p>The email address to verify.</p>
    pub email_address: &'a std::option::Option<std::string::String>,
    /// <p>The name of the custom verification email template to use when sending the
    /// verification email.</p>
    pub template_name: &'a std::option::Option<std::string::String>,
    /// <p>Name of a configuration set to use when sending the verification email.</p>
    pub configuration_set_name: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for SendCustomVerificationEmailInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendCustomVerificationEmailInputBody");
        formatter.field("email_address", &self.email_address);
        formatter.field("template_name", &self.template_name);
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.finish()
    }
}

/// <p>Represents a request to send a single formatted email using Amazon SES. For more
/// information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-formatted.html">Amazon SES Developer
/// Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendEmailInputBody<'a> {
    /// <p>The email address that you want to use as the "From" address for the email. The
    /// address that you specify has to be verified.
    /// </p>
    pub from_email_address: &'a std::option::Option<std::string::String>,
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    /// that is associated with the sending authorization policy that permits you to use the
    /// email address specified in the <code>FromEmailAddress</code> parameter.</p>
    /// <p>For example, if the owner of example.com (which has ARN
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    /// authorizes you to use sender@example.com, then you would specify the
    /// <code>FromEmailAddressIdentityArn</code> to be
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    /// <code>FromEmailAddress</code> to be sender@example.com.</p>
    /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    /// Guide</a>.</p>
    /// <p>For Raw emails, the <code>FromEmailAddressIdentityArn</code> value overrides the
    /// X-SES-SOURCE-ARN and X-SES-FROM-ARN headers specified in raw email message
    /// content.</p>
    pub from_email_address_identity_arn: &'a std::option::Option<std::string::String>,
    /// <p>An object that contains the recipients of the email message.</p>
    pub destination: &'a std::option::Option<crate::model::Destination>,
    /// <p>The "Reply-to" email addresses for the message. When the recipient replies to the
    /// message, each Reply-to address receives the reply.</p>
    pub reply_to_addresses: &'a std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The address that you want bounce and complaint notifications to be sent to.</p>
    pub feedback_forwarding_email_address: &'a std::option::Option<std::string::String>,
    /// <p>This parameter is used only for sending authorization. It is the ARN of the identity
    /// that is associated with the sending authorization policy that permits you to use the
    /// email address specified in the <code>FeedbackForwardingEmailAddress</code>
    /// parameter.</p>
    /// <p>For example, if the owner of example.com (which has ARN
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com) attaches a policy to it that
    /// authorizes you to use feedback@example.com, then you would specify the
    /// <code>FeedbackForwardingEmailAddressIdentityArn</code> to be
    /// arn:aws:ses:us-east-1:123456789012:identity/example.com, and the
    /// <code>FeedbackForwardingEmailAddress</code> to be feedback@example.com.</p>
    /// <p>For more information about sending authorization, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization.html">Amazon SES Developer
    /// Guide</a>.</p>
    pub feedback_forwarding_email_address_identity_arn:
        &'a std::option::Option<std::string::String>,
    /// <p>An object that contains the body of the message. You can send either a Simple message
    /// Raw message or a template Message.</p>
    pub content: &'a std::option::Option<crate::model::EmailContent>,
    /// <p>A list of tags, in the form of name/value pairs, to apply to an email that you send
    /// using the <code>SendEmail</code> operation. Tags correspond to characteristics of the
    /// email that you define, so that you can publish email sending events. </p>
    pub email_tags: &'a std::option::Option<std::vec::Vec<crate::model::MessageTag>>,
    /// <p>The name of the configuration set that you want to use when sending the email.</p>
    pub configuration_set_name: &'a std::option::Option<std::string::String>,
    /// <p>An object used to specify a list or topic to which an email belongs, which will be
    /// used when a contact chooses to unsubscribe.</p>
    pub list_management_options: &'a std::option::Option<crate::model::ListManagementOptions>,
}
impl<'a> std::fmt::Debug for SendEmailInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendEmailInputBody");
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field(
            "from_email_address_identity_arn",
            &self.from_email_address_identity_arn,
        );
        formatter.field("destination", &self.destination);
        formatter.field("reply_to_addresses", &self.reply_to_addresses);
        formatter.field(
            "feedback_forwarding_email_address",
            &self.feedback_forwarding_email_address,
        );
        formatter.field(
            "feedback_forwarding_email_address_identity_arn",
            &self.feedback_forwarding_email_address_identity_arn,
        );
        formatter.field("content", &self.content);
        formatter.field("email_tags", &self.email_tags);
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.field("list_management_options", &self.list_management_options);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInputBody<'a> {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to add one or more tags
    /// to.</p>
    pub resource_arn: &'a std::option::Option<std::string::String>,
    /// <p>A list of the tags that you want to add to the resource. A tag consists of a required
    /// tag key (<code>Key</code>) and an associated tag value (<code>Value</code>). The maximum
    /// length of a tag key is 128 characters. The maximum length of a tag value is 256
    /// characters.</p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for TagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInputBody");
        formatter.field("resource_arn", &self.resource_arn);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>>Represents a request to create a preview of the MIME content of an email when
/// provided with a template and a set of replacement data.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestRenderEmailTemplateInputBody<'a> {
    /// <p>A list of replacement values to apply to the template. This parameter is a JSON
    /// object, typically consisting of key-value pairs in which the keys correspond to
    /// replacement tags in the email template.</p>
    pub template_data: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for TestRenderEmailTemplateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestRenderEmailTemplateInputBody");
        formatter.field("template_data", &self.template_data);
        formatter.finish()
    }
}

/// <p>A request to change the settings for an event destination for a configuration
/// set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateConfigurationSetEventDestinationInputBody<'a> {
    /// <p>An object that defines the event destination.</p>
    pub event_destination: &'a std::option::Option<crate::model::EventDestinationDefinition>,
}
impl<'a> std::fmt::Debug for UpdateConfigurationSetEventDestinationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateConfigurationSetEventDestinationInputBody");
        formatter.field("event_destination", &self.event_destination);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateContactInputBody<'a> {
    /// <p>The contact's preference for being opted-in to or opted-out of a topic.</p>
    pub topic_preferences: &'a std::option::Option<std::vec::Vec<crate::model::TopicPreference>>,
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    /// topics.</p>
    pub unsubscribe_all: &'a bool,
    /// <p>The attribute data attached to a contact.</p>
    pub attributes_data: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateContactInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateContactInputBody");
        formatter.field("topic_preferences", &self.topic_preferences);
        formatter.field("unsubscribe_all", &self.unsubscribe_all);
        formatter.field("attributes_data", &self.attributes_data);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateContactListInputBody<'a> {
    /// <p>An interest group, theme, or label within a list. A contact list can have multiple
    /// topics.</p>
    pub topics: &'a std::option::Option<std::vec::Vec<crate::model::Topic>>,
    /// <p>A description of what the contact list is about.</p>
    pub description: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateContactListInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateContactListInputBody");
        formatter.field("topics", &self.topics);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}

/// <p>Represents a request to update an existing custom verification email template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateCustomVerificationEmailTemplateInputBody<'a> {
    /// <p>The email address that the custom verification email is sent from.</p>
    pub from_email_address: &'a std::option::Option<std::string::String>,
    /// <p>The subject line of the custom verification email.</p>
    pub template_subject: &'a std::option::Option<std::string::String>,
    /// <p>The content of the custom verification email. The total size of the email must be less
    /// than 10 MB. The message body may contain HTML, with some limitations. For more
    /// information, see <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-verify-address-custom.html#custom-verification-emails-faq">Custom Verification Email Frequently Asked Questions</a> in the <i>Amazon SES
    /// Developer Guide</i>.</p>
    pub template_content: &'a std::option::Option<std::string::String>,
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    /// is successfully verified.</p>
    pub success_redirection_url: &'a std::option::Option<std::string::String>,
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    /// is not successfully verified.</p>
    pub failure_redirection_url: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateCustomVerificationEmailTemplateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateCustomVerificationEmailTemplateInputBody");
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field("template_subject", &self.template_subject);
        formatter.field("template_content", &self.template_content);
        formatter.field("success_redirection_url", &self.success_redirection_url);
        formatter.field("failure_redirection_url", &self.failure_redirection_url);
        formatter.finish()
    }
}

/// <p>Represents a request to update a sending authorization policy for an identity. Sending
/// authorization is an Amazon SES feature that enables you to authorize other senders to use
/// your identities. For information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-identity-owner-tasks-management.html">Amazon SES Developer Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEmailIdentityPolicyInputBody<'a> {
    /// <p>The text of the policy in JSON format. The policy cannot exceed 4 KB.</p>
    /// <p> For information about the syntax of sending authorization policies, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/sending-authorization-policies.html">Amazon SES Developer
    /// Guide</a>.</p>
    pub policy: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateEmailIdentityPolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEmailIdentityPolicyInputBody");
        formatter.field("policy", &self.policy);
        formatter.finish()
    }
}

/// <p>Represents a request to update an email template. For more information, see the <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-personalized-email-api.html">Amazon SES
/// Developer Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateEmailTemplateInputBody<'a> {
    /// <p>The content of the email template, composed of a subject line, an HTML part, and a
    /// text-only part.</p>
    pub template_content: &'a std::option::Option<crate::model::EmailTemplateContent>,
}
impl<'a> std::fmt::Debug for UpdateEmailTemplateInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateEmailTemplateInputBody");
        formatter.field("template_content", &self.template_content);
        formatter.finish()
    }
}

/// <p>Information about the predictive inbox placement test that you created.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateDeliverabilityTestReportOutputBody {
    /// <p>A unique string that identifies the predictive inbox placement test.</p>
    #[serde(rename = "ReportId")]
    #[serde(default)]
    pub report_id: std::option::Option<std::string::String>,
    /// <p>The status of the predictive inbox placement test. If the status is <code>IN_PROGRESS</code>, then the predictive inbox placement test
    /// is currently running. Predictive inbox placement tests are usually complete within 24 hours of creating the
    /// test. If the status is <code>COMPLETE</code>, then the test is finished, and you can use
    /// the <code>GetDeliverabilityTestReport</code> to view the results of the test.</p>
    #[serde(rename = "DeliverabilityTestStatus")]
    #[serde(default)]
    pub deliverability_test_status: std::option::Option<crate::model::DeliverabilityTestStatus>,
}
impl std::fmt::Debug for CreateDeliverabilityTestReportOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateDeliverabilityTestReportOutputBody");
        formatter.field("report_id", &self.report_id);
        formatter.field(
            "deliverability_test_status",
            &self.deliverability_test_status,
        );
        formatter.finish()
    }
}

/// <p>If the email identity is a domain, this object contains information about the DKIM
/// verification status for the domain.</p>
/// <p>If the email identity is an email address, this object is empty. </p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateEmailIdentityOutputBody {
    /// <p>The email identity type.</p>
    #[serde(rename = "IdentityType")]
    #[serde(default)]
    pub identity_type: std::option::Option<crate::model::IdentityType>,
    /// <p>Specifies whether or not the identity is verified. You can only send email from
    /// verified email addresses or domains. For more information about verifying identities,
    /// see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide</a>.</p>
    #[serde(rename = "VerifiedForSendingStatus")]
    #[serde(default)]
    pub verified_for_sending_status: bool,
    /// <p>An object that contains information about the DKIM attributes for the identity.</p>
    #[serde(rename = "DkimAttributes")]
    #[serde(default)]
    pub dkim_attributes: std::option::Option<crate::model::DkimAttributes>,
}
impl std::fmt::Debug for CreateEmailIdentityOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateEmailIdentityOutputBody");
        formatter.field("identity_type", &self.identity_type);
        formatter.field(
            "verified_for_sending_status",
            &self.verified_for_sending_status,
        );
        formatter.field("dkim_attributes", &self.dkim_attributes);
        formatter.finish()
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
/// fails.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateImportJobOutputBody {
    /// <p>A string that represents the import job ID.</p>
    #[serde(rename = "JobId")]
    #[serde(default)]
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateImportJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateImportJobOutputBody");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}

/// <p>A list of details about the email-sending capabilities of your Amazon SES account in the
/// current AWS Region.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetAccountOutputBody {
    /// <p>Indicates whether or not the automatic warm-up feature is enabled for dedicated IP
    /// addresses that are associated with your account.</p>
    #[serde(rename = "DedicatedIpAutoWarmupEnabled")]
    #[serde(default)]
    pub dedicated_ip_auto_warmup_enabled: bool,
    /// <p>The reputation status of your Amazon SES account. The status can be one of the
    /// following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HEALTHY</code> – There are no reputation-related issues that
    /// currently impact your account.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PROBATION</code> – We've identified potential issues with your
    /// Amazon SES account. We're placing your account under review while you work on
    /// correcting these issues.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SHUTDOWN</code> – Your account's ability to send email is
    /// currently paused because of an issue with the email sent from your account. When
    /// you correct the issue, you can contact us and request that your account's
    /// ability to send email is resumed.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "EnforcementStatus")]
    #[serde(default)]
    pub enforcement_status: std::option::Option<std::string::String>,
    /// <p>Indicates whether or not your account has production access in the current AWS
    /// Region.</p>
    /// <p>If the value is <code>false</code>, then your account is in the
    /// <i>sandbox</i>. When your account is in the sandbox, you can only send
    /// email to verified identities. Additionally, the maximum number of emails you can send in
    /// a 24-hour period (your sending quota) is 200, and the maximum number of emails you can
    /// send per second (your maximum sending rate) is 1.</p>
    /// <p>If the value is <code>true</code>, then your account has production access. When your
    /// account has production access, you can send email to any address. The sending quota and
    /// maximum sending rate for your account vary based on your specific use case.</p>
    #[serde(rename = "ProductionAccessEnabled")]
    #[serde(default)]
    pub production_access_enabled: bool,
    /// <p>An object that contains information about the per-day and per-second sending limits
    /// for your Amazon SES account in the current AWS Region.</p>
    #[serde(rename = "SendQuota")]
    #[serde(default)]
    pub send_quota: std::option::Option<crate::model::SendQuota>,
    /// <p>Indicates whether or not email sending is enabled for your Amazon SES account in the
    /// current AWS Region.</p>
    #[serde(rename = "SendingEnabled")]
    #[serde(default)]
    pub sending_enabled: bool,
    /// <p>An object that contains information about the email address suppression preferences
    /// for your account in the current AWS Region.</p>
    #[serde(rename = "SuppressionAttributes")]
    #[serde(default)]
    pub suppression_attributes: std::option::Option<crate::model::SuppressionAttributes>,
    /// <p>An object that defines your account details.</p>
    #[serde(rename = "Details")]
    #[serde(default)]
    pub details: std::option::Option<crate::model::AccountDetails>,
}
impl std::fmt::Debug for GetAccountOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetAccountOutputBody");
        formatter.field(
            "dedicated_ip_auto_warmup_enabled",
            &self.dedicated_ip_auto_warmup_enabled,
        );
        formatter.field("enforcement_status", &self.enforcement_status);
        formatter.field("production_access_enabled", &self.production_access_enabled);
        formatter.field("send_quota", &self.send_quota);
        formatter.field("sending_enabled", &self.sending_enabled);
        formatter.field("suppression_attributes", &self.suppression_attributes);
        formatter.field("details", &self.details);
        formatter.finish()
    }
}

/// <p>An object that contains information about blacklist events.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetBlacklistReportsOutputBody {
    /// <p>An object that contains information about a blacklist that one of your dedicated IP
    /// addresses appears on.</p>
    #[serde(rename = "BlacklistReport")]
    #[serde(default)]
    pub blacklist_report: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<crate::model::BlacklistEntry>>,
    >,
}
impl std::fmt::Debug for GetBlacklistReportsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetBlacklistReportsOutputBody");
        formatter.field("blacklist_report", &self.blacklist_report);
        formatter.finish()
    }
}

/// <p>Information about a configuration set.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConfigurationSetOutputBody {
    /// <p>The name of the configuration set.</p>
    #[serde(rename = "ConfigurationSetName")]
    #[serde(default)]
    pub configuration_set_name: std::option::Option<std::string::String>,
    /// <p>An object that defines the open and click tracking options for emails that you send
    /// using the configuration set.</p>
    #[serde(rename = "TrackingOptions")]
    #[serde(default)]
    pub tracking_options: std::option::Option<crate::model::TrackingOptions>,
    /// <p>An object that defines the dedicated IP pool that is used to send emails that you send
    /// using the configuration set.</p>
    #[serde(rename = "DeliveryOptions")]
    #[serde(default)]
    pub delivery_options: std::option::Option<crate::model::DeliveryOptions>,
    /// <p>An object that defines whether or not Amazon SES collects reputation metrics for the emails
    /// that you send that use the configuration set.</p>
    #[serde(rename = "ReputationOptions")]
    #[serde(default)]
    pub reputation_options: std::option::Option<crate::model::ReputationOptions>,
    /// <p>An object that defines whether or not Amazon SES can send email that you send using the
    /// configuration set.</p>
    #[serde(rename = "SendingOptions")]
    #[serde(default)]
    pub sending_options: std::option::Option<crate::model::SendingOptions>,
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    /// the configuration set.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>An object that contains information about the suppression list preferences for your
    /// account.</p>
    #[serde(rename = "SuppressionOptions")]
    #[serde(default)]
    pub suppression_options: std::option::Option<crate::model::SuppressionOptions>,
}
impl std::fmt::Debug for GetConfigurationSetOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConfigurationSetOutputBody");
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.field("tracking_options", &self.tracking_options);
        formatter.field("delivery_options", &self.delivery_options);
        formatter.field("reputation_options", &self.reputation_options);
        formatter.field("sending_options", &self.sending_options);
        formatter.field("tags", &self.tags);
        formatter.field("suppression_options", &self.suppression_options);
        formatter.finish()
    }
}

/// <p>Information about an event destination for a configuration set.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetConfigurationSetEventDestinationsOutputBody {
    /// <p>An array that includes all of the events destinations that have been configured for
    /// the configuration set.</p>
    #[serde(rename = "EventDestinations")]
    #[serde(default)]
    pub event_destinations: std::option::Option<std::vec::Vec<crate::model::EventDestination>>,
}
impl std::fmt::Debug for GetConfigurationSetEventDestinationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetConfigurationSetEventDestinationsOutputBody");
        formatter.field("event_destinations", &self.event_destinations);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContactOutputBody {
    /// <p>The name of the contact list to which the contact belongs.</p>
    #[serde(rename = "ContactListName")]
    #[serde(default)]
    pub contact_list_name: std::option::Option<std::string::String>,
    /// <p>The contact's email addres.</p>
    #[serde(rename = "EmailAddress")]
    #[serde(default)]
    pub email_address: std::option::Option<std::string::String>,
    /// <p>The contact's preference for being opted-in to or opted-out of a topic.></p>
    #[serde(rename = "TopicPreferences")]
    #[serde(default)]
    pub topic_preferences: std::option::Option<std::vec::Vec<crate::model::TopicPreference>>,
    /// <p>The default topic preferences applied to the contact.</p>
    #[serde(rename = "TopicDefaultPreferences")]
    #[serde(default)]
    pub topic_default_preferences:
        std::option::Option<std::vec::Vec<crate::model::TopicPreference>>,
    /// <p>A boolean value status noting if the contact is unsubscribed from all contact list
    /// topics.</p>
    #[serde(rename = "UnsubscribeAll")]
    #[serde(default)]
    pub unsubscribe_all: bool,
    /// <p>The attribute data attached to a contact.</p>
    #[serde(rename = "AttributesData")]
    #[serde(default)]
    pub attributes_data: std::option::Option<std::string::String>,
    /// <p>A timestamp noting when the contact was created.</p>
    #[serde(rename = "CreatedTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp noting the last time the contact's information was updated.</p>
    #[serde(rename = "LastUpdatedTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_updated_timestamp: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for GetContactOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContactOutputBody");
        formatter.field("contact_list_name", &self.contact_list_name);
        formatter.field("email_address", &self.email_address);
        formatter.field("topic_preferences", &self.topic_preferences);
        formatter.field("topic_default_preferences", &self.topic_default_preferences);
        formatter.field("unsubscribe_all", &self.unsubscribe_all);
        formatter.field("attributes_data", &self.attributes_data);
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("last_updated_timestamp", &self.last_updated_timestamp);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetContactListOutputBody {
    /// <p>The name of the contact list.</p>
    #[serde(rename = "ContactListName")]
    #[serde(default)]
    pub contact_list_name: std::option::Option<std::string::String>,
    /// <p>An interest group, theme, or label within a list. A contact list can have multiple
    /// topics.</p>
    #[serde(rename = "Topics")]
    #[serde(default)]
    pub topics: std::option::Option<std::vec::Vec<crate::model::Topic>>,
    /// <p>A description of what the contact list is about.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>A timestamp noting when the contact list was created.</p>
    #[serde(rename = "CreatedTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>A timestamp noting the last time the contact list was updated.</p>
    #[serde(rename = "LastUpdatedTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_updated_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The tags associated with a contact list.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for GetContactListOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetContactListOutputBody");
        formatter.field("contact_list_name", &self.contact_list_name);
        formatter.field("topics", &self.topics);
        formatter.field("description", &self.description);
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("last_updated_timestamp", &self.last_updated_timestamp);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>The following elements are returned by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetCustomVerificationEmailTemplateOutputBody {
    /// <p>The name of the custom verification email template.</p>
    #[serde(rename = "TemplateName")]
    #[serde(default)]
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The email address that the custom verification email is sent from.</p>
    #[serde(rename = "FromEmailAddress")]
    #[serde(default)]
    pub from_email_address: std::option::Option<std::string::String>,
    /// <p>The subject line of the custom verification email.</p>
    #[serde(rename = "TemplateSubject")]
    #[serde(default)]
    pub template_subject: std::option::Option<std::string::String>,
    /// <p>The content of the custom verification email.</p>
    #[serde(rename = "TemplateContent")]
    #[serde(default)]
    pub template_content: std::option::Option<std::string::String>,
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    /// is successfully verified.</p>
    #[serde(rename = "SuccessRedirectionURL")]
    #[serde(default)]
    pub success_redirection_url: std::option::Option<std::string::String>,
    /// <p>The URL that the recipient of the verification email is sent to if his or her address
    /// is not successfully verified.</p>
    #[serde(rename = "FailureRedirectionURL")]
    #[serde(default)]
    pub failure_redirection_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetCustomVerificationEmailTemplateOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetCustomVerificationEmailTemplateOutputBody");
        formatter.field("template_name", &self.template_name);
        formatter.field("from_email_address", &self.from_email_address);
        formatter.field("template_subject", &self.template_subject);
        formatter.field("template_content", &self.template_content);
        formatter.field("success_redirection_url", &self.success_redirection_url);
        formatter.field("failure_redirection_url", &self.failure_redirection_url);
        formatter.finish()
    }
}

/// <p>Information about a dedicated IP address.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDedicatedIpOutputBody {
    /// <p>An object that contains information about a dedicated IP address.</p>
    #[serde(rename = "DedicatedIp")]
    #[serde(default)]
    pub dedicated_ip: std::option::Option<crate::model::DedicatedIp>,
}
impl std::fmt::Debug for GetDedicatedIpOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDedicatedIpOutputBody");
        formatter.field("dedicated_ip", &self.dedicated_ip);
        formatter.finish()
    }
}

/// <p>Information about the dedicated IP addresses that are associated with your AWS
/// account.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDedicatedIpsOutputBody {
    /// <p>A list of dedicated IP addresses that are associated with your AWS account.</p>
    #[serde(rename = "DedicatedIps")]
    #[serde(default)]
    pub dedicated_ips: std::option::Option<std::vec::Vec<crate::model::DedicatedIp>>,
    /// <p>A token that indicates that there are additional dedicated IP addresses to list. To
    /// view additional addresses, issue another request to <code>GetDedicatedIps</code>,
    /// passing this token in the <code>NextToken</code> parameter.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetDedicatedIpsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDedicatedIpsOutputBody");
        formatter.field("dedicated_ips", &self.dedicated_ips);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>An object that shows the status of the Deliverability dashboard.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDeliverabilityDashboardOptionsOutputBody {
    /// <p>Specifies whether the Deliverability dashboard is enabled. If this value is <code>true</code>,
    /// the dashboard is enabled.</p>
    #[serde(rename = "DashboardEnabled")]
    #[serde(default)]
    pub dashboard_enabled: bool,
    /// <p>The date, in Unix time format, when your current subscription to the Deliverability dashboard
    /// is scheduled to expire, if your subscription is scheduled to expire at the end of the
    /// current calendar month. This value is null if you have an active subscription that isn’t
    /// due to expire at the end of the month.</p>
    #[serde(rename = "SubscriptionExpiryDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub subscription_expiry_date: std::option::Option<smithy_types::Instant>,
    /// <p>The current status of your Deliverability dashboard subscription. If this value is
    /// <code>PENDING_EXPIRATION</code>, your subscription is scheduled to expire at the end
    /// of the current calendar month.</p>
    #[serde(rename = "AccountStatus")]
    #[serde(default)]
    pub account_status: std::option::Option<crate::model::DeliverabilityDashboardAccountStatus>,
    /// <p>An array of objects, one for each verified domain that you use to send email and
    /// currently has an active Deliverability dashboard subscription that isn’t scheduled to expire at
    /// the end of the current calendar month.</p>
    #[serde(rename = "ActiveSubscribedDomains")]
    #[serde(default)]
    pub active_subscribed_domains:
        std::option::Option<std::vec::Vec<crate::model::DomainDeliverabilityTrackingOption>>,
    /// <p>An array of objects, one for each verified domain that you use to send email and
    /// currently has an active Deliverability dashboard subscription that's scheduled to expire at the
    /// end of the current calendar month.</p>
    #[serde(rename = "PendingExpirationSubscribedDomains")]
    #[serde(default)]
    pub pending_expiration_subscribed_domains:
        std::option::Option<std::vec::Vec<crate::model::DomainDeliverabilityTrackingOption>>,
}
impl std::fmt::Debug for GetDeliverabilityDashboardOptionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDeliverabilityDashboardOptionsOutputBody");
        formatter.field("dashboard_enabled", &self.dashboard_enabled);
        formatter.field("subscription_expiry_date", &self.subscription_expiry_date);
        formatter.field("account_status", &self.account_status);
        formatter.field("active_subscribed_domains", &self.active_subscribed_domains);
        formatter.field(
            "pending_expiration_subscribed_domains",
            &self.pending_expiration_subscribed_domains,
        );
        formatter.finish()
    }
}

/// <p>The results of the predictive inbox placement test.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDeliverabilityTestReportOutputBody {
    /// <p>An object that contains the results of the predictive inbox placement test.</p>
    #[serde(rename = "DeliverabilityTestReport")]
    #[serde(default)]
    pub deliverability_test_report: std::option::Option<crate::model::DeliverabilityTestReport>,
    /// <p>An object that specifies how many test messages that were sent during the predictive inbox placement test were
    /// delivered to recipients' inboxes, how many were sent to recipients' spam folders, and
    /// how many weren't delivered.</p>
    #[serde(rename = "OverallPlacement")]
    #[serde(default)]
    pub overall_placement: std::option::Option<crate::model::PlacementStatistics>,
    /// <p>An object that describes how the test email was handled by several email providers,
    /// including Gmail, Hotmail, Yahoo, AOL, and others.</p>
    #[serde(rename = "IspPlacements")]
    #[serde(default)]
    pub isp_placements: std::option::Option<std::vec::Vec<crate::model::IspPlacement>>,
    /// <p>An object that contains the message that you sent when you performed this
    /// predictive inbox placement test.</p>
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    /// the predictive inbox placement test.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for GetDeliverabilityTestReportOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDeliverabilityTestReportOutputBody");
        formatter.field(
            "deliverability_test_report",
            &self.deliverability_test_report,
        );
        formatter.field("overall_placement", &self.overall_placement);
        formatter.field("isp_placements", &self.isp_placements);
        formatter.field("message", &self.message);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>An object that contains all the deliverability data for a specific campaign. This data
/// is available for a campaign only if the campaign sent email by using a domain that the
/// Deliverability dashboard is enabled for.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDomainDeliverabilityCampaignOutputBody {
    /// <p>An object that contains the deliverability data for the campaign.</p>
    #[serde(rename = "DomainDeliverabilityCampaign")]
    #[serde(default)]
    pub domain_deliverability_campaign:
        std::option::Option<crate::model::DomainDeliverabilityCampaign>,
}
impl std::fmt::Debug for GetDomainDeliverabilityCampaignOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDomainDeliverabilityCampaignOutputBody");
        formatter.field(
            "domain_deliverability_campaign",
            &self.domain_deliverability_campaign,
        );
        formatter.finish()
    }
}

/// <p>An object that includes statistics that are related to the domain that you
/// specified.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetDomainStatisticsReportOutputBody {
    /// <p>An object that contains deliverability metrics for the domain that you specified. The
    /// data in this object is a summary of all of the data that was collected from the
    /// <code>StartDate</code> to the <code>EndDate</code>.</p>
    #[serde(rename = "OverallVolume")]
    #[serde(default)]
    pub overall_volume: std::option::Option<crate::model::OverallVolume>,
    /// <p>An object that contains deliverability metrics for the domain that you specified. This
    /// object contains data for each day, starting on the <code>StartDate</code> and ending on
    /// the <code>EndDate</code>.</p>
    #[serde(rename = "DailyVolumes")]
    #[serde(default)]
    pub daily_volumes: std::option::Option<std::vec::Vec<crate::model::DailyVolume>>,
}
impl std::fmt::Debug for GetDomainStatisticsReportOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetDomainStatisticsReportOutputBody");
        formatter.field("overall_volume", &self.overall_volume);
        formatter.field("daily_volumes", &self.daily_volumes);
        formatter.finish()
    }
}

/// <p>Details about an email identity.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetEmailIdentityOutputBody {
    /// <p>The email identity type.</p>
    #[serde(rename = "IdentityType")]
    #[serde(default)]
    pub identity_type: std::option::Option<crate::model::IdentityType>,
    /// <p>The feedback forwarding configuration for the identity.</p>
    /// <p>If the value is <code>true</code>, you receive email notifications when bounce or
    /// complaint events occur. These notifications are sent to the address that you specified
    /// in the <code>Return-Path</code> header of the original email.</p>
    /// <p>You're required to have a method of tracking bounces and complaints. If you haven't
    /// set up another mechanism for receiving bounce or complaint notifications (for example,
    /// by setting up an event destination), you receive an email notification when these events
    /// occur (even if this setting is disabled).</p>
    #[serde(rename = "FeedbackForwardingStatus")]
    #[serde(default)]
    pub feedback_forwarding_status: bool,
    /// <p>Specifies whether or not the identity is verified. You can only send email from
    /// verified email addresses or domains. For more information about verifying identities,
    /// see the <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-email-manage-verify.html">Amazon Pinpoint User Guide</a>.</p>
    #[serde(rename = "VerifiedForSendingStatus")]
    #[serde(default)]
    pub verified_for_sending_status: bool,
    /// <p>An object that contains information about the DKIM attributes for the identity.</p>
    #[serde(rename = "DkimAttributes")]
    #[serde(default)]
    pub dkim_attributes: std::option::Option<crate::model::DkimAttributes>,
    /// <p>An object that contains information about the Mail-From attributes for the email
    /// identity.</p>
    #[serde(rename = "MailFromAttributes")]
    #[serde(default)]
    pub mail_from_attributes: std::option::Option<crate::model::MailFromAttributes>,
    /// <p>A map of policy names to policies.</p>
    #[serde(rename = "Policies")]
    #[serde(default)]
    pub policies:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>An array of objects that define the tags (keys and values) that are associated with
    /// the email identity.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>The configuration set used by default when sending from this identity.</p>
    #[serde(rename = "ConfigurationSetName")]
    #[serde(default)]
    pub configuration_set_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetEmailIdentityOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetEmailIdentityOutputBody");
        formatter.field("identity_type", &self.identity_type);
        formatter.field(
            "feedback_forwarding_status",
            &self.feedback_forwarding_status,
        );
        formatter.field(
            "verified_for_sending_status",
            &self.verified_for_sending_status,
        );
        formatter.field("dkim_attributes", &self.dkim_attributes);
        formatter.field("mail_from_attributes", &self.mail_from_attributes);
        formatter.field("policies", &self.policies);
        formatter.field("tags", &self.tags);
        formatter.field("configuration_set_name", &self.configuration_set_name);
        formatter.finish()
    }
}

/// <p>Identity policies associated with email identity.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetEmailIdentityPoliciesOutputBody {
    /// <p>A map of policy names to policies.</p>
    #[serde(rename = "Policies")]
    #[serde(default)]
    pub policies:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for GetEmailIdentityPoliciesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetEmailIdentityPoliciesOutputBody");
        formatter.field("policies", &self.policies);
        formatter.finish()
    }
}

/// <p>The following element is returned by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetEmailTemplateOutputBody {
    /// <p>The name of the template you want to retrieve.</p>
    #[serde(rename = "TemplateName")]
    #[serde(default)]
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The content of the email template, composed of a subject line, an HTML part, and a
    /// text-only part.</p>
    #[serde(rename = "TemplateContent")]
    #[serde(default)]
    pub template_content: std::option::Option<crate::model::EmailTemplateContent>,
}
impl std::fmt::Debug for GetEmailTemplateOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetEmailTemplateOutputBody");
        formatter.field("template_name", &self.template_name);
        formatter.field("template_content", &self.template_content);
        formatter.finish()
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
/// fails.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetImportJobOutputBody {
    /// <p>A string that represents the import job ID.</p>
    #[serde(rename = "JobId")]
    #[serde(default)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The destination of the import job.</p>
    #[serde(rename = "ImportDestination")]
    #[serde(default)]
    pub import_destination: std::option::Option<crate::model::ImportDestination>,
    /// <p>The data source of the import job.</p>
    #[serde(rename = "ImportDataSource")]
    #[serde(default)]
    pub import_data_source: std::option::Option<crate::model::ImportDataSource>,
    /// <p>The failure details about an import job.</p>
    #[serde(rename = "FailureInfo")]
    #[serde(default)]
    pub failure_info: std::option::Option<crate::model::FailureInfo>,
    /// <p>The status of the import job.</p>
    #[serde(rename = "JobStatus")]
    #[serde(default)]
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>The time stamp of when the import job was created.</p>
    #[serde(rename = "CreatedTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The time stamp of when the import job was completed.</p>
    #[serde(rename = "CompletedTimestamp")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub completed_timestamp: std::option::Option<smithy_types::Instant>,
    /// <p>The current number of records processed.</p>
    #[serde(rename = "ProcessedRecordsCount")]
    #[serde(default)]
    pub processed_records_count: std::option::Option<i32>,
    /// <p>The number of records that failed processing because of invalid input or other
    /// reasons.</p>
    #[serde(rename = "FailedRecordsCount")]
    #[serde(default)]
    pub failed_records_count: std::option::Option<i32>,
}
impl std::fmt::Debug for GetImportJobOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetImportJobOutputBody");
        formatter.field("job_id", &self.job_id);
        formatter.field("import_destination", &self.import_destination);
        formatter.field("import_data_source", &self.import_data_source);
        formatter.field("failure_info", &self.failure_info);
        formatter.field("job_status", &self.job_status);
        formatter.field("created_timestamp", &self.created_timestamp);
        formatter.field("completed_timestamp", &self.completed_timestamp);
        formatter.field("processed_records_count", &self.processed_records_count);
        formatter.field("failed_records_count", &self.failed_records_count);
        formatter.finish()
    }
}

/// <p>Information about the suppressed email address.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSuppressedDestinationOutputBody {
    /// <p>An object containing information about the suppressed email address.</p>
    #[serde(rename = "SuppressedDestination")]
    #[serde(default)]
    pub suppressed_destination: std::option::Option<crate::model::SuppressedDestination>,
}
impl std::fmt::Debug for GetSuppressedDestinationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSuppressedDestinationOutputBody");
        formatter.field("suppressed_destination", &self.suppressed_destination);
        formatter.finish()
    }
}

/// <p>A list of configuration sets in your Amazon SES account in the current AWS Region.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListConfigurationSetsOutputBody {
    /// <p>An array that contains all of the configuration sets in your Amazon SES account in the
    /// current AWS Region.</p>
    #[serde(rename = "ConfigurationSets")]
    #[serde(default)]
    pub configuration_sets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A token that indicates that there are additional configuration sets to list. To view
    /// additional configuration sets, issue another request to
    /// <code>ListConfigurationSets</code>, and pass this token in the
    /// <code>NextToken</code> parameter.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListConfigurationSetsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListConfigurationSetsOutputBody");
        formatter.field("configuration_sets", &self.configuration_sets);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListContactListsOutputBody {
    /// <p>The available contact lists.</p>
    #[serde(rename = "ContactLists")]
    #[serde(default)]
    pub contact_lists: std::option::Option<std::vec::Vec<crate::model::ContactList>>,
    /// <p>A string token indicating that there might be additional contact lists available to be
    /// listed. Copy this token to a subsequent call to <code>ListContactLists</code> with the
    /// same parameters to retrieve the next page of contact lists.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListContactListsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListContactListsOutputBody");
        formatter.field("contact_lists", &self.contact_lists);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListContactsOutputBody {
    /// <p>The contacts present in a specific contact list.</p>
    #[serde(rename = "Contacts")]
    #[serde(default)]
    pub contacts: std::option::Option<std::vec::Vec<crate::model::Contact>>,
    /// <p>A string token indicating that there might be additional contacts available to be
    /// listed. Copy this token to a subsequent call to <code>ListContacts</code> with the same
    /// parameters to retrieve the next page of contacts.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListContactsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListContactsOutputBody");
        formatter.field("contacts", &self.contacts);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>The following elements are returned by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListCustomVerificationEmailTemplatesOutputBody {
    /// <p>A list of the custom verification email templates that exist in your account.</p>
    #[serde(rename = "CustomVerificationEmailTemplates")]
    #[serde(default)]
    pub custom_verification_email_templates:
        std::option::Option<std::vec::Vec<crate::model::CustomVerificationEmailTemplateMetadata>>,
    /// <p>A token indicating that there are additional custom verification email templates
    /// available to be listed. Pass this token to a subsequent call to
    /// <code>ListCustomVerificationEmailTemplates</code> to retrieve the next 50 custom
    /// verification email templates.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListCustomVerificationEmailTemplatesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListCustomVerificationEmailTemplatesOutputBody");
        formatter.field(
            "custom_verification_email_templates",
            &self.custom_verification_email_templates,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>A list of dedicated IP pools.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDedicatedIpPoolsOutputBody {
    /// <p>A list of all of the dedicated IP pools that are associated with your AWS account in
    /// the current Region.</p>
    #[serde(rename = "DedicatedIpPools")]
    #[serde(default)]
    pub dedicated_ip_pools: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A token that indicates that there are additional IP pools to list. To view additional
    /// IP pools, issue another request to <code>ListDedicatedIpPools</code>, passing this token
    /// in the <code>NextToken</code> parameter.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDedicatedIpPoolsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDedicatedIpPoolsOutputBody");
        formatter.field("dedicated_ip_pools", &self.dedicated_ip_pools);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>A list of the predictive inbox placement test reports that are available for your account, regardless of
/// whether or not those tests are complete.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDeliverabilityTestReportsOutputBody {
    /// <p>An object that contains a lists of predictive inbox placement tests that you've performed.</p>
    #[serde(rename = "DeliverabilityTestReports")]
    #[serde(default)]
    pub deliverability_test_reports:
        std::option::Option<std::vec::Vec<crate::model::DeliverabilityTestReport>>,
    /// <p>A token that indicates that there are additional predictive inbox placement tests to list. To view additional
    /// predictive inbox placement tests, issue another request to <code>ListDeliverabilityTestReports</code>, and pass
    /// this token in the <code>NextToken</code> parameter.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDeliverabilityTestReportsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDeliverabilityTestReportsOutputBody");
        formatter.field(
            "deliverability_test_reports",
            &self.deliverability_test_reports,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>An array of objects that provide deliverability data for all the campaigns that used a
/// specific domain to send email during a specified time range. This data is available for
/// a domain only if you enabled the Deliverability dashboard for the domain.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListDomainDeliverabilityCampaignsOutputBody {
    /// <p>An array of responses, one for each campaign that used the domain to send email during
    /// the specified time range.</p>
    #[serde(rename = "DomainDeliverabilityCampaigns")]
    #[serde(default)]
    pub domain_deliverability_campaigns:
        std::option::Option<std::vec::Vec<crate::model::DomainDeliverabilityCampaign>>,
    /// <p>A token that’s returned from a previous call to the
    /// <code>ListDomainDeliverabilityCampaigns</code> operation. This token indicates the
    /// position of the campaign in the list of campaigns.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListDomainDeliverabilityCampaignsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListDomainDeliverabilityCampaignsOutputBody");
        formatter.field(
            "domain_deliverability_campaigns",
            &self.domain_deliverability_campaigns,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>A list of all of the identities that you've attempted to verify, regardless of whether
/// or not those identities were successfully verified.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEmailIdentitiesOutputBody {
    /// <p>An array that includes all of the email identities associated with your AWS
    /// account.</p>
    #[serde(rename = "EmailIdentities")]
    #[serde(default)]
    pub email_identities: std::option::Option<std::vec::Vec<crate::model::IdentityInfo>>,
    /// <p>A token that indicates that there are additional configuration sets to list. To view
    /// additional configuration sets, issue another request to
    /// <code>ListEmailIdentities</code>, and pass this token in the <code>NextToken</code>
    /// parameter.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEmailIdentitiesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEmailIdentitiesOutputBody");
        formatter.field("email_identities", &self.email_identities);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>The following elements are returned by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEmailTemplatesOutputBody {
    /// <p>An array the contains the name and creation time stamp for each template in your Amazon SES
    /// account.</p>
    #[serde(rename = "TemplatesMetadata")]
    #[serde(default)]
    pub templates_metadata: std::option::Option<std::vec::Vec<crate::model::EmailTemplateMetadata>>,
    /// <p>A token indicating that there are additional email templates available to be listed.
    /// Pass this token to a subsequent <code>ListEmailTemplates</code> call to retrieve the
    /// next 10 email templates.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEmailTemplatesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEmailTemplatesOutputBody");
        formatter.field("templates_metadata", &self.templates_metadata);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>An HTTP 200 response if the request succeeds, or an error message if the request
/// fails.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImportJobsOutputBody {
    /// <p>A list of the import job summaries.</p>
    #[serde(rename = "ImportJobs")]
    #[serde(default)]
    pub import_jobs: std::option::Option<std::vec::Vec<crate::model::ImportJobSummary>>,
    /// <p>A string token indicating that there might be additional import jobs available to be
    /// listed. Copy this token to a subsequent call to <code>ListImportJobs</code> with the
    /// same parameters to retrieve the next page of import jobs.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListImportJobsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImportJobsOutputBody");
        formatter.field("import_jobs", &self.import_jobs);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

/// <p>A list of suppressed email addresses.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSuppressedDestinationsOutputBody {
    /// <p>A list of summaries, each containing a summary for a suppressed email
    /// destination.</p>
    #[serde(rename = "SuppressedDestinationSummaries")]
    #[serde(default)]
    pub suppressed_destination_summaries:
        std::option::Option<std::vec::Vec<crate::model::SuppressedDestinationSummary>>,
    /// <p>A token that indicates that there are additional email addresses on the suppression
    /// list for your account. To view additional suppressed addresses, issue another request to
    /// <code>ListSuppressedDestinations</code>, and pass this token in the
    /// <code>NextToken</code> parameter.</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListSuppressedDestinationsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSuppressedDestinationsOutputBody");
        formatter.field(
            "suppressed_destination_summaries",
            &self.suppressed_destination_summaries,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListTagsForResourceOutputBody {
    /// <p>An array that lists all the tags that are associated with the resource. Each tag
    /// consists of a required tag key (<code>Key</code>) and an associated tag value
    /// (<code>Value</code>)</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for ListTagsForResourceOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListTagsForResourceOutputBody");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

/// <p>If the action is successful, the service sends back an HTTP 200 response.</p>
/// <p>The following data is returned in JSON format by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutEmailIdentityDkimSigningAttributesOutputBody {
    /// <p>The DKIM authentication status of the identity. Amazon SES determines the authentication
    /// status by searching for specific records in the DNS configuration for your domain. If
    /// you used <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy
    /// DKIM</a> to set up DKIM authentication, Amazon SES tries to find three unique CNAME
    /// records in the DNS configuration for your domain.</p>
    /// <p>If you provided a public key to perform DKIM authentication, Amazon SES tries to find a TXT
    /// record that uses the selector that you specified. The value of the TXT record must be a
    /// public key that's paired with the private key that you specified in the process of
    /// creating the identity.</p>
    /// <p>The status can be one of the following:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>PENDING</code> – The verification process was initiated, but Amazon SES
    /// hasn't yet detected the DKIM records in the DNS configuration for the
    /// domain.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SUCCESS</code> – The verification process completed
    /// successfully.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>FAILED</code> – The verification process failed. This typically
    /// occurs when Amazon SES fails to find the DKIM records in the DNS configuration of the
    /// domain.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>TEMPORARY_FAILURE</code> – A temporary issue is preventing Amazon SES
    /// from determining the DKIM authentication status of the domain.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>NOT_STARTED</code> – The DKIM verification process hasn't been
    /// initiated for the domain.</p>
    /// </li>
    /// </ul>
    #[serde(rename = "DkimStatus")]
    #[serde(default)]
    pub dkim_status: std::option::Option<crate::model::DkimStatus>,
    /// <p>If you used <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/easy-dkim.html">Easy DKIM</a> to configure DKIM authentication for the domain, then this object
    /// contains a set of unique strings that you use to create a set of CNAME records that you
    /// add to the DNS configuration for your domain. When Amazon SES detects these records in the
    /// DNS configuration for your domain, the DKIM authentication process is complete.</p>
    /// <p>If you configured DKIM authentication for the domain by providing your own
    /// public-private key pair, then this object contains the selector that's associated with
    /// your public key.</p>
    /// <p>Regardless of the DKIM authentication method you use, Amazon SES searches for the
    /// appropriate records in the DNS configuration of the domain for up to 72 hours.</p>
    #[serde(rename = "DkimTokens")]
    #[serde(default)]
    pub dkim_tokens: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for PutEmailIdentityDkimSigningAttributesOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutEmailIdentityDkimSigningAttributesOutputBody");
        formatter.field("dkim_status", &self.dkim_status);
        formatter.field("dkim_tokens", &self.dkim_tokens);
        formatter.finish()
    }
}

/// <p>The following data is returned in JSON format by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendBulkEmailOutputBody {
    /// <p>A list of <code>BulkMailEntry</code> objects.</p>
    #[serde(rename = "BulkEmailEntryResults")]
    #[serde(default)]
    pub bulk_email_entry_results:
        std::option::Option<std::vec::Vec<crate::model::BulkEmailEntryResult>>,
}
impl std::fmt::Debug for SendBulkEmailOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendBulkEmailOutputBody");
        formatter.field("bulk_email_entry_results", &self.bulk_email_entry_results);
        formatter.finish()
    }
}

/// <p>The following element is returned by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendCustomVerificationEmailOutputBody {
    /// <p>The unique message identifier returned from the
    /// <code>SendCustomVerificationEmail</code> operation.</p>
    #[serde(rename = "MessageId")]
    #[serde(default)]
    pub message_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendCustomVerificationEmailOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendCustomVerificationEmailOutputBody");
        formatter.field("message_id", &self.message_id);
        formatter.finish()
    }
}

/// <p>A unique message ID that you receive when an email is accepted for sending.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct SendEmailOutputBody {
    /// <p>A unique identifier for the message that is generated when the message is
    /// accepted.</p>
    /// <note>
    /// <p>It's possible for Amazon SES to accept a message without sending it. This can happen
    /// when the message that you're trying to send has an attachment contains a virus, or
    /// when you send a templated email that contains invalid personalization content, for
    /// example.</p>
    /// </note>
    #[serde(rename = "MessageId")]
    #[serde(default)]
    pub message_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SendEmailOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendEmailOutputBody");
        formatter.field("message_id", &self.message_id);
        formatter.finish()
    }
}

/// <p>The following element is returned by the service.</p>
#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct TestRenderEmailTemplateOutputBody {
    /// <p>The complete MIME message rendered by applying the data in the
    /// <code>TemplateData</code> parameter to the template specified in the TemplateName
    /// parameter.</p>
    #[serde(rename = "RenderedTemplate")]
    #[serde(default)]
    pub rendered_template: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TestRenderEmailTemplateOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestRenderEmailTemplateOutputBody");
        formatter.field("rendered_template", &self.rendered_template);
        formatter.finish()
    }
}
