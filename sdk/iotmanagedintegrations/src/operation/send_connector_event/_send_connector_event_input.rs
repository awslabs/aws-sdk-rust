// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SendConnectorEventInput {
    /// <p>The id of the connector between the third-party cloud provider and IoT managed integrations.</p>
    pub connector_id: ::std::option::Option<::std::string::String>,
    /// <p>The id of the third-party cloud provider.</p>
    pub user_id: ::std::option::Option<::std::string::String>,
    /// <p>The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing.</p><note>
    /// <p>The field op can have a value of "I" or "U". The field "cn" will contain the capability types.</p>
    /// </note>
    pub operation: ::std::option::Option<crate::types::ConnectorEventOperation>,
    /// <p>The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see <a href="https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf">OCF Security Specification</a>.</p>
    pub operation_version: ::std::option::Option<::std::string::String>,
    /// <p>The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.</p>
    pub status_code: ::std::option::Option<i32>,
    /// <p>The device state change event payload.</p>
    /// <p>This parameter will include the following three fields:</p>
    /// <ul>
    /// <li>
    /// <p><code>uri</code>: <code>schema auc://&lt;PARTNER-DEVICE-ID&gt;/ResourcePath</code> (The <code>Resourcepath</code> corresponds to an OCF resource.)</p></li>
    /// <li>
    /// <p><code>op</code>: For device state changes, this field must populate as <code>n+d</code>.</p></li>
    /// <li>
    /// <p><code>cn</code>: The content depends on the OCF resource referenced in <code>ResourcePath</code>.</p></li>
    /// </ul>
    pub message: ::std::option::Option<::std::string::String>,
    /// <p>The id for the device discovery job.</p>
    pub device_discovery_id: ::std::option::Option<::std::string::String>,
    /// <p>The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).</p><note>
    /// <p>This parameter is used for cloud-to-cloud devices only.</p>
    /// </note>
    pub connector_device_id: ::std::option::Option<::std::string::String>,
    /// <p>The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.</p>
    pub trace_id: ::std::option::Option<::std::string::String>,
    /// <p>The list of devices.</p>
    pub devices: ::std::option::Option<::std::vec::Vec<crate::types::Device>>,
    /// <p>The device endpoint.</p>
    pub matter_endpoint: ::std::option::Option<crate::types::MatterEndpoint>,
}
impl SendConnectorEventInput {
    /// <p>The id of the connector between the third-party cloud provider and IoT managed integrations.</p>
    pub fn connector_id(&self) -> ::std::option::Option<&str> {
        self.connector_id.as_deref()
    }
    /// <p>The id of the third-party cloud provider.</p>
    pub fn user_id(&self) -> ::std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing.</p><note>
    /// <p>The field op can have a value of "I" or "U". The field "cn" will contain the capability types.</p>
    /// </note>
    pub fn operation(&self) -> ::std::option::Option<&crate::types::ConnectorEventOperation> {
        self.operation.as_ref()
    }
    /// <p>The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see <a href="https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf">OCF Security Specification</a>.</p>
    pub fn operation_version(&self) -> ::std::option::Option<&str> {
        self.operation_version.as_deref()
    }
    /// <p>The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.</p>
    pub fn status_code(&self) -> ::std::option::Option<i32> {
        self.status_code
    }
    /// <p>The device state change event payload.</p>
    /// <p>This parameter will include the following three fields:</p>
    /// <ul>
    /// <li>
    /// <p><code>uri</code>: <code>schema auc://&lt;PARTNER-DEVICE-ID&gt;/ResourcePath</code> (The <code>Resourcepath</code> corresponds to an OCF resource.)</p></li>
    /// <li>
    /// <p><code>op</code>: For device state changes, this field must populate as <code>n+d</code>.</p></li>
    /// <li>
    /// <p><code>cn</code>: The content depends on the OCF resource referenced in <code>ResourcePath</code>.</p></li>
    /// </ul>
    pub fn message(&self) -> ::std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>The id for the device discovery job.</p>
    pub fn device_discovery_id(&self) -> ::std::option::Option<&str> {
        self.device_discovery_id.as_deref()
    }
    /// <p>The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).</p><note>
    /// <p>This parameter is used for cloud-to-cloud devices only.</p>
    /// </note>
    pub fn connector_device_id(&self) -> ::std::option::Option<&str> {
        self.connector_device_id.as_deref()
    }
    /// <p>The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.</p>
    pub fn trace_id(&self) -> ::std::option::Option<&str> {
        self.trace_id.as_deref()
    }
    /// <p>The list of devices.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.devices.is_none()`.
    pub fn devices(&self) -> &[crate::types::Device] {
        self.devices.as_deref().unwrap_or_default()
    }
    /// <p>The device endpoint.</p>
    pub fn matter_endpoint(&self) -> ::std::option::Option<&crate::types::MatterEndpoint> {
        self.matter_endpoint.as_ref()
    }
}
impl ::std::fmt::Debug for SendConnectorEventInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SendConnectorEventInput");
        formatter.field("connector_id", &self.connector_id);
        formatter.field("user_id", &"*** Sensitive Data Redacted ***");
        formatter.field("operation", &self.operation);
        formatter.field("operation_version", &"*** Sensitive Data Redacted ***");
        formatter.field("status_code", &"*** Sensitive Data Redacted ***");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.field("device_discovery_id", &self.device_discovery_id);
        formatter.field("connector_device_id", &"*** Sensitive Data Redacted ***");
        formatter.field("trace_id", &self.trace_id);
        formatter.field("devices", &self.devices);
        formatter.field("matter_endpoint", &self.matter_endpoint);
        formatter.finish()
    }
}
impl SendConnectorEventInput {
    /// Creates a new builder-style object to manufacture [`SendConnectorEventInput`](crate::operation::send_connector_event::SendConnectorEventInput).
    pub fn builder() -> crate::operation::send_connector_event::builders::SendConnectorEventInputBuilder {
        crate::operation::send_connector_event::builders::SendConnectorEventInputBuilder::default()
    }
}

/// A builder for [`SendConnectorEventInput`](crate::operation::send_connector_event::SendConnectorEventInput).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct SendConnectorEventInputBuilder {
    pub(crate) connector_id: ::std::option::Option<::std::string::String>,
    pub(crate) user_id: ::std::option::Option<::std::string::String>,
    pub(crate) operation: ::std::option::Option<crate::types::ConnectorEventOperation>,
    pub(crate) operation_version: ::std::option::Option<::std::string::String>,
    pub(crate) status_code: ::std::option::Option<i32>,
    pub(crate) message: ::std::option::Option<::std::string::String>,
    pub(crate) device_discovery_id: ::std::option::Option<::std::string::String>,
    pub(crate) connector_device_id: ::std::option::Option<::std::string::String>,
    pub(crate) trace_id: ::std::option::Option<::std::string::String>,
    pub(crate) devices: ::std::option::Option<::std::vec::Vec<crate::types::Device>>,
    pub(crate) matter_endpoint: ::std::option::Option<crate::types::MatterEndpoint>,
}
impl SendConnectorEventInputBuilder {
    /// <p>The id of the connector between the third-party cloud provider and IoT managed integrations.</p>
    /// This field is required.
    pub fn connector_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.connector_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The id of the connector between the third-party cloud provider and IoT managed integrations.</p>
    pub fn set_connector_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.connector_id = input;
        self
    }
    /// <p>The id of the connector between the third-party cloud provider and IoT managed integrations.</p>
    pub fn get_connector_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.connector_id
    }
    /// <p>The id of the third-party cloud provider.</p>
    pub fn user_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The id of the third-party cloud provider.</p>
    pub fn set_user_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user_id = input;
        self
    }
    /// <p>The id of the third-party cloud provider.</p>
    pub fn get_user_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.user_id
    }
    /// <p>The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing.</p><note>
    /// <p>The field op can have a value of "I" or "U". The field "cn" will contain the capability types.</p>
    /// </note>
    /// This field is required.
    pub fn operation(mut self, input: crate::types::ConnectorEventOperation) -> Self {
        self.operation = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing.</p><note>
    /// <p>The field op can have a value of "I" or "U". The field "cn" will contain the capability types.</p>
    /// </note>
    pub fn set_operation(mut self, input: ::std::option::Option<crate::types::ConnectorEventOperation>) -> Self {
        self.operation = input;
        self
    }
    /// <p>The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing.</p><note>
    /// <p>The field op can have a value of "I" or "U". The field "cn" will contain the capability types.</p>
    /// </note>
    pub fn get_operation(&self) -> &::std::option::Option<crate::types::ConnectorEventOperation> {
        &self.operation
    }
    /// <p>The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see <a href="https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf">OCF Security Specification</a>.</p>
    pub fn operation_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.operation_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see <a href="https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf">OCF Security Specification</a>.</p>
    pub fn set_operation_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.operation_version = input;
        self
    }
    /// <p>The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see <a href="https://openconnectivity.org/specs/OCF_Security_Specification_v1.0.0.pdf">OCF Security Specification</a>.</p>
    pub fn get_operation_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.operation_version
    }
    /// <p>The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.</p>
    pub fn status_code(mut self, input: i32) -> Self {
        self.status_code = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.</p>
    pub fn set_status_code(mut self, input: ::std::option::Option<i32>) -> Self {
        self.status_code = input;
        self
    }
    /// <p>The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.</p>
    pub fn get_status_code(&self) -> &::std::option::Option<i32> {
        &self.status_code
    }
    /// <p>The device state change event payload.</p>
    /// <p>This parameter will include the following three fields:</p>
    /// <ul>
    /// <li>
    /// <p><code>uri</code>: <code>schema auc://&lt;PARTNER-DEVICE-ID&gt;/ResourcePath</code> (The <code>Resourcepath</code> corresponds to an OCF resource.)</p></li>
    /// <li>
    /// <p><code>op</code>: For device state changes, this field must populate as <code>n+d</code>.</p></li>
    /// <li>
    /// <p><code>cn</code>: The content depends on the OCF resource referenced in <code>ResourcePath</code>.</p></li>
    /// </ul>
    pub fn message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The device state change event payload.</p>
    /// <p>This parameter will include the following three fields:</p>
    /// <ul>
    /// <li>
    /// <p><code>uri</code>: <code>schema auc://&lt;PARTNER-DEVICE-ID&gt;/ResourcePath</code> (The <code>Resourcepath</code> corresponds to an OCF resource.)</p></li>
    /// <li>
    /// <p><code>op</code>: For device state changes, this field must populate as <code>n+d</code>.</p></li>
    /// <li>
    /// <p><code>cn</code>: The content depends on the OCF resource referenced in <code>ResourcePath</code>.</p></li>
    /// </ul>
    pub fn set_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message = input;
        self
    }
    /// <p>The device state change event payload.</p>
    /// <p>This parameter will include the following three fields:</p>
    /// <ul>
    /// <li>
    /// <p><code>uri</code>: <code>schema auc://&lt;PARTNER-DEVICE-ID&gt;/ResourcePath</code> (The <code>Resourcepath</code> corresponds to an OCF resource.)</p></li>
    /// <li>
    /// <p><code>op</code>: For device state changes, this field must populate as <code>n+d</code>.</p></li>
    /// <li>
    /// <p><code>cn</code>: The content depends on the OCF resource referenced in <code>ResourcePath</code>.</p></li>
    /// </ul>
    pub fn get_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.message
    }
    /// <p>The id for the device discovery job.</p>
    pub fn device_discovery_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.device_discovery_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The id for the device discovery job.</p>
    pub fn set_device_discovery_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.device_discovery_id = input;
        self
    }
    /// <p>The id for the device discovery job.</p>
    pub fn get_device_discovery_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.device_discovery_id
    }
    /// <p>The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).</p><note>
    /// <p>This parameter is used for cloud-to-cloud devices only.</p>
    /// </note>
    pub fn connector_device_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.connector_device_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).</p><note>
    /// <p>This parameter is used for cloud-to-cloud devices only.</p>
    /// </note>
    pub fn set_connector_device_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.connector_device_id = input;
        self
    }
    /// <p>The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).</p><note>
    /// <p>This parameter is used for cloud-to-cloud devices only.</p>
    /// </note>
    pub fn get_connector_device_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.connector_device_id
    }
    /// <p>The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.</p>
    pub fn trace_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.trace_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.</p>
    pub fn set_trace_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.trace_id = input;
        self
    }
    /// <p>The trace request identifier. This is generated by IoT managed integrations and can be used to trace this command and its related operations in CloudWatch.</p>
    pub fn get_trace_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.trace_id
    }
    /// Appends an item to `devices`.
    ///
    /// To override the contents of this collection use [`set_devices`](Self::set_devices).
    ///
    /// <p>The list of devices.</p>
    pub fn devices(mut self, input: crate::types::Device) -> Self {
        let mut v = self.devices.unwrap_or_default();
        v.push(input);
        self.devices = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of devices.</p>
    pub fn set_devices(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Device>>) -> Self {
        self.devices = input;
        self
    }
    /// <p>The list of devices.</p>
    pub fn get_devices(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Device>> {
        &self.devices
    }
    /// <p>The device endpoint.</p>
    pub fn matter_endpoint(mut self, input: crate::types::MatterEndpoint) -> Self {
        self.matter_endpoint = ::std::option::Option::Some(input);
        self
    }
    /// <p>The device endpoint.</p>
    pub fn set_matter_endpoint(mut self, input: ::std::option::Option<crate::types::MatterEndpoint>) -> Self {
        self.matter_endpoint = input;
        self
    }
    /// <p>The device endpoint.</p>
    pub fn get_matter_endpoint(&self) -> &::std::option::Option<crate::types::MatterEndpoint> {
        &self.matter_endpoint
    }
    /// Consumes the builder and constructs a [`SendConnectorEventInput`](crate::operation::send_connector_event::SendConnectorEventInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::send_connector_event::SendConnectorEventInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::send_connector_event::SendConnectorEventInput {
            connector_id: self.connector_id,
            user_id: self.user_id,
            operation: self.operation,
            operation_version: self.operation_version,
            status_code: self.status_code,
            message: self.message,
            device_discovery_id: self.device_discovery_id,
            connector_device_id: self.connector_device_id,
            trace_id: self.trace_id,
            devices: self.devices,
            matter_endpoint: self.matter_endpoint,
        })
    }
}
impl ::std::fmt::Debug for SendConnectorEventInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SendConnectorEventInputBuilder");
        formatter.field("connector_id", &self.connector_id);
        formatter.field("user_id", &"*** Sensitive Data Redacted ***");
        formatter.field("operation", &self.operation);
        formatter.field("operation_version", &"*** Sensitive Data Redacted ***");
        formatter.field("status_code", &"*** Sensitive Data Redacted ***");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.field("device_discovery_id", &self.device_discovery_id);
        formatter.field("connector_device_id", &"*** Sensitive Data Redacted ***");
        formatter.field("trace_id", &self.trace_id);
        formatter.field("devices", &self.devices);
        formatter.field("matter_endpoint", &self.matter_endpoint);
        formatter.finish()
    }
}
