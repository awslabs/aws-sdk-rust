// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignInstanceOutput, crate::error::AssignInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AssignInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AssignInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::AssignInstanceError { meta: generic, kind: crate::error::AssignInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssignInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::AssignInstanceError { meta: generic, kind: crate::error::AssignInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssignInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AssignInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignInstanceOutput, crate::error::AssignInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::assign_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignVolumeOutput, crate::error::AssignVolumeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AssignVolumeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AssignVolumeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::AssignVolumeError { meta: generic, kind: crate::error::AssignVolumeErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssignVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::AssignVolumeError { meta: generic, kind: crate::error::AssignVolumeErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssignVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AssignVolumeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_assign_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssignVolumeOutput, crate::error::AssignVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::assign_volume_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_elastic_ip_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateElasticIpOutput, crate::error::AssociateElasticIpError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AssociateElasticIpError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AssociateElasticIpError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::AssociateElasticIpError { meta: generic, kind: crate::error::AssociateElasticIpErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::AssociateElasticIpError { meta: generic, kind: crate::error::AssociateElasticIpErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AssociateElasticIpError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_elastic_ip_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateElasticIpOutput, crate::error::AssociateElasticIpError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_elastic_ip_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_elastic_load_balancer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachElasticLoadBalancerOutput, crate::error::AttachElasticLoadBalancerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AttachElasticLoadBalancerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AttachElasticLoadBalancerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::AttachElasticLoadBalancerError { meta: generic, kind: crate::error::AttachElasticLoadBalancerErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AttachElasticLoadBalancerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::AttachElasticLoadBalancerError { meta: generic, kind: crate::error::AttachElasticLoadBalancerErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AttachElasticLoadBalancerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AttachElasticLoadBalancerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_attach_elastic_load_balancer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AttachElasticLoadBalancerOutput, crate::error::AttachElasticLoadBalancerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::attach_elastic_load_balancer_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_clone_stack_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CloneStackOutput, crate::error::CloneStackError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CloneStackError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CloneStackError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::CloneStackError { meta: generic, kind: crate::error::CloneStackErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CloneStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::CloneStackError { meta: generic, kind: crate::error::CloneStackErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CloneStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CloneStackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_clone_stack_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CloneStackOutput, crate::error::CloneStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::clone_stack_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_clone_stack(response.body().as_ref(), output).map_err(crate::error::CloneStackError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_app_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAppOutput, crate::error::CreateAppError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateAppError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateAppError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::CreateAppError { meta: generic, kind: crate::error::CreateAppErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAppError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::CreateAppError { meta: generic, kind: crate::error::CreateAppErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateAppError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateAppError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_app_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateAppOutput, crate::error::CreateAppError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_app_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_app(response.body().as_ref(), output).map_err(crate::error::CreateAppError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deployment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateDeploymentError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateDeploymentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::CreateDeploymentError { meta: generic, kind: crate::error::CreateDeploymentErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDeploymentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::CreateDeploymentError { meta: generic, kind: crate::error::CreateDeploymentErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDeploymentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateDeploymentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_deployment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateDeploymentOutput, crate::error::CreateDeploymentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_deployment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_deployment(response.body().as_ref(), output).map_err(crate::error::CreateDeploymentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInstanceOutput, crate::error::CreateInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::CreateInstanceError { meta: generic, kind: crate::error::CreateInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::CreateInstanceError { meta: generic, kind: crate::error::CreateInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateInstanceOutput, crate::error::CreateInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_instance(response.body().as_ref(), output).map_err(crate::error::CreateInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_layer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLayerOutput, crate::error::CreateLayerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateLayerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateLayerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::CreateLayerError { meta: generic, kind: crate::error::CreateLayerErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLayerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::CreateLayerError { meta: generic, kind: crate::error::CreateLayerErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLayerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateLayerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_layer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateLayerOutput, crate::error::CreateLayerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_layer_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_layer(response.body().as_ref(), output).map_err(crate::error::CreateLayerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStackOutput, crate::error::CreateStackError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateStackError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateStackError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ValidationException" => crate::error::CreateStackError { meta: generic, kind: crate::error::CreateStackErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateStackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_stack_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateStackOutput, crate::error::CreateStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_stack_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_stack(response.body().as_ref(), output).map_err(crate::error::CreateStackError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateUserProfileOutput, crate::error::CreateUserProfileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateUserProfileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateUserProfileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ValidationException" => crate::error::CreateUserProfileError { meta: generic, kind: crate::error::CreateUserProfileErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUserProfileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateUserProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_user_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateUserProfileOutput, crate::error::CreateUserProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_user_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_user_profile(response.body().as_ref(), output).map_err(crate::error::CreateUserProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_app_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteAppOutput, crate::error::DeleteAppError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteAppError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteAppError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeleteAppError { meta: generic, kind: crate::error::DeleteAppErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAppError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeleteAppError { meta: generic, kind: crate::error::DeleteAppErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteAppError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteAppError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_app_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteAppOutput, crate::error::DeleteAppError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_app_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInstanceOutput, crate::error::DeleteInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeleteInstanceError { meta: generic, kind: crate::error::DeleteInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeleteInstanceError { meta: generic, kind: crate::error::DeleteInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteInstanceOutput, crate::error::DeleteInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_layer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLayerOutput, crate::error::DeleteLayerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteLayerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteLayerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeleteLayerError { meta: generic, kind: crate::error::DeleteLayerErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLayerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeleteLayerError { meta: generic, kind: crate::error::DeleteLayerErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLayerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteLayerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_layer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteLayerOutput, crate::error::DeleteLayerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_layer_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteStackOutput, crate::error::DeleteStackError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteStackError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteStackError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeleteStackError { meta: generic, kind: crate::error::DeleteStackErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeleteStackError { meta: generic, kind: crate::error::DeleteStackErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteStackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_stack_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteStackOutput, crate::error::DeleteStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_stack_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteUserProfileOutput, crate::error::DeleteUserProfileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteUserProfileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteUserProfileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeleteUserProfileError { meta: generic, kind: crate::error::DeleteUserProfileErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserProfileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeleteUserProfileError { meta: generic, kind: crate::error::DeleteUserProfileErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteUserProfileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteUserProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_user_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteUserProfileOutput, crate::error::DeleteUserProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_user_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_ecs_cluster_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterEcsClusterOutput, crate::error::DeregisterEcsClusterError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterEcsClusterError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterEcsClusterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeregisterEcsClusterError { meta: generic, kind: crate::error::DeregisterEcsClusterErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterEcsClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeregisterEcsClusterError { meta: generic, kind: crate::error::DeregisterEcsClusterErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterEcsClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterEcsClusterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_ecs_cluster_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterEcsClusterOutput, crate::error::DeregisterEcsClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_ecs_cluster_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_elastic_ip_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterElasticIpOutput, crate::error::DeregisterElasticIpError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterElasticIpError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterElasticIpError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeregisterElasticIpError { meta: generic, kind: crate::error::DeregisterElasticIpErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeregisterElasticIpError { meta: generic, kind: crate::error::DeregisterElasticIpErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterElasticIpError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_elastic_ip_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterElasticIpOutput, crate::error::DeregisterElasticIpError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_elastic_ip_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterInstanceOutput, crate::error::DeregisterInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeregisterInstanceError { meta: generic, kind: crate::error::DeregisterInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeregisterInstanceError { meta: generic, kind: crate::error::DeregisterInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterInstanceOutput, crate::error::DeregisterInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_rds_db_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterRdsDbInstanceOutput, crate::error::DeregisterRdsDbInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterRdsDbInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterRdsDbInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeregisterRdsDbInstanceError { meta: generic, kind: crate::error::DeregisterRdsDbInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterRdsDbInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeregisterRdsDbInstanceError { meta: generic, kind: crate::error::DeregisterRdsDbInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterRdsDbInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterRdsDbInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_rds_db_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterRdsDbInstanceOutput, crate::error::DeregisterRdsDbInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_rds_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterVolumeOutput, crate::error::DeregisterVolumeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeregisterVolumeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeregisterVolumeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DeregisterVolumeError { meta: generic, kind: crate::error::DeregisterVolumeErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DeregisterVolumeError { meta: generic, kind: crate::error::DeregisterVolumeErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeregisterVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeregisterVolumeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_deregister_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeregisterVolumeOutput, crate::error::DeregisterVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::deregister_volume_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_agent_versions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAgentVersionsOutput, crate::error::DescribeAgentVersionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeAgentVersionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAgentVersionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeAgentVersionsError { meta: generic, kind: crate::error::DescribeAgentVersionsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAgentVersionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeAgentVersionsError { meta: generic, kind: crate::error::DescribeAgentVersionsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAgentVersionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAgentVersionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_agent_versions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAgentVersionsOutput, crate::error::DescribeAgentVersionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_agent_versions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_agent_versions(response.body().as_ref(), output).map_err(crate::error::DescribeAgentVersionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_apps_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAppsOutput, crate::error::DescribeAppsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeAppsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeAppsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeAppsError { meta: generic, kind: crate::error::DescribeAppsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAppsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeAppsError { meta: generic, kind: crate::error::DescribeAppsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeAppsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeAppsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_apps_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeAppsOutput, crate::error::DescribeAppsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_apps_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_apps(response.body().as_ref(), output).map_err(crate::error::DescribeAppsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_commands_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCommandsOutput, crate::error::DescribeCommandsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeCommandsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeCommandsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeCommandsError { meta: generic, kind: crate::error::DescribeCommandsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeCommandsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeCommandsError { meta: generic, kind: crate::error::DescribeCommandsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeCommandsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeCommandsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_commands_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeCommandsOutput, crate::error::DescribeCommandsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_commands_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_commands(response.body().as_ref(), output).map_err(crate::error::DescribeCommandsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_deployments_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDeploymentsOutput, crate::error::DescribeDeploymentsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeDeploymentsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeDeploymentsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeDeploymentsError { meta: generic, kind: crate::error::DescribeDeploymentsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDeploymentsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeDeploymentsError { meta: generic, kind: crate::error::DescribeDeploymentsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDeploymentsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDeploymentsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_deployments_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeDeploymentsOutput, crate::error::DescribeDeploymentsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_deployments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_deployments(response.body().as_ref(), output).map_err(crate::error::DescribeDeploymentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ecs_clusters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEcsClustersOutput, crate::error::DescribeEcsClustersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeEcsClustersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeEcsClustersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeEcsClustersError { meta: generic, kind: crate::error::DescribeEcsClustersErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEcsClustersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeEcsClustersError { meta: generic, kind: crate::error::DescribeEcsClustersErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeEcsClustersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeEcsClustersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_ecs_clusters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeEcsClustersOutput, crate::error::DescribeEcsClustersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_ecs_clusters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_ecs_clusters(response.body().as_ref(), output).map_err(crate::error::DescribeEcsClustersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_ips_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeElasticIpsOutput, crate::error::DescribeElasticIpsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeElasticIpsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeElasticIpsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeElasticIpsError { meta: generic, kind: crate::error::DescribeElasticIpsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeElasticIpsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeElasticIpsError { meta: generic, kind: crate::error::DescribeElasticIpsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeElasticIpsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeElasticIpsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_ips_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeElasticIpsOutput, crate::error::DescribeElasticIpsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_elastic_ips_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_elastic_ips(response.body().as_ref(), output).map_err(crate::error::DescribeElasticIpsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_load_balancers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeElasticLoadBalancersOutput, crate::error::DescribeElasticLoadBalancersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeElasticLoadBalancersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeElasticLoadBalancersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeElasticLoadBalancersError { meta: generic, kind: crate::error::DescribeElasticLoadBalancersErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeElasticLoadBalancersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeElasticLoadBalancersError { meta: generic, kind: crate::error::DescribeElasticLoadBalancersErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeElasticLoadBalancersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeElasticLoadBalancersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_elastic_load_balancers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeElasticLoadBalancersOutput, crate::error::DescribeElasticLoadBalancersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_elastic_load_balancers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_elastic_load_balancers(response.body().as_ref(), output).map_err(crate::error::DescribeElasticLoadBalancersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeInstancesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeInstancesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeInstancesError { meta: generic, kind: crate::error::DescribeInstancesErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeInstancesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeInstancesOutput, crate::error::DescribeInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_instances(response.body().as_ref(), output).map_err(crate::error::DescribeInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_layers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLayersOutput, crate::error::DescribeLayersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeLayersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeLayersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeLayersError { meta: generic, kind: crate::error::DescribeLayersErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLayersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeLayersError { meta: generic, kind: crate::error::DescribeLayersErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLayersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeLayersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_layers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLayersOutput, crate::error::DescribeLayersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_layers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_layers(response.body().as_ref(), output).map_err(crate::error::DescribeLayersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_load_based_auto_scaling_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLoadBasedAutoScalingOutput, crate::error::DescribeLoadBasedAutoScalingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeLoadBasedAutoScalingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeLoadBasedAutoScalingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeLoadBasedAutoScalingError { meta: generic, kind: crate::error::DescribeLoadBasedAutoScalingErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoadBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeLoadBasedAutoScalingError { meta: generic, kind: crate::error::DescribeLoadBasedAutoScalingErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoadBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeLoadBasedAutoScalingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_load_based_auto_scaling_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeLoadBasedAutoScalingOutput, crate::error::DescribeLoadBasedAutoScalingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_load_based_auto_scaling_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_load_based_auto_scaling(response.body().as_ref(), output).map_err(crate::error::DescribeLoadBasedAutoScalingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_my_user_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMyUserProfileOutput, crate::error::DescribeMyUserProfileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeMyUserProfileError::unhandled)?;
    Err(crate::error::DescribeMyUserProfileError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_my_user_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMyUserProfileOutput, crate::error::DescribeMyUserProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_my_user_profile_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_my_user_profile(response.body().as_ref(), output).map_err(crate::error::DescribeMyUserProfileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_operating_systems_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeOperatingSystemsOutput, crate::error::DescribeOperatingSystemsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeOperatingSystemsError::unhandled)?;
    Err(crate::error::DescribeOperatingSystemsError::generic(generic))
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_operating_systems_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeOperatingSystemsOutput, crate::error::DescribeOperatingSystemsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_operating_systems_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_operating_systems(response.body().as_ref(), output).map_err(crate::error::DescribeOperatingSystemsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_permissions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePermissionsOutput, crate::error::DescribePermissionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribePermissionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePermissionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribePermissionsError { meta: generic, kind: crate::error::DescribePermissionsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribePermissionsError { meta: generic, kind: crate::error::DescribePermissionsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePermissionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribePermissionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_permissions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePermissionsOutput, crate::error::DescribePermissionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_permissions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_permissions(response.body().as_ref(), output).map_err(crate::error::DescribePermissionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_raid_arrays_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRaidArraysOutput, crate::error::DescribeRaidArraysError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeRaidArraysError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeRaidArraysError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeRaidArraysError { meta: generic, kind: crate::error::DescribeRaidArraysErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRaidArraysError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeRaidArraysError { meta: generic, kind: crate::error::DescribeRaidArraysErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRaidArraysError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeRaidArraysError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_raid_arrays_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRaidArraysOutput, crate::error::DescribeRaidArraysError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_raid_arrays_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_raid_arrays(response.body().as_ref(), output).map_err(crate::error::DescribeRaidArraysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_rds_db_instances_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRdsDbInstancesOutput, crate::error::DescribeRdsDbInstancesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeRdsDbInstancesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeRdsDbInstancesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeRdsDbInstancesError { meta: generic, kind: crate::error::DescribeRdsDbInstancesErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRdsDbInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeRdsDbInstancesError { meta: generic, kind: crate::error::DescribeRdsDbInstancesErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRdsDbInstancesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeRdsDbInstancesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_rds_db_instances_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeRdsDbInstancesOutput, crate::error::DescribeRdsDbInstancesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_rds_db_instances_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_rds_db_instances(response.body().as_ref(), output).map_err(crate::error::DescribeRdsDbInstancesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_service_errors_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeServiceErrorsOutput, crate::error::DescribeServiceErrorsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeServiceErrorsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeServiceErrorsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeServiceErrorsError { meta: generic, kind: crate::error::DescribeServiceErrorsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeServiceErrorsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeServiceErrorsError { meta: generic, kind: crate::error::DescribeServiceErrorsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeServiceErrorsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeServiceErrorsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_service_errors_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeServiceErrorsOutput, crate::error::DescribeServiceErrorsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_service_errors_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_service_errors(response.body().as_ref(), output).map_err(crate::error::DescribeServiceErrorsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_provisioning_parameters_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStackProvisioningParametersOutput, crate::error::DescribeStackProvisioningParametersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeStackProvisioningParametersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeStackProvisioningParametersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeStackProvisioningParametersError { meta: generic, kind: crate::error::DescribeStackProvisioningParametersErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackProvisioningParametersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeStackProvisioningParametersError { meta: generic, kind: crate::error::DescribeStackProvisioningParametersErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackProvisioningParametersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeStackProvisioningParametersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_provisioning_parameters_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStackProvisioningParametersOutput, crate::error::DescribeStackProvisioningParametersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_provisioning_parameters_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_stack_provisioning_parameters(response.body().as_ref(), output).map_err(crate::error::DescribeStackProvisioningParametersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stacks_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStacksOutput, crate::error::DescribeStacksError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeStacksError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeStacksError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeStacksError { meta: generic, kind: crate::error::DescribeStacksErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStacksError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeStacksError { meta: generic, kind: crate::error::DescribeStacksErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStacksError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeStacksError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stacks_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStacksOutput, crate::error::DescribeStacksError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stacks_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_stacks(response.body().as_ref(), output).map_err(crate::error::DescribeStacksError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_summary_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStackSummaryOutput, crate::error::DescribeStackSummaryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeStackSummaryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeStackSummaryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeStackSummaryError { meta: generic, kind: crate::error::DescribeStackSummaryErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeStackSummaryError { meta: generic, kind: crate::error::DescribeStackSummaryErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeStackSummaryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeStackSummaryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_stack_summary_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeStackSummaryOutput, crate::error::DescribeStackSummaryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_stack_summary_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_stack_summary(response.body().as_ref(), output).map_err(crate::error::DescribeStackSummaryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_time_based_auto_scaling_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTimeBasedAutoScalingOutput, crate::error::DescribeTimeBasedAutoScalingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeTimeBasedAutoScalingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeTimeBasedAutoScalingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeTimeBasedAutoScalingError { meta: generic, kind: crate::error::DescribeTimeBasedAutoScalingErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeTimeBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeTimeBasedAutoScalingError { meta: generic, kind: crate::error::DescribeTimeBasedAutoScalingErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeTimeBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeTimeBasedAutoScalingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_time_based_auto_scaling_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeTimeBasedAutoScalingOutput, crate::error::DescribeTimeBasedAutoScalingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_time_based_auto_scaling_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_time_based_auto_scaling(response.body().as_ref(), output).map_err(crate::error::DescribeTimeBasedAutoScalingError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_user_profiles_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeUserProfilesOutput, crate::error::DescribeUserProfilesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeUserProfilesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeUserProfilesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeUserProfilesError { meta: generic, kind: crate::error::DescribeUserProfilesErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeUserProfilesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeUserProfilesError { meta: generic, kind: crate::error::DescribeUserProfilesErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeUserProfilesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeUserProfilesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_user_profiles_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeUserProfilesOutput, crate::error::DescribeUserProfilesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_user_profiles_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_user_profiles(response.body().as_ref(), output).map_err(crate::error::DescribeUserProfilesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumesOutput, crate::error::DescribeVolumesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeVolumesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeVolumesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DescribeVolumesError { meta: generic, kind: crate::error::DescribeVolumesErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVolumesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DescribeVolumesError { meta: generic, kind: crate::error::DescribeVolumesErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVolumesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeVolumesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_volumes_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeVolumesOutput, crate::error::DescribeVolumesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_volumes_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_volumes(response.body().as_ref(), output).map_err(crate::error::DescribeVolumesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_elastic_load_balancer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachElasticLoadBalancerOutput, crate::error::DetachElasticLoadBalancerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DetachElasticLoadBalancerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DetachElasticLoadBalancerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DetachElasticLoadBalancerError { meta: generic, kind: crate::error::DetachElasticLoadBalancerErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DetachElasticLoadBalancerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DetachElasticLoadBalancerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_detach_elastic_load_balancer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DetachElasticLoadBalancerOutput, crate::error::DetachElasticLoadBalancerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::detach_elastic_load_balancer_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_elastic_ip_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateElasticIpOutput, crate::error::DisassociateElasticIpError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DisassociateElasticIpError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DisassociateElasticIpError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::DisassociateElasticIpError { meta: generic, kind: crate::error::DisassociateElasticIpErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::DisassociateElasticIpError { meta: generic, kind: crate::error::DisassociateElasticIpErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DisassociateElasticIpError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_elastic_ip_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateElasticIpOutput, crate::error::DisassociateElasticIpError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_elastic_ip_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hostname_suggestion_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetHostnameSuggestionOutput, crate::error::GetHostnameSuggestionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetHostnameSuggestionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetHostnameSuggestionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::GetHostnameSuggestionError { meta: generic, kind: crate::error::GetHostnameSuggestionErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetHostnameSuggestionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GetHostnameSuggestionError { meta: generic, kind: crate::error::GetHostnameSuggestionErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetHostnameSuggestionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetHostnameSuggestionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_hostname_suggestion_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetHostnameSuggestionOutput, crate::error::GetHostnameSuggestionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_hostname_suggestion_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_hostname_suggestion(response.body().as_ref(), output).map_err(crate::error::GetHostnameSuggestionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_grant_access_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GrantAccessOutput, crate::error::GrantAccessError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GrantAccessError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GrantAccessError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::GrantAccessError { meta: generic, kind: crate::error::GrantAccessErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GrantAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::GrantAccessError { meta: generic, kind: crate::error::GrantAccessErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GrantAccessError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GrantAccessError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_grant_access_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GrantAccessOutput, crate::error::GrantAccessError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::grant_access_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_grant_access(response.body().as_ref(), output).map_err(crate::error::GrantAccessError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListTagsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListTagsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::ListTagsError { meta: generic, kind: crate::error::ListTagsErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::ListTagsError { meta: generic, kind: crate::error::ListTagsErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListTagsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsOutput, crate::error::ListTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags(response.body().as_ref(), output).map_err(crate::error::ListTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RebootInstanceOutput, crate::error::RebootInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RebootInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RebootInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::RebootInstanceError { meta: generic, kind: crate::error::RebootInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RebootInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::RebootInstanceError { meta: generic, kind: crate::error::RebootInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RebootInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RebootInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_reboot_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RebootInstanceOutput, crate::error::RebootInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::reboot_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_ecs_cluster_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterEcsClusterOutput, crate::error::RegisterEcsClusterError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterEcsClusterError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterEcsClusterError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::RegisterEcsClusterError { meta: generic, kind: crate::error::RegisterEcsClusterErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterEcsClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::RegisterEcsClusterError { meta: generic, kind: crate::error::RegisterEcsClusterErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterEcsClusterError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterEcsClusterError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_ecs_cluster_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterEcsClusterOutput, crate::error::RegisterEcsClusterError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_ecs_cluster_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_ecs_cluster(response.body().as_ref(), output).map_err(crate::error::RegisterEcsClusterError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_elastic_ip_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterElasticIpOutput, crate::error::RegisterElasticIpError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterElasticIpError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterElasticIpError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::RegisterElasticIpError { meta: generic, kind: crate::error::RegisterElasticIpErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::RegisterElasticIpError { meta: generic, kind: crate::error::RegisterElasticIpErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterElasticIpError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_elastic_ip_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterElasticIpOutput, crate::error::RegisterElasticIpError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_elastic_ip_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_elastic_ip(response.body().as_ref(), output).map_err(crate::error::RegisterElasticIpError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterInstanceOutput, crate::error::RegisterInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::RegisterInstanceError { meta: generic, kind: crate::error::RegisterInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::RegisterInstanceError { meta: generic, kind: crate::error::RegisterInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterInstanceOutput, crate::error::RegisterInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_instance_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_instance(response.body().as_ref(), output).map_err(crate::error::RegisterInstanceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_rds_db_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterRdsDbInstanceOutput, crate::error::RegisterRdsDbInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterRdsDbInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterRdsDbInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::RegisterRdsDbInstanceError { meta: generic, kind: crate::error::RegisterRdsDbInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterRdsDbInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::RegisterRdsDbInstanceError { meta: generic, kind: crate::error::RegisterRdsDbInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterRdsDbInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterRdsDbInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_rds_db_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterRdsDbInstanceOutput, crate::error::RegisterRdsDbInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_rds_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterVolumeOutput, crate::error::RegisterVolumeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::RegisterVolumeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::RegisterVolumeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::RegisterVolumeError { meta: generic, kind: crate::error::RegisterVolumeErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::RegisterVolumeError { meta: generic, kind: crate::error::RegisterVolumeErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::RegisterVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::RegisterVolumeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_register_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::RegisterVolumeOutput, crate::error::RegisterVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::register_volume_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_register_volume(response.body().as_ref(), output).map_err(crate::error::RegisterVolumeError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_load_based_auto_scaling_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetLoadBasedAutoScalingOutput, crate::error::SetLoadBasedAutoScalingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SetLoadBasedAutoScalingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SetLoadBasedAutoScalingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::SetLoadBasedAutoScalingError { meta: generic, kind: crate::error::SetLoadBasedAutoScalingErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SetLoadBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::SetLoadBasedAutoScalingError { meta: generic, kind: crate::error::SetLoadBasedAutoScalingErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SetLoadBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SetLoadBasedAutoScalingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_load_based_auto_scaling_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetLoadBasedAutoScalingOutput, crate::error::SetLoadBasedAutoScalingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_load_based_auto_scaling_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_permission_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetPermissionOutput, crate::error::SetPermissionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SetPermissionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SetPermissionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::SetPermissionError { meta: generic, kind: crate::error::SetPermissionErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SetPermissionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::SetPermissionError { meta: generic, kind: crate::error::SetPermissionErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SetPermissionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SetPermissionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_permission_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetPermissionOutput, crate::error::SetPermissionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_permission_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_time_based_auto_scaling_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetTimeBasedAutoScalingOutput, crate::error::SetTimeBasedAutoScalingError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::SetTimeBasedAutoScalingError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::SetTimeBasedAutoScalingError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::SetTimeBasedAutoScalingError { meta: generic, kind: crate::error::SetTimeBasedAutoScalingErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SetTimeBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::SetTimeBasedAutoScalingError { meta: generic, kind: crate::error::SetTimeBasedAutoScalingErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::SetTimeBasedAutoScalingError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::SetTimeBasedAutoScalingError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_set_time_based_auto_scaling_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::SetTimeBasedAutoScalingOutput, crate::error::SetTimeBasedAutoScalingError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::set_time_based_auto_scaling_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartInstanceOutput, crate::error::StartInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::StartInstanceError { meta: generic, kind: crate::error::StartInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::StartInstanceError { meta: generic, kind: crate::error::StartInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartInstanceOutput, crate::error::StartInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_stack_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartStackOutput, crate::error::StartStackError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StartStackError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StartStackError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::StartStackError { meta: generic, kind: crate::error::StartStackErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::StartStackError { meta: generic, kind: crate::error::StartStackErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StartStackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_stack_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StartStackOutput, crate::error::StartStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_stack_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopInstanceOutput, crate::error::StopInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::StopInstanceError { meta: generic, kind: crate::error::StopInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::StopInstanceError { meta: generic, kind: crate::error::StopInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopInstanceOutput, crate::error::StopInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_stack_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopStackOutput, crate::error::StopStackError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::StopStackError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::StopStackError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::StopStackError { meta: generic, kind: crate::error::StopStackErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::StopStackError { meta: generic, kind: crate::error::StopStackErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::StopStackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_stack_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::StopStackOutput, crate::error::StopStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_stack_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignInstanceOutput, crate::error::UnassignInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UnassignInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UnassignInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UnassignInstanceError { meta: generic, kind: crate::error::UnassignInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UnassignInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UnassignInstanceError { meta: generic, kind: crate::error::UnassignInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UnassignInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UnassignInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignInstanceOutput, crate::error::UnassignInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unassign_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignVolumeOutput, crate::error::UnassignVolumeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UnassignVolumeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UnassignVolumeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UnassignVolumeError { meta: generic, kind: crate::error::UnassignVolumeErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UnassignVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UnassignVolumeError { meta: generic, kind: crate::error::UnassignVolumeErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UnassignVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UnassignVolumeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_unassign_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UnassignVolumeOutput, crate::error::UnassignVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::unassign_volume_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UntagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UntagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_app_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAppOutput, crate::error::UpdateAppError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateAppError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateAppError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateAppError { meta: generic, kind: crate::error::UpdateAppErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAppError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateAppError { meta: generic, kind: crate::error::UpdateAppErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateAppError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateAppError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_app_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateAppOutput, crate::error::UpdateAppError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_app_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_elastic_ip_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateElasticIpOutput, crate::error::UpdateElasticIpError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateElasticIpError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateElasticIpError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateElasticIpError { meta: generic, kind: crate::error::UpdateElasticIpErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateElasticIpError { meta: generic, kind: crate::error::UpdateElasticIpErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateElasticIpError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateElasticIpError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_elastic_ip_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateElasticIpOutput, crate::error::UpdateElasticIpError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_elastic_ip_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateInstanceOutput, crate::error::UpdateInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateInstanceError { meta: generic, kind: crate::error::UpdateInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateInstanceError { meta: generic, kind: crate::error::UpdateInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateInstanceOutput, crate::error::UpdateInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_layer_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateLayerOutput, crate::error::UpdateLayerError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateLayerError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateLayerError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateLayerError { meta: generic, kind: crate::error::UpdateLayerErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateLayerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateLayerError { meta: generic, kind: crate::error::UpdateLayerErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateLayerError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateLayerError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_layer_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateLayerOutput, crate::error::UpdateLayerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_layer_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_my_user_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMyUserProfileOutput, crate::error::UpdateMyUserProfileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateMyUserProfileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateMyUserProfileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ValidationException" => crate::error::UpdateMyUserProfileError { meta: generic, kind: crate::error::UpdateMyUserProfileErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateMyUserProfileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateMyUserProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_my_user_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateMyUserProfileOutput, crate::error::UpdateMyUserProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_my_user_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_rds_db_instance_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRdsDbInstanceOutput, crate::error::UpdateRdsDbInstanceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateRdsDbInstanceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateRdsDbInstanceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateRdsDbInstanceError { meta: generic, kind: crate::error::UpdateRdsDbInstanceErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRdsDbInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateRdsDbInstanceError { meta: generic, kind: crate::error::UpdateRdsDbInstanceErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRdsDbInstanceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateRdsDbInstanceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_rds_db_instance_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRdsDbInstanceOutput, crate::error::UpdateRdsDbInstanceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_rds_db_instance_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateStackOutput, crate::error::UpdateStackError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateStackError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateStackError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateStackError { meta: generic, kind: crate::error::UpdateStackErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateStackError { meta: generic, kind: crate::error::UpdateStackErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateStackError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateStackError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_stack_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateStackOutput, crate::error::UpdateStackError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_stack_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_profile_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateUserProfileOutput, crate::error::UpdateUserProfileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateUserProfileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateUserProfileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateUserProfileError { meta: generic, kind: crate::error::UpdateUserProfileErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserProfileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateUserProfileError { meta: generic, kind: crate::error::UpdateUserProfileErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateUserProfileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateUserProfileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_user_profile_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateUserProfileOutput, crate::error::UpdateUserProfileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_user_profile_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_volume_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateVolumeOutput, crate::error::UpdateVolumeError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateVolumeError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateVolumeError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ResourceNotFoundException" => crate::error::UpdateVolumeError { meta: generic, kind: crate::error::UpdateVolumeErrorKind::ResourceNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ValidationException" => crate::error::UpdateVolumeError { meta: generic, kind: crate::error::UpdateVolumeErrorKind::ValidationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::validation_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_validation_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVolumeError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateVolumeError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_volume_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateVolumeOutput, crate::error::UpdateVolumeError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_volume_output::Builder::default();
        let _ = response;
        output.build()
    })
}

