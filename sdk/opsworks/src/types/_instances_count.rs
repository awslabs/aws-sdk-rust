// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes how many instances a stack has for each status.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstancesCount {
    /// <p>The number of instances in the Assigning state.</p>
    #[doc(hidden)]
    pub assigning: std::option::Option<i32>,
    /// <p>The number of instances with <code>booting</code> status.</p>
    #[doc(hidden)]
    pub booting: std::option::Option<i32>,
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    #[doc(hidden)]
    pub connection_lost: std::option::Option<i32>,
    /// <p>The number of instances in the Deregistering state.</p>
    #[doc(hidden)]
    pub deregistering: std::option::Option<i32>,
    /// <p>The number of instances with <code>online</code> status.</p>
    #[doc(hidden)]
    pub online: std::option::Option<i32>,
    /// <p>The number of instances with <code>pending</code> status.</p>
    #[doc(hidden)]
    pub pending: std::option::Option<i32>,
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    #[doc(hidden)]
    pub rebooting: std::option::Option<i32>,
    /// <p>The number of instances in the Registered state.</p>
    #[doc(hidden)]
    pub registered: std::option::Option<i32>,
    /// <p>The number of instances in the Registering state.</p>
    #[doc(hidden)]
    pub registering: std::option::Option<i32>,
    /// <p>The number of instances with <code>requested</code> status.</p>
    #[doc(hidden)]
    pub requested: std::option::Option<i32>,
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    #[doc(hidden)]
    pub running_setup: std::option::Option<i32>,
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    #[doc(hidden)]
    pub setup_failed: std::option::Option<i32>,
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    #[doc(hidden)]
    pub shutting_down: std::option::Option<i32>,
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    #[doc(hidden)]
    pub start_failed: std::option::Option<i32>,
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    #[doc(hidden)]
    pub stop_failed: std::option::Option<i32>,
    /// <p>The number of instances with <code>stopped</code> status.</p>
    #[doc(hidden)]
    pub stopped: std::option::Option<i32>,
    /// <p>The number of instances with <code>stopping</code> status.</p>
    #[doc(hidden)]
    pub stopping: std::option::Option<i32>,
    /// <p>The number of instances with <code>terminated</code> status.</p>
    #[doc(hidden)]
    pub terminated: std::option::Option<i32>,
    /// <p>The number of instances with <code>terminating</code> status.</p>
    #[doc(hidden)]
    pub terminating: std::option::Option<i32>,
    /// <p>The number of instances in the Unassigning state.</p>
    #[doc(hidden)]
    pub unassigning: std::option::Option<i32>,
}
impl InstancesCount {
    /// <p>The number of instances in the Assigning state.</p>
    pub fn assigning(&self) -> std::option::Option<i32> {
        self.assigning
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn booting(&self) -> std::option::Option<i32> {
        self.booting
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn connection_lost(&self) -> std::option::Option<i32> {
        self.connection_lost
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn deregistering(&self) -> std::option::Option<i32> {
        self.deregistering
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn online(&self) -> std::option::Option<i32> {
        self.online
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn pending(&self) -> std::option::Option<i32> {
        self.pending
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn rebooting(&self) -> std::option::Option<i32> {
        self.rebooting
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn registered(&self) -> std::option::Option<i32> {
        self.registered
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn registering(&self) -> std::option::Option<i32> {
        self.registering
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn requested(&self) -> std::option::Option<i32> {
        self.requested
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn running_setup(&self) -> std::option::Option<i32> {
        self.running_setup
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn setup_failed(&self) -> std::option::Option<i32> {
        self.setup_failed
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn shutting_down(&self) -> std::option::Option<i32> {
        self.shutting_down
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn start_failed(&self) -> std::option::Option<i32> {
        self.start_failed
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn stop_failed(&self) -> std::option::Option<i32> {
        self.stop_failed
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn stopped(&self) -> std::option::Option<i32> {
        self.stopped
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn stopping(&self) -> std::option::Option<i32> {
        self.stopping
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn terminated(&self) -> std::option::Option<i32> {
        self.terminated
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn terminating(&self) -> std::option::Option<i32> {
        self.terminating
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn unassigning(&self) -> std::option::Option<i32> {
        self.unassigning
    }
}
impl InstancesCount {
    /// Creates a new builder-style object to manufacture [`InstancesCount`](crate::types::InstancesCount).
    pub fn builder() -> crate::types::builders::InstancesCountBuilder {
        crate::types::builders::InstancesCountBuilder::default()
    }
}

/// A builder for [`InstancesCount`](crate::types::InstancesCount).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct InstancesCountBuilder {
    pub(crate) assigning: std::option::Option<i32>,
    pub(crate) booting: std::option::Option<i32>,
    pub(crate) connection_lost: std::option::Option<i32>,
    pub(crate) deregistering: std::option::Option<i32>,
    pub(crate) online: std::option::Option<i32>,
    pub(crate) pending: std::option::Option<i32>,
    pub(crate) rebooting: std::option::Option<i32>,
    pub(crate) registered: std::option::Option<i32>,
    pub(crate) registering: std::option::Option<i32>,
    pub(crate) requested: std::option::Option<i32>,
    pub(crate) running_setup: std::option::Option<i32>,
    pub(crate) setup_failed: std::option::Option<i32>,
    pub(crate) shutting_down: std::option::Option<i32>,
    pub(crate) start_failed: std::option::Option<i32>,
    pub(crate) stop_failed: std::option::Option<i32>,
    pub(crate) stopped: std::option::Option<i32>,
    pub(crate) stopping: std::option::Option<i32>,
    pub(crate) terminated: std::option::Option<i32>,
    pub(crate) terminating: std::option::Option<i32>,
    pub(crate) unassigning: std::option::Option<i32>,
}
impl InstancesCountBuilder {
    /// <p>The number of instances in the Assigning state.</p>
    pub fn assigning(mut self, input: i32) -> Self {
        self.assigning = Some(input);
        self
    }
    /// <p>The number of instances in the Assigning state.</p>
    pub fn set_assigning(mut self, input: std::option::Option<i32>) -> Self {
        self.assigning = input;
        self
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn booting(mut self, input: i32) -> Self {
        self.booting = Some(input);
        self
    }
    /// <p>The number of instances with <code>booting</code> status.</p>
    pub fn set_booting(mut self, input: std::option::Option<i32>) -> Self {
        self.booting = input;
        self
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn connection_lost(mut self, input: i32) -> Self {
        self.connection_lost = Some(input);
        self
    }
    /// <p>The number of instances with <code>connection_lost</code> status.</p>
    pub fn set_connection_lost(mut self, input: std::option::Option<i32>) -> Self {
        self.connection_lost = input;
        self
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn deregistering(mut self, input: i32) -> Self {
        self.deregistering = Some(input);
        self
    }
    /// <p>The number of instances in the Deregistering state.</p>
    pub fn set_deregistering(mut self, input: std::option::Option<i32>) -> Self {
        self.deregistering = input;
        self
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn online(mut self, input: i32) -> Self {
        self.online = Some(input);
        self
    }
    /// <p>The number of instances with <code>online</code> status.</p>
    pub fn set_online(mut self, input: std::option::Option<i32>) -> Self {
        self.online = input;
        self
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn pending(mut self, input: i32) -> Self {
        self.pending = Some(input);
        self
    }
    /// <p>The number of instances with <code>pending</code> status.</p>
    pub fn set_pending(mut self, input: std::option::Option<i32>) -> Self {
        self.pending = input;
        self
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn rebooting(mut self, input: i32) -> Self {
        self.rebooting = Some(input);
        self
    }
    /// <p>The number of instances with <code>rebooting</code> status.</p>
    pub fn set_rebooting(mut self, input: std::option::Option<i32>) -> Self {
        self.rebooting = input;
        self
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn registered(mut self, input: i32) -> Self {
        self.registered = Some(input);
        self
    }
    /// <p>The number of instances in the Registered state.</p>
    pub fn set_registered(mut self, input: std::option::Option<i32>) -> Self {
        self.registered = input;
        self
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn registering(mut self, input: i32) -> Self {
        self.registering = Some(input);
        self
    }
    /// <p>The number of instances in the Registering state.</p>
    pub fn set_registering(mut self, input: std::option::Option<i32>) -> Self {
        self.registering = input;
        self
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn requested(mut self, input: i32) -> Self {
        self.requested = Some(input);
        self
    }
    /// <p>The number of instances with <code>requested</code> status.</p>
    pub fn set_requested(mut self, input: std::option::Option<i32>) -> Self {
        self.requested = input;
        self
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn running_setup(mut self, input: i32) -> Self {
        self.running_setup = Some(input);
        self
    }
    /// <p>The number of instances with <code>running_setup</code> status.</p>
    pub fn set_running_setup(mut self, input: std::option::Option<i32>) -> Self {
        self.running_setup = input;
        self
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn setup_failed(mut self, input: i32) -> Self {
        self.setup_failed = Some(input);
        self
    }
    /// <p>The number of instances with <code>setup_failed</code> status.</p>
    pub fn set_setup_failed(mut self, input: std::option::Option<i32>) -> Self {
        self.setup_failed = input;
        self
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn shutting_down(mut self, input: i32) -> Self {
        self.shutting_down = Some(input);
        self
    }
    /// <p>The number of instances with <code>shutting_down</code> status.</p>
    pub fn set_shutting_down(mut self, input: std::option::Option<i32>) -> Self {
        self.shutting_down = input;
        self
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn start_failed(mut self, input: i32) -> Self {
        self.start_failed = Some(input);
        self
    }
    /// <p>The number of instances with <code>start_failed</code> status.</p>
    pub fn set_start_failed(mut self, input: std::option::Option<i32>) -> Self {
        self.start_failed = input;
        self
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn stop_failed(mut self, input: i32) -> Self {
        self.stop_failed = Some(input);
        self
    }
    /// <p>The number of instances with <code>stop_failed</code> status.</p>
    pub fn set_stop_failed(mut self, input: std::option::Option<i32>) -> Self {
        self.stop_failed = input;
        self
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn stopped(mut self, input: i32) -> Self {
        self.stopped = Some(input);
        self
    }
    /// <p>The number of instances with <code>stopped</code> status.</p>
    pub fn set_stopped(mut self, input: std::option::Option<i32>) -> Self {
        self.stopped = input;
        self
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn stopping(mut self, input: i32) -> Self {
        self.stopping = Some(input);
        self
    }
    /// <p>The number of instances with <code>stopping</code> status.</p>
    pub fn set_stopping(mut self, input: std::option::Option<i32>) -> Self {
        self.stopping = input;
        self
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn terminated(mut self, input: i32) -> Self {
        self.terminated = Some(input);
        self
    }
    /// <p>The number of instances with <code>terminated</code> status.</p>
    pub fn set_terminated(mut self, input: std::option::Option<i32>) -> Self {
        self.terminated = input;
        self
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn terminating(mut self, input: i32) -> Self {
        self.terminating = Some(input);
        self
    }
    /// <p>The number of instances with <code>terminating</code> status.</p>
    pub fn set_terminating(mut self, input: std::option::Option<i32>) -> Self {
        self.terminating = input;
        self
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn unassigning(mut self, input: i32) -> Self {
        self.unassigning = Some(input);
        self
    }
    /// <p>The number of instances in the Unassigning state.</p>
    pub fn set_unassigning(mut self, input: std::option::Option<i32>) -> Self {
        self.unassigning = input;
        self
    }
    /// Consumes the builder and constructs a [`InstancesCount`](crate::types::InstancesCount).
    pub fn build(self) -> crate::types::InstancesCount {
        crate::types::InstancesCount {
            assigning: self.assigning,
            booting: self.booting,
            connection_lost: self.connection_lost,
            deregistering: self.deregistering,
            online: self.online,
            pending: self.pending,
            rebooting: self.rebooting,
            registered: self.registered,
            registering: self.registering,
            requested: self.requested,
            running_setup: self.running_setup,
            setup_failed: self.setup_failed,
            shutting_down: self.shutting_down,
            start_failed: self.start_failed,
            stop_failed: self.stop_failed,
            stopped: self.stopped,
            stopping: self.stopping,
            terminated: self.terminated,
            terminating: self.terminating,
            unassigning: self.unassigning,
        }
    }
}
