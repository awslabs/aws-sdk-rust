// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains the parameters needed for you to provide custom input to a target based on one or more pieces of data extracted from the event.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct InputTransformer {
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p>
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p>
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub input_paths_map: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; </p>
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p>
    /// <ul>
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li>
    /// </ul>
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": '{"myInstance":
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    pub input_template: ::std::string::String,
}
impl InputTransformer {
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p>
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p>
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn input_paths_map(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.input_paths_map.as_ref()
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; </p>
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p>
    /// <ul>
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li>
    /// </ul>
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": '{"myInstance":
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    pub fn input_template(&self) -> &str {
        use std::ops::Deref;
        self.input_template.deref()
    }
}
impl InputTransformer {
    /// Creates a new builder-style object to manufacture [`InputTransformer`](crate::types::InputTransformer).
    pub fn builder() -> crate::types::builders::InputTransformerBuilder {
        crate::types::builders::InputTransformerBuilder::default()
    }
}

/// A builder for [`InputTransformer`](crate::types::InputTransformer).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct InputTransformerBuilder {
    pub(crate) input_paths_map: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) input_template: ::std::option::Option<::std::string::String>,
}
impl InputTransformerBuilder {
    /// Adds a key-value pair to `input_paths_map`.
    ///
    /// To override the contents of this collection use [`set_input_paths_map`](Self::set_input_paths_map).
    ///
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p>
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p>
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn input_paths_map(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.input_paths_map.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.input_paths_map = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p>
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p>
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn set_input_paths_map(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.input_paths_map = input;
        self
    }
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the template in <code>InputTemplate</code> to produce the output you want to be sent to the target.</p>
    /// <p> <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket notation.</p>
    /// <p>The keys cannot start with "Amazon Web Services." </p>
    pub fn get_input_paths_map(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.input_paths_map
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; </p>
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p>
    /// <ul>
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li>
    /// </ul>
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": '{"myInstance":
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// This field is required.
    pub fn input_template(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.input_template = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; </p>
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p>
    /// <ul>
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li>
    /// </ul>
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": '{"myInstance":
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    pub fn set_input_template(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.input_template = input;
        self
    }
    /// <p>Input template where you specify placeholders that will be filled with the values of the keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each <code>InputPathsMaps</code> value in brackets: &lt;<i>value</i>&gt; </p>
    /// <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following restrictions apply:</p>
    /// <ul>
    /// <li> <p>The placeholder cannot be used as an object key.</p> </li>
    /// </ul>
    /// <p>The following example shows the syntax for using <code>InputPathsMap</code> and <code>InputTemplate</code>.</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state
    /// <status>
    /// "
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape each quote marks with a slash, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""
    /// </status>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    /// <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out, as in the following example:</p>
    /// <p> <code> "InputTransformer":</code> </p>
    /// <p> <code>{</code> </p>
    /// <p> <code>"InputPathsMap": {"instance": "$.detail.instance","status": "$.detail.status"},</code> </p>
    /// <p> <code>"InputTemplate": '{"myInstance":
    /// <instance>
    /// ,"myStatus": "
    /// <instance>
    /// is in state \"
    /// <status>
    /// \""}'
    /// </status>
    /// </instance>
    /// </instance></code> </p>
    /// <p> <code>}</code> </p>
    pub fn get_input_template(&self) -> &::std::option::Option<::std::string::String> {
        &self.input_template
    }
    /// Consumes the builder and constructs a [`InputTransformer`](crate::types::InputTransformer).
    /// This method will fail if any of the following fields are not set:
    /// - [`input_template`](crate::types::builders::InputTransformerBuilder::input_template)
    pub fn build(self) -> ::std::result::Result<crate::types::InputTransformer, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::InputTransformer {
            input_paths_map: self.input_paths_map,
            input_template: self.input_template.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "input_template",
                    "input_template was not specified but it is required when building InputTransformer",
                )
            })?,
        })
    }
}
