// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_endpoint::_create_endpoint_output::CreateEndpointOutputBuilder;

pub use crate::operation::create_endpoint::_create_endpoint_input::CreateEndpointInputBuilder;

impl CreateEndpointInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_endpoint::CreateEndpointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_endpoint::CreateEndpointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_endpoint();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateEndpoint`.
///
/// <p>Creates a global endpoint. Global endpoints improve your application's availability by making it regional-fault tolerant. To do this, you define a primary and secondary Region with event buses in each Region. You also create a Amazon Route&nbsp;53 health check that will tell EventBridge to route events to the secondary Region when an "unhealthy" state is encountered and events will be routed back to the primary Region when the health check reports a "healthy" state.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateEndpointFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_endpoint::builders::CreateEndpointInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_endpoint::CreateEndpointOutput,
        crate::operation::create_endpoint::CreateEndpointError,
    > for CreateEndpointFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_endpoint::CreateEndpointOutput,
            crate::operation::create_endpoint::CreateEndpointError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateEndpointFluentBuilder {
    /// Creates a new `CreateEndpoint`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateEndpoint as a reference.
    pub fn as_input(&self) -> &crate::operation::create_endpoint::builders::CreateEndpointInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_endpoint::CreateEndpointOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_endpoint::CreateEndpointError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_endpoint::CreateEndpoint::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_endpoint::CreateEndpoint::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_endpoint::CreateEndpointOutput,
        crate::operation::create_endpoint::CreateEndpointError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the global endpoint. For example, <code>"Name":"us-east-2-custom_bus_A-endpoint"</code>.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.name(input.into());
        self
    }
    /// <p>The name of the global endpoint. For example, <code>"Name":"us-east-2-custom_bus_A-endpoint"</code>.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_name(input);
        self
    }
    /// <p>The name of the global endpoint. For example, <code>"Name":"us-east-2-custom_bus_A-endpoint"</code>.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_name()
    }
    /// <p>A description of the global endpoint.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>A description of the global endpoint.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>A description of the global endpoint.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>Configure the routing policy, including the health check and secondary Region..</p>
    pub fn routing_config(mut self, input: crate::types::RoutingConfig) -> Self {
        self.inner = self.inner.routing_config(input);
        self
    }
    /// <p>Configure the routing policy, including the health check and secondary Region..</p>
    pub fn set_routing_config(mut self, input: ::std::option::Option<crate::types::RoutingConfig>) -> Self {
        self.inner = self.inner.set_routing_config(input);
        self
    }
    /// <p>Configure the routing policy, including the health check and secondary Region..</p>
    pub fn get_routing_config(&self) -> &::std::option::Option<crate::types::RoutingConfig> {
        self.inner.get_routing_config()
    }
    /// <p>Enable or disable event replication. The default state is <code>ENABLED</code> which means you must supply a <code>RoleArn</code>. If you don't have a <code>RoleArn</code> or you don't want event replication enabled, set the state to <code>DISABLED</code>.</p>
    pub fn replication_config(mut self, input: crate::types::ReplicationConfig) -> Self {
        self.inner = self.inner.replication_config(input);
        self
    }
    /// <p>Enable or disable event replication. The default state is <code>ENABLED</code> which means you must supply a <code>RoleArn</code>. If you don't have a <code>RoleArn</code> or you don't want event replication enabled, set the state to <code>DISABLED</code>.</p>
    pub fn set_replication_config(mut self, input: ::std::option::Option<crate::types::ReplicationConfig>) -> Self {
        self.inner = self.inner.set_replication_config(input);
        self
    }
    /// <p>Enable or disable event replication. The default state is <code>ENABLED</code> which means you must supply a <code>RoleArn</code>. If you don't have a <code>RoleArn</code> or you don't want event replication enabled, set the state to <code>DISABLED</code>.</p>
    pub fn get_replication_config(&self) -> &::std::option::Option<crate::types::ReplicationConfig> {
        self.inner.get_replication_config()
    }
    /// Appends an item to `EventBuses`.
    ///
    /// To override the contents of this collection use [`set_event_buses`](Self::set_event_buses).
    ///
    /// <p>Define the event buses used.</p><important>
    /// <p>The names of the event buses must be identical in each Region.</p>
    /// </important>
    pub fn event_buses(mut self, input: crate::types::EndpointEventBus) -> Self {
        self.inner = self.inner.event_buses(input);
        self
    }
    /// <p>Define the event buses used.</p><important>
    /// <p>The names of the event buses must be identical in each Region.</p>
    /// </important>
    pub fn set_event_buses(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::EndpointEventBus>>) -> Self {
        self.inner = self.inner.set_event_buses(input);
        self
    }
    /// <p>Define the event buses used.</p><important>
    /// <p>The names of the event buses must be identical in each Region.</p>
    /// </important>
    pub fn get_event_buses(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::EndpointEventBus>> {
        self.inner.get_event_buses()
    }
    /// <p>The ARN of the role used for replication.</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.role_arn(input.into());
        self
    }
    /// <p>The ARN of the role used for replication.</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_role_arn(input);
        self
    }
    /// <p>The ARN of the role used for replication.</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_role_arn()
    }
}
