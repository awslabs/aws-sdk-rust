// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ActivateEventSourceError {
    pub kind: ActivateEventSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ActivateEventSourceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    InvalidStateException(crate::error::InvalidStateException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ActivateEventSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ActivateEventSourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            ActivateEventSourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            ActivateEventSourceErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            ActivateEventSourceErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            ActivateEventSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ActivateEventSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ActivateEventSourceError {
    fn code(&self) -> Option<&str> {
        ActivateEventSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ActivateEventSourceError {
    pub fn new(kind: ActivateEventSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ActivateEventSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ActivateEventSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivateEventSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivateEventSourceErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivateEventSourceErrorKind::InvalidStateException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivateEventSourceErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ActivateEventSourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ActivateEventSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ActivateEventSourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            ActivateEventSourceErrorKind::InternalException(_inner) => Some(_inner),
            ActivateEventSourceErrorKind::InvalidStateException(_inner) => Some(_inner),
            ActivateEventSourceErrorKind::OperationDisabledException(_inner) => Some(_inner),
            ActivateEventSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ActivateEventSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelReplayError {
    pub kind: CancelReplayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelReplayErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    IllegalStatusException(crate::error::IllegalStatusException),
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelReplayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelReplayErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CancelReplayErrorKind::IllegalStatusException(_inner) => _inner.fmt(f),
            CancelReplayErrorKind::InternalException(_inner) => _inner.fmt(f),
            CancelReplayErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CancelReplayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelReplayError {
    fn code(&self) -> Option<&str> {
        CancelReplayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelReplayError {
    pub fn new(kind: CancelReplayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelReplayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelReplayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelReplayErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_illegal_status_exception(&self) -> bool {
        matches!(&self.kind, CancelReplayErrorKind::IllegalStatusException(_))
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CancelReplayErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelReplayErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CancelReplayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelReplayErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CancelReplayErrorKind::IllegalStatusException(_inner) => Some(_inner),
            CancelReplayErrorKind::InternalException(_inner) => Some(_inner),
            CancelReplayErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelReplayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApiDestinationError {
    pub kind: CreateApiDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApiDestinationErrorKind {
    InternalException(crate::error::InternalException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApiDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApiDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateApiDestinationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateApiDestinationErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateApiDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateApiDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateApiDestinationError {
    fn code(&self) -> Option<&str> {
        CreateApiDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApiDestinationError {
    pub fn new(kind: CreateApiDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApiDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApiDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiDestinationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiDestinationErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApiDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreateApiDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApiDestinationErrorKind::InternalException(_inner) => Some(_inner),
            CreateApiDestinationErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateApiDestinationErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateApiDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateApiDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateArchiveError {
    pub kind: CreateArchiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateArchiveErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    InvalidEventPatternException(crate::error::InvalidEventPatternException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateArchiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateArchiveErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateArchiveErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateArchiveErrorKind::InvalidEventPatternException(_inner) => _inner.fmt(f),
            CreateArchiveErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateArchiveErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateArchiveErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateArchiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateArchiveError {
    fn code(&self) -> Option<&str> {
        CreateArchiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateArchiveError {
    pub fn new(kind: CreateArchiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateArchiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateArchiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateArchiveErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateArchiveErrorKind::InternalException(_))
    }
    pub fn is_invalid_event_pattern_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateArchiveErrorKind::InvalidEventPatternException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateArchiveErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateArchiveErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateArchiveErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreateArchiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateArchiveErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateArchiveErrorKind::InternalException(_inner) => Some(_inner),
            CreateArchiveErrorKind::InvalidEventPatternException(_inner) => Some(_inner),
            CreateArchiveErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateArchiveErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateArchiveErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateArchiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConnectionError {
    pub kind: CreateConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConnectionErrorKind {
    InternalException(crate::error::InternalException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConnectionErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConnectionError {
    fn code(&self) -> Option<&str> {
        CreateConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConnectionError {
    pub fn new(kind: CreateConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateConnectionErrorKind::InternalException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::ResourceAlreadyExistsException(_)
        )
    }
}
impl std::error::Error for CreateConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConnectionErrorKind::InternalException(_inner) => Some(_inner),
            CreateConnectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateConnectionErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEventBusError {
    pub kind: CreateEventBusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEventBusErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    InvalidStateException(crate::error::InvalidStateException),
    LimitExceededException(crate::error::LimitExceededException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEventBusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEventBusErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateEventBusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEventBusError {
    fn code(&self) -> Option<&str> {
        CreateEventBusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEventBusError {
    pub fn new(kind: CreateEventBusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEventBusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEventBusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventBusErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, CreateEventBusErrorKind::InternalException(_))
    }
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventBusErrorKind::InvalidStateException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventBusErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventBusErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventBusErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEventBusErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for CreateEventBusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEventBusErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateEventBusErrorKind::InternalException(_inner) => Some(_inner),
            CreateEventBusErrorKind::InvalidStateException(_inner) => Some(_inner),
            CreateEventBusErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateEventBusErrorKind::OperationDisabledException(_inner) => Some(_inner),
            CreateEventBusErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            CreateEventBusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateEventBusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePartnerEventSourceError {
    pub kind: CreatePartnerEventSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePartnerEventSourceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    LimitExceededException(crate::error::LimitExceededException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePartnerEventSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePartnerEventSourceErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            CreatePartnerEventSourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            CreatePartnerEventSourceErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreatePartnerEventSourceErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            CreatePartnerEventSourceErrorKind::ResourceAlreadyExistsException(_inner) => {
                _inner.fmt(f)
            }
            CreatePartnerEventSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePartnerEventSourceError {
    fn code(&self) -> Option<&str> {
        CreatePartnerEventSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePartnerEventSourceError {
    pub fn new(kind: CreatePartnerEventSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePartnerEventSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePartnerEventSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerEventSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerEventSourceErrorKind::InternalException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerEventSourceErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerEventSourceErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePartnerEventSourceErrorKind::ResourceAlreadyExistsException(_)
        )
    }
}
impl std::error::Error for CreatePartnerEventSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePartnerEventSourceErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            CreatePartnerEventSourceErrorKind::InternalException(_inner) => Some(_inner),
            CreatePartnerEventSourceErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreatePartnerEventSourceErrorKind::OperationDisabledException(_inner) => Some(_inner),
            CreatePartnerEventSourceErrorKind::ResourceAlreadyExistsException(_inner) => {
                Some(_inner)
            }
            CreatePartnerEventSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeactivateEventSourceError {
    pub kind: DeactivateEventSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeactivateEventSourceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    InvalidStateException(crate::error::InvalidStateException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeactivateEventSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeactivateEventSourceErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DeactivateEventSourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeactivateEventSourceErrorKind::InvalidStateException(_inner) => _inner.fmt(f),
            DeactivateEventSourceErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            DeactivateEventSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeactivateEventSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeactivateEventSourceError {
    fn code(&self) -> Option<&str> {
        DeactivateEventSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeactivateEventSourceError {
    pub fn new(kind: DeactivateEventSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeactivateEventSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeactivateEventSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateEventSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateEventSourceErrorKind::InternalException(_)
        )
    }
    pub fn is_invalid_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateEventSourceErrorKind::InvalidStateException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateEventSourceErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeactivateEventSourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeactivateEventSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeactivateEventSourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeactivateEventSourceErrorKind::InternalException(_inner) => Some(_inner),
            DeactivateEventSourceErrorKind::InvalidStateException(_inner) => Some(_inner),
            DeactivateEventSourceErrorKind::OperationDisabledException(_inner) => Some(_inner),
            DeactivateEventSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeactivateEventSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeauthorizeConnectionError {
    pub kind: DeauthorizeConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeauthorizeConnectionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeauthorizeConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeauthorizeConnectionErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DeauthorizeConnectionErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeauthorizeConnectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeauthorizeConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeauthorizeConnectionError {
    fn code(&self) -> Option<&str> {
        DeauthorizeConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeauthorizeConnectionError {
    pub fn new(kind: DeauthorizeConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeauthorizeConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeauthorizeConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeauthorizeConnectionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeauthorizeConnectionErrorKind::InternalException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeauthorizeConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeauthorizeConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeauthorizeConnectionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeauthorizeConnectionErrorKind::InternalException(_inner) => Some(_inner),
            DeauthorizeConnectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeauthorizeConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApiDestinationError {
    pub kind: DeleteApiDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApiDestinationErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApiDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApiDestinationErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteApiDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteApiDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteApiDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApiDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteApiDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApiDestinationError {
    pub fn new(kind: DeleteApiDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApiDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApiDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiDestinationErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApiDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteApiDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApiDestinationErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteApiDestinationErrorKind::InternalException(_inner) => Some(_inner),
            DeleteApiDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteApiDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteArchiveError {
    pub kind: DeleteArchiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteArchiveErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteArchiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteArchiveErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteArchiveErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteArchiveErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteArchiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteArchiveError {
    fn code(&self) -> Option<&str> {
        DeleteArchiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteArchiveError {
    pub fn new(kind: DeleteArchiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteArchiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteArchiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteArchiveErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteArchiveErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteArchiveErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteArchiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteArchiveErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteArchiveErrorKind::InternalException(_inner) => Some(_inner),
            DeleteArchiveErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteArchiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConnectionError {
    pub kind: DeleteConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConnectionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConnectionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConnectionError {
    fn code(&self) -> Option<&str> {
        DeleteConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConnectionError {
    pub fn new(kind: DeleteConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteConnectionErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConnectionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::InternalException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventBusError {
    pub kind: DeleteEventBusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventBusErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventBusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventBusErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteEventBusErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteEventBusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventBusError {
    fn code(&self) -> Option<&str> {
        DeleteEventBusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventBusError {
    pub fn new(kind: DeleteEventBusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventBusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventBusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventBusErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteEventBusErrorKind::InternalException(_))
    }
}
impl std::error::Error for DeleteEventBusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventBusErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteEventBusErrorKind::InternalException(_inner) => Some(_inner),
            DeleteEventBusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePartnerEventSourceError {
    pub kind: DeletePartnerEventSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePartnerEventSourceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePartnerEventSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePartnerEventSourceErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DeletePartnerEventSourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeletePartnerEventSourceErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            DeletePartnerEventSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePartnerEventSourceError {
    fn code(&self) -> Option<&str> {
        DeletePartnerEventSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePartnerEventSourceError {
    pub fn new(kind: DeletePartnerEventSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePartnerEventSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePartnerEventSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartnerEventSourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartnerEventSourceErrorKind::InternalException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePartnerEventSourceErrorKind::OperationDisabledException(_)
        )
    }
}
impl std::error::Error for DeletePartnerEventSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePartnerEventSourceErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            DeletePartnerEventSourceErrorKind::InternalException(_inner) => Some(_inner),
            DeletePartnerEventSourceErrorKind::OperationDisabledException(_inner) => Some(_inner),
            DeletePartnerEventSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRuleError {
    pub kind: DeleteRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRuleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRuleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DeleteRuleErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            DeleteRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRuleError {
    fn code(&self) -> Option<&str> {
        DeleteRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRuleError {
    pub fn new(kind: DeleteRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRuleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DeleteRuleErrorKind::InternalException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, DeleteRuleErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRuleErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DeleteRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRuleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteRuleErrorKind::InternalException(_inner) => Some(_inner),
            DeleteRuleErrorKind::ManagedRuleException(_inner) => Some(_inner),
            DeleteRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeApiDestinationError {
    pub kind: DescribeApiDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeApiDestinationErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeApiDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeApiDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeApiDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeApiDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeApiDestinationError {
    fn code(&self) -> Option<&str> {
        DescribeApiDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeApiDestinationError {
    pub fn new(kind: DescribeApiDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeApiDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeApiDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeApiDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeApiDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeApiDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeApiDestinationErrorKind::InternalException(_inner) => Some(_inner),
            DescribeApiDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeApiDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeArchiveError {
    pub kind: DescribeArchiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeArchiveErrorKind {
    InternalException(crate::error::InternalException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeArchiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeArchiveErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeArchiveErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            DescribeArchiveErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeArchiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeArchiveError {
    fn code(&self) -> Option<&str> {
        DescribeArchiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeArchiveError {
    pub fn new(kind: DescribeArchiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeArchiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeArchiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeArchiveErrorKind::InternalException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeArchiveErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeArchiveErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeArchiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeArchiveErrorKind::InternalException(_inner) => Some(_inner),
            DescribeArchiveErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            DescribeArchiveErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeArchiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectionError {
    pub kind: DescribeConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectionErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectionErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeConnectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectionError {
    fn code(&self) -> Option<&str> {
        DescribeConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectionError {
    pub fn new(kind: DescribeConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionErrorKind::InternalException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectionErrorKind::InternalException(_inner) => Some(_inner),
            DescribeConnectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventBusError {
    pub kind: DescribeEventBusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventBusErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventBusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventBusErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeEventBusErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeEventBusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventBusError {
    fn code(&self) -> Option<&str> {
        DescribeEventBusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventBusError {
    pub fn new(kind: DescribeEventBusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventBusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventBusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeEventBusErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventBusErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeEventBusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventBusErrorKind::InternalException(_inner) => Some(_inner),
            DescribeEventBusErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeEventBusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventSourceError {
    pub kind: DescribeEventSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventSourceErrorKind {
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventSourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeEventSourceErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            DescribeEventSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeEventSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventSourceError {
    fn code(&self) -> Option<&str> {
        DescribeEventSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventSourceError {
    pub fn new(kind: DescribeEventSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventSourceErrorKind::InternalException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventSourceErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventSourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeEventSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventSourceErrorKind::InternalException(_inner) => Some(_inner),
            DescribeEventSourceErrorKind::OperationDisabledException(_inner) => Some(_inner),
            DescribeEventSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeEventSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePartnerEventSourceError {
    pub kind: DescribePartnerEventSourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePartnerEventSourceErrorKind {
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePartnerEventSourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePartnerEventSourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribePartnerEventSourceErrorKind::OperationDisabledException(_inner) => {
                _inner.fmt(f)
            }
            DescribePartnerEventSourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribePartnerEventSourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePartnerEventSourceError {
    fn code(&self) -> Option<&str> {
        DescribePartnerEventSourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePartnerEventSourceError {
    pub fn new(kind: DescribePartnerEventSourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePartnerEventSourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePartnerEventSourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePartnerEventSourceErrorKind::InternalException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePartnerEventSourceErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePartnerEventSourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribePartnerEventSourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePartnerEventSourceErrorKind::InternalException(_inner) => Some(_inner),
            DescribePartnerEventSourceErrorKind::OperationDisabledException(_inner) => Some(_inner),
            DescribePartnerEventSourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribePartnerEventSourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReplayError {
    pub kind: DescribeReplayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReplayErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReplayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReplayErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeReplayErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeReplayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReplayError {
    fn code(&self) -> Option<&str> {
        DescribeReplayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReplayError {
    pub fn new(kind: DescribeReplayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReplayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReplayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeReplayErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReplayErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeReplayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReplayErrorKind::InternalException(_inner) => Some(_inner),
            DescribeReplayErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeReplayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeRuleError {
    pub kind: DescribeRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeRuleErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DescribeRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DescribeRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeRuleError {
    fn code(&self) -> Option<&str> {
        DescribeRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeRuleError {
    pub fn new(kind: DescribeRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DescribeRuleErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeRuleErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DescribeRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeRuleErrorKind::InternalException(_inner) => Some(_inner),
            DescribeRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DescribeRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisableRuleError {
    pub kind: DisableRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisableRuleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisableRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisableRuleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DisableRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            DisableRuleErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            DisableRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DisableRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisableRuleError {
    fn code(&self) -> Option<&str> {
        DisableRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisableRuleError {
    pub fn new(kind: DisableRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisableRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisableRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableRuleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, DisableRuleErrorKind::InternalException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, DisableRuleErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisableRuleErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for DisableRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisableRuleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DisableRuleErrorKind::InternalException(_inner) => Some(_inner),
            DisableRuleErrorKind::ManagedRuleException(_inner) => Some(_inner),
            DisableRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DisableRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EnableRuleError {
    pub kind: EnableRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EnableRuleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EnableRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EnableRuleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            EnableRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            EnableRuleErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            EnableRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            EnableRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EnableRuleError {
    fn code(&self) -> Option<&str> {
        EnableRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EnableRuleError {
    pub fn new(kind: EnableRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EnableRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EnableRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableRuleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, EnableRuleErrorKind::InternalException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, EnableRuleErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            EnableRuleErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for EnableRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EnableRuleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            EnableRuleErrorKind::InternalException(_inner) => Some(_inner),
            EnableRuleErrorKind::ManagedRuleException(_inner) => Some(_inner),
            EnableRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            EnableRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListApiDestinationsError {
    pub kind: ListApiDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApiDestinationsErrorKind {
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListApiDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListApiDestinationsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListApiDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListApiDestinationsError {
    fn code(&self) -> Option<&str> {
        ListApiDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApiDestinationsError {
    pub fn new(kind: ListApiDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListApiDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListApiDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApiDestinationsErrorKind::InternalException(_)
        )
    }
}
impl std::error::Error for ListApiDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListApiDestinationsErrorKind::InternalException(_inner) => Some(_inner),
            ListApiDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListArchivesError {
    pub kind: ListArchivesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListArchivesErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListArchivesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListArchivesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListArchivesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListArchivesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListArchivesError {
    fn code(&self) -> Option<&str> {
        ListArchivesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListArchivesError {
    pub fn new(kind: ListArchivesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListArchivesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListArchivesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListArchivesErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListArchivesErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListArchivesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListArchivesErrorKind::InternalException(_inner) => Some(_inner),
            ListArchivesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListArchivesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListConnectionsError {
    pub kind: ListConnectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListConnectionsErrorKind {
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListConnectionsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListConnectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListConnectionsError {
    fn code(&self) -> Option<&str> {
        ListConnectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListConnectionsError {
    pub fn new(kind: ListConnectionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListConnectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListConnectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListConnectionsErrorKind::InternalException(_))
    }
}
impl std::error::Error for ListConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListConnectionsErrorKind::InternalException(_inner) => Some(_inner),
            ListConnectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEventBusesError {
    pub kind: ListEventBusesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEventBusesErrorKind {
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEventBusesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEventBusesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListEventBusesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEventBusesError {
    fn code(&self) -> Option<&str> {
        ListEventBusesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEventBusesError {
    pub fn new(kind: ListEventBusesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEventBusesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEventBusesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListEventBusesErrorKind::InternalException(_))
    }
}
impl std::error::Error for ListEventBusesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEventBusesErrorKind::InternalException(_inner) => Some(_inner),
            ListEventBusesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEventSourcesError {
    pub kind: ListEventSourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEventSourcesErrorKind {
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEventSourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEventSourcesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListEventSourcesErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            ListEventSourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEventSourcesError {
    fn code(&self) -> Option<&str> {
        ListEventSourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListEventSourcesError {
    pub fn new(kind: ListEventSourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEventSourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEventSourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListEventSourcesErrorKind::InternalException(_))
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEventSourcesErrorKind::OperationDisabledException(_)
        )
    }
}
impl std::error::Error for ListEventSourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEventSourcesErrorKind::InternalException(_inner) => Some(_inner),
            ListEventSourcesErrorKind::OperationDisabledException(_inner) => Some(_inner),
            ListEventSourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPartnerEventSourceAccountsError {
    pub kind: ListPartnerEventSourceAccountsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPartnerEventSourceAccountsErrorKind {
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPartnerEventSourceAccountsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPartnerEventSourceAccountsErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListPartnerEventSourceAccountsErrorKind::OperationDisabledException(_inner) => {
                _inner.fmt(f)
            }
            ListPartnerEventSourceAccountsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListPartnerEventSourceAccountsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPartnerEventSourceAccountsError {
    fn code(&self) -> Option<&str> {
        ListPartnerEventSourceAccountsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPartnerEventSourceAccountsError {
    pub fn new(kind: ListPartnerEventSourceAccountsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPartnerEventSourceAccountsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPartnerEventSourceAccountsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerEventSourceAccountsErrorKind::InternalException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerEventSourceAccountsErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerEventSourceAccountsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListPartnerEventSourceAccountsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPartnerEventSourceAccountsErrorKind::InternalException(_inner) => Some(_inner),
            ListPartnerEventSourceAccountsErrorKind::OperationDisabledException(_inner) => {
                Some(_inner)
            }
            ListPartnerEventSourceAccountsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListPartnerEventSourceAccountsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPartnerEventSourcesError {
    pub kind: ListPartnerEventSourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPartnerEventSourcesErrorKind {
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPartnerEventSourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPartnerEventSourcesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListPartnerEventSourcesErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            ListPartnerEventSourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPartnerEventSourcesError {
    fn code(&self) -> Option<&str> {
        ListPartnerEventSourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPartnerEventSourcesError {
    pub fn new(kind: ListPartnerEventSourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPartnerEventSourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPartnerEventSourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerEventSourcesErrorKind::InternalException(_)
        )
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerEventSourcesErrorKind::OperationDisabledException(_)
        )
    }
}
impl std::error::Error for ListPartnerEventSourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPartnerEventSourcesErrorKind::InternalException(_inner) => Some(_inner),
            ListPartnerEventSourcesErrorKind::OperationDisabledException(_inner) => Some(_inner),
            ListPartnerEventSourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListReplaysError {
    pub kind: ListReplaysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListReplaysErrorKind {
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListReplaysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListReplaysErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListReplaysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListReplaysError {
    fn code(&self) -> Option<&str> {
        ListReplaysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListReplaysError {
    pub fn new(kind: ListReplaysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListReplaysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListReplaysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListReplaysErrorKind::InternalException(_))
    }
}
impl std::error::Error for ListReplaysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListReplaysErrorKind::InternalException(_inner) => Some(_inner),
            ListReplaysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRuleNamesByTargetError {
    pub kind: ListRuleNamesByTargetErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRuleNamesByTargetErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRuleNamesByTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRuleNamesByTargetErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListRuleNamesByTargetErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListRuleNamesByTargetErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRuleNamesByTargetError {
    fn code(&self) -> Option<&str> {
        ListRuleNamesByTargetError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRuleNamesByTargetError {
    pub fn new(kind: ListRuleNamesByTargetErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRuleNamesByTargetErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRuleNamesByTargetErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRuleNamesByTargetErrorKind::InternalException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRuleNamesByTargetErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListRuleNamesByTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRuleNamesByTargetErrorKind::InternalException(_inner) => Some(_inner),
            ListRuleNamesByTargetErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListRuleNamesByTargetErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRulesError {
    pub kind: ListRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRulesErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRulesErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListRulesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRulesError {
    fn code(&self) -> Option<&str> {
        ListRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRulesError {
    pub fn new(kind: ListRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListRulesErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListRulesErrorKind::ResourceNotFoundException(_))
    }
}
impl std::error::Error for ListRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRulesErrorKind::InternalException(_inner) => Some(_inner),
            ListRulesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTargetsByRuleError {
    pub kind: ListTargetsByRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTargetsByRuleErrorKind {
    InternalException(crate::error::InternalException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTargetsByRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTargetsByRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            ListTargetsByRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTargetsByRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTargetsByRuleError {
    fn code(&self) -> Option<&str> {
        ListTargetsByRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTargetsByRuleError {
    pub fn new(kind: ListTargetsByRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTargetsByRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTargetsByRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, ListTargetsByRuleErrorKind::InternalException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTargetsByRuleErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for ListTargetsByRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTargetsByRuleErrorKind::InternalException(_inner) => Some(_inner),
            ListTargetsByRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTargetsByRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEventsError {
    pub kind: PutEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEventsErrorKind {
    InternalException(crate::error::InternalException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEventsErrorKind::InternalException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEventsError {
    fn code(&self) -> Option<&str> {
        PutEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEventsError {
    pub fn new(kind: PutEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::InternalException(_))
    }
}
impl std::error::Error for PutEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEventsErrorKind::InternalException(_inner) => Some(_inner),
            PutEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutPartnerEventsError {
    pub kind: PutPartnerEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPartnerEventsErrorKind {
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutPartnerEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutPartnerEventsErrorKind::InternalException(_inner) => _inner.fmt(f),
            PutPartnerEventsErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            PutPartnerEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutPartnerEventsError {
    fn code(&self) -> Option<&str> {
        PutPartnerEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPartnerEventsError {
    pub fn new(kind: PutPartnerEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutPartnerEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutPartnerEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, PutPartnerEventsErrorKind::InternalException(_))
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPartnerEventsErrorKind::OperationDisabledException(_)
        )
    }
}
impl std::error::Error for PutPartnerEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutPartnerEventsErrorKind::InternalException(_inner) => Some(_inner),
            PutPartnerEventsErrorKind::OperationDisabledException(_inner) => Some(_inner),
            PutPartnerEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutPermissionError {
    pub kind: PutPermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutPermissionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    PolicyLengthExceededException(crate::error::PolicyLengthExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutPermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutPermissionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            PutPermissionErrorKind::InternalException(_inner) => _inner.fmt(f),
            PutPermissionErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            PutPermissionErrorKind::PolicyLengthExceededException(_inner) => _inner.fmt(f),
            PutPermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutPermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutPermissionError {
    fn code(&self) -> Option<&str> {
        PutPermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutPermissionError {
    pub fn new(kind: PutPermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutPermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutPermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPermissionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, PutPermissionErrorKind::InternalException(_))
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPermissionErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_policy_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPermissionErrorKind::PolicyLengthExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutPermissionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for PutPermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutPermissionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            PutPermissionErrorKind::InternalException(_inner) => Some(_inner),
            PutPermissionErrorKind::OperationDisabledException(_inner) => Some(_inner),
            PutPermissionErrorKind::PolicyLengthExceededException(_inner) => Some(_inner),
            PutPermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutPermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRuleError {
    pub kind: PutRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRuleErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    InvalidEventPatternException(crate::error::InvalidEventPatternException),
    LimitExceededException(crate::error::LimitExceededException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRuleErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            PutRuleErrorKind::InternalException(_inner) => _inner.fmt(f),
            PutRuleErrorKind::InvalidEventPatternException(_inner) => _inner.fmt(f),
            PutRuleErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutRuleErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            PutRuleErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRuleError {
    fn code(&self) -> Option<&str> {
        PutRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRuleError {
    pub fn new(kind: PutRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRuleErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, PutRuleErrorKind::InternalException(_))
    }
    pub fn is_invalid_event_pattern_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRuleErrorKind::InvalidEventPatternException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutRuleErrorKind::LimitExceededException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, PutRuleErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutRuleErrorKind::ResourceNotFoundException(_))
    }
}
impl std::error::Error for PutRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRuleErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            PutRuleErrorKind::InternalException(_inner) => Some(_inner),
            PutRuleErrorKind::InvalidEventPatternException(_inner) => Some(_inner),
            PutRuleErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutRuleErrorKind::ManagedRuleException(_inner) => Some(_inner),
            PutRuleErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutTargetsError {
    pub kind: PutTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutTargetsErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    LimitExceededException(crate::error::LimitExceededException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutTargetsErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            PutTargetsErrorKind::InternalException(_inner) => _inner.fmt(f),
            PutTargetsErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            PutTargetsErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            PutTargetsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutTargetsError {
    fn code(&self) -> Option<&str> {
        PutTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutTargetsError {
    pub fn new(kind: PutTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutTargetsErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, PutTargetsErrorKind::InternalException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutTargetsErrorKind::LimitExceededException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, PutTargetsErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutTargetsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for PutTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutTargetsErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            PutTargetsErrorKind::InternalException(_inner) => Some(_inner),
            PutTargetsErrorKind::LimitExceededException(_inner) => Some(_inner),
            PutTargetsErrorKind::ManagedRuleException(_inner) => Some(_inner),
            PutTargetsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemovePermissionError {
    pub kind: RemovePermissionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemovePermissionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    OperationDisabledException(crate::error::OperationDisabledException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemovePermissionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemovePermissionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::InternalException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::OperationDisabledException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RemovePermissionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemovePermissionError {
    fn code(&self) -> Option<&str> {
        RemovePermissionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemovePermissionError {
    pub fn new(kind: RemovePermissionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemovePermissionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, RemovePermissionErrorKind::InternalException(_))
    }
    pub fn is_operation_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::OperationDisabledException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemovePermissionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for RemovePermissionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemovePermissionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            RemovePermissionErrorKind::InternalException(_inner) => Some(_inner),
            RemovePermissionErrorKind::OperationDisabledException(_inner) => Some(_inner),
            RemovePermissionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemovePermissionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTargetsError {
    pub kind: RemoveTargetsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTargetsErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTargetsErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            RemoveTargetsErrorKind::InternalException(_inner) => _inner.fmt(f),
            RemoveTargetsErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            RemoveTargetsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            RemoveTargetsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTargetsError {
    fn code(&self) -> Option<&str> {
        RemoveTargetsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTargetsError {
    pub fn new(kind: RemoveTargetsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTargetsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTargetsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTargetsErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, RemoveTargetsErrorKind::InternalException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, RemoveTargetsErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTargetsErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for RemoveTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTargetsErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            RemoveTargetsErrorKind::InternalException(_inner) => Some(_inner),
            RemoveTargetsErrorKind::ManagedRuleException(_inner) => Some(_inner),
            RemoveTargetsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            RemoveTargetsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartReplayError {
    pub kind: StartReplayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartReplayErrorKind {
    InternalException(crate::error::InternalException),
    InvalidEventPatternException(crate::error::InvalidEventPatternException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceAlreadyExistsException(crate::error::ResourceAlreadyExistsException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartReplayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartReplayErrorKind::InternalException(_inner) => _inner.fmt(f),
            StartReplayErrorKind::InvalidEventPatternException(_inner) => _inner.fmt(f),
            StartReplayErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            StartReplayErrorKind::ResourceAlreadyExistsException(_inner) => _inner.fmt(f),
            StartReplayErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            StartReplayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartReplayError {
    fn code(&self) -> Option<&str> {
        StartReplayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartReplayError {
    pub fn new(kind: StartReplayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartReplayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartReplayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, StartReplayErrorKind::InternalException(_))
    }
    pub fn is_invalid_event_pattern_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReplayErrorKind::InvalidEventPatternException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, StartReplayErrorKind::LimitExceededException(_))
    }
    pub fn is_resource_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReplayErrorKind::ResourceAlreadyExistsException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartReplayErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for StartReplayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartReplayErrorKind::InternalException(_inner) => Some(_inner),
            StartReplayErrorKind::InvalidEventPatternException(_inner) => Some(_inner),
            StartReplayErrorKind::LimitExceededException(_inner) => Some(_inner),
            StartReplayErrorKind::ResourceAlreadyExistsException(_inner) => Some(_inner),
            StartReplayErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            StartReplayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalException(_inner) => Some(_inner),
            TagResourceErrorKind::ManagedRuleException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestEventPatternError {
    pub kind: TestEventPatternErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestEventPatternErrorKind {
    InternalException(crate::error::InternalException),
    InvalidEventPatternException(crate::error::InvalidEventPatternException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestEventPatternError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestEventPatternErrorKind::InternalException(_inner) => _inner.fmt(f),
            TestEventPatternErrorKind::InvalidEventPatternException(_inner) => _inner.fmt(f),
            TestEventPatternErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestEventPatternError {
    fn code(&self) -> Option<&str> {
        TestEventPatternError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestEventPatternError {
    pub fn new(kind: TestEventPatternErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestEventPatternErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestEventPatternErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, TestEventPatternErrorKind::InternalException(_))
    }
    pub fn is_invalid_event_pattern_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestEventPatternErrorKind::InvalidEventPatternException(_)
        )
    }
}
impl std::error::Error for TestEventPatternError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestEventPatternErrorKind::InternalException(_inner) => Some(_inner),
            TestEventPatternErrorKind::InvalidEventPatternException(_inner) => Some(_inner),
            TestEventPatternErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    ManagedRuleException(crate::error::ManagedRuleException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ManagedRuleException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalException(_))
    }
    pub fn is_managed_rule_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ManagedRuleException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalException(_inner) => Some(_inner),
            UntagResourceErrorKind::ManagedRuleException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApiDestinationError {
    pub kind: UpdateApiDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApiDestinationErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApiDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApiDestinationErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateApiDestinationErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateApiDestinationErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateApiDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateApiDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApiDestinationError {
    fn code(&self) -> Option<&str> {
        UpdateApiDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApiDestinationError {
    pub fn new(kind: UpdateApiDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApiDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApiDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiDestinationErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiDestinationErrorKind::InternalException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiDestinationErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApiDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateApiDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApiDestinationErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateApiDestinationErrorKind::InternalException(_inner) => Some(_inner),
            UpdateApiDestinationErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateApiDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateApiDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateArchiveError {
    pub kind: UpdateArchiveErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateArchiveErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    InvalidEventPatternException(crate::error::InvalidEventPatternException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateArchiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateArchiveErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateArchiveErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateArchiveErrorKind::InvalidEventPatternException(_inner) => _inner.fmt(f),
            UpdateArchiveErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateArchiveErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateArchiveErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateArchiveError {
    fn code(&self) -> Option<&str> {
        UpdateArchiveError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateArchiveError {
    pub fn new(kind: UpdateArchiveErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateArchiveErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateArchiveErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateArchiveErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, UpdateArchiveErrorKind::InternalException(_))
    }
    pub fn is_invalid_event_pattern_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateArchiveErrorKind::InvalidEventPatternException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateArchiveErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateArchiveErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateArchiveError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateArchiveErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateArchiveErrorKind::InternalException(_inner) => Some(_inner),
            UpdateArchiveErrorKind::InvalidEventPatternException(_inner) => Some(_inner),
            UpdateArchiveErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateArchiveErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateArchiveErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConnectionError {
    pub kind: UpdateConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConnectionErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InternalException(crate::error::InternalException),
    LimitExceededException(crate::error::LimitExceededException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConnectionErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::InternalException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConnectionError {
    fn code(&self) -> Option<&str> {
        UpdateConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConnectionError {
    pub fn new(kind: UpdateConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_internal_exception(&self) -> bool {
        matches!(&self.kind, UpdateConnectionErrorKind::InternalException(_))
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
}
impl std::error::Error for UpdateConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConnectionErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::InternalException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>An entity that you specified does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request failed because it attempted to create resource beyond the allowed service
/// quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>This exception occurs due to unexpected causes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalException {}
/// See [`InternalException`](crate::error::InternalException)
pub mod internal_exception {
    /// A builder for [`InternalException`](crate::error::InternalException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalException`](crate::error::InternalException)
        pub fn build(self) -> crate::error::InternalException {
            crate::error::InternalException {
                message: self.message,
            }
        }
    }
}
impl InternalException {
    /// Creates a new builder-style object to manufacture [`InternalException`](crate::error::InternalException)
    pub fn builder() -> crate::error::internal_exception::Builder {
        crate::error::internal_exception::Builder::default()
    }
}

/// <p>There is concurrent modification on a rule, target, archive, or replay.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>The event pattern is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEventPatternException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEventPatternException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEventPatternException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEventPatternException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEventPatternException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEventPatternException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEventPatternException {}
/// See [`InvalidEventPatternException`](crate::error::InvalidEventPatternException)
pub mod invalid_event_pattern_exception {
    /// A builder for [`InvalidEventPatternException`](crate::error::InvalidEventPatternException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEventPatternException`](crate::error::InvalidEventPatternException)
        pub fn build(self) -> crate::error::InvalidEventPatternException {
            crate::error::InvalidEventPatternException {
                message: self.message,
            }
        }
    }
}
impl InvalidEventPatternException {
    /// Creates a new builder-style object to manufacture [`InvalidEventPatternException`](crate::error::InvalidEventPatternException)
    pub fn builder() -> crate::error::invalid_event_pattern_exception::Builder {
        crate::error::invalid_event_pattern_exception::Builder::default()
    }
}

/// <p>This rule was created by an Amazon Web Services service on behalf of your account. It is managed by that
/// service. If you see this error in response to <code>DeleteRule</code> or
/// <code>RemoveTargets</code>, you can use the <code>Force</code> parameter in those calls to
/// delete the rule or remove targets from the rule. You cannot modify these managed rules by
/// using <code>DisableRule</code>, <code>EnableRule</code>, <code>PutTargets</code>,
/// <code>PutRule</code>, <code>TagResource</code>, or <code>UntagResource</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedRuleException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ManagedRuleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedRuleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ManagedRuleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ManagedRuleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ManagedRuleException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ManagedRuleException {}
/// See [`ManagedRuleException`](crate::error::ManagedRuleException)
pub mod managed_rule_exception {
    /// A builder for [`ManagedRuleException`](crate::error::ManagedRuleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedRuleException`](crate::error::ManagedRuleException)
        pub fn build(self) -> crate::error::ManagedRuleException {
            crate::error::ManagedRuleException {
                message: self.message,
            }
        }
    }
}
impl ManagedRuleException {
    /// Creates a new builder-style object to manufacture [`ManagedRuleException`](crate::error::ManagedRuleException)
    pub fn builder() -> crate::error::managed_rule_exception::Builder {
        crate::error::managed_rule_exception::Builder::default()
    }
}

/// <p>The resource you are trying to create already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceAlreadyExistsException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceAlreadyExistsException {}
/// See [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
pub mod resource_already_exists_exception {
    /// A builder for [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
        pub fn build(self) -> crate::error::ResourceAlreadyExistsException {
            crate::error::ResourceAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ResourceAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ResourceAlreadyExistsException`](crate::error::ResourceAlreadyExistsException)
    pub fn builder() -> crate::error::resource_already_exists_exception::Builder {
        crate::error::resource_already_exists_exception::Builder::default()
    }
}

/// <p>The operation you are attempting is not available in this region.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OperationDisabledException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OperationDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OperationDisabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OperationDisabledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationDisabledException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for OperationDisabledException {}
/// See [`OperationDisabledException`](crate::error::OperationDisabledException)
pub mod operation_disabled_exception {
    /// A builder for [`OperationDisabledException`](crate::error::OperationDisabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OperationDisabledException`](crate::error::OperationDisabledException)
        pub fn build(self) -> crate::error::OperationDisabledException {
            crate::error::OperationDisabledException {
                message: self.message,
            }
        }
    }
}
impl OperationDisabledException {
    /// Creates a new builder-style object to manufacture [`OperationDisabledException`](crate::error::OperationDisabledException)
    pub fn builder() -> crate::error::operation_disabled_exception::Builder {
        crate::error::operation_disabled_exception::Builder::default()
    }
}

/// <p>The event bus policy is too long. For more information, see the limits.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PolicyLengthExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PolicyLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PolicyLengthExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PolicyLengthExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PolicyLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PolicyLengthExceededException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for PolicyLengthExceededException {}
/// See [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
pub mod policy_length_exceeded_exception {
    /// A builder for [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
        pub fn build(self) -> crate::error::PolicyLengthExceededException {
            crate::error::PolicyLengthExceededException {
                message: self.message,
            }
        }
    }
}
impl PolicyLengthExceededException {
    /// Creates a new builder-style object to manufacture [`PolicyLengthExceededException`](crate::error::PolicyLengthExceededException)
    pub fn builder() -> crate::error::policy_length_exceeded_exception::Builder {
        crate::error::policy_length_exceeded_exception::Builder::default()
    }
}

/// <p>The specified state is not a valid state for an event source.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidStateException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidStateException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidStateException {}
/// See [`InvalidStateException`](crate::error::InvalidStateException)
pub mod invalid_state_exception {
    /// A builder for [`InvalidStateException`](crate::error::InvalidStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidStateException`](crate::error::InvalidStateException)
        pub fn build(self) -> crate::error::InvalidStateException {
            crate::error::InvalidStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidStateException {
    /// Creates a new builder-style object to manufacture [`InvalidStateException`](crate::error::InvalidStateException)
    pub fn builder() -> crate::error::invalid_state_exception::Builder {
        crate::error::invalid_state_exception::Builder::default()
    }
}

/// <p>An error occurred because a replay can be canceled only when the state is Running or
/// Starting.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IllegalStatusException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IllegalStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IllegalStatusException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IllegalStatusException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IllegalStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IllegalStatusException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for IllegalStatusException {}
/// See [`IllegalStatusException`](crate::error::IllegalStatusException)
pub mod illegal_status_exception {
    /// A builder for [`IllegalStatusException`](crate::error::IllegalStatusException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IllegalStatusException`](crate::error::IllegalStatusException)
        pub fn build(self) -> crate::error::IllegalStatusException {
            crate::error::IllegalStatusException {
                message: self.message,
            }
        }
    }
}
impl IllegalStatusException {
    /// Creates a new builder-style object to manufacture [`IllegalStatusException`](crate::error::IllegalStatusException)
    pub fn builder() -> crate::error::illegal_status_exception::Builder {
        crate::error::illegal_status_exception::Builder::default()
    }
}
