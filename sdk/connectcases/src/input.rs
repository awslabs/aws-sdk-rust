// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

/// See [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
pub mod batch_get_field_input {
    
    /// A builder for [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>A list of unique field identifiers. </p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
                            v.push(input);
                            self.fields = Some(v);
                            self
        }
        /// <p>A list of unique field identifiers. </p>
        pub fn set_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>) -> Self {
            self.fields = input; self
        }
        /// Consumes the builder and constructs a [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
        pub fn build(self) -> Result<crate::input::BatchGetFieldInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchGetFieldInput {
                    domain_id: self.domain_id
                    ,
                    fields: self.fields
                    ,
                }
            )
        }
    }
    
    
}
impl BatchGetFieldInput {
    /// Consumes the builder and constructs an Operation<[`BatchGetField`](crate::operation::BatchGetField)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchGetField, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchGetFieldInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.domain_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/fields-batch", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchGetFieldInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_get_field(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchGetField::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchGetField", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
    pub fn builder() -> crate::input::batch_get_field_input::Builder {
        crate::input::batch_get_field_input::Builder::default()
    }
}

/// See [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
pub mod batch_put_field_options_input {
    
    /// A builder for [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<std::vec::Vec<crate::model::FieldOption>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input; self
        }
        /// Appends an item to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>A list of <code>FieldOption</code> objects.</p>
        pub fn options(mut self, input: crate::model::FieldOption) -> Self {
            let mut v = self.options.unwrap_or_default();
                            v.push(input);
                            self.options = Some(v);
                            self
        }
        /// <p>A list of <code>FieldOption</code> objects.</p>
        pub fn set_options(mut self, input: std::option::Option<std::vec::Vec<crate::model::FieldOption>>) -> Self {
            self.options = input; self
        }
        /// Consumes the builder and constructs a [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
        pub fn build(self) -> Result<crate::input::BatchPutFieldOptionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::BatchPutFieldOptionsInput {
                    domain_id: self.domain_id
                    ,
                    field_id: self.field_id
                    ,
                    options: self.options
                    ,
                }
            )
        }
    }
    
    
}
impl BatchPutFieldOptionsInput {
    /// Consumes the builder and constructs an Operation<[`BatchPutFieldOptions`](crate::operation::BatchPutFieldOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::BatchPutFieldOptions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::BatchPutFieldOptionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.domain_id;
                let input_2 = input_2.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_2, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_3 = &_input.field_id;
                let input_3 = input_3.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("field_id", "cannot be empty or unset"))?;
                let field_id = aws_smithy_http::label::fmt_string(input_3, aws_smithy_http::label::EncodingStrategy::Default);
                if field_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("field_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/fields/{fieldId}/options", domainId = domain_id, fieldId = field_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::BatchPutFieldOptionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_put_field_options(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::BatchPutFieldOptions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("BatchPutFieldOptions", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
    pub fn builder() -> crate::input::batch_put_field_options_input::Builder {
        crate::input::batch_put_field_options_input::Builder::default()
    }
}

/// See [`CreateCaseInput`](crate::input::CreateCaseInput).
pub mod create_case_input {
    
    /// A builder for [`CreateCaseInput`](crate::input::CreateCaseInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input; self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
        pub fn fields(mut self, input: crate::model::FieldValue) -> Self {
            let mut v = self.fields.unwrap_or_default();
                            v.push(input);
                            self.fields = Some(v);
                            self
        }
        /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
        pub fn set_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::FieldValue>>) -> Self {
            self.fields = input; self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input; self
        }
        /// Consumes the builder and constructs a [`CreateCaseInput`](crate::input::CreateCaseInput).
        pub fn build(self) -> Result<crate::input::CreateCaseInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateCaseInput {
                    domain_id: self.domain_id
                    ,
                    template_id: self.template_id
                    ,
                    fields: self.fields
                    ,
                    client_token: self.client_token
                    ,
                }
            )
        }
    }
    
    
}
impl CreateCaseInput {
    /// Consumes the builder and constructs an Operation<[`CreateCase`](crate::operation::CreateCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateCase, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_token.is_none() {
                                self.client_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::input::CreateCaseInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.domain_id;
                let input_4 = input_4.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_4, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/cases", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateCaseInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_case(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateCase::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateCase", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateCaseInput`](crate::input::CreateCaseInput).
    pub fn builder() -> crate::input::create_case_input::Builder {
        crate::input::create_case_input::Builder::default()
    }
}

/// See [`CreateDomainInput`](crate::input::CreateDomainInput).
pub mod create_domain_input {
    
    /// A builder for [`CreateDomainInput`](crate::input::CreateDomainInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// Consumes the builder and constructs a [`CreateDomainInput`](crate::input::CreateDomainInput).
        pub fn build(self) -> Result<crate::input::CreateDomainInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateDomainInput {
                    name: self.name
                    ,
                }
            )
        }
    }
    
    
}
impl CreateDomainInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomain`](crate::operation::CreateDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateDomain, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateDomainInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/domains").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateDomainInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_domain(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateDomain::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateDomain", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput).
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
}

/// See [`CreateFieldInput`](crate::input::CreateFieldInput).
pub mod create_field_input {
    
    /// A builder for [`CreateFieldInput`](crate::input::CreateFieldInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::FieldType>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Defines the data type, some system constraints, and default display of the field.</p>
        pub fn r#type(mut self, input: crate::model::FieldType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Defines the data type, some system constraints, and default display of the field.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::FieldType>) -> Self {
            self.r#type = input; self
        }
        /// <p>The description of the field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Consumes the builder and constructs a [`CreateFieldInput`](crate::input::CreateFieldInput).
        pub fn build(self) -> Result<crate::input::CreateFieldInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateFieldInput {
                    domain_id: self.domain_id
                    ,
                    name: self.name
                    ,
                    r#type: self.r#type
                    ,
                    description: self.description
                    ,
                }
            )
        }
    }
    
    
}
impl CreateFieldInput {
    /// Consumes the builder and constructs an Operation<[`CreateField`](crate::operation::CreateField)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateField, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateFieldInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.domain_id;
                let input_5 = input_5.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_5, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/fields", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateFieldInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_field(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateField::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateField", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateFieldInput`](crate::input::CreateFieldInput).
    pub fn builder() -> crate::input::create_field_input::Builder {
        crate::input::create_field_input::Builder::default()
    }
}

/// See [`CreateLayoutInput`](crate::input::CreateLayoutInput).
pub mod create_layout_input {
    
    /// A builder for [`CreateLayoutInput`](crate::input::CreateLayoutInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<crate::model::LayoutContent>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The name of the layout. It must be unique for the Cases domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the layout. It must be unique for the Cases domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
        pub fn content(mut self, input: crate::model::LayoutContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
        pub fn set_content(mut self, input: std::option::Option<crate::model::LayoutContent>) -> Self {
            self.content = input; self
        }
        /// Consumes the builder and constructs a [`CreateLayoutInput`](crate::input::CreateLayoutInput).
        pub fn build(self) -> Result<crate::input::CreateLayoutInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateLayoutInput {
                    domain_id: self.domain_id
                    ,
                    name: self.name
                    ,
                    content: self.content
                    ,
                }
            )
        }
    }
    
    
}
impl CreateLayoutInput {
    /// Consumes the builder and constructs an Operation<[`CreateLayout`](crate::operation::CreateLayout)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateLayout, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateLayoutInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.domain_id;
                let input_6 = input_6.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_6, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/layouts", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateLayoutInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_layout(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateLayout::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateLayout", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateLayoutInput`](crate::input::CreateLayoutInput).
    pub fn builder() -> crate::input::create_layout_input::Builder {
        crate::input::create_layout_input::Builder::default()
    }
}

/// See [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
pub mod create_related_item_input {
    
    /// A builder for [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::RelatedItemType>,
        pub(crate) content: std::option::Option<crate::model::RelatedItemInputContent>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input; self
        }
        /// <p>The type of a related item.</p>
        pub fn r#type(mut self, input: crate::model::RelatedItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of a related item.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::RelatedItemType>) -> Self {
            self.r#type = input; self
        }
        /// <p>The content of a related item to be created.</p>
        pub fn content(mut self, input: crate::model::RelatedItemInputContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>The content of a related item to be created.</p>
        pub fn set_content(mut self, input: std::option::Option<crate::model::RelatedItemInputContent>) -> Self {
            self.content = input; self
        }
        /// Consumes the builder and constructs a [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
        pub fn build(self) -> Result<crate::input::CreateRelatedItemInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateRelatedItemInput {
                    domain_id: self.domain_id
                    ,
                    case_id: self.case_id
                    ,
                    r#type: self.r#type
                    ,
                    content: self.content
                    ,
                }
            )
        }
    }
    
    
}
impl CreateRelatedItemInput {
    /// Consumes the builder and constructs an Operation<[`CreateRelatedItem`](crate::operation::CreateRelatedItem)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateRelatedItem, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateRelatedItemInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.domain_id;
                let input_7 = input_7.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_7, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_8 = &_input.case_id;
                let input_8 = input_8.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))?;
                let case_id = aws_smithy_http::label::fmt_string(input_8, aws_smithy_http::label::EncodingStrategy::Default);
                if case_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/cases/{caseId}/related-items", domainId = domain_id, caseId = case_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateRelatedItemInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_related_item(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateRelatedItem::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateRelatedItem", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
    pub fn builder() -> crate::input::create_related_item_input::Builder {
        crate::input::create_related_item_input::Builder::default()
    }
}

/// See [`CreateTemplateInput`](crate::input::CreateTemplateInput).
pub mod create_template_input {
    
    /// A builder for [`CreateTemplateInput`](crate::input::CreateTemplateInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
        pub(crate) required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
        pub(crate) status: std::option::Option<crate::model::TemplateStatus>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A name for the template. It must be unique per domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the template. It must be unique per domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A brief description of the template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn layout_configuration(mut self, input: crate::model::LayoutConfiguration) -> Self {
            self.layout_configuration = Some(input);
            self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn set_layout_configuration(mut self, input: std::option::Option<crate::model::LayoutConfiguration>) -> Self {
            self.layout_configuration = input; self
        }
        /// Appends an item to `required_fields`.
        ///
        /// To override the contents of this collection use [`set_required_fields`](Self::set_required_fields).
        ///
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn required_fields(mut self, input: crate::model::RequiredField) -> Self {
            let mut v = self.required_fields.unwrap_or_default();
                            v.push(input);
                            self.required_fields = Some(v);
                            self
        }
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn set_required_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::RequiredField>>) -> Self {
            self.required_fields = input; self
        }
        /// <p>The status of the template.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the template.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::TemplateStatus>) -> Self {
            self.status = input; self
        }
        /// Consumes the builder and constructs a [`CreateTemplateInput`](crate::input::CreateTemplateInput).
        pub fn build(self) -> Result<crate::input::CreateTemplateInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::CreateTemplateInput {
                    domain_id: self.domain_id
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                    layout_configuration: self.layout_configuration
                    ,
                    required_fields: self.required_fields
                    ,
                    status: self.status
                    ,
                }
            )
        }
    }
    
    
}
impl CreateTemplateInput {
    /// Consumes the builder and constructs an Operation<[`CreateTemplate`](crate::operation::CreateTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::CreateTemplate, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::CreateTemplateInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.domain_id;
                let input_9 = input_9.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_9, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/templates", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::CreateTemplateInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_template(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::CreateTemplate::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateTemplate", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`CreateTemplateInput`](crate::input::CreateTemplateInput).
    pub fn builder() -> crate::input::create_template_input::Builder {
        crate::input::create_template_input::Builder::default()
    }
}

/// See [`GetCaseInput`](crate::input::GetCaseInput).
pub mod get_case_input {
    
    /// A builder for [`GetCaseInput`](crate::input::GetCaseInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input; self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>A list of unique field identifiers. </p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
                            v.push(input);
                            self.fields = Some(v);
                            self
        }
        /// <p>A list of unique field identifiers. </p>
        pub fn set_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>) -> Self {
            self.fields = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`GetCaseInput`](crate::input::GetCaseInput).
        pub fn build(self) -> Result<crate::input::GetCaseInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetCaseInput {
                    case_id: self.case_id
                    ,
                    domain_id: self.domain_id
                    ,
                    fields: self.fields
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl GetCaseInput {
    /// Consumes the builder and constructs an Operation<[`GetCase`](crate::operation::GetCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetCase, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetCaseInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.domain_id;
                let input_10 = input_10.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_10, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_11 = &_input.case_id;
                let input_11 = input_11.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))?;
                let case_id = aws_smithy_http::label::fmt_string(input_11, aws_smithy_http::label::EncodingStrategy::Default);
                if case_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/cases/{caseId}", domainId = domain_id, caseId = case_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetCaseInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_case(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetCase::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetCase", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetCaseInput`](crate::input::GetCaseInput).
    pub fn builder() -> crate::input::get_case_input::Builder {
        crate::input::get_case_input::Builder::default()
    }
}

/// See [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
pub mod get_case_event_configuration_input {
    
    /// A builder for [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// Consumes the builder and constructs a [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
        pub fn build(self) -> Result<crate::input::GetCaseEventConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetCaseEventConfigurationInput {
                    domain_id: self.domain_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetCaseEventConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetCaseEventConfiguration`](crate::operation::GetCaseEventConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetCaseEventConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetCaseEventConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.domain_id;
                let input_12 = input_12.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_12, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/case-event-configuration", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetCaseEventConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetCaseEventConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetCaseEventConfiguration", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
    pub fn builder() -> crate::input::get_case_event_configuration_input::Builder {
        crate::input::get_case_event_configuration_input::Builder::default()
    }
}

/// See [`GetDomainInput`](crate::input::GetDomainInput).
pub mod get_domain_input {
    
    /// A builder for [`GetDomainInput`](crate::input::GetDomainInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// Consumes the builder and constructs a [`GetDomainInput`](crate::input::GetDomainInput).
        pub fn build(self) -> Result<crate::input::GetDomainInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetDomainInput {
                    domain_id: self.domain_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetDomainInput {
    /// Consumes the builder and constructs an Operation<[`GetDomain`](crate::operation::GetDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetDomain, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetDomainInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.domain_id;
                let input_13 = input_13.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_13, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetDomainInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetDomain::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetDomain", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetDomainInput`](crate::input::GetDomainInput).
    pub fn builder() -> crate::input::get_domain_input::Builder {
        crate::input::get_domain_input::Builder::default()
    }
}

/// See [`GetLayoutInput`](crate::input::GetLayoutInput).
pub mod get_layout_input {
    
    /// A builder for [`GetLayoutInput`](crate::input::GetLayoutInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) layout_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.layout_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn set_layout_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layout_id = input; self
        }
        /// Consumes the builder and constructs a [`GetLayoutInput`](crate::input::GetLayoutInput).
        pub fn build(self) -> Result<crate::input::GetLayoutInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetLayoutInput {
                    domain_id: self.domain_id
                    ,
                    layout_id: self.layout_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetLayoutInput {
    /// Consumes the builder and constructs an Operation<[`GetLayout`](crate::operation::GetLayout)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetLayout, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetLayoutInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.domain_id;
                let input_14 = input_14.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_14, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_15 = &_input.layout_id;
                let input_15 = input_15.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("layout_id", "cannot be empty or unset"))?;
                let layout_id = aws_smithy_http::label::fmt_string(input_15, aws_smithy_http::label::EncodingStrategy::Default);
                if layout_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("layout_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/layouts/{layoutId}", domainId = domain_id, layoutId = layout_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetLayoutInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetLayout::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetLayout", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetLayoutInput`](crate::input::GetLayoutInput).
    pub fn builder() -> crate::input::get_layout_input::Builder {
        crate::input::get_layout_input::Builder::default()
    }
}

/// See [`GetTemplateInput`](crate::input::GetTemplateInput).
pub mod get_template_input {
    
    /// A builder for [`GetTemplateInput`](crate::input::GetTemplateInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input; self
        }
        /// Consumes the builder and constructs a [`GetTemplateInput`](crate::input::GetTemplateInput).
        pub fn build(self) -> Result<crate::input::GetTemplateInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::GetTemplateInput {
                    domain_id: self.domain_id
                    ,
                    template_id: self.template_id
                    ,
                }
            )
        }
    }
    
    
}
impl GetTemplateInput {
    /// Consumes the builder and constructs an Operation<[`GetTemplate`](crate::operation::GetTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::GetTemplate, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::GetTemplateInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.domain_id;
                let input_16 = input_16.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_16, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_17 = &_input.template_id;
                let input_17 = input_17.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("template_id", "cannot be empty or unset"))?;
                let template_id = aws_smithy_http::label::fmt_string(input_17, aws_smithy_http::label::EncodingStrategy::Default);
                if template_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("template_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/templates/{templateId}", domainId = domain_id, templateId = template_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::GetTemplateInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::GetTemplate::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("GetTemplate", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`GetTemplateInput`](crate::input::GetTemplateInput).
    pub fn builder() -> crate::input::get_template_input::Builder {
        crate::input::get_template_input::Builder::default()
    }
}

/// See [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
pub mod list_cases_for_contact_input {
    
    /// A builder for [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) contact_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn contact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_arn = Some(input.into());
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn set_contact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_arn = input; self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
        pub fn build(self) -> Result<crate::input::ListCasesForContactInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListCasesForContactInput {
                    domain_id: self.domain_id
                    ,
                    contact_arn: self.contact_arn
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListCasesForContactInput {
    /// Consumes the builder and constructs an Operation<[`ListCasesForContact`](crate::operation::ListCasesForContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListCasesForContact, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListCasesForContactInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.domain_id;
                let input_18 = input_18.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_18, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/list-cases-for-contact", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListCasesForContactInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_cases_for_contact(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListCasesForContact::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListCasesForContact", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
    pub fn builder() -> crate::input::list_cases_for_contact_input::Builder {
        crate::input::list_cases_for_contact_input::Builder::default()
    }
}

/// See [`ListDomainsInput`](crate::input::ListDomainsInput).
pub mod list_domains_input {
    
    /// A builder for [`ListDomainsInput`](crate::input::ListDomainsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListDomainsInput`](crate::input::ListDomainsInput).
        pub fn build(self) -> Result<crate::input::ListDomainsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListDomainsInput {
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListDomainsInput {
    /// Consumes the builder and constructs an Operation<[`ListDomains`](crate::operation::ListDomains)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListDomains, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListDomainsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/domains-list").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListDomainsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_19) = &_input.max_results {
                    if *inner_19 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_19).encode());
                    }
                }
                if let Some(inner_20) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_20));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListDomainsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListDomains::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListDomains", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput).
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
}

/// See [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
pub mod list_field_options_input {
    
    /// A builder for [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input; self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
                            v.push(input.into());
                            self.values = Some(v);
                            self
        }
        /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.values = input; self
        }
        /// Consumes the builder and constructs a [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
        pub fn build(self) -> Result<crate::input::ListFieldOptionsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListFieldOptionsInput {
                    domain_id: self.domain_id
                    ,
                    field_id: self.field_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    values: self.values
                    ,
                }
            )
        }
    }
    
    
}
impl ListFieldOptionsInput {
    /// Consumes the builder and constructs an Operation<[`ListFieldOptions`](crate::operation::ListFieldOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListFieldOptions, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListFieldOptionsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_21 = &_input.domain_id;
                let input_21 = input_21.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_21, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_22 = &_input.field_id;
                let input_22 = input_22.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("field_id", "cannot be empty or unset"))?;
                let field_id = aws_smithy_http::label::fmt_string(input_22, aws_smithy_http::label::EncodingStrategy::Default);
                if field_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("field_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/fields/{fieldId}/options-list", domainId = domain_id, fieldId = field_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListFieldOptionsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_23) = &_input.max_results {
                    if *inner_23 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_23).encode());
                    }
                }
                if let Some(inner_24) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_24));
                    }
                }
                if let Some(inner_25) = &_input.values {
                     {
                        for inner_26 in inner_25 {
                            query.push_kv("values", &aws_smithy_http::query::fmt_string(&inner_26));
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListFieldOptionsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListFieldOptions::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListFieldOptions", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
    pub fn builder() -> crate::input::list_field_options_input::Builder {
        crate::input::list_field_options_input::Builder::default()
    }
}

/// See [`ListFieldsInput`](crate::input::ListFieldsInput).
pub mod list_fields_input {
    
    /// A builder for [`ListFieldsInput`](crate::input::ListFieldsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListFieldsInput`](crate::input::ListFieldsInput).
        pub fn build(self) -> Result<crate::input::ListFieldsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListFieldsInput {
                    domain_id: self.domain_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListFieldsInput {
    /// Consumes the builder and constructs an Operation<[`ListFields`](crate::operation::ListFields)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListFields, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListFieldsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_27 = &_input.domain_id;
                let input_27 = input_27.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_27, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/fields-list", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListFieldsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_28) = &_input.max_results {
                    if *inner_28 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_28).encode());
                    }
                }
                if let Some(inner_29) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_29));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListFieldsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListFields::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListFields", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListFieldsInput`](crate::input::ListFieldsInput).
    pub fn builder() -> crate::input::list_fields_input::Builder {
        crate::input::list_fields_input::Builder::default()
    }
}

/// See [`ListLayoutsInput`](crate::input::ListLayoutsInput).
pub mod list_layouts_input {
    
    /// A builder for [`ListLayoutsInput`](crate::input::ListLayoutsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Consumes the builder and constructs a [`ListLayoutsInput`](crate::input::ListLayoutsInput).
        pub fn build(self) -> Result<crate::input::ListLayoutsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListLayoutsInput {
                    domain_id: self.domain_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                }
            )
        }
    }
    
    
}
impl ListLayoutsInput {
    /// Consumes the builder and constructs an Operation<[`ListLayouts`](crate::operation::ListLayouts)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListLayouts, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListLayoutsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.domain_id;
                let input_30 = input_30.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_30, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/layouts-list", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListLayoutsInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_31) = &_input.max_results {
                    if *inner_31 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_31).encode());
                    }
                }
                if let Some(inner_32) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_32));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListLayoutsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListLayouts::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListLayouts", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListLayoutsInput`](crate::input::ListLayoutsInput).
    pub fn builder() -> crate::input::list_layouts_input::Builder {
        crate::input::list_layouts_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {
    
    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(self) -> Result<crate::input::ListTagsForResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTagsForResourceInput {
                    arn: self.arn
                    ,
                }
            )
        }
    }
    
    
}
impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTagsForResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTagsForResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_33 = &_input.arn;
                let input_33 = input_33.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("arn", "cannot be empty or unset"))?;
                let arn = aws_smithy_http::label::fmt_string(input_33, aws_smithy_http::label::EncodingStrategy::Default);
                if arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{arn}", arn = arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTagsForResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTagsForResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTagsForResource", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTemplatesInput`](crate::input::ListTemplatesInput).
pub mod list_templates_input {
    
    /// A builder for [`ListTemplatesInput`](crate::input::ListTemplatesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::vec::Vec<crate::model::TemplateStatus>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Appends an item to `status`.
        ///
        /// To override the contents of this collection use [`set_status`](Self::set_status).
        ///
        /// <p>A list of status values to filter on.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            let mut v = self.status.unwrap_or_default();
                            v.push(input);
                            self.status = Some(v);
                            self
        }
        /// <p>A list of status values to filter on.</p>
        pub fn set_status(mut self, input: std::option::Option<std::vec::Vec<crate::model::TemplateStatus>>) -> Self {
            self.status = input; self
        }
        /// Consumes the builder and constructs a [`ListTemplatesInput`](crate::input::ListTemplatesInput).
        pub fn build(self) -> Result<crate::input::ListTemplatesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::ListTemplatesInput {
                    domain_id: self.domain_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    status: self.status
                    ,
                }
            )
        }
    }
    
    
}
impl ListTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListTemplates`](crate::operation::ListTemplates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::ListTemplates, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::ListTemplatesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.domain_id;
                let input_34 = input_34.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_34, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/templates-list", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::ListTemplatesInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_35) = &_input.max_results {
                    if *inner_35 != 0 {
                        query.push_kv("maxResults", aws_smithy_types::primitive::Encoder::from(*inner_35).encode());
                    }
                }
                if let Some(inner_36) = &_input.next_token {
                     {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_36));
                    }
                }
                if let Some(inner_37) = &_input.status {
                     {
                        for inner_38 in inner_37 {
                            query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_38));
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::ListTemplatesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::ListTemplates::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("ListTemplates", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`ListTemplatesInput`](crate::input::ListTemplatesInput).
    pub fn builder() -> crate::input::list_templates_input::Builder {
        crate::input::list_templates_input::Builder::default()
    }
}

/// See [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
pub mod put_case_event_configuration_input {
    
    /// A builder for [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) event_bridge: std::option::Option<crate::model::EventBridgeConfiguration>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
        pub fn event_bridge(mut self, input: crate::model::EventBridgeConfiguration) -> Self {
            self.event_bridge = Some(input);
            self
        }
        /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
        pub fn set_event_bridge(mut self, input: std::option::Option<crate::model::EventBridgeConfiguration>) -> Self {
            self.event_bridge = input; self
        }
        /// Consumes the builder and constructs a [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
        pub fn build(self) -> Result<crate::input::PutCaseEventConfigurationInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::PutCaseEventConfigurationInput {
                    domain_id: self.domain_id
                    ,
                    event_bridge: self.event_bridge
                    ,
                }
            )
        }
    }
    
    
}
impl PutCaseEventConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutCaseEventConfiguration`](crate::operation::PutCaseEventConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::PutCaseEventConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::PutCaseEventConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.domain_id;
                let input_39 = input_39.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_39, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/case-event-configuration", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::PutCaseEventConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_case_event_configuration(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::PutCaseEventConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("PutCaseEventConfiguration", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
    pub fn builder() -> crate::input::put_case_event_configuration_input::Builder {
        crate::input::put_case_event_configuration_input::Builder::default()
    }
}

/// See [`SearchCasesInput`](crate::input::SearchCasesInput).
pub mod search_cases_input {
    
    /// A builder for [`SearchCasesInput`](crate::input::SearchCasesInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) search_term: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::CaseFilter>,
        pub(crate) sorts: std::option::Option<std::vec::Vec<crate::model::Sort>>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// <p>A word or phrase used to perform a quick search.</p>
        pub fn search_term(mut self, input: impl Into<std::string::String>) -> Self {
            self.search_term = Some(input.into());
            self
        }
        /// <p>A word or phrase used to perform a quick search.</p>
        pub fn set_search_term(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.search_term = input; self
        }
        /// <p>A list of filter objects.</p>
        pub fn filter(mut self, input: crate::model::CaseFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A list of filter objects.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::CaseFilter>) -> Self {
            self.filter = input; self
        }
        /// Appends an item to `sorts`.
        ///
        /// To override the contents of this collection use [`set_sorts`](Self::set_sorts).
        ///
        /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
        pub fn sorts(mut self, input: crate::model::Sort) -> Self {
            let mut v = self.sorts.unwrap_or_default();
                            v.push(input);
                            self.sorts = Some(v);
                            self
        }
        /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
        pub fn set_sorts(mut self, input: std::option::Option<std::vec::Vec<crate::model::Sort>>) -> Self {
            self.sorts = input; self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>The list of field identifiers to be returned as part of the response.</p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
                            v.push(input);
                            self.fields = Some(v);
                            self
        }
        /// <p>The list of field identifiers to be returned as part of the response.</p>
        pub fn set_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>) -> Self {
            self.fields = input; self
        }
        /// Consumes the builder and constructs a [`SearchCasesInput`](crate::input::SearchCasesInput).
        pub fn build(self) -> Result<crate::input::SearchCasesInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::SearchCasesInput {
                    domain_id: self.domain_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    search_term: self.search_term
                    ,
                    filter: self.filter
                    ,
                    sorts: self.sorts
                    ,
                    fields: self.fields
                    ,
                }
            )
        }
    }
    
    
}
impl SearchCasesInput {
    /// Consumes the builder and constructs an Operation<[`SearchCases`](crate::operation::SearchCases)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::SearchCases, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::SearchCasesInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_40 = &_input.domain_id;
                let input_40 = input_40.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_40, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/cases-search", domainId = domain_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::SearchCasesInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_search_cases(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::SearchCases::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("SearchCases", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SearchCasesInput`](crate::input::SearchCasesInput).
    pub fn builder() -> crate::input::search_cases_input::Builder {
        crate::input::search_cases_input::Builder::default()
    }
}

/// See [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
pub mod search_related_items_input {
    
    /// A builder for [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::RelatedItemTypeFilter>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input; self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input; self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input; self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>The list of types of related items and their parameters to use for filtering.</p>
        pub fn filters(mut self, input: crate::model::RelatedItemTypeFilter) -> Self {
            let mut v = self.filters.unwrap_or_default();
                            v.push(input);
                            self.filters = Some(v);
                            self
        }
        /// <p>The list of types of related items and their parameters to use for filtering.</p>
        pub fn set_filters(mut self, input: std::option::Option<std::vec::Vec<crate::model::RelatedItemTypeFilter>>) -> Self {
            self.filters = input; self
        }
        /// Consumes the builder and constructs a [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
        pub fn build(self) -> Result<crate::input::SearchRelatedItemsInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::SearchRelatedItemsInput {
                    domain_id: self.domain_id
                    ,
                    case_id: self.case_id
                    ,
                    max_results: self.max_results
                    ,
                    next_token: self.next_token
                    ,
                    filters: self.filters
                    ,
                }
            )
        }
    }
    
    
}
impl SearchRelatedItemsInput {
    /// Consumes the builder and constructs an Operation<[`SearchRelatedItems`](crate::operation::SearchRelatedItems)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::SearchRelatedItems, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::SearchRelatedItemsInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_41 = &_input.domain_id;
                let input_41 = input_41.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_41, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_42 = &_input.case_id;
                let input_42 = input_42.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))?;
                let case_id = aws_smithy_http::label::fmt_string(input_42, aws_smithy_http::label::EncodingStrategy::Default);
                if case_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/cases/{caseId}/related-items-search", domainId = domain_id, caseId = case_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::SearchRelatedItemsInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_search_related_items(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::SearchRelatedItems::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("SearchRelatedItems", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
    pub fn builder() -> crate::input::search_related_items_input::Builder {
        crate::input::search_related_items_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {
    
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn tags(mut self, k: impl Into<std::string::String>, v: std::option::Option<std::string::String>) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
                            hash_map.insert(k.into(), v);
                            self.tags = Some(hash_map);
                            self
        }
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>>) -> Self {
            self.tags = input; self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(self) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::TagResourceInput {
                    arn: self.arn
                    ,
                    tags: self.tags
                    ,
                }
            )
        }
    }
    
    
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::TagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::TagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_43 = &_input.arn;
                let input_43 = input_43.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("arn", "cannot be empty or unset"))?;
                let arn = aws_smithy_http::label::fmt_string(input_43, aws_smithy_http::label::EncodingStrategy::Default);
                if arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{arn}", arn = arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::TagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::TagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("TagResource", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {
    
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input; self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>List of tag keys.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
                            v.push(input.into());
                            self.tag_keys = Some(v);
                            self
        }
        /// <p>List of tag keys.</p>
        pub fn set_tag_keys(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
            self.tag_keys = input; self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(self) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UntagResourceInput {
                    arn: self.arn
                    ,
                    tag_keys: self.tag_keys
                    ,
                }
            )
        }
    }
    
    
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UntagResource, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UntagResourceInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_44 = &_input.arn;
                let input_44 = input_44.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("arn", "cannot be empty or unset"))?;
                let arn = aws_smithy_http::label::fmt_string(input_44, aws_smithy_http::label::EncodingStrategy::Default);
                if arn.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("arn", "cannot be empty or unset"))
                            }
                write!(output, "/tags/{arn}", arn = arn).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(_input: &crate::input::UntagResourceInput, mut output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_45 = &_input.tag_keys;
                let inner_45 = inner_45.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("tag_keys", "cannot be empty or unset"))?;
                for inner_46 in inner_45 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_46));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UntagResourceInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            ""
        );
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UntagResource::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UntagResource", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateCaseInput`](crate::input::UpdateCaseInput).
pub mod update_case_input {
    
    /// A builder for [`UpdateCaseInput`](crate::input::UpdateCaseInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input; self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
        pub fn fields(mut self, input: crate::model::FieldValue) -> Self {
            let mut v = self.fields.unwrap_or_default();
                            v.push(input);
                            self.fields = Some(v);
                            self
        }
        /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
        pub fn set_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::FieldValue>>) -> Self {
            self.fields = input; self
        }
        /// Consumes the builder and constructs a [`UpdateCaseInput`](crate::input::UpdateCaseInput).
        pub fn build(self) -> Result<crate::input::UpdateCaseInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateCaseInput {
                    domain_id: self.domain_id
                    ,
                    case_id: self.case_id
                    ,
                    fields: self.fields
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateCaseInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCase`](crate::operation::UpdateCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateCase, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateCaseInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_47 = &_input.domain_id;
                let input_47 = input_47.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_47, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_48 = &_input.case_id;
                let input_48 = input_48.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))?;
                let case_id = aws_smithy_http::label::fmt_string(input_48, aws_smithy_http::label::EncodingStrategy::Default);
                if case_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("case_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/cases/{caseId}", domainId = domain_id, caseId = case_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateCaseInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_case(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateCase::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateCase", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateCaseInput`](crate::input::UpdateCaseInput).
    pub fn builder() -> crate::input::update_case_input::Builder {
        crate::input::update_case_input::Builder::default()
    }
}

/// See [`UpdateFieldInput`](crate::input::UpdateFieldInput).
pub mod update_field_input {
    
    /// A builder for [`UpdateFieldInput`](crate::input::UpdateFieldInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input; self
        }
        /// <p>The name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>The description of a field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// Consumes the builder and constructs a [`UpdateFieldInput`](crate::input::UpdateFieldInput).
        pub fn build(self) -> Result<crate::input::UpdateFieldInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateFieldInput {
                    domain_id: self.domain_id
                    ,
                    field_id: self.field_id
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateFieldInput {
    /// Consumes the builder and constructs an Operation<[`UpdateField`](crate::operation::UpdateField)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateField, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateFieldInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_49 = &_input.domain_id;
                let input_49 = input_49.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_49, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_50 = &_input.field_id;
                let input_50 = input_50.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("field_id", "cannot be empty or unset"))?;
                let field_id = aws_smithy_http::label::fmt_string(input_50, aws_smithy_http::label::EncodingStrategy::Default);
                if field_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("field_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/fields/{fieldId}", domainId = domain_id, fieldId = field_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateFieldInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_field(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateField::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateField", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateFieldInput`](crate::input::UpdateFieldInput).
    pub fn builder() -> crate::input::update_field_input::Builder {
        crate::input::update_field_input::Builder::default()
    }
}

/// See [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
pub mod update_layout_input {
    
    /// A builder for [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) layout_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<crate::model::LayoutContent>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.layout_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn set_layout_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layout_id = input; self
        }
        /// <p>The name of the layout. It must be unique per domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the layout. It must be unique per domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
        pub fn content(mut self, input: crate::model::LayoutContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
        pub fn set_content(mut self, input: std::option::Option<crate::model::LayoutContent>) -> Self {
            self.content = input; self
        }
        /// Consumes the builder and constructs a [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
        pub fn build(self) -> Result<crate::input::UpdateLayoutInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateLayoutInput {
                    domain_id: self.domain_id
                    ,
                    layout_id: self.layout_id
                    ,
                    name: self.name
                    ,
                    content: self.content
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateLayoutInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLayout`](crate::operation::UpdateLayout)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateLayout, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateLayoutInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.domain_id;
                let input_51 = input_51.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_51, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_52 = &_input.layout_id;
                let input_52 = input_52.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("layout_id", "cannot be empty or unset"))?;
                let layout_id = aws_smithy_http::label::fmt_string(input_52, aws_smithy_http::label::EncodingStrategy::Default);
                if layout_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("layout_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/layouts/{layoutId}", domainId = domain_id, layoutId = layout_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateLayoutInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_layout(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateLayout::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateLayout", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
    pub fn builder() -> crate::input::update_layout_input::Builder {
        crate::input::update_layout_input::Builder::default()
    }
}

/// See [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
pub mod update_template_input {
    
    /// A builder for [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
        pub(crate) required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
        pub(crate) status: std::option::Option<crate::model::TemplateStatus>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input; self
        }
        /// <p>A unique identifier for the template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input; self
        }
        /// <p>The name of the template. It must be unique per domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the template. It must be unique per domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input; self
        }
        /// <p>A brief description of the template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input; self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn layout_configuration(mut self, input: crate::model::LayoutConfiguration) -> Self {
            self.layout_configuration = Some(input);
            self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn set_layout_configuration(mut self, input: std::option::Option<crate::model::LayoutConfiguration>) -> Self {
            self.layout_configuration = input; self
        }
        /// Appends an item to `required_fields`.
        ///
        /// To override the contents of this collection use [`set_required_fields`](Self::set_required_fields).
        ///
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn required_fields(mut self, input: crate::model::RequiredField) -> Self {
            let mut v = self.required_fields.unwrap_or_default();
                            v.push(input);
                            self.required_fields = Some(v);
                            self
        }
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn set_required_fields(mut self, input: std::option::Option<std::vec::Vec<crate::model::RequiredField>>) -> Self {
            self.required_fields = input; self
        }
        /// <p>The status of the template.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the template.</p>
        pub fn set_status(mut self, input: std::option::Option<crate::model::TemplateStatus>) -> Self {
            self.status = input; self
        }
        /// Consumes the builder and constructs a [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
        pub fn build(self) -> Result<crate::input::UpdateTemplateInput, aws_smithy_http::operation::error::BuildError> {
            Ok(
                crate::input::UpdateTemplateInput {
                    domain_id: self.domain_id
                    ,
                    template_id: self.template_id
                    ,
                    name: self.name
                    ,
                    description: self.description
                    ,
                    layout_configuration: self.layout_configuration
                    ,
                    required_fields: self.required_fields
                    ,
                    status: self.status
                    ,
                }
            )
        }
    }
    
    
}
impl UpdateTemplateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTemplate`](crate::operation::UpdateTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::UpdateTemplate, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::input::UpdateTemplateInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_53 = &_input.domain_id;
                let input_53 = input_53.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))?;
                let domain_id = aws_smithy_http::label::fmt_string(input_53, aws_smithy_http::label::EncodingStrategy::Default);
                if domain_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("domain_id", "cannot be empty or unset"))
                            }
                let input_54 = &_input.template_id;
                let input_54 = input_54.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("template_id", "cannot be empty or unset"))?;
                let template_id = aws_smithy_http::label::fmt_string(input_54, aws_smithy_http::label::EncodingStrategy::Default);
                if template_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("template_id", "cannot be empty or unset"))
                            }
                write!(output, "/domains/{domainId}/templates/{templateId}", domainId = domain_id, templateId = template_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::input::UpdateTemplateInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_template(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::UpdateTemplate::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("UpdateTemplate", "connectcases"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
    /// Creates a new builder-style object to manufacture [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
    pub fn builder() -> crate::input::update_template_input::Builder {
        crate::input::update_template_input::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTemplatesInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of status values to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::vec::Vec<crate::model::TemplateStatus>>,
}
impl ListTemplatesInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A list of status values to filter on.</p>
    pub fn status(&self) -> std::option::Option<& [crate::model::TemplateStatus]> {
        self.status.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTemplateInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A name for the template. It must be unique per domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration of layouts associated to the template.</p>
    #[doc(hidden)]
    pub layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    #[doc(hidden)]
    pub required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
    /// <p>The status of the template.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TemplateStatus>,
}
impl CreateTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A name for the template. It must be unique per domain.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the template.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Configuration of layouts associated to the template.</p>
    pub fn layout_configuration(&self) -> std::option::Option<& crate::model::LayoutConfiguration> {
        self.layout_configuration.as_ref()
    }
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    pub fn required_fields(&self) -> std::option::Option<& [crate::model::RequiredField]> {
        self.required_fields.as_deref()
    }
    /// <p>The status of the template.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::TemplateStatus> {
        self.status.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateTemplateInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>The name of the template. It must be unique per domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration of layouts associated to the template.</p>
    #[doc(hidden)]
    pub layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    #[doc(hidden)]
    pub required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
    /// <p>The status of the template.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TemplateStatus>,
}
impl UpdateTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier for the template.</p>
    pub fn template_id(&self) -> std::option::Option<& str> {
        self.template_id.as_deref()
    }
    /// <p>The name of the template. It must be unique per domain.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the template.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>Configuration of layouts associated to the template.</p>
    pub fn layout_configuration(&self) -> std::option::Option<& crate::model::LayoutConfiguration> {
        self.layout_configuration.as_ref()
    }
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    pub fn required_fields(&self) -> std::option::Option<& [crate::model::RequiredField]> {
        self.required_fields.as_deref()
    }
    /// <p>The status of the template.</p>
    pub fn status(&self) -> std::option::Option<& crate::model::TemplateStatus> {
        self.status.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTemplateInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
}
impl GetTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of a template.</p>
    pub fn template_id(&self) -> std::option::Option<& str> {
        self.template_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLayoutsInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLayoutsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateLayoutInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The name of the layout. It must be unique for the Cases domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::LayoutContent>,
}
impl CreateLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The name of the layout. It must be unique for the Cases domain.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
    pub fn content(&self) -> std::option::Option<& crate::model::LayoutContent> {
        self.content.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateLayoutInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the layout.</p>
    #[doc(hidden)]
    pub layout_id: std::option::Option<std::string::String>,
    /// <p>The name of the layout. It must be unique per domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::LayoutContent>,
}
impl UpdateLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of the layout.</p>
    pub fn layout_id(&self) -> std::option::Option<& str> {
        self.layout_id.as_deref()
    }
    /// <p>The name of the layout. It must be unique per domain.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
    pub fn content(&self) -> std::option::Option<& crate::model::LayoutContent> {
        self.content.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLayoutInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the layout.</p>
    #[doc(hidden)]
    pub layout_id: std::option::Option<std::string::String>,
}
impl GetLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of the layout.</p>
    pub fn layout_id(&self) -> std::option::Option<& str> {
        self.layout_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFieldOptionsInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListFieldOptionsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<& str> {
        self.field_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
    pub fn values(&self) -> std::option::Option<& [std::string::String]> {
        self.values.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutFieldOptionsInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>A list of <code>FieldOption</code> objects.</p>
    #[doc(hidden)]
    pub options: std::option::Option<std::vec::Vec<crate::model::FieldOption>>,
}
impl BatchPutFieldOptionsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<& str> {
        self.field_id.as_deref()
    }
    /// <p>A list of <code>FieldOption</code> objects.</p>
    pub fn options(&self) -> std::option::Option<& [crate::model::FieldOption]> {
        self.options.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetFieldInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A list of unique field identifiers. </p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
}
impl BatchGetFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A list of unique field identifiers. </p>
    pub fn fields(&self) -> std::option::Option<& [crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFieldsInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListFieldsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFieldInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the data type, some system constraints, and default display of the field.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::FieldType>,
    /// <p>The description of the field.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl CreateFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The name of the field.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>Defines the data type, some system constraints, and default display of the field.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::FieldType> {
        self.r#type.as_ref()
    }
    /// <p>The description of the field.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFieldInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of a field.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<& str> {
        self.field_id.as_deref()
    }
    /// <p>The name of the field.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The description of a field.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutCaseEventConfigurationInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
    #[doc(hidden)]
    pub event_bridge: std::option::Option<crate::model::EventBridgeConfiguration>,
}
impl PutCaseEventConfigurationInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
    pub fn event_bridge(&self) -> std::option::Option<& crate::model::EventBridgeConfiguration> {
        self.event_bridge.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCaseEventConfigurationInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
}
impl GetCaseEventConfigurationInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDomainsInput  {
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDomainsInput {
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDomainInput  {
    /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl CreateDomainInput {
    /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDomainInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
}
impl GetDomainInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchCasesInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A word or phrase used to perform a quick search.</p>
    #[doc(hidden)]
    pub search_term: std::option::Option<std::string::String>,
    /// <p>A list of filter objects.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::CaseFilter>,
    /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
    #[doc(hidden)]
    pub sorts: std::option::Option<std::vec::Vec<crate::model::Sort>>,
    /// <p>The list of field identifiers to be returned as part of the response.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
}
impl SearchCasesInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>A word or phrase used to perform a quick search.</p>
    pub fn search_term(&self) -> std::option::Option<& str> {
        self.search_term.as_deref()
    }
    /// <p>A list of filter objects.</p>
    pub fn filter(&self) -> std::option::Option<& crate::model::CaseFilter> {
        self.filter.as_ref()
    }
    /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
    pub fn sorts(&self) -> std::option::Option<& [crate::model::Sort]> {
        self.sorts.as_deref()
    }
    /// <p>The list of field identifiers to be returned as part of the response.</p>
    pub fn fields(&self) -> std::option::Option<& [crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCasesForContactInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    #[doc(hidden)]
    pub contact_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCasesForContactInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    pub fn contact_arn(&self) -> std::option::Option<& str> {
        self.contact_arn.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCaseInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateCaseInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of a template.</p>
    pub fn template_id(&self) -> std::option::Option<& str> {
        self.template_id.as_deref()
    }
    /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
    pub fn fields(&self) -> std::option::Option<& [crate::model::FieldValue]> {
        self.fields.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<& str> {
        self.client_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCaseInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
}
impl UpdateCaseInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<& str> {
        self.case_id.as_deref()
    }
    /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
    pub fn fields(&self) -> std::option::Option<& [crate::model::FieldValue]> {
        self.fields.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCaseInput  {
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A list of unique field identifiers. </p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCaseInput {
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<& str> {
        self.case_id.as_deref()
    }
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A list of unique field identifiers. </p>
    pub fn fields(&self) -> std::option::Option<& [crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchRelatedItemsInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The list of types of related items and their parameters to use for filtering.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::RelatedItemTypeFilter>>,
}
impl SearchRelatedItemsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<& str> {
        self.case_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<& str> {
        self.next_token.as_deref()
    }
    /// <p>The list of types of related items and their parameters to use for filtering.</p>
    pub fn filters(&self) -> std::option::Option<& [crate::model::RelatedItemTypeFilter]> {
        self.filters.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRelatedItemInput  {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>The type of a related item.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::RelatedItemType>,
    /// <p>The content of a related item to be created.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::RelatedItemInputContent>,
}
impl CreateRelatedItemInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<& str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<& str> {
        self.case_id.as_deref()
    }
    /// <p>The type of a related item.</p>
    pub fn r#type(&self) -> std::option::Option<& crate::model::RelatedItemType> {
        self.r#type.as_ref()
    }
    /// <p>The content of a related item to be created.</p>
    pub fn content(&self) -> std::option::Option<& crate::model::RelatedItemInputContent> {
        self.content.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput  {
    /// <p>The Amazon Resource Name (ARN)</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>List of tag keys.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>List of tag keys.</p>
    pub fn tag_keys(&self) -> std::option::Option<& [std::string::String]> {
        self.tag_keys.as_deref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput  {
    /// <p>The Amazon Resource Name (ARN)</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>>,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>> {
        self.tags.as_ref()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput  {
    /// <p>The Amazon Resource Name (ARN)</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
}

