// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;
impl BatchGetFieldInput {
    /// Consumes the builder and constructs an Operation<[`BatchGetField`](crate::operation::BatchGetField)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchGetField,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchGetFieldInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.domain_id;
                let input_1 = input_1.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_1,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/fields-batch",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchGetFieldInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_get_field(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchGetField::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchGetField",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl BatchPutFieldOptionsInput {
    /// Consumes the builder and constructs an Operation<[`BatchPutFieldOptions`](crate::operation::BatchPutFieldOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::BatchPutFieldOptions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::BatchPutFieldOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_2 = &_input.domain_id;
                let input_2 = input_2.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_2,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_3 = &_input.field_id;
                let input_3 = input_3.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "field_id",
                        "cannot be empty or unset",
                    )
                })?;
                let field_id = aws_smithy_http::label::fmt_string(
                    input_3,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if field_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "field_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/fields/{fieldId}/options",
                    domainId = domain_id,
                    fieldId = field_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::BatchPutFieldOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_batch_put_field_options(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::BatchPutFieldOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchPutFieldOptions",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateCaseInput {
    /// Consumes the builder and constructs an Operation<[`CreateCase`](crate::operation::CreateCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateCase,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        if self.client_token.is_none() {
            self.client_token = Some(_config.make_token.make_idempotency_token());
        }
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateCaseInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_4 = &_input.domain_id;
                let input_4 = input_4.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_4,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/domains/{domainId}/cases", domainId = domain_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateCaseInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_case(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateCase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateCase",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateDomainInput {
    /// Consumes the builder and constructs an Operation<[`CreateDomain`](crate::operation::CreateDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/domains").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_domain(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateDomain::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDomain",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateFieldInput {
    /// Consumes the builder and constructs an Operation<[`CreateField`](crate::operation::CreateField)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateField,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateFieldInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_5 = &_input.domain_id;
                let input_5 = input_5.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_5,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/domains/{domainId}/fields", domainId = domain_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateFieldInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_field(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateField::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateField",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateLayoutInput {
    /// Consumes the builder and constructs an Operation<[`CreateLayout`](crate::operation::CreateLayout)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateLayout,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateLayoutInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_6 = &_input.domain_id;
                let input_6 = input_6.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_6,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/domains/{domainId}/layouts", domainId = domain_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateLayoutInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_layout(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateLayout::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateLayout",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateRelatedItemInput {
    /// Consumes the builder and constructs an Operation<[`CreateRelatedItem`](crate::operation::CreateRelatedItem)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateRelatedItem,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateRelatedItemInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_7 = &_input.domain_id;
                let input_7 = input_7.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_7,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_8 = &_input.case_id;
                let input_8 = input_8.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "case_id",
                        "cannot be empty or unset",
                    )
                })?;
                let case_id = aws_smithy_http::label::fmt_string(
                    input_8,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if case_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "case_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/cases/{caseId}/related-items",
                    domainId = domain_id,
                    caseId = case_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateRelatedItemInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_related_item(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateRelatedItem::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateRelatedItem",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl CreateTemplateInput {
    /// Consumes the builder and constructs an Operation<[`CreateTemplate`](crate::operation::CreateTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::CreateTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::CreateTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_9 = &_input.domain_id;
                let input_9 = input_9.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_9,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/templates",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::CreateTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_create_template(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::CreateTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateTemplate",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCaseInput {
    /// Consumes the builder and constructs an Operation<[`GetCase`](crate::operation::GetCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCase,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCaseInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_10 = &_input.domain_id;
                let input_10 = input_10.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_10,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_11 = &_input.case_id;
                let input_11 = input_11.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "case_id",
                        "cannot be empty or unset",
                    )
                })?;
                let case_id = aws_smithy_http::label::fmt_string(
                    input_11,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if case_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "case_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/cases/{caseId}",
                    domainId = domain_id,
                    caseId = case_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCaseInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_get_case(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetCase::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetCase",
                    "connectcases",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetCaseEventConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`GetCaseEventConfiguration`](crate::operation::GetCaseEventConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetCaseEventConfiguration,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetCaseEventConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_12 = &_input.domain_id;
                let input_12 = input_12.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_12,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/case-event-configuration",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetCaseEventConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetCaseEventConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetCaseEventConfiguration",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetDomainInput {
    /// Consumes the builder and constructs an Operation<[`GetDomain`](crate::operation::GetDomain)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetDomain,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetDomainInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_13 = &_input.domain_id;
                let input_13 = input_13.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_13,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/domains/{domainId}", domainId = domain_id)
                    .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetDomainInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetDomain::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetDomain",
                    "connectcases",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetLayoutInput {
    /// Consumes the builder and constructs an Operation<[`GetLayout`](crate::operation::GetLayout)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetLayout,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetLayoutInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_14 = &_input.domain_id;
                let input_14 = input_14.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_14,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_15 = &_input.layout_id;
                let input_15 = input_15.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "layout_id",
                        "cannot be empty or unset",
                    )
                })?;
                let layout_id = aws_smithy_http::label::fmt_string(
                    input_15,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if layout_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "layout_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/layouts/{layoutId}",
                    domainId = domain_id,
                    layoutId = layout_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetLayoutInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op =
            aws_smithy_http::operation::Operation::new(request, crate::operation::GetLayout::new())
                .with_metadata(aws_smithy_http::operation::Metadata::new(
                    "GetLayout",
                    "connectcases",
                ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl GetTemplateInput {
    /// Consumes the builder and constructs an Operation<[`GetTemplate`](crate::operation::GetTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::GetTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::GetTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_16 = &_input.domain_id;
                let input_16 = input_16.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_16,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_17 = &_input.template_id;
                let input_17 = input_17.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "template_id",
                        "cannot be empty or unset",
                    )
                })?;
                let template_id = aws_smithy_http::label::fmt_string(
                    input_17,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if template_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "template_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/templates/{templateId}",
                    domainId = domain_id,
                    templateId = template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::GetTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::GetTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "GetTemplate",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListCasesForContactInput {
    /// Consumes the builder and constructs an Operation<[`ListCasesForContact`](crate::operation::ListCasesForContact)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListCasesForContact,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListCasesForContactInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_18 = &_input.domain_id;
                let input_18 = input_18.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_18,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/list-cases-for-contact",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListCasesForContactInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_list_cases_for_contact(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListCasesForContact::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListCasesForContact",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListDomainsInput {
    /// Consumes the builder and constructs an Operation<[`ListDomains`](crate::operation::ListDomains)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListDomains,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListDomainsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/domains-list").expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListDomainsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_19) = &_input.max_results {
                    if *inner_19 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_19).encode(),
                        );
                    }
                }
                if let Some(inner_20) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_20));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListDomainsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListDomains::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListDomains",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListFieldOptionsInput {
    /// Consumes the builder and constructs an Operation<[`ListFieldOptions`](crate::operation::ListFieldOptions)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListFieldOptions,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListFieldOptionsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_21 = &_input.domain_id;
                let input_21 = input_21.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_21,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_22 = &_input.field_id;
                let input_22 = input_22.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "field_id",
                        "cannot be empty or unset",
                    )
                })?;
                let field_id = aws_smithy_http::label::fmt_string(
                    input_22,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if field_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "field_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/fields/{fieldId}/options-list",
                    domainId = domain_id,
                    fieldId = field_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListFieldOptionsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_23) = &_input.max_results {
                    if *inner_23 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_23).encode(),
                        );
                    }
                }
                if let Some(inner_24) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_24));
                    }
                }
                if let Some(inner_25) = &_input.values {
                    {
                        for inner_26 in inner_25 {
                            query.push_kv("values", &aws_smithy_http::query::fmt_string(&inner_26));
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListFieldOptionsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListFieldOptions::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListFieldOptions",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListFieldsInput {
    /// Consumes the builder and constructs an Operation<[`ListFields`](crate::operation::ListFields)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListFields,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListFieldsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_27 = &_input.domain_id;
                let input_27 = input_27.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_27,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/fields-list",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListFieldsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_28) = &_input.max_results {
                    if *inner_28 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_28).encode(),
                        );
                    }
                }
                if let Some(inner_29) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_29));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListFieldsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListFields::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListFields",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListLayoutsInput {
    /// Consumes the builder and constructs an Operation<[`ListLayouts`](crate::operation::ListLayouts)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListLayouts,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListLayoutsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_30 = &_input.domain_id;
                let input_30 = input_30.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_30,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/layouts-list",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListLayoutsInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_31) = &_input.max_results {
                    if *inner_31 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_31).encode(),
                        );
                    }
                }
                if let Some(inner_32) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_32));
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListLayoutsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListLayouts::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListLayouts",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTagsForResourceInput {
    /// Consumes the builder and constructs an Operation<[`ListTagsForResource`](crate::operation::ListTagsForResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTagsForResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTagsForResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_33 = &_input.arn;
                let input_33 = input_33.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "arn",
                        "cannot be empty or unset",
                    )
                })?;
                let arn = aws_smithy_http::label::fmt_string(
                    input_33,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{arn}", arn = arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTagsForResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("GET").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTagsForResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTagsForResource",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl ListTemplatesInput {
    /// Consumes the builder and constructs an Operation<[`ListTemplates`](crate::operation::ListTemplates)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::ListTemplates,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::ListTemplatesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_34 = &_input.domain_id;
                let input_34 = input_34.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_34,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/templates-list",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::ListTemplatesInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                if let Some(inner_35) = &_input.max_results {
                    if *inner_35 != 0 {
                        query.push_kv(
                            "maxResults",
                            aws_smithy_types::primitive::Encoder::from(*inner_35).encode(),
                        );
                    }
                }
                if let Some(inner_36) = &_input.next_token {
                    {
                        query.push_kv("nextToken", &aws_smithy_http::query::fmt_string(&inner_36));
                    }
                }
                if let Some(inner_37) = &_input.status {
                    {
                        for inner_38 in inner_37 {
                            query.push_kv("status", &aws_smithy_http::query::fmt_string(&inner_38));
                        }
                    }
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::ListTemplatesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::ListTemplates::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "ListTemplates",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl PutCaseEventConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`PutCaseEventConfiguration`](crate::operation::PutCaseEventConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::PutCaseEventConfiguration,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::PutCaseEventConfigurationInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_39 = &_input.domain_id;
                let input_39 = input_39.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_39,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/case-event-configuration",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::PutCaseEventConfigurationInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_put_case_event_configuration(
                &self,
            )?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::PutCaseEventConfiguration::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutCaseEventConfiguration",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchCasesInput {
    /// Consumes the builder and constructs an Operation<[`SearchCases`](crate::operation::SearchCases)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchCases,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchCasesInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_40 = &_input.domain_id;
                let input_40 = input_40.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_40,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/cases-search",
                    domainId = domain_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchCasesInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_search_cases(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchCases::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchCases",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl SearchRelatedItemsInput {
    /// Consumes the builder and constructs an Operation<[`SearchRelatedItems`](crate::operation::SearchRelatedItems)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::SearchRelatedItems,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::SearchRelatedItemsInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_41 = &_input.domain_id;
                let input_41 = input_41.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_41,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_42 = &_input.case_id;
                let input_42 = input_42.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "case_id",
                        "cannot be empty or unset",
                    )
                })?;
                let case_id = aws_smithy_http::label::fmt_string(
                    input_42,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if case_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "case_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/cases/{caseId}/related-items-search",
                    domainId = domain_id,
                    caseId = case_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::SearchRelatedItemsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_search_related_items(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::SearchRelatedItems::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "SearchRelatedItems",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::TagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_43 = &_input.arn;
                let input_43 = input_43.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "arn",
                        "cannot be empty or unset",
                    )
                })?;
                let arn = aws_smithy_http::label::fmt_string(
                    input_43,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{arn}", arn = arn).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::TagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_tag_resource(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::TagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "TagResource",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UntagResourceInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_44 = &_input.arn;
                let input_44 = input_44.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "arn",
                        "cannot be empty or unset",
                    )
                })?;
                let arn = aws_smithy_http::label::fmt_string(
                    input_44,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if arn.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "arn",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(output, "/tags/{arn}", arn = arn).expect("formatting should succeed");
                Ok(())
            }
            fn uri_query(
                _input: &crate::input::UntagResourceInput,
                mut output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let mut query = aws_smithy_http::query::Writer::new(&mut output);
                let inner_45 = &_input.tag_keys;
                let inner_45 = inner_45.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "tag_keys",
                        "cannot be empty or unset",
                    )
                })?;
                for inner_46 in inner_45 {
                    query.push_kv("tagKeys", &aws_smithy_http::query::fmt_string(&inner_46));
                }
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UntagResourceInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                uri_query(input, &mut uri)?;
                Ok(builder.method("DELETE").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from("");
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UntagResource::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UntagResource",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateCaseInput {
    /// Consumes the builder and constructs an Operation<[`UpdateCase`](crate::operation::UpdateCase)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateCase,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateCaseInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_47 = &_input.domain_id;
                let input_47 = input_47.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_47,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_48 = &_input.case_id;
                let input_48 = input_48.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "case_id",
                        "cannot be empty or unset",
                    )
                })?;
                let case_id = aws_smithy_http::label::fmt_string(
                    input_48,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if case_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "case_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/cases/{caseId}",
                    domainId = domain_id,
                    caseId = case_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateCaseInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_case(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateCase::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateCase",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateFieldInput {
    /// Consumes the builder and constructs an Operation<[`UpdateField`](crate::operation::UpdateField)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateField,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateFieldInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_49 = &_input.domain_id;
                let input_49 = input_49.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_49,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_50 = &_input.field_id;
                let input_50 = input_50.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "field_id",
                        "cannot be empty or unset",
                    )
                })?;
                let field_id = aws_smithy_http::label::fmt_string(
                    input_50,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if field_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "field_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/fields/{fieldId}",
                    domainId = domain_id,
                    fieldId = field_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateFieldInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_field(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateField::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateField",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateLayoutInput {
    /// Consumes the builder and constructs an Operation<[`UpdateLayout`](crate::operation::UpdateLayout)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateLayout,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateLayoutInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_51 = &_input.domain_id;
                let input_51 = input_51.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_51,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_52 = &_input.layout_id;
                let input_52 = input_52.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "layout_id",
                        "cannot be empty or unset",
                    )
                })?;
                let layout_id = aws_smithy_http::label::fmt_string(
                    input_52,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if layout_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "layout_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/layouts/{layoutId}",
                    domainId = domain_id,
                    layoutId = layout_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateLayoutInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_layout(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateLayout::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateLayout",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

impl UpdateTemplateInput {
    /// Consumes the builder and constructs an Operation<[`UpdateTemplate`](crate::operation::UpdateTemplate)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::UpdateTemplate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::input::UpdateTemplateInput,
                output: &mut String,
            ) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_53 = &_input.domain_id;
                let input_53 = input_53.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "domain_id",
                        "cannot be empty or unset",
                    )
                })?;
                let domain_id = aws_smithy_http::label::fmt_string(
                    input_53,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if domain_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "domain_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                let input_54 = &_input.template_id;
                let input_54 = input_54.as_ref().ok_or_else(|| {
                    aws_smithy_http::operation::error::BuildError::missing_field(
                        "template_id",
                        "cannot be empty or unset",
                    )
                })?;
                let template_id = aws_smithy_http::label::fmt_string(
                    input_54,
                    aws_smithy_http::label::EncodingStrategy::Default,
                );
                if template_id.is_empty() {
                    return Err(
                        aws_smithy_http::operation::error::BuildError::missing_field(
                            "template_id",
                            "cannot be empty or unset",
                        ),
                    );
                }
                write!(
                    output,
                    "/domains/{domainId}/templates/{templateId}",
                    domainId = domain_id,
                    templateId = template_id
                )
                .expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::input::UpdateTemplateInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("PUT").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::operation_ser::serialize_operation_crate_operation_update_template(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::UpdateTemplate::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "UpdateTemplate",
            "connectcases",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTemplatesInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of status values to filter on.</p>
    #[doc(hidden)]
    pub status: std::option::Option<std::vec::Vec<crate::model::TemplateStatus>>,
}
impl ListTemplatesInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>A list of status values to filter on.</p>
    pub fn status(&self) -> std::option::Option<&[crate::model::TemplateStatus]> {
        self.status.as_deref()
    }
}
impl ListTemplatesInput {
    /// Creates a new builder-style object to manufacture [`ListTemplatesInput`](crate::input::ListTemplatesInput).
    pub fn builder() -> crate::input::list_templates_input::Builder {
        crate::input::list_templates_input::Builder::default()
    }
}

/// See [`ListTemplatesInput`](crate::input::ListTemplatesInput).
pub mod list_templates_input {

    /// A builder for [`ListTemplatesInput`](crate::input::ListTemplatesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<std::vec::Vec<crate::model::TemplateStatus>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `status`.
        ///
        /// To override the contents of this collection use [`set_status`](Self::set_status).
        ///
        /// <p>A list of status values to filter on.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            let mut v = self.status.unwrap_or_default();
            v.push(input);
            self.status = Some(v);
            self
        }
        /// <p>A list of status values to filter on.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TemplateStatus>>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTemplatesInput`](crate::input::ListTemplatesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListTemplatesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListTemplatesInput {
                domain_id: self.domain_id,
                max_results: self.max_results,
                next_token: self.next_token,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A name for the template. It must be unique per domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration of layouts associated to the template.</p>
    #[doc(hidden)]
    pub layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    #[doc(hidden)]
    pub required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
    /// <p>The status of the template.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TemplateStatus>,
}
impl CreateTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A name for the template. It must be unique per domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Configuration of layouts associated to the template.</p>
    pub fn layout_configuration(&self) -> std::option::Option<&crate::model::LayoutConfiguration> {
        self.layout_configuration.as_ref()
    }
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    pub fn required_fields(&self) -> std::option::Option<&[crate::model::RequiredField]> {
        self.required_fields.as_deref()
    }
    /// <p>The status of the template.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TemplateStatus> {
        self.status.as_ref()
    }
}
impl CreateTemplateInput {
    /// Creates a new builder-style object to manufacture [`CreateTemplateInput`](crate::input::CreateTemplateInput).
    pub fn builder() -> crate::input::create_template_input::Builder {
        crate::input::create_template_input::Builder::default()
    }
}

/// See [`CreateTemplateInput`](crate::input::CreateTemplateInput).
pub mod create_template_input {

    /// A builder for [`CreateTemplateInput`](crate::input::CreateTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
        pub(crate) required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
        pub(crate) status: std::option::Option<crate::model::TemplateStatus>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A name for the template. It must be unique per domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A name for the template. It must be unique per domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn layout_configuration(mut self, input: crate::model::LayoutConfiguration) -> Self {
            self.layout_configuration = Some(input);
            self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn set_layout_configuration(
            mut self,
            input: std::option::Option<crate::model::LayoutConfiguration>,
        ) -> Self {
            self.layout_configuration = input;
            self
        }
        /// Appends an item to `required_fields`.
        ///
        /// To override the contents of this collection use [`set_required_fields`](Self::set_required_fields).
        ///
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn required_fields(mut self, input: crate::model::RequiredField) -> Self {
            let mut v = self.required_fields.unwrap_or_default();
            v.push(input);
            self.required_fields = Some(v);
            self
        }
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn set_required_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
        ) -> Self {
            self.required_fields = input;
            self
        }
        /// <p>The status of the template.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the template.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTemplateInput`](crate::input::CreateTemplateInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateTemplateInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateTemplateInput {
                domain_id: self.domain_id,
                name: self.name,
                description: self.description,
                layout_configuration: self.layout_configuration,
                required_fields: self.required_fields,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier for the template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>The name of the template. It must be unique per domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A brief description of the template.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Configuration of layouts associated to the template.</p>
    #[doc(hidden)]
    pub layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    #[doc(hidden)]
    pub required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
    /// <p>The status of the template.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TemplateStatus>,
}
impl UpdateTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier for the template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>The name of the template. It must be unique per domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A brief description of the template.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Configuration of layouts associated to the template.</p>
    pub fn layout_configuration(&self) -> std::option::Option<&crate::model::LayoutConfiguration> {
        self.layout_configuration.as_ref()
    }
    /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
    pub fn required_fields(&self) -> std::option::Option<&[crate::model::RequiredField]> {
        self.required_fields.as_deref()
    }
    /// <p>The status of the template.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TemplateStatus> {
        self.status.as_ref()
    }
}
impl UpdateTemplateInput {
    /// Creates a new builder-style object to manufacture [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
    pub fn builder() -> crate::input::update_template_input::Builder {
        crate::input::update_template_input::Builder::default()
    }
}

/// See [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
pub mod update_template_input {

    /// A builder for [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) layout_configuration: std::option::Option<crate::model::LayoutConfiguration>,
        pub(crate) required_fields: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
        pub(crate) status: std::option::Option<crate::model::TemplateStatus>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier for the template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier for the template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>The name of the template. It must be unique per domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the template. It must be unique per domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A brief description of the template.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A brief description of the template.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn layout_configuration(mut self, input: crate::model::LayoutConfiguration) -> Self {
            self.layout_configuration = Some(input);
            self
        }
        /// <p>Configuration of layouts associated to the template.</p>
        pub fn set_layout_configuration(
            mut self,
            input: std::option::Option<crate::model::LayoutConfiguration>,
        ) -> Self {
            self.layout_configuration = input;
            self
        }
        /// Appends an item to `required_fields`.
        ///
        /// To override the contents of this collection use [`set_required_fields`](Self::set_required_fields).
        ///
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn required_fields(mut self, input: crate::model::RequiredField) -> Self {
            let mut v = self.required_fields.unwrap_or_default();
            v.push(input);
            self.required_fields = Some(v);
            self
        }
        /// <p>A list of fields that must contain a value for a case to be successfully created with this template.</p>
        pub fn set_required_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RequiredField>>,
        ) -> Self {
            self.required_fields = input;
            self
        }
        /// <p>The status of the template.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the template.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateTemplateInput`](crate::input::UpdateTemplateInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateTemplateInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateTemplateInput {
                domain_id: self.domain_id,
                template_id: self.template_id,
                name: self.name,
                description: self.description,
                layout_configuration: self.layout_configuration,
                required_fields: self.required_fields,
                status: self.status,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
}
impl GetTemplateInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of a template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
}
impl GetTemplateInput {
    /// Creates a new builder-style object to manufacture [`GetTemplateInput`](crate::input::GetTemplateInput).
    pub fn builder() -> crate::input::get_template_input::Builder {
        crate::input::get_template_input::Builder::default()
    }
}

/// See [`GetTemplateInput`](crate::input::GetTemplateInput).
pub mod get_template_input {

    /// A builder for [`GetTemplateInput`](crate::input::GetTemplateInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetTemplateInput`](crate::input::GetTemplateInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetTemplateInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetTemplateInput {
                domain_id: self.domain_id,
                template_id: self.template_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListLayoutsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListLayoutsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListLayoutsInput {
    /// Creates a new builder-style object to manufacture [`ListLayoutsInput`](crate::input::ListLayoutsInput).
    pub fn builder() -> crate::input::list_layouts_input::Builder {
        crate::input::list_layouts_input::Builder::default()
    }
}

/// See [`ListLayoutsInput`](crate::input::ListLayoutsInput).
pub mod list_layouts_input {

    /// A builder for [`ListLayoutsInput`](crate::input::ListLayoutsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListLayoutsInput`](crate::input::ListLayoutsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListLayoutsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListLayoutsInput {
                domain_id: self.domain_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The name of the layout. It must be unique for the Cases domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::LayoutContent>,
}
impl CreateLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The name of the layout. It must be unique for the Cases domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
    pub fn content(&self) -> std::option::Option<&crate::model::LayoutContent> {
        self.content.as_ref()
    }
}
impl CreateLayoutInput {
    /// Creates a new builder-style object to manufacture [`CreateLayoutInput`](crate::input::CreateLayoutInput).
    pub fn builder() -> crate::input::create_layout_input::Builder {
        crate::input::create_layout_input::Builder::default()
    }
}

/// See [`CreateLayoutInput`](crate::input::CreateLayoutInput).
pub mod create_layout_input {

    /// A builder for [`CreateLayoutInput`](crate::input::CreateLayoutInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<crate::model::LayoutContent>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The name of the layout. It must be unique for the Cases domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the layout. It must be unique for the Cases domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
        pub fn content(mut self, input: crate::model::LayoutContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>Information about which fields will be present in the layout, and information about the order of the fields.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::LayoutContent>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateLayoutInput`](crate::input::CreateLayoutInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateLayoutInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateLayoutInput {
                domain_id: self.domain_id,
                name: self.name,
                content: self.content,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the layout.</p>
    #[doc(hidden)]
    pub layout_id: std::option::Option<std::string::String>,
    /// <p>The name of the layout. It must be unique per domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::LayoutContent>,
}
impl UpdateLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of the layout.</p>
    pub fn layout_id(&self) -> std::option::Option<&str> {
        self.layout_id.as_deref()
    }
    /// <p>The name of the layout. It must be unique per domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
    pub fn content(&self) -> std::option::Option<&crate::model::LayoutContent> {
        self.content.as_ref()
    }
}
impl UpdateLayoutInput {
    /// Creates a new builder-style object to manufacture [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
    pub fn builder() -> crate::input::update_layout_input::Builder {
        crate::input::update_layout_input::Builder::default()
    }
}

/// See [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
pub mod update_layout_input {

    /// A builder for [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) layout_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<crate::model::LayoutContent>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.layout_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn set_layout_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layout_id = input;
            self
        }
        /// <p>The name of the layout. It must be unique per domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the layout. It must be unique per domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
        pub fn content(mut self, input: crate::model::LayoutContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>Information about which fields will be present in the layout, the order of the fields, and a read-only attribute of the field. </p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::LayoutContent>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateLayoutInput`](crate::input::UpdateLayoutInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateLayoutInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateLayoutInput {
                domain_id: self.domain_id,
                layout_id: self.layout_id,
                name: self.name,
                content: self.content,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the layout.</p>
    #[doc(hidden)]
    pub layout_id: std::option::Option<std::string::String>,
}
impl GetLayoutInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of the layout.</p>
    pub fn layout_id(&self) -> std::option::Option<&str> {
        self.layout_id.as_deref()
    }
}
impl GetLayoutInput {
    /// Creates a new builder-style object to manufacture [`GetLayoutInput`](crate::input::GetLayoutInput).
    pub fn builder() -> crate::input::get_layout_input::Builder {
        crate::input::get_layout_input::Builder::default()
    }
}

/// See [`GetLayoutInput`](crate::input::GetLayoutInput).
pub mod get_layout_input {

    /// A builder for [`GetLayoutInput`](crate::input::GetLayoutInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) layout_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.layout_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the layout.</p>
        pub fn set_layout_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layout_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetLayoutInput`](crate::input::GetLayoutInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetLayoutInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetLayoutInput {
                domain_id: self.domain_id,
                layout_id: self.layout_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFieldOptionsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
    #[doc(hidden)]
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ListFieldOptionsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
    pub fn values(&self) -> std::option::Option<&[std::string::String]> {
        self.values.as_deref()
    }
}
impl ListFieldOptionsInput {
    /// Creates a new builder-style object to manufacture [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
    pub fn builder() -> crate::input::list_field_options_input::Builder {
        crate::input::list_field_options_input::Builder::default()
    }
}

/// See [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
pub mod list_field_options_input {

    /// A builder for [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>A list of <code>FieldOption</code> values to filter on for <code>ListFieldOptions</code>.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ListFieldOptionsInput`](crate::input::ListFieldOptionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListFieldOptionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListFieldOptionsInput {
                domain_id: self.domain_id,
                field_id: self.field_id,
                max_results: self.max_results,
                next_token: self.next_token,
                values: self.values,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchPutFieldOptionsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>A list of <code>FieldOption</code> objects.</p>
    #[doc(hidden)]
    pub options: std::option::Option<std::vec::Vec<crate::model::FieldOption>>,
}
impl BatchPutFieldOptionsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>A list of <code>FieldOption</code> objects.</p>
    pub fn options(&self) -> std::option::Option<&[crate::model::FieldOption]> {
        self.options.as_deref()
    }
}
impl BatchPutFieldOptionsInput {
    /// Creates a new builder-style object to manufacture [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
    pub fn builder() -> crate::input::batch_put_field_options_input::Builder {
        crate::input::batch_put_field_options_input::Builder::default()
    }
}

/// See [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
pub mod batch_put_field_options_input {

    /// A builder for [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) options: std::option::Option<std::vec::Vec<crate::model::FieldOption>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// Appends an item to `options`.
        ///
        /// To override the contents of this collection use [`set_options`](Self::set_options).
        ///
        /// <p>A list of <code>FieldOption</code> objects.</p>
        pub fn options(mut self, input: crate::model::FieldOption) -> Self {
            let mut v = self.options.unwrap_or_default();
            v.push(input);
            self.options = Some(v);
            self
        }
        /// <p>A list of <code>FieldOption</code> objects.</p>
        pub fn set_options(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldOption>>,
        ) -> Self {
            self.options = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchPutFieldOptionsInput`](crate::input::BatchPutFieldOptionsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::BatchPutFieldOptionsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::BatchPutFieldOptionsInput {
                domain_id: self.domain_id,
                field_id: self.field_id,
                options: self.options,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchGetFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A list of unique field identifiers. </p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
}
impl BatchGetFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A list of unique field identifiers. </p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
}
impl BatchGetFieldInput {
    /// Creates a new builder-style object to manufacture [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
    pub fn builder() -> crate::input::batch_get_field_input::Builder {
        crate::input::batch_get_field_input::Builder::default()
    }
}

/// See [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
pub mod batch_get_field_input {

    /// A builder for [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>A list of unique field identifiers. </p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>A list of unique field identifiers. </p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`BatchGetFieldInput`](crate::input::BatchGetFieldInput).
        pub fn build(
            self,
        ) -> Result<crate::input::BatchGetFieldInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::BatchGetFieldInput {
                domain_id: self.domain_id,
                fields: self.fields,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListFieldsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListFieldsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListFieldsInput {
    /// Creates a new builder-style object to manufacture [`ListFieldsInput`](crate::input::ListFieldsInput).
    pub fn builder() -> crate::input::list_fields_input::Builder {
        crate::input::list_fields_input::Builder::default()
    }
}

/// See [`ListFieldsInput`](crate::input::ListFieldsInput).
pub mod list_fields_input {

    /// A builder for [`ListFieldsInput`](crate::input::ListFieldsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListFieldsInput`](crate::input::ListFieldsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListFieldsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListFieldsInput {
                domain_id: self.domain_id,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Defines the data type, some system constraints, and default display of the field.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::FieldType>,
    /// <p>The description of the field.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl CreateFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The name of the field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Defines the data type, some system constraints, and default display of the field.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::FieldType> {
        self.r#type.as_ref()
    }
    /// <p>The description of the field.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl CreateFieldInput {
    /// Creates a new builder-style object to manufacture [`CreateFieldInput`](crate::input::CreateFieldInput).
    pub fn builder() -> crate::input::create_field_input::Builder {
        crate::input::create_field_input::Builder::default()
    }
}

/// See [`CreateFieldInput`](crate::input::CreateFieldInput).
pub mod create_field_input {

    /// A builder for [`CreateFieldInput`](crate::input::CreateFieldInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::FieldType>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Defines the data type, some system constraints, and default display of the field.</p>
        pub fn r#type(mut self, input: crate::model::FieldType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Defines the data type, some system constraints, and default display of the field.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::FieldType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The description of the field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateFieldInput`](crate::input::CreateFieldInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateFieldInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateFieldInput {
                domain_id: self.domain_id,
                name: self.name,
                r#type: self.r#type,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of a field.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateFieldInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The name of the field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of a field.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
impl UpdateFieldInput {
    /// Creates a new builder-style object to manufacture [`UpdateFieldInput`](crate::input::UpdateFieldInput).
    pub fn builder() -> crate::input::update_field_input::Builder {
        crate::input::update_field_input::Builder::default()
    }
}

/// See [`UpdateFieldInput`](crate::input::UpdateFieldInput).
pub mod update_field_input {

    /// A builder for [`UpdateFieldInput`](crate::input::UpdateFieldInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of a field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFieldInput`](crate::input::UpdateFieldInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateFieldInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateFieldInput {
                domain_id: self.domain_id,
                field_id: self.field_id,
                name: self.name,
                description: self.description,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutCaseEventConfigurationInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
    #[doc(hidden)]
    pub event_bridge: std::option::Option<crate::model::EventBridgeConfiguration>,
}
impl PutCaseEventConfigurationInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
    pub fn event_bridge(&self) -> std::option::Option<&crate::model::EventBridgeConfiguration> {
        self.event_bridge.as_ref()
    }
}
impl PutCaseEventConfigurationInput {
    /// Creates a new builder-style object to manufacture [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
    pub fn builder() -> crate::input::put_case_event_configuration_input::Builder {
        crate::input::put_case_event_configuration_input::Builder::default()
    }
}

/// See [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
pub mod put_case_event_configuration_input {

    /// A builder for [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) event_bridge: std::option::Option<crate::model::EventBridgeConfiguration>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
        pub fn event_bridge(mut self, input: crate::model::EventBridgeConfiguration) -> Self {
            self.event_bridge = Some(input);
            self
        }
        /// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
        pub fn set_event_bridge(
            mut self,
            input: std::option::Option<crate::model::EventBridgeConfiguration>,
        ) -> Self {
            self.event_bridge = input;
            self
        }
        /// Consumes the builder and constructs a [`PutCaseEventConfigurationInput`](crate::input::PutCaseEventConfigurationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::PutCaseEventConfigurationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::PutCaseEventConfigurationInput {
                domain_id: self.domain_id,
                event_bridge: self.event_bridge,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCaseEventConfigurationInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
}
impl GetCaseEventConfigurationInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
}
impl GetCaseEventConfigurationInput {
    /// Creates a new builder-style object to manufacture [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
    pub fn builder() -> crate::input::get_case_event_configuration_input::Builder {
        crate::input::get_case_event_configuration_input::Builder::default()
    }
}

/// See [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
pub mod get_case_event_configuration_input {

    /// A builder for [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCaseEventConfigurationInput`](crate::input::GetCaseEventConfigurationInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::GetCaseEventConfigurationInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::GetCaseEventConfigurationInput {
                domain_id: self.domain_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListDomainsInput {
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListDomainsInput {
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListDomainsInput {
    /// Creates a new builder-style object to manufacture [`ListDomainsInput`](crate::input::ListDomainsInput).
    pub fn builder() -> crate::input::list_domains_input::Builder {
        crate::input::list_domains_input::Builder::default()
    }
}

/// See [`ListDomainsInput`](crate::input::ListDomainsInput).
pub mod list_domains_input {

    /// A builder for [`ListDomainsInput`](crate::input::ListDomainsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListDomainsInput`](crate::input::ListDomainsInput).
        pub fn build(
            self,
        ) -> Result<crate::input::ListDomainsInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::ListDomainsInput {
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateDomainInput {
    /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl CreateDomainInput {
    /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl CreateDomainInput {
    /// Creates a new builder-style object to manufacture [`CreateDomainInput`](crate::input::CreateDomainInput).
    pub fn builder() -> crate::input::create_domain_input::Builder {
        crate::input::create_domain_input::Builder::default()
    }
}

/// See [`CreateDomainInput`](crate::input::CreateDomainInput).
pub mod create_domain_input {

    /// A builder for [`CreateDomainInput`](crate::input::CreateDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for your Cases domain. It must be unique for your Amazon Web Services account.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateDomainInput`](crate::input::CreateDomainInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateDomainInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateDomainInput { name: self.name })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetDomainInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
}
impl GetDomainInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
}
impl GetDomainInput {
    /// Creates a new builder-style object to manufacture [`GetDomainInput`](crate::input::GetDomainInput).
    pub fn builder() -> crate::input::get_domain_input::Builder {
        crate::input::get_domain_input::Builder::default()
    }
}

/// See [`GetDomainInput`](crate::input::GetDomainInput).
pub mod get_domain_input {

    /// A builder for [`GetDomainInput`](crate::input::GetDomainInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// Consumes the builder and constructs a [`GetDomainInput`](crate::input::GetDomainInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetDomainInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetDomainInput {
                domain_id: self.domain_id,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchCasesInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>A word or phrase used to perform a quick search.</p>
    #[doc(hidden)]
    pub search_term: std::option::Option<std::string::String>,
    /// <p>A list of filter objects.</p>
    #[doc(hidden)]
    pub filter: std::option::Option<crate::model::CaseFilter>,
    /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
    #[doc(hidden)]
    pub sorts: std::option::Option<std::vec::Vec<crate::model::Sort>>,
    /// <p>The list of field identifiers to be returned as part of the response.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
}
impl SearchCasesInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>A word or phrase used to perform a quick search.</p>
    pub fn search_term(&self) -> std::option::Option<&str> {
        self.search_term.as_deref()
    }
    /// <p>A list of filter objects.</p>
    pub fn filter(&self) -> std::option::Option<&crate::model::CaseFilter> {
        self.filter.as_ref()
    }
    /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
    pub fn sorts(&self) -> std::option::Option<&[crate::model::Sort]> {
        self.sorts.as_deref()
    }
    /// <p>The list of field identifiers to be returned as part of the response.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
}
impl SearchCasesInput {
    /// Creates a new builder-style object to manufacture [`SearchCasesInput`](crate::input::SearchCasesInput).
    pub fn builder() -> crate::input::search_cases_input::Builder {
        crate::input::search_cases_input::Builder::default()
    }
}

/// See [`SearchCasesInput`](crate::input::SearchCasesInput).
pub mod search_cases_input {

    /// A builder for [`SearchCasesInput`](crate::input::SearchCasesInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) search_term: std::option::Option<std::string::String>,
        pub(crate) filter: std::option::Option<crate::model::CaseFilter>,
        pub(crate) sorts: std::option::Option<std::vec::Vec<crate::model::Sort>>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of cases to return. The current maximum supported value is 25. This is also the default value when no other value is provided.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>A word or phrase used to perform a quick search.</p>
        pub fn search_term(mut self, input: impl Into<std::string::String>) -> Self {
            self.search_term = Some(input.into());
            self
        }
        /// <p>A word or phrase used to perform a quick search.</p>
        pub fn set_search_term(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.search_term = input;
            self
        }
        /// <p>A list of filter objects.</p>
        pub fn filter(mut self, input: crate::model::CaseFilter) -> Self {
            self.filter = Some(input);
            self
        }
        /// <p>A list of filter objects.</p>
        pub fn set_filter(mut self, input: std::option::Option<crate::model::CaseFilter>) -> Self {
            self.filter = input;
            self
        }
        /// Appends an item to `sorts`.
        ///
        /// To override the contents of this collection use [`set_sorts`](Self::set_sorts).
        ///
        /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
        pub fn sorts(mut self, input: crate::model::Sort) -> Self {
            let mut v = self.sorts.unwrap_or_default();
            v.push(input);
            self.sorts = Some(v);
            self
        }
        /// <p>A list of sorts where each sort specifies a field and their sort order to be applied to the results. </p>
        pub fn set_sorts(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Sort>>,
        ) -> Self {
            self.sorts = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>The list of field identifiers to be returned as part of the response.</p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>The list of field identifiers to be returned as part of the response.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchCasesInput`](crate::input::SearchCasesInput).
        pub fn build(
            self,
        ) -> Result<crate::input::SearchCasesInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::SearchCasesInput {
                domain_id: self.domain_id,
                max_results: self.max_results,
                next_token: self.next_token,
                search_term: self.search_term,
                filter: self.filter,
                sorts: self.sorts,
                fields: self.fields,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListCasesForContactInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    #[doc(hidden)]
    pub contact_arn: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl ListCasesForContactInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    pub fn contact_arn(&self) -> std::option::Option<&str> {
        self.contact_arn.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl ListCasesForContactInput {
    /// Creates a new builder-style object to manufacture [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
    pub fn builder() -> crate::input::list_cases_for_contact_input::Builder {
        crate::input::list_cases_for_contact_input::Builder::default()
    }
}

/// See [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
pub mod list_cases_for_contact_input {

    /// A builder for [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) contact_arn: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn contact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_arn = Some(input.into());
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn set_contact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_arn = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListCasesForContactInput`](crate::input::ListCasesForContactInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListCasesForContactInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListCasesForContactInput {
                domain_id: self.domain_id,
                contact_arn: self.contact_arn,
                max_results: self.max_results,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateCaseInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    #[doc(hidden)]
    pub client_token: std::option::Option<std::string::String>,
}
impl CreateCaseInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of a template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldValue]> {
        self.fields.as_deref()
    }
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
    pub fn client_token(&self) -> std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl CreateCaseInput {
    /// Creates a new builder-style object to manufacture [`CreateCaseInput`](crate::input::CreateCaseInput).
    pub fn builder() -> crate::input::create_case_input::Builder {
        crate::input::create_case_input::Builder::default()
    }
}

/// See [`CreateCaseInput`](crate::input::CreateCaseInput).
pub mod create_case_input {

    /// A builder for [`CreateCaseInput`](crate::input::CreateCaseInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
        pub(crate) client_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
        pub fn fields(mut self, input: crate::model::FieldValue) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>An array of objects with field ID (matching ListFields/DescribeField) and value union data.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_token = Some(input.into());
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see <a href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making retries safe with idempotent APIs</a>.</p>
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateCaseInput`](crate::input::CreateCaseInput).
        pub fn build(
            self,
        ) -> Result<crate::input::CreateCaseInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::CreateCaseInput {
                domain_id: self.domain_id,
                template_id: self.template_id,
                fields: self.fields,
                client_token: self.client_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateCaseInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
}
impl UpdateCaseInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<&str> {
        self.case_id.as_deref()
    }
    /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldValue]> {
        self.fields.as_deref()
    }
}
impl UpdateCaseInput {
    /// Creates a new builder-style object to manufacture [`UpdateCaseInput`](crate::input::UpdateCaseInput).
    pub fn builder() -> crate::input::update_case_input::Builder {
        crate::input::update_case_input::Builder::default()
    }
}

/// See [`UpdateCaseInput`](crate::input::UpdateCaseInput).
pub mod update_case_input {

    /// A builder for [`UpdateCaseInput`](crate::input::UpdateCaseInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
        pub fn fields(mut self, input: crate::model::FieldValue) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>An array of objects with <code>fieldId</code> (matching ListFields/DescribeField) and value union data, structured identical to <code>CreateCase</code>.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateCaseInput`](crate::input::UpdateCaseInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateCaseInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UpdateCaseInput {
                domain_id: self.domain_id,
                case_id: self.case_id,
                fields: self.fields,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetCaseInput {
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A list of unique field identifiers. </p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
}
impl GetCaseInput {
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<&str> {
        self.case_id.as_deref()
    }
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A list of unique field identifiers. </p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl GetCaseInput {
    /// Creates a new builder-style object to manufacture [`GetCaseInput`](crate::input::GetCaseInput).
    pub fn builder() -> crate::input::get_case_input::Builder {
        crate::input::get_case_input::Builder::default()
    }
}

/// See [`GetCaseInput`](crate::input::GetCaseInput).
pub mod get_case_input {

    /// A builder for [`GetCaseInput`](crate::input::GetCaseInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input;
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>A list of unique field identifiers. </p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>A list of unique field identifiers. </p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`GetCaseInput`](crate::input::GetCaseInput).
        pub fn build(
            self,
        ) -> Result<crate::input::GetCaseInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::GetCaseInput {
                case_id: self.case_id,
                domain_id: self.domain_id,
                fields: self.fields,
                next_token: self.next_token,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchRelatedItemsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>The maximum number of results to return per page.</p>
    #[doc(hidden)]
    pub max_results: std::option::Option<i32>,
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    #[doc(hidden)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The list of types of related items and their parameters to use for filtering.</p>
    #[doc(hidden)]
    pub filters: std::option::Option<std::vec::Vec<crate::model::RelatedItemTypeFilter>>,
}
impl SearchRelatedItemsInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<&str> {
        self.case_id.as_deref()
    }
    /// <p>The maximum number of results to return per page.</p>
    pub fn max_results(&self) -> std::option::Option<i32> {
        self.max_results
    }
    /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
    /// <p>The list of types of related items and their parameters to use for filtering.</p>
    pub fn filters(&self) -> std::option::Option<&[crate::model::RelatedItemTypeFilter]> {
        self.filters.as_deref()
    }
}
impl SearchRelatedItemsInput {
    /// Creates a new builder-style object to manufacture [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
    pub fn builder() -> crate::input::search_related_items_input::Builder {
        crate::input::search_related_items_input::Builder::default()
    }
}

/// See [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
pub mod search_related_items_input {

    /// A builder for [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) max_results: std::option::Option<i32>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) filters: std::option::Option<std::vec::Vec<crate::model::RelatedItemTypeFilter>>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input;
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.max_results = Some(input);
            self
        }
        /// <p>The maximum number of results to return per page.</p>
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.max_results = input;
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Appends an item to `filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        ///
        /// <p>The list of types of related items and their parameters to use for filtering.</p>
        pub fn filters(mut self, input: crate::model::RelatedItemTypeFilter) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(input);
            self.filters = Some(v);
            self
        }
        /// <p>The list of types of related items and their parameters to use for filtering.</p>
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelatedItemTypeFilter>>,
        ) -> Self {
            self.filters = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchRelatedItemsInput`](crate::input::SearchRelatedItemsInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::SearchRelatedItemsInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::SearchRelatedItemsInput {
                domain_id: self.domain_id,
                case_id: self.case_id,
                max_results: self.max_results,
                next_token: self.next_token,
                filters: self.filters,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CreateRelatedItemInput {
    /// <p>The unique identifier of the Cases domain. </p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>The type of a related item.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::RelatedItemType>,
    /// <p>The content of a related item to be created.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::RelatedItemInputContent>,
}
impl CreateRelatedItemInput {
    /// <p>The unique identifier of the Cases domain. </p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<&str> {
        self.case_id.as_deref()
    }
    /// <p>The type of a related item.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::RelatedItemType> {
        self.r#type.as_ref()
    }
    /// <p>The content of a related item to be created.</p>
    pub fn content(&self) -> std::option::Option<&crate::model::RelatedItemInputContent> {
        self.content.as_ref()
    }
}
impl CreateRelatedItemInput {
    /// Creates a new builder-style object to manufacture [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
    pub fn builder() -> crate::input::create_related_item_input::Builder {
        crate::input::create_related_item_input::Builder::default()
    }
}

/// See [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
pub mod create_related_item_input {

    /// A builder for [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::RelatedItemType>,
        pub(crate) content: std::option::Option<crate::model::RelatedItemInputContent>,
    }
    impl Builder {
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Cases domain. </p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input;
            self
        }
        /// <p>The type of a related item.</p>
        pub fn r#type(mut self, input: crate::model::RelatedItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of a related item.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::RelatedItemType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The content of a related item to be created.</p>
        pub fn content(mut self, input: crate::model::RelatedItemInputContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>The content of a related item to be created.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::RelatedItemInputContent>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRelatedItemInput`](crate::input::CreateRelatedItemInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::CreateRelatedItemInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::CreateRelatedItemInput {
                domain_id: self.domain_id,
                case_id: self.case_id,
                r#type: self.r#type,
                content: self.content,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>List of tag keys.</p>
    #[doc(hidden)]
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl UntagResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>List of tag keys.</p>
    pub fn tag_keys(&self) -> std::option::Option<&[std::string::String]> {
        self.tag_keys.as_deref()
    }
}
impl UntagResourceInput {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput).
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput).
pub mod untag_resource_input {

    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Appends an item to `tag_keys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        ///
        /// <p>List of tag keys.</p>
        pub fn tag_keys(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(input.into());
            self.tag_keys = Some(v);
            self
        }
        /// <p>List of tag keys.</p>
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = input;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::UntagResourceInput {
                arn: self.arn,
                tag_keys: self.tag_keys,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl TagResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    > {
        self.tags.as_ref()
    }
}
impl TagResourceInput {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput).
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput).
pub mod tag_resource_input {

    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::option::Option<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: std::option::Option<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput).
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, aws_smithy_http::operation::error::BuildError>
        {
            Ok(crate::input::TagResourceInput {
                arn: self.arn,
                tags: self.tags,
            })
        }
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl ListTagsForResourceInput {
    /// <p>The Amazon Resource Name (ARN)</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl ListTagsForResourceInput {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
}

/// See [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
pub mod list_tags_for_resource_input {

    /// A builder for [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN)</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput).
        pub fn build(
            self,
        ) -> Result<
            crate::input::ListTagsForResourceInput,
            aws_smithy_http::operation::error::BuildError,
        > {
            Ok(crate::input::ListTagsForResourceInput { arn: self.arn })
        }
    }
}
