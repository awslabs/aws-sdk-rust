// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `ListTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTemplatesError {
    /// Kind of error that occurred.
                    pub kind: ListTemplatesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListTemplatesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListTemplatesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTemplatesErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTemplatesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListTemplatesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListTemplatesErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListTemplatesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListTemplatesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListTemplatesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTemplatesError {
    fn code(&self) -> Option<&str> {
        ListTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListTemplatesErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListTemplatesErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListTemplatesError {
    /// Creates a new `ListTemplatesError`.
                    pub fn new(kind: ListTemplatesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListTemplatesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListTemplatesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListTemplatesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListTemplatesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListTemplatesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListTemplatesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListTemplatesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListTemplatesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListTemplatesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTemplatesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListTemplatesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListTemplatesErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListTemplatesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListTemplatesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListTemplatesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The request isn't valid. Check the syntax and try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ValidationException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
             {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {
    
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ThrottlingException {
    /// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
    pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
        aws_smithy_types::retry::ErrorKind::ClientError
    }
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
             {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {
    
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceNotFoundException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>Unique identifier of the resource affected.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>Type of the resource affected.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// <p>Unique identifier of the resource affected.</p>
    pub fn resource_id(&self) -> std::option::Option<& str> {
        self.resource_id.as_deref()
    }
    /// <p>Type of the resource affected.</p>
    pub fn resource_type(&self) -> std::option::Option<& str> {
        self.resource_type.as_deref()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
             {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {
    
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>Unique identifier of the resource affected.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of the resource affected.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input; self
        }
        /// <p>Type of the resource affected.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        /// <p>Type of the resource affected.</p>
        pub fn set_resource_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_type = input; self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message
                ,
                resource_id: self.resource_id
                ,
                resource_type: self.resource_type
                ,
            }
        }
    }
    
    
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InternalServerException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>Advice to clients on when the call can be safely retried.</p>
    #[doc(hidden)]
    pub retry_after_seconds: std::option::Option<i32>,
}
impl InternalServerException {
    /// <p>Advice to clients on when the call can be safely retried.</p>
    pub fn retry_after_seconds(&self) -> std::option::Option<i32> {
        self.retry_after_seconds
    }
}
impl InternalServerException {
    /// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
    pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
        aws_smithy_types::retry::ErrorKind::ServerError
    }
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
             {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException).
pub mod internal_server_exception {
    
    /// A builder for [`InternalServerException`](crate::error::InternalServerException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) retry_after_seconds: std::option::Option<i32>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// <p>Advice to clients on when the call can be safely retried.</p>
        pub fn retry_after_seconds(mut self, input: i32) -> Self {
            self.retry_after_seconds = Some(input);
            self
        }
        /// <p>Advice to clients on when the call can be safely retried.</p>
        pub fn set_retry_after_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.retry_after_seconds = input; self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException).
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message
                ,
                retry_after_seconds: self.retry_after_seconds
                ,
            }
        }
    }
    
    
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException).
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessDeniedException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
             {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException).
pub mod access_denied_exception {
    
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException).
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException).
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// Error type for the `CreateTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTemplateError {
    /// Kind of error that occurred.
                    pub kind: CreateTemplateErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateTemplateError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateTemplateErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTemplateErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTemplateErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateTemplateError {
    fn code(&self) -> Option<&str> {
        CreateTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateTemplateErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            CreateTemplateErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl CreateTemplateError {
    /// Creates a new `CreateTemplateError`.
                    pub fn new(kind: CreateTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateTemplateErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateTemplateErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateTemplateErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTemplateErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceQuotaExceededException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ServiceQuotaExceededException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_6) = &self.message {
             {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
pub mod service_quota_exceeded_exception {
    
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException).
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictException  {
    #[allow(missing_docs)] // documentation missing in model
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl ConflictException {
    /// Returns the error message.
                        pub fn message(&self) -> std::option::Option<& str> { self.message.as_deref() }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
             {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException).
pub mod conflict_exception {
    
    /// A builder for [`ConflictException`](crate::error::ConflictException).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input; self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException).
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message
                ,
            }
        }
    }
    
    
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException).
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// Error type for the `UpdateTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTemplateError {
    /// Kind of error that occurred.
                    pub kind: UpdateTemplateErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateTemplateError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateTemplateErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTemplateErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTemplateErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateTemplateErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateTemplateErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateTemplateErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateTemplateErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateTemplateErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateTemplateErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            UpdateTemplateErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl UpdateTemplateError {
    /// Creates a new `UpdateTemplateError`.
                    pub fn new(kind: UpdateTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateTemplateErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateTemplateErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateTemplateErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateTemplateErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTemplateErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateTemplateErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateTemplateErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateTemplateErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateTemplateErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateTemplateErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetTemplateError {
    /// Kind of error that occurred.
                    pub kind: GetTemplateErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetTemplateError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetTemplateErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetTemplateErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetTemplateErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetTemplateErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetTemplateErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetTemplateErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetTemplateErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetTemplateError {
    fn code(&self) -> Option<&str> {
        GetTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetTemplateErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            GetTemplateErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl GetTemplateError {
    /// Creates a new `GetTemplateError`.
                    pub fn new(kind: GetTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetTemplateError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetTemplateErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetTemplateErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetTemplateErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetTemplateErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetTemplateErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetTemplateErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetTemplateErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetTemplateErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetTemplateErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetTemplateErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetTemplateErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetTemplateErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetTemplateErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetTemplateErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetTemplateErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetTemplateErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetTemplateErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListLayouts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListLayoutsError {
    /// Kind of error that occurred.
                    pub kind: ListLayoutsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListLayoutsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListLayoutsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListLayouts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListLayoutsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListLayoutsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListLayoutsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListLayoutsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListLayoutsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListLayoutsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListLayoutsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListLayoutsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListLayoutsError {
    fn code(&self) -> Option<&str> {
        ListLayoutsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListLayoutsErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListLayoutsErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListLayoutsError {
    /// Creates a new `ListLayoutsError`.
                    pub fn new(kind: ListLayoutsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListLayoutsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListLayoutsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListLayoutsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListLayoutsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListLayoutsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListLayoutsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListLayoutsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListLayoutsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListLayoutsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListLayoutsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListLayoutsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListLayoutsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListLayoutsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListLayoutsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListLayoutsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListLayoutsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListLayoutsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListLayoutsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListLayoutsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListLayoutsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListLayoutsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateLayout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLayoutError {
    /// Kind of error that occurred.
                    pub kind: CreateLayoutErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateLayoutError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateLayoutErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateLayout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLayoutErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateLayoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLayoutErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateLayoutErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateLayoutError {
    fn code(&self) -> Option<&str> {
        CreateLayoutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateLayoutErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            CreateLayoutErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl CreateLayoutError {
    /// Creates a new `CreateLayoutError`.
                    pub fn new(kind: CreateLayoutErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateLayoutError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateLayoutErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateLayoutError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateLayoutErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateLayoutErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateLayoutErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateLayoutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLayoutErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateLayoutErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateLayout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLayoutError {
    /// Kind of error that occurred.
                    pub kind: UpdateLayoutErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateLayoutError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateLayoutErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateLayout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLayoutErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateLayoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLayoutErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateLayoutErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateLayoutError {
    fn code(&self) -> Option<&str> {
        UpdateLayoutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateLayoutErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            UpdateLayoutErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl UpdateLayoutError {
    /// Creates a new `UpdateLayoutError`.
                    pub fn new(kind: UpdateLayoutErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateLayoutError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateLayoutErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateLayoutError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateLayoutErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateLayoutErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateLayoutErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateLayoutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLayoutErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateLayoutErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetLayout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLayoutError {
    /// Kind of error that occurred.
                    pub kind: GetLayoutErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetLayoutError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetLayoutErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetLayout` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLayoutErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetLayoutError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLayoutErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetLayoutErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetLayoutErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetLayoutErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetLayoutErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetLayoutErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetLayoutError {
    fn code(&self) -> Option<&str> {
        GetLayoutError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetLayoutErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            GetLayoutErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl GetLayoutError {
    /// Creates a new `GetLayoutError`.
                    pub fn new(kind: GetLayoutErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetLayoutError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetLayoutErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetLayoutError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetLayoutErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetLayoutErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetLayoutErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetLayoutErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetLayoutErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetLayoutErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetLayoutErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetLayoutErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetLayoutErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetLayoutErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetLayoutErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetLayoutError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLayoutErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetLayoutErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetLayoutErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetLayoutErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetLayoutErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetLayoutErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListFieldOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFieldOptionsError {
    /// Kind of error that occurred.
                    pub kind: ListFieldOptionsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListFieldOptionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListFieldOptionsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListFieldOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFieldOptionsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListFieldOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFieldOptionsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldOptionsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldOptionsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldOptionsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldOptionsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldOptionsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFieldOptionsError {
    fn code(&self) -> Option<&str> {
        ListFieldOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListFieldOptionsErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListFieldOptionsErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListFieldOptionsError {
    /// Creates a new `ListFieldOptionsError`.
                    pub fn new(kind: ListFieldOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListFieldOptionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListFieldOptionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListFieldOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListFieldOptionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListFieldOptionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFieldOptionsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListFieldOptionsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListFieldOptionsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListFieldOptionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListFieldOptionsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListFieldOptionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFieldOptionsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListFieldOptionsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListFieldOptionsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListFieldOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFieldOptionsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListFieldOptionsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListFieldOptionsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListFieldOptionsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListFieldOptionsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListFieldOptionsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `BatchPutFieldOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchPutFieldOptionsError {
    /// Kind of error that occurred.
                    pub kind: BatchPutFieldOptionsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for BatchPutFieldOptionsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchPutFieldOptionsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `BatchPutFieldOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchPutFieldOptionsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchPutFieldOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchPutFieldOptionsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchPutFieldOptionsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            BatchPutFieldOptionsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchPutFieldOptionsErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            BatchPutFieldOptionsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            BatchPutFieldOptionsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            BatchPutFieldOptionsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchPutFieldOptionsError {
    fn code(&self) -> Option<&str> {
        BatchPutFieldOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            BatchPutFieldOptionsErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            BatchPutFieldOptionsErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl BatchPutFieldOptionsError {
    /// Creates a new `BatchPutFieldOptionsError`.
                    pub fn new(kind: BatchPutFieldOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `BatchPutFieldOptionsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: BatchPutFieldOptionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `BatchPutFieldOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: BatchPutFieldOptionsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `BatchPutFieldOptionsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchPutFieldOptionsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchPutFieldOptionsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, BatchPutFieldOptionsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `BatchPutFieldOptionsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchPutFieldOptionsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchPutFieldOptionsErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, BatchPutFieldOptionsErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchPutFieldOptionsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, BatchPutFieldOptionsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `BatchPutFieldOptionsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, BatchPutFieldOptionsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for BatchPutFieldOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchPutFieldOptionsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchPutFieldOptionsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            BatchPutFieldOptionsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchPutFieldOptionsErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            BatchPutFieldOptionsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            BatchPutFieldOptionsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            BatchPutFieldOptionsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `BatchGetField` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetFieldError {
    /// Kind of error that occurred.
                    pub kind: BatchGetFieldErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetFieldError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: BatchGetFieldErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `BatchGetField` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetFieldErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for BatchGetFieldError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetFieldErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetFieldErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetFieldErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetFieldErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetFieldErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            BatchGetFieldErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetFieldError {
    fn code(&self) -> Option<&str> {
        BatchGetFieldError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            BatchGetFieldErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            BatchGetFieldErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl BatchGetFieldError {
    /// Creates a new `BatchGetFieldError`.
                    pub fn new(kind: BatchGetFieldErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `BatchGetFieldError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: BatchGetFieldErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `BatchGetFieldError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: BatchGetFieldErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `BatchGetFieldErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchGetFieldErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetFieldErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, BatchGetFieldErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `BatchGetFieldErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchGetFieldErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchGetFieldErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, BatchGetFieldErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `BatchGetFieldErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, BatchGetFieldErrorKind::ValidationException(_))
    }
}
impl std::error::Error for BatchGetFieldError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetFieldErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchGetFieldErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            BatchGetFieldErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchGetFieldErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            BatchGetFieldErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            BatchGetFieldErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListFields` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListFieldsError {
    /// Kind of error that occurred.
                    pub kind: ListFieldsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListFieldsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListFieldsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListFields` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListFieldsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListFieldsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListFieldsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListFieldsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListFieldsError {
    fn code(&self) -> Option<&str> {
        ListFieldsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListFieldsErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListFieldsErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListFieldsError {
    /// Creates a new `ListFieldsError`.
                    pub fn new(kind: ListFieldsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListFieldsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListFieldsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListFieldsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListFieldsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListFieldsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListFieldsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListFieldsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListFieldsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListFieldsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListFieldsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListFieldsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListFieldsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListFieldsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListFieldsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListFieldsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListFieldsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListFieldsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListFieldsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListFieldsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListFieldsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListFieldsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateField` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateFieldError {
    /// Kind of error that occurred.
                    pub kind: CreateFieldErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateFieldError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateFieldErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateField` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateFieldErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateFieldError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateFieldErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateFieldErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateFieldError {
    fn code(&self) -> Option<&str> {
        CreateFieldError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateFieldErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            CreateFieldErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl CreateFieldError {
    /// Creates a new `CreateFieldError`.
                    pub fn new(kind: CreateFieldErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateFieldError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateFieldErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateFieldError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateFieldErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateFieldErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateFieldErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateFieldError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateFieldErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateFieldErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateField` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateFieldError {
    /// Kind of error that occurred.
                    pub kind: UpdateFieldErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateFieldError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateFieldErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateField` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateFieldErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateFieldError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateFieldErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateFieldErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateFieldErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateFieldErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateFieldErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateFieldErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateFieldErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateFieldError {
    fn code(&self) -> Option<&str> {
        UpdateFieldError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateFieldErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            UpdateFieldErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl UpdateFieldError {
    /// Creates a new `UpdateFieldError`.
                    pub fn new(kind: UpdateFieldErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateFieldError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateFieldErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateFieldError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateFieldErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateFieldErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateFieldErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateFieldErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateFieldErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateFieldErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateFieldErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateFieldErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateFieldErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateFieldError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateFieldErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateFieldErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            UpdateFieldErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateFieldErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateFieldErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateFieldErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateFieldErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `PutCaseEventConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutCaseEventConfigurationError {
    /// Kind of error that occurred.
                    pub kind: PutCaseEventConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for PutCaseEventConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: PutCaseEventConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `PutCaseEventConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutCaseEventConfigurationErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for PutCaseEventConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutCaseEventConfigurationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PutCaseEventConfigurationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            PutCaseEventConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PutCaseEventConfigurationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            PutCaseEventConfigurationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            PutCaseEventConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutCaseEventConfigurationError {
    fn code(&self) -> Option<&str> {
        PutCaseEventConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            PutCaseEventConfigurationErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            PutCaseEventConfigurationErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl PutCaseEventConfigurationError {
    /// Creates a new `PutCaseEventConfigurationError`.
                    pub fn new(kind: PutCaseEventConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `PutCaseEventConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: PutCaseEventConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `PutCaseEventConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: PutCaseEventConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `PutCaseEventConfigurationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, PutCaseEventConfigurationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutCaseEventConfigurationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, PutCaseEventConfigurationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `PutCaseEventConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutCaseEventConfigurationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutCaseEventConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, PutCaseEventConfigurationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `PutCaseEventConfigurationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, PutCaseEventConfigurationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for PutCaseEventConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutCaseEventConfigurationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PutCaseEventConfigurationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            PutCaseEventConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            PutCaseEventConfigurationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            PutCaseEventConfigurationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            PutCaseEventConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetCaseEventConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCaseEventConfigurationError {
    /// Kind of error that occurred.
                    pub kind: GetCaseEventConfigurationErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetCaseEventConfigurationError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetCaseEventConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetCaseEventConfiguration` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCaseEventConfigurationErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetCaseEventConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCaseEventConfigurationErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseEventConfigurationErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseEventConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseEventConfigurationErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseEventConfigurationErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseEventConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCaseEventConfigurationError {
    fn code(&self) -> Option<&str> {
        GetCaseEventConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetCaseEventConfigurationErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            GetCaseEventConfigurationErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl GetCaseEventConfigurationError {
    /// Creates a new `GetCaseEventConfigurationError`.
                    pub fn new(kind: GetCaseEventConfigurationErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetCaseEventConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetCaseEventConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetCaseEventConfigurationError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetCaseEventConfigurationErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetCaseEventConfigurationErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetCaseEventConfigurationErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCaseEventConfigurationErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetCaseEventConfigurationErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetCaseEventConfigurationErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetCaseEventConfigurationErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCaseEventConfigurationErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetCaseEventConfigurationErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetCaseEventConfigurationErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetCaseEventConfigurationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetCaseEventConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCaseEventConfigurationErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetCaseEventConfigurationErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetCaseEventConfigurationErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetCaseEventConfigurationErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetCaseEventConfigurationErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetCaseEventConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListDomains` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDomainsError {
    /// Kind of error that occurred.
                    pub kind: ListDomainsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListDomainsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListDomainsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListDomains` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDomainsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListDomainsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDomainsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListDomainsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListDomainsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListDomainsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListDomainsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDomainsError {
    fn code(&self) -> Option<&str> {
        ListDomainsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListDomainsErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListDomainsErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListDomainsError {
    /// Creates a new `ListDomainsError`.
                    pub fn new(kind: ListDomainsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListDomainsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListDomainsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListDomainsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListDomainsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListDomainsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListDomainsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListDomainsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListDomainsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDomainsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListDomainsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListDomainsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListDomainsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListDomainsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDomainError {
    /// Kind of error that occurred.
                    pub kind: CreateDomainErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDomainError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateDomainErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDomainErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDomainErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDomainErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDomainErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDomainErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDomainErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDomainErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDomainErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDomainError {
    fn code(&self) -> Option<&str> {
        CreateDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateDomainErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            CreateDomainErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl CreateDomainError {
    /// Creates a new `CreateDomainError`.
                    pub fn new(kind: CreateDomainErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateDomainErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateDomainError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateDomainErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateDomainErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateDomainErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateDomainErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateDomainErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDomainErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateDomainErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateDomainErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDomainErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateDomainErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateDomainErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateDomainErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateDomainErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateDomainErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateDomainErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDomainError {
    /// Kind of error that occurred.
                    pub kind: GetDomainErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetDomainError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetDomainErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetDomain` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDomainErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetDomainError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDomainErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetDomainErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetDomainErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetDomainErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetDomainErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetDomainErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDomainError {
    fn code(&self) -> Option<&str> {
        GetDomainError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetDomainErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            GetDomainErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl GetDomainError {
    /// Creates a new `GetDomainError`.
                    pub fn new(kind: GetDomainErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetDomainError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetDomainErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetDomainError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetDomainErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetDomainErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetDomainErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetDomainErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetDomainErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetDomainErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetDomainErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetDomainError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDomainErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetDomainErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetDomainErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetDomainErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetDomainErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetDomainErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `SearchCases` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchCasesError {
    /// Kind of error that occurred.
                    pub kind: SearchCasesErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for SearchCasesError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: SearchCasesErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `SearchCases` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchCasesErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for SearchCasesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchCasesErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            SearchCasesErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            SearchCasesErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            SearchCasesErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            SearchCasesErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            SearchCasesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchCasesError {
    fn code(&self) -> Option<&str> {
        SearchCasesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            SearchCasesErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            SearchCasesErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl SearchCasesError {
    /// Creates a new `SearchCasesError`.
                    pub fn new(kind: SearchCasesErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `SearchCasesError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: SearchCasesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `SearchCasesError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: SearchCasesErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `SearchCasesErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, SearchCasesErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `SearchCasesErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, SearchCasesErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `SearchCasesErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, SearchCasesErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `SearchCasesErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchCasesErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `SearchCasesErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, SearchCasesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for SearchCasesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchCasesErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            SearchCasesErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            SearchCasesErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            SearchCasesErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            SearchCasesErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            SearchCasesErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListCasesForContact` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListCasesForContactError {
    /// Kind of error that occurred.
                    pub kind: ListCasesForContactErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListCasesForContactError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListCasesForContactErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListCasesForContact` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListCasesForContactErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListCasesForContactError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListCasesForContactErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListCasesForContactErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListCasesForContactErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListCasesForContactErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListCasesForContactErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListCasesForContactErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListCasesForContactError {
    fn code(&self) -> Option<&str> {
        ListCasesForContactError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListCasesForContactErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListCasesForContactErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListCasesForContactError {
    /// Creates a new `ListCasesForContactError`.
                    pub fn new(kind: ListCasesForContactErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListCasesForContactError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListCasesForContactErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListCasesForContactError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListCasesForContactErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListCasesForContactErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListCasesForContactErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListCasesForContactErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListCasesForContactErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListCasesForContactErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListCasesForContactErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListCasesForContactErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListCasesForContactErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListCasesForContactErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListCasesForContactErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListCasesForContactError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListCasesForContactErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListCasesForContactErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListCasesForContactErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListCasesForContactErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListCasesForContactErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListCasesForContactErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateCase` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCaseError {
    /// Kind of error that occurred.
                    pub kind: CreateCaseErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCaseError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateCaseErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateCase` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCaseErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.</p>
    ConflictException(crate::error::ConflictException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCaseErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCaseErrorKind::ConflictException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCaseErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCaseErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCaseErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCaseErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateCaseErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCaseError {
    fn code(&self) -> Option<&str> {
        CreateCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateCaseErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            CreateCaseErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl CreateCaseError {
    /// Creates a new `CreateCaseError`.
                    pub fn new(kind: CreateCaseErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateCaseError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateCaseErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateCaseError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateCaseErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateCaseErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateCaseErrorKind::ConflictException`.
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::ConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateCaseErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateCaseErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateCaseErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateCaseErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateCaseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCaseErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateCaseErrorKind::ConflictException(_inner) =>
            Some(_inner)
            ,
            CreateCaseErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateCaseErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateCaseErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateCaseErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateCaseErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UpdateCase` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCaseError {
    /// Kind of error that occurred.
                    pub kind: UpdateCaseErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateCaseError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UpdateCaseErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UpdateCase` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCaseErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UpdateCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCaseErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCaseErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCaseErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCaseErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCaseErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateCaseErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCaseError {
    fn code(&self) -> Option<&str> {
        UpdateCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateCaseErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            UpdateCaseErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl UpdateCaseError {
    /// Creates a new `UpdateCaseError`.
                    pub fn new(kind: UpdateCaseErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UpdateCaseError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UpdateCaseErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UpdateCaseError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UpdateCaseErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UpdateCaseErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateCaseErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateCaseErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UpdateCaseErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UpdateCaseErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateCaseErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateCaseErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateCaseErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateCaseErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateCaseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCaseErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdateCaseErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UpdateCaseErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdateCaseErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UpdateCaseErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UpdateCaseErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `GetCase` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCaseError {
    /// Kind of error that occurred.
                    pub kind: GetCaseErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for GetCaseError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: GetCaseErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `GetCase` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCaseErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for GetCaseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCaseErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            GetCaseErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCaseError {
    fn code(&self) -> Option<&str> {
        GetCaseError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetCaseErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            GetCaseErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl GetCaseError {
    /// Creates a new `GetCaseError`.
                    pub fn new(kind: GetCaseErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `GetCaseError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: GetCaseErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `GetCaseError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: GetCaseErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `GetCaseErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetCaseErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCaseErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetCaseErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `GetCaseErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetCaseErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCaseErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetCaseErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `GetCaseErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetCaseErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetCaseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCaseErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            GetCaseErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            GetCaseErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            GetCaseErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            GetCaseErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            GetCaseErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `SearchRelatedItems` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SearchRelatedItemsError {
    /// Kind of error that occurred.
                    pub kind: SearchRelatedItemsErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for SearchRelatedItemsError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: SearchRelatedItemsErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `SearchRelatedItems` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SearchRelatedItemsErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for SearchRelatedItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SearchRelatedItemsErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            SearchRelatedItemsErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            SearchRelatedItemsErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            SearchRelatedItemsErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            SearchRelatedItemsErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            SearchRelatedItemsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SearchRelatedItemsError {
    fn code(&self) -> Option<&str> {
        SearchRelatedItemsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            SearchRelatedItemsErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            SearchRelatedItemsErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl SearchRelatedItemsError {
    /// Creates a new `SearchRelatedItemsError`.
                    pub fn new(kind: SearchRelatedItemsErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `SearchRelatedItemsError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: SearchRelatedItemsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `SearchRelatedItemsError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: SearchRelatedItemsErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `SearchRelatedItemsErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, SearchRelatedItemsErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `SearchRelatedItemsErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, SearchRelatedItemsErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `SearchRelatedItemsErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, SearchRelatedItemsErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `SearchRelatedItemsErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, SearchRelatedItemsErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `SearchRelatedItemsErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, SearchRelatedItemsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for SearchRelatedItemsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SearchRelatedItemsErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            SearchRelatedItemsErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            SearchRelatedItemsErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            SearchRelatedItemsErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            SearchRelatedItemsErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            SearchRelatedItemsErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `CreateRelatedItem` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRelatedItemError {
    /// Kind of error that occurred.
                    pub kind: CreateRelatedItemErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRelatedItemError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: CreateRelatedItemErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `CreateRelatedItem` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRelatedItemErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The service quota has been exceeded. For a list of service quotas, see <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.</p>
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for CreateRelatedItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRelatedItemErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateRelatedItemErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateRelatedItemErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateRelatedItemErrorKind::ServiceQuotaExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateRelatedItemErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            CreateRelatedItemErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            CreateRelatedItemErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRelatedItemError {
    fn code(&self) -> Option<&str> {
        CreateRelatedItemError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateRelatedItemErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            CreateRelatedItemErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl CreateRelatedItemError {
    /// Creates a new `CreateRelatedItemError`.
                    pub fn new(kind: CreateRelatedItemErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `CreateRelatedItemError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: CreateRelatedItemErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `CreateRelatedItemError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: CreateRelatedItemErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `CreateRelatedItemErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateRelatedItemErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateRelatedItemErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, CreateRelatedItemErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `CreateRelatedItemErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateRelatedItemErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateRelatedItemErrorKind::ServiceQuotaExceededException`.
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateRelatedItemErrorKind::ServiceQuotaExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRelatedItemErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateRelatedItemErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateRelatedItemErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateRelatedItemErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateRelatedItemError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRelatedItemErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateRelatedItemErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            CreateRelatedItemErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateRelatedItemErrorKind::ServiceQuotaExceededException(_inner) =>
            Some(_inner)
            ,
            CreateRelatedItemErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            CreateRelatedItemErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            CreateRelatedItemErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
                    pub kind: UntagResourceErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            UntagResourceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            UntagResourceErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
                    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: UntagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: UntagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            UntagResourceErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
                    pub kind: TagResourceErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            TagResourceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            TagResourceErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
                    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `TagResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: TagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: TagResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            TagResourceErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
                    pub kind: ListTagsForResourceErrorKind,
                    /// Additional metadata about the error, including error code, message, and request ID.
                    pub (crate) meta: aws_smithy_types::Error
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(crate::error::Unhandled::new(source)),
            meta: Default::default()
        }
    }
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>You do not have sufficient access to perform this action.</p>
    AccessDeniedException(crate::error::AccessDeniedException),
    /// <p>We couldn't process your request because of an issue with the server. Try again later.</p>
    InternalServerException(crate::error::InternalServerException),
    /// <p>We couldn't find the requested resource. Check that your resources exists and were created in the same Amazon Web Services Region as your request, and try your request again.</p>
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// <p>The rate has been exceeded for this API. Please try again after a few minutes.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The request isn't valid. Check the syntax and try again.</p>
    ValidationException(crate::error::ValidationException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::InternalServerException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::ThrottlingException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            ListTagsForResourceErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(inner) => Some(inner.retryable_error_kind()),
            ListTagsForResourceErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None
        }
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
                    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
                        Self { kind, meta }
                    }
    
                    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self {
                            kind: ListTagsForResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                            meta: Default::default()
                        }
                    }
    
                    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
                    pub fn generic(err: aws_smithy_types::Error) -> Self {
                        Self {
                            meta: err.clone(),
                            kind: ListTagsForResourceErrorKind::Unhandled(crate::error::Unhandled::new(err.into())),
                        }
                    }
    
                    /// Returns the error message if one is available.
                    pub fn message(&self) -> Option<&str> {
                        self.meta.message()
                    }
    
                    /// Returns error metadata, which includes the error code, message,
                    /// request ID, and potentially additional information.
                    pub fn meta(&self) -> &aws_smithy_types::Error {
                        &self.meta
                    }
    
                    /// Returns the request ID if it's available.
                    pub fn request_id(&self) -> Option<&str> {
                        self.meta.request_id()
                    }
    
                    /// Returns the error code if it's available.
                    pub fn code(&self) -> Option<&str> {
                        self.meta.code()
                    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InternalServerException`.
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::InternalServerException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::InternalServerException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::ThrottlingException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::ValidationException(_inner) =>
            Some(_inner)
            ,
            ListTagsForResourceErrorKind::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

/// 
/// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
/// 
/// When logging an error from the SDK, it is recommended that you either wrap the error in
/// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
/// error reporter library that visits the error's cause/source chain, or call
/// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
/// 
#[derive(Debug)]
        pub struct Unhandled {
            source: Box<dyn std::error::Error + Send + Sync + 'static>,
        }
        impl Unhandled {
            #[allow(unused)]
            pub(crate) fn new(source: Box<dyn std::error::Error + Send + Sync + 'static>) -> Self {
                Self { source }
            }
        }
        impl std::fmt::Display for Unhandled {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
                write!(f, "unhandled error")
            }
        }
        impl std::error::Error for Unhandled {
            fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                Some(self.source.as_ref() as _)
            }
        }

