// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Template summary information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TemplateSummary {
    /// <p>The unique identifier for the template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    #[doc(hidden)]
    pub template_arn: std::option::Option<std::string::String>,
    /// <p>The template name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The status of the template.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::TemplateStatus>,
}
impl TemplateSummary {
    /// <p>The unique identifier for the template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the template.</p>
    pub fn template_arn(&self) -> std::option::Option<&str> {
        self.template_arn.as_deref()
    }
    /// <p>The template name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The status of the template.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::TemplateStatus> {
        self.status.as_ref()
    }
}
impl TemplateSummary {
    /// Creates a new builder-style object to manufacture [`TemplateSummary`](crate::model::TemplateSummary).
    pub fn builder() -> crate::model::template_summary::Builder {
        crate::model::template_summary::Builder::default()
    }
}

/// See [`TemplateSummary`](crate::model::TemplateSummary).
pub mod template_summary {

    /// A builder for [`TemplateSummary`](crate::model::TemplateSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) template_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::TemplateStatus>,
    }
    impl Builder {
        /// <p>The unique identifier for the template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn template_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the template.</p>
        pub fn set_template_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_arn = input;
            self
        }
        /// <p>The template name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The template name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The status of the template.</p>
        pub fn status(mut self, input: crate::model::TemplateStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the template.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::TemplateStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateSummary`](crate::model::TemplateSummary).
        pub fn build(self) -> crate::model::TemplateSummary {
            crate::model::TemplateSummary {
                template_id: self.template_id,
                template_arn: self.template_arn,
                name: self.name,
                status: self.status,
            }
        }
    }
}

/// When writing a match expression against `TemplateStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let templatestatus = unimplemented!();
/// match templatestatus {
///     TemplateStatus::Active => { /* ... */ },
///     TemplateStatus::Inactive => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `templatestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TemplateStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TemplateStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TemplateStatus::NewFeature` is defined.
/// Specifically, when `templatestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TemplateStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Status of a template
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemplateStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TemplateStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => TemplateStatus::Active,
            "Inactive" => TemplateStatus::Inactive,
            other => TemplateStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for TemplateStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TemplateStatus::from(s))
    }
}
impl TemplateStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TemplateStatus::Active => "Active",
            TemplateStatus::Inactive => "Inactive",
            TemplateStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "Inactive"]
    }
}
impl AsRef<str> for TemplateStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>List of fields that must have a value provided to create a case.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RequiredField {
    /// <p>Unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
}
impl RequiredField {
    /// <p>Unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
}
impl RequiredField {
    /// Creates a new builder-style object to manufacture [`RequiredField`](crate::model::RequiredField).
    pub fn builder() -> crate::model::required_field::Builder {
        crate::model::required_field::Builder::default()
    }
}

/// See [`RequiredField`](crate::model::RequiredField).
pub mod required_field {

    /// A builder for [`RequiredField`](crate::model::RequiredField).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RequiredField`](crate::model::RequiredField).
        pub fn build(self) -> crate::model::RequiredField {
            crate::model::RequiredField {
                field_id: self.field_id,
            }
        }
    }
}

/// <p>Object to store configuration of layouts associated to the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayoutConfiguration {
    /// <p> Unique identifier of a layout. </p>
    #[doc(hidden)]
    pub default_layout: std::option::Option<std::string::String>,
}
impl LayoutConfiguration {
    /// <p> Unique identifier of a layout. </p>
    pub fn default_layout(&self) -> std::option::Option<&str> {
        self.default_layout.as_deref()
    }
}
impl LayoutConfiguration {
    /// Creates a new builder-style object to manufacture [`LayoutConfiguration`](crate::model::LayoutConfiguration).
    pub fn builder() -> crate::model::layout_configuration::Builder {
        crate::model::layout_configuration::Builder::default()
    }
}

/// See [`LayoutConfiguration`](crate::model::LayoutConfiguration).
pub mod layout_configuration {

    /// A builder for [`LayoutConfiguration`](crate::model::LayoutConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_layout: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> Unique identifier of a layout. </p>
        pub fn default_layout(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_layout = Some(input.into());
            self
        }
        /// <p> Unique identifier of a layout. </p>
        pub fn set_default_layout(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_layout = input;
            self
        }
        /// Consumes the builder and constructs a [`LayoutConfiguration`](crate::model::LayoutConfiguration).
        pub fn build(self) -> crate::model::LayoutConfiguration {
            crate::model::LayoutConfiguration {
                default_layout: self.default_layout,
            }
        }
    }
}

/// <p>Object for the summarized details of the layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayoutSummary {
    /// <p>The unique identifier for of the layout.</p>
    #[doc(hidden)]
    pub layout_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the layout.</p>
    #[doc(hidden)]
    pub layout_arn: std::option::Option<std::string::String>,
    /// <p>The name of the layout.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl LayoutSummary {
    /// <p>The unique identifier for of the layout.</p>
    pub fn layout_id(&self) -> std::option::Option<&str> {
        self.layout_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the layout.</p>
    pub fn layout_arn(&self) -> std::option::Option<&str> {
        self.layout_arn.as_deref()
    }
    /// <p>The name of the layout.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl LayoutSummary {
    /// Creates a new builder-style object to manufacture [`LayoutSummary`](crate::model::LayoutSummary).
    pub fn builder() -> crate::model::layout_summary::Builder {
        crate::model::layout_summary::Builder::default()
    }
}

/// See [`LayoutSummary`](crate::model::LayoutSummary).
pub mod layout_summary {

    /// A builder for [`LayoutSummary`](crate::model::LayoutSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) layout_id: std::option::Option<std::string::String>,
        pub(crate) layout_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for of the layout.</p>
        pub fn layout_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.layout_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for of the layout.</p>
        pub fn set_layout_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layout_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the layout.</p>
        pub fn layout_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.layout_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the layout.</p>
        pub fn set_layout_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layout_arn = input;
            self
        }
        /// <p>The name of the layout.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the layout.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`LayoutSummary`](crate::model::LayoutSummary).
        pub fn build(self) -> crate::model::LayoutSummary {
            crate::model::LayoutSummary {
                layout_id: self.layout_id,
                layout_arn: self.layout_arn,
                name: self.name,
            }
        }
    }
}

/// <p>Object to store union of different versions of layout content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum LayoutContent {
    /// <p>Content specific to <code>BasicLayout</code> type. It configures fields in the top panel and More Info tab of Cases user interface.</p>
    Basic(crate::model::BasicLayout),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl LayoutContent {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Basic`](crate::model::LayoutContent::Basic), extracting the inner [`BasicLayout`](crate::model::BasicLayout).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_basic(&self) -> std::result::Result<&crate::model::BasicLayout, &Self> {
        if let LayoutContent::Basic(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Basic`](crate::model::LayoutContent::Basic).
    pub fn is_basic(&self) -> bool {
        self.as_basic().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Content specific to <code>BasicLayout</code> type. It configures fields in the top panel and More Info tab of agent application. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BasicLayout {
    /// <p>This represents sections in a panel of the page layout.</p>
    #[doc(hidden)]
    pub top_panel: std::option::Option<crate::model::LayoutSections>,
    /// <p>This represents sections in a tab of the page layout.</p>
    #[doc(hidden)]
    pub more_info: std::option::Option<crate::model::LayoutSections>,
}
impl BasicLayout {
    /// <p>This represents sections in a panel of the page layout.</p>
    pub fn top_panel(&self) -> std::option::Option<&crate::model::LayoutSections> {
        self.top_panel.as_ref()
    }
    /// <p>This represents sections in a tab of the page layout.</p>
    pub fn more_info(&self) -> std::option::Option<&crate::model::LayoutSections> {
        self.more_info.as_ref()
    }
}
impl BasicLayout {
    /// Creates a new builder-style object to manufacture [`BasicLayout`](crate::model::BasicLayout).
    pub fn builder() -> crate::model::basic_layout::Builder {
        crate::model::basic_layout::Builder::default()
    }
}

/// See [`BasicLayout`](crate::model::BasicLayout).
pub mod basic_layout {

    /// A builder for [`BasicLayout`](crate::model::BasicLayout).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) top_panel: std::option::Option<crate::model::LayoutSections>,
        pub(crate) more_info: std::option::Option<crate::model::LayoutSections>,
    }
    impl Builder {
        /// <p>This represents sections in a panel of the page layout.</p>
        pub fn top_panel(mut self, input: crate::model::LayoutSections) -> Self {
            self.top_panel = Some(input);
            self
        }
        /// <p>This represents sections in a panel of the page layout.</p>
        pub fn set_top_panel(
            mut self,
            input: std::option::Option<crate::model::LayoutSections>,
        ) -> Self {
            self.top_panel = input;
            self
        }
        /// <p>This represents sections in a tab of the page layout.</p>
        pub fn more_info(mut self, input: crate::model::LayoutSections) -> Self {
            self.more_info = Some(input);
            self
        }
        /// <p>This represents sections in a tab of the page layout.</p>
        pub fn set_more_info(
            mut self,
            input: std::option::Option<crate::model::LayoutSections>,
        ) -> Self {
            self.more_info = input;
            self
        }
        /// Consumes the builder and constructs a [`BasicLayout`](crate::model::BasicLayout).
        pub fn build(self) -> crate::model::BasicLayout {
            crate::model::BasicLayout {
                top_panel: self.top_panel,
                more_info: self.more_info,
            }
        }
    }
}

/// <p>Ordered list containing different kinds of sections that can be added. A LayoutSections object can only contain one section.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LayoutSections {
    /// <p>Ordered list containing different kinds of sections that can be added.</p>
    #[doc(hidden)]
    pub sections: std::option::Option<std::vec::Vec<crate::model::Section>>,
}
impl LayoutSections {
    /// <p>Ordered list containing different kinds of sections that can be added.</p>
    pub fn sections(&self) -> std::option::Option<&[crate::model::Section]> {
        self.sections.as_deref()
    }
}
impl LayoutSections {
    /// Creates a new builder-style object to manufacture [`LayoutSections`](crate::model::LayoutSections).
    pub fn builder() -> crate::model::layout_sections::Builder {
        crate::model::layout_sections::Builder::default()
    }
}

/// See [`LayoutSections`](crate::model::LayoutSections).
pub mod layout_sections {

    /// A builder for [`LayoutSections`](crate::model::LayoutSections).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sections: std::option::Option<std::vec::Vec<crate::model::Section>>,
    }
    impl Builder {
        /// Appends an item to `sections`.
        ///
        /// To override the contents of this collection use [`set_sections`](Self::set_sections).
        ///
        /// <p>Ordered list containing different kinds of sections that can be added.</p>
        pub fn sections(mut self, input: crate::model::Section) -> Self {
            let mut v = self.sections.unwrap_or_default();
            v.push(input);
            self.sections = Some(v);
            self
        }
        /// <p>Ordered list containing different kinds of sections that can be added.</p>
        pub fn set_sections(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Section>>,
        ) -> Self {
            self.sections = input;
            self
        }
        /// Consumes the builder and constructs a [`LayoutSections`](crate::model::LayoutSections).
        pub fn build(self) -> crate::model::LayoutSections {
            crate::model::LayoutSections {
                sections: self.sections,
            }
        }
    }
}

/// <p>This represents a sections within a panel or tab of the page layout.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum Section {
    /// <p>Consists of a group of fields and associated properties.</p>
    FieldGroup(crate::model::FieldGroup),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl Section {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`FieldGroup`](crate::model::Section::FieldGroup), extracting the inner [`FieldGroup`](crate::model::FieldGroup).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_field_group(&self) -> std::result::Result<&crate::model::FieldGroup, &Self> {
        if let Section::FieldGroup(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`FieldGroup`](crate::model::Section::FieldGroup).
    pub fn is_field_group(&self) -> bool {
        self.as_field_group().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Object for a group of fields and associated properties.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldGroup {
    /// <p>Name of the field group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Represents an ordered list containing field related information.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldItem>>,
}
impl FieldGroup {
    /// <p>Name of the field group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Represents an ordered list containing field related information.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldItem]> {
        self.fields.as_deref()
    }
}
impl FieldGroup {
    /// Creates a new builder-style object to manufacture [`FieldGroup`](crate::model::FieldGroup).
    pub fn builder() -> crate::model::field_group::Builder {
        crate::model::field_group::Builder::default()
    }
}

/// See [`FieldGroup`](crate::model::FieldGroup).
pub mod field_group {

    /// A builder for [`FieldGroup`](crate::model::FieldGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldItem>>,
    }
    impl Builder {
        /// <p>Name of the field group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the field group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>Represents an ordered list containing field related information.</p>
        pub fn fields(mut self, input: crate::model::FieldItem) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>Represents an ordered list containing field related information.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldItem>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldGroup`](crate::model::FieldGroup).
        pub fn build(self) -> crate::model::FieldGroup {
            crate::model::FieldGroup {
                name: self.name,
                fields: self.fields,
            }
        }
    }
}

/// <p>Object for field related information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldItem {
    /// <p>Unique identifier of a field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl FieldItem {
    /// <p>Unique identifier of a field.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl FieldItem {
    /// Creates a new builder-style object to manufacture [`FieldItem`](crate::model::FieldItem).
    pub fn builder() -> crate::model::field_item::Builder {
        crate::model::field_item::Builder::default()
    }
}

/// See [`FieldItem`](crate::model::FieldItem).
pub mod field_item {

    /// A builder for [`FieldItem`](crate::model::FieldItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unique identifier of a field.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Unique identifier of a field.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldItem`](crate::model::FieldItem).
        pub fn build(self) -> crate::model::FieldItem {
            crate::model::FieldItem { id: self.id }
        }
    }
}

/// <p>Object for field Options information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldOption {
    /// <p> <code>FieldOptionName</code> has max length 100 and disallows trailing spaces.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> <code>FieldOptionValue</code> has max length 100 and must be alphanumeric with hyphens and underscores.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
    /// <p>Describes whether the <code>FieldOption</code> is active (displayed) or inactive.</p>
    #[doc(hidden)]
    pub active: std::option::Option<bool>,
}
impl FieldOption {
    /// <p> <code>FieldOptionName</code> has max length 100 and disallows trailing spaces.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> <code>FieldOptionValue</code> has max length 100 and must be alphanumeric with hyphens and underscores.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
    /// <p>Describes whether the <code>FieldOption</code> is active (displayed) or inactive.</p>
    pub fn active(&self) -> std::option::Option<bool> {
        self.active
    }
}
impl FieldOption {
    /// Creates a new builder-style object to manufacture [`FieldOption`](crate::model::FieldOption).
    pub fn builder() -> crate::model::field_option::Builder {
        crate::model::field_option::Builder::default()
    }
}

/// See [`FieldOption`](crate::model::FieldOption).
pub mod field_option {

    /// A builder for [`FieldOption`](crate::model::FieldOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) active: std::option::Option<bool>,
    }
    impl Builder {
        /// <p> <code>FieldOptionName</code> has max length 100 and disallows trailing spaces.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p> <code>FieldOptionName</code> has max length 100 and disallows trailing spaces.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> <code>FieldOptionValue</code> has max length 100 and must be alphanumeric with hyphens and underscores.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p> <code>FieldOptionValue</code> has max length 100 and must be alphanumeric with hyphens and underscores.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Describes whether the <code>FieldOption</code> is active (displayed) or inactive.</p>
        pub fn active(mut self, input: bool) -> Self {
            self.active = Some(input);
            self
        }
        /// <p>Describes whether the <code>FieldOption</code> is active (displayed) or inactive.</p>
        pub fn set_active(mut self, input: std::option::Option<bool>) -> Self {
            self.active = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldOption`](crate::model::FieldOption).
        pub fn build(self) -> crate::model::FieldOption {
            crate::model::FieldOption {
                name: self.name,
                value: self.value,
                active: self.active,
            }
        }
    }
}

/// <p>Object for field Options errors.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldOptionError {
    /// <p>Error message from creating or updating field option.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    /// <p>Error code from creating or updating field option.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The field option value that caused the error.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl FieldOptionError {
    /// <p>Error message from creating or updating field option.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
    /// <p>Error code from creating or updating field option.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The field option value that caused the error.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl FieldOptionError {
    /// Creates a new builder-style object to manufacture [`FieldOptionError`](crate::model::FieldOptionError).
    pub fn builder() -> crate::model::field_option_error::Builder {
        crate::model::field_option_error::Builder::default()
    }
}

/// See [`FieldOptionError`](crate::model::FieldOptionError).
pub mod field_option_error {

    /// A builder for [`FieldOptionError`](crate::model::FieldOptionError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Error message from creating or updating field option.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Error message from creating or updating field option.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Error code from creating or updating field option.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>Error code from creating or updating field option.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The field option value that caused the error.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The field option value that caused the error.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldOptionError`](crate::model::FieldOptionError).
        pub fn build(self) -> crate::model::FieldOptionError {
            crate::model::FieldOptionError {
                message: self.message,
                error_code: self.error_code,
                value: self.value,
            }
        }
    }
}

/// <p>Object for errors on fields.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldError {
    /// <p>The field identifier that caused the error.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The error code from getting a field.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message from getting a field.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
}
impl FieldError {
    /// <p>The field identifier that caused the error.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The error code from getting a field.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The error message from getting a field.</p>
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl FieldError {
    /// Creates a new builder-style object to manufacture [`FieldError`](crate::model::FieldError).
    pub fn builder() -> crate::model::field_error::Builder {
        crate::model::field_error::Builder::default()
    }
}

/// See [`FieldError`](crate::model::FieldError).
pub mod field_error {

    /// A builder for [`FieldError`](crate::model::FieldError).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The field identifier that caused the error.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The field identifier that caused the error.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The error code from getting a field.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code from getting a field.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message from getting a field.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The error message from getting a field.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldError`](crate::model::FieldError).
        pub fn build(self) -> crate::model::FieldError {
            crate::model::FieldError {
                id: self.id,
                error_code: self.error_code,
                message: self.message,
            }
        }
    }
}

/// <p>Object to store detailed field information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetFieldResponse {
    /// <p>Unique identifier of the field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>Name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the field.</p>
    #[doc(hidden)]
    pub field_arn: std::option::Option<std::string::String>,
    /// <p>Description of the field.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Type of the field.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::FieldType>,
    /// <p>Namespace of the field.</p>
    #[doc(hidden)]
    pub namespace: std::option::Option<crate::model::FieldNamespace>,
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl GetFieldResponse {
    /// <p>Unique identifier of the field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>Name of the field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the field.</p>
    pub fn field_arn(&self) -> std::option::Option<&str> {
        self.field_arn.as_deref()
    }
    /// <p>Description of the field.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Type of the field.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::FieldType> {
        self.r#type.as_ref()
    }
    /// <p>Namespace of the field.</p>
    pub fn namespace(&self) -> std::option::Option<&crate::model::FieldNamespace> {
        self.namespace.as_ref()
    }
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    > {
        self.tags.as_ref()
    }
}
impl GetFieldResponse {
    /// Creates a new builder-style object to manufacture [`GetFieldResponse`](crate::model::GetFieldResponse).
    pub fn builder() -> crate::model::get_field_response::Builder {
        crate::model::get_field_response::Builder::default()
    }
}

/// See [`GetFieldResponse`](crate::model::GetFieldResponse).
pub mod get_field_response {

    /// A builder for [`GetFieldResponse`](crate::model::GetFieldResponse).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) field_arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::FieldType>,
        pub(crate) namespace: std::option::Option<crate::model::FieldNamespace>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::option::Option<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// <p>Unique identifier of the field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of the field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>Name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the field.</p>
        pub fn field_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the field.</p>
        pub fn set_field_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_arn = input;
            self
        }
        /// <p>Description of the field.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>Description of the field.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Type of the field.</p>
        pub fn r#type(mut self, input: crate::model::FieldType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type of the field.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::FieldType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Namespace of the field.</p>
        pub fn namespace(mut self, input: crate::model::FieldNamespace) -> Self {
            self.namespace = Some(input);
            self
        }
        /// <p>Namespace of the field.</p>
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::FieldNamespace>,
        ) -> Self {
            self.namespace = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: std::option::Option<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`GetFieldResponse`](crate::model::GetFieldResponse).
        pub fn build(self) -> crate::model::GetFieldResponse {
            crate::model::GetFieldResponse {
                field_id: self.field_id,
                name: self.name,
                field_arn: self.field_arn,
                description: self.description,
                r#type: self.r#type,
                namespace: self.namespace,
                tags: self.tags,
            }
        }
    }
}

/// When writing a match expression against `FieldNamespace`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fieldnamespace = unimplemented!();
/// match fieldnamespace {
///     FieldNamespace::Custom => { /* ... */ },
///     FieldNamespace::System => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fieldnamespace` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FieldNamespace::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FieldNamespace::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FieldNamespace::NewFeature` is defined.
/// Specifically, when `fieldnamespace` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FieldNamespace::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FieldNamespace {
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    System,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FieldNamespace {
    fn from(s: &str) -> Self {
        match s {
            "Custom" => FieldNamespace::Custom,
            "System" => FieldNamespace::System,
            other => FieldNamespace::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FieldNamespace {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FieldNamespace::from(s))
    }
}
impl FieldNamespace {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FieldNamespace::Custom => "Custom",
            FieldNamespace::System => "System",
            FieldNamespace::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Custom", "System"]
    }
}
impl AsRef<str> for FieldNamespace {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FieldType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fieldtype = unimplemented!();
/// match fieldtype {
///     FieldType::Boolean => { /* ... */ },
///     FieldType::DateTime => { /* ... */ },
///     FieldType::Number => { /* ... */ },
///     FieldType::SingleSelect => { /* ... */ },
///     FieldType::Text => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fieldtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FieldType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FieldType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FieldType::NewFeature` is defined.
/// Specifically, when `fieldtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FieldType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FieldType {
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    DateTime,
    #[allow(missing_docs)] // documentation missing in model
    Number,
    #[allow(missing_docs)] // documentation missing in model
    SingleSelect,
    #[allow(missing_docs)] // documentation missing in model
    Text,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FieldType {
    fn from(s: &str) -> Self {
        match s {
            "Boolean" => FieldType::Boolean,
            "DateTime" => FieldType::DateTime,
            "Number" => FieldType::Number,
            "SingleSelect" => FieldType::SingleSelect,
            "Text" => FieldType::Text,
            other => FieldType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FieldType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FieldType::from(s))
    }
}
impl FieldType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FieldType::Boolean => "Boolean",
            FieldType::DateTime => "DateTime",
            FieldType::Number => "Number",
            FieldType::SingleSelect => "SingleSelect",
            FieldType::Text => "Text",
            FieldType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Boolean", "DateTime", "Number", "SingleSelect", "Text"]
    }
}
impl AsRef<str> for FieldType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Object for unique identifier of a field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldIdentifier {
    /// <p>Unique identifier of a field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl FieldIdentifier {
    /// <p>Unique identifier of a field.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl FieldIdentifier {
    /// Creates a new builder-style object to manufacture [`FieldIdentifier`](crate::model::FieldIdentifier).
    pub fn builder() -> crate::model::field_identifier::Builder {
        crate::model::field_identifier::Builder::default()
    }
}

/// See [`FieldIdentifier`](crate::model::FieldIdentifier).
pub mod field_identifier {

    /// A builder for [`FieldIdentifier`](crate::model::FieldIdentifier).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Unique identifier of a field.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Unique identifier of a field.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldIdentifier`](crate::model::FieldIdentifier).
        pub fn build(self) -> crate::model::FieldIdentifier {
            crate::model::FieldIdentifier { id: self.id }
        }
    }
}

/// <p>Object for the summarized details of the field.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldSummary {
    /// <p>The unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the field.</p>
    #[doc(hidden)]
    pub field_arn: std::option::Option<std::string::String>,
    /// <p>Name of the field.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of a field.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::FieldType>,
    /// <p>The namespace of a field.</p>
    #[doc(hidden)]
    pub namespace: std::option::Option<crate::model::FieldNamespace>,
}
impl FieldSummary {
    /// <p>The unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the field.</p>
    pub fn field_arn(&self) -> std::option::Option<&str> {
        self.field_arn.as_deref()
    }
    /// <p>Name of the field.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of a field.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::FieldType> {
        self.r#type.as_ref()
    }
    /// <p>The namespace of a field.</p>
    pub fn namespace(&self) -> std::option::Option<&crate::model::FieldNamespace> {
        self.namespace.as_ref()
    }
}
impl FieldSummary {
    /// Creates a new builder-style object to manufacture [`FieldSummary`](crate::model::FieldSummary).
    pub fn builder() -> crate::model::field_summary::Builder {
        crate::model::field_summary::Builder::default()
    }
}

/// See [`FieldSummary`](crate::model::FieldSummary).
pub mod field_summary {

    /// A builder for [`FieldSummary`](crate::model::FieldSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) field_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::FieldType>,
        pub(crate) namespace: std::option::Option<crate::model::FieldNamespace>,
    }
    impl Builder {
        /// <p>The unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the field.</p>
        pub fn field_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the field.</p>
        pub fn set_field_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_arn = input;
            self
        }
        /// <p>Name of the field.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the field.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of a field.</p>
        pub fn r#type(mut self, input: crate::model::FieldType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of a field.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::FieldType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The namespace of a field.</p>
        pub fn namespace(mut self, input: crate::model::FieldNamespace) -> Self {
            self.namespace = Some(input);
            self
        }
        /// <p>The namespace of a field.</p>
        pub fn set_namespace(
            mut self,
            input: std::option::Option<crate::model::FieldNamespace>,
        ) -> Self {
            self.namespace = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldSummary`](crate::model::FieldSummary).
        pub fn build(self) -> crate::model::FieldSummary {
            crate::model::FieldSummary {
                field_id: self.field_id,
                field_arn: self.field_arn,
                name: self.name,
                r#type: self.r#type,
                namespace: self.namespace,
            }
        }
    }
}

/// <p>Configuration to enable EventBridge case event delivery and determine what data is delivered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventBridgeConfiguration {
    /// <p>Indicates whether the to broadcast case event data to the customer.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>Details of what case and related item data is published through the case event stream.</p>
    #[doc(hidden)]
    pub included_data: std::option::Option<crate::model::EventIncludedData>,
}
impl EventBridgeConfiguration {
    /// <p>Indicates whether the to broadcast case event data to the customer.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>Details of what case and related item data is published through the case event stream.</p>
    pub fn included_data(&self) -> std::option::Option<&crate::model::EventIncludedData> {
        self.included_data.as_ref()
    }
}
impl EventBridgeConfiguration {
    /// Creates a new builder-style object to manufacture [`EventBridgeConfiguration`](crate::model::EventBridgeConfiguration).
    pub fn builder() -> crate::model::event_bridge_configuration::Builder {
        crate::model::event_bridge_configuration::Builder::default()
    }
}

/// See [`EventBridgeConfiguration`](crate::model::EventBridgeConfiguration).
pub mod event_bridge_configuration {

    /// A builder for [`EventBridgeConfiguration`](crate::model::EventBridgeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) included_data: std::option::Option<crate::model::EventIncludedData>,
    }
    impl Builder {
        /// <p>Indicates whether the to broadcast case event data to the customer.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Indicates whether the to broadcast case event data to the customer.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>Details of what case and related item data is published through the case event stream.</p>
        pub fn included_data(mut self, input: crate::model::EventIncludedData) -> Self {
            self.included_data = Some(input);
            self
        }
        /// <p>Details of what case and related item data is published through the case event stream.</p>
        pub fn set_included_data(
            mut self,
            input: std::option::Option<crate::model::EventIncludedData>,
        ) -> Self {
            self.included_data = input;
            self
        }
        /// Consumes the builder and constructs a [`EventBridgeConfiguration`](crate::model::EventBridgeConfiguration).
        pub fn build(self) -> crate::model::EventBridgeConfiguration {
            crate::model::EventBridgeConfiguration {
                enabled: self.enabled,
                included_data: self.included_data,
            }
        }
    }
}

/// <p>Details of what case and related item data is published through the case event stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventIncludedData {
    /// <p>Details of what case data is published through the case event stream.</p>
    #[doc(hidden)]
    pub case_data: std::option::Option<crate::model::CaseEventIncludedData>,
    /// <p>Details of what related item data is published through the case event stream.</p>
    #[doc(hidden)]
    pub related_item_data: std::option::Option<crate::model::RelatedItemEventIncludedData>,
}
impl EventIncludedData {
    /// <p>Details of what case data is published through the case event stream.</p>
    pub fn case_data(&self) -> std::option::Option<&crate::model::CaseEventIncludedData> {
        self.case_data.as_ref()
    }
    /// <p>Details of what related item data is published through the case event stream.</p>
    pub fn related_item_data(
        &self,
    ) -> std::option::Option<&crate::model::RelatedItemEventIncludedData> {
        self.related_item_data.as_ref()
    }
}
impl EventIncludedData {
    /// Creates a new builder-style object to manufacture [`EventIncludedData`](crate::model::EventIncludedData).
    pub fn builder() -> crate::model::event_included_data::Builder {
        crate::model::event_included_data::Builder::default()
    }
}

/// See [`EventIncludedData`](crate::model::EventIncludedData).
pub mod event_included_data {

    /// A builder for [`EventIncludedData`](crate::model::EventIncludedData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) case_data: std::option::Option<crate::model::CaseEventIncludedData>,
        pub(crate) related_item_data:
            std::option::Option<crate::model::RelatedItemEventIncludedData>,
    }
    impl Builder {
        /// <p>Details of what case data is published through the case event stream.</p>
        pub fn case_data(mut self, input: crate::model::CaseEventIncludedData) -> Self {
            self.case_data = Some(input);
            self
        }
        /// <p>Details of what case data is published through the case event stream.</p>
        pub fn set_case_data(
            mut self,
            input: std::option::Option<crate::model::CaseEventIncludedData>,
        ) -> Self {
            self.case_data = input;
            self
        }
        /// <p>Details of what related item data is published through the case event stream.</p>
        pub fn related_item_data(
            mut self,
            input: crate::model::RelatedItemEventIncludedData,
        ) -> Self {
            self.related_item_data = Some(input);
            self
        }
        /// <p>Details of what related item data is published through the case event stream.</p>
        pub fn set_related_item_data(
            mut self,
            input: std::option::Option<crate::model::RelatedItemEventIncludedData>,
        ) -> Self {
            self.related_item_data = input;
            self
        }
        /// Consumes the builder and constructs a [`EventIncludedData`](crate::model::EventIncludedData).
        pub fn build(self) -> crate::model::EventIncludedData {
            crate::model::EventIncludedData {
                case_data: self.case_data,
                related_item_data: self.related_item_data,
            }
        }
    }
}

/// <p>Details of what related item data is published through the case event stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelatedItemEventIncludedData {
    /// <p>Details of what related item data is published through the case event stream.</p>
    #[doc(hidden)]
    pub include_content: std::option::Option<bool>,
}
impl RelatedItemEventIncludedData {
    /// <p>Details of what related item data is published through the case event stream.</p>
    pub fn include_content(&self) -> std::option::Option<bool> {
        self.include_content
    }
}
impl RelatedItemEventIncludedData {
    /// Creates a new builder-style object to manufacture [`RelatedItemEventIncludedData`](crate::model::RelatedItemEventIncludedData).
    pub fn builder() -> crate::model::related_item_event_included_data::Builder {
        crate::model::related_item_event_included_data::Builder::default()
    }
}

/// See [`RelatedItemEventIncludedData`](crate::model::RelatedItemEventIncludedData).
pub mod related_item_event_included_data {

    /// A builder for [`RelatedItemEventIncludedData`](crate::model::RelatedItemEventIncludedData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) include_content: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Details of what related item data is published through the case event stream.</p>
        pub fn include_content(mut self, input: bool) -> Self {
            self.include_content = Some(input);
            self
        }
        /// <p>Details of what related item data is published through the case event stream.</p>
        pub fn set_include_content(mut self, input: std::option::Option<bool>) -> Self {
            self.include_content = input;
            self
        }
        /// Consumes the builder and constructs a [`RelatedItemEventIncludedData`](crate::model::RelatedItemEventIncludedData).
        pub fn build(self) -> crate::model::RelatedItemEventIncludedData {
            crate::model::RelatedItemEventIncludedData {
                include_content: self.include_content,
            }
        }
    }
}

/// <p>Details of what case data is published through the case event stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CaseEventIncludedData {
    /// <p>List of field identifiers.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
}
impl CaseEventIncludedData {
    /// <p>List of field identifiers.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldIdentifier]> {
        self.fields.as_deref()
    }
}
impl CaseEventIncludedData {
    /// Creates a new builder-style object to manufacture [`CaseEventIncludedData`](crate::model::CaseEventIncludedData).
    pub fn builder() -> crate::model::case_event_included_data::Builder {
        crate::model::case_event_included_data::Builder::default()
    }
}

/// See [`CaseEventIncludedData`](crate::model::CaseEventIncludedData).
pub mod case_event_included_data {

    /// A builder for [`CaseEventIncludedData`](crate::model::CaseEventIncludedData).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
    }
    impl Builder {
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>List of field identifiers.</p>
        pub fn fields(mut self, input: crate::model::FieldIdentifier) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>List of field identifiers.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldIdentifier>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Consumes the builder and constructs a [`CaseEventIncludedData`](crate::model::CaseEventIncludedData).
        pub fn build(self) -> crate::model::CaseEventIncludedData {
            crate::model::CaseEventIncludedData {
                fields: self.fields,
            }
        }
    }
}

/// <p>Object for the summarized details of the domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DomainSummary {
    /// <p>The unique identifier of the domain.</p>
    #[doc(hidden)]
    pub domain_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the domain.</p>
    #[doc(hidden)]
    pub domain_arn: std::option::Option<std::string::String>,
    /// <p>The name of the domain.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl DomainSummary {
    /// <p>The unique identifier of the domain.</p>
    pub fn domain_id(&self) -> std::option::Option<&str> {
        self.domain_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the domain.</p>
    pub fn domain_arn(&self) -> std::option::Option<&str> {
        self.domain_arn.as_deref()
    }
    /// <p>The name of the domain.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl DomainSummary {
    /// Creates a new builder-style object to manufacture [`DomainSummary`](crate::model::DomainSummary).
    pub fn builder() -> crate::model::domain_summary::Builder {
        crate::model::domain_summary::Builder::default()
    }
}

/// See [`DomainSummary`](crate::model::DomainSummary).
pub mod domain_summary {

    /// A builder for [`DomainSummary`](crate::model::DomainSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_id: std::option::Option<std::string::String>,
        pub(crate) domain_arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier of the domain.</p>
        pub fn domain_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the domain.</p>
        pub fn set_domain_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain.</p>
        pub fn domain_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the domain.</p>
        pub fn set_domain_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_arn = input;
            self
        }
        /// <p>The name of the domain.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the domain.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`DomainSummary`](crate::model::DomainSummary).
        pub fn build(self) -> crate::model::DomainSummary {
            crate::model::DomainSummary {
                domain_id: self.domain_id,
                domain_arn: self.domain_arn,
                name: self.name,
            }
        }
    }
}

/// When writing a match expression against `DomainStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let domainstatus = unimplemented!();
/// match domainstatus {
///     DomainStatus::Active => { /* ... */ },
///     DomainStatus::CreationFailed => { /* ... */ },
///     DomainStatus::CreationInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `domainstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DomainStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DomainStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DomainStatus::NewFeature` is defined.
/// Specifically, when `domainstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DomainStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DomainStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreationInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DomainStatus {
    fn from(s: &str) -> Self {
        match s {
            "Active" => DomainStatus::Active,
            "CreationFailed" => DomainStatus::CreationFailed,
            "CreationInProgress" => DomainStatus::CreationInProgress,
            other => DomainStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DomainStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DomainStatus::from(s))
    }
}
impl DomainStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DomainStatus::Active => "Active",
            DomainStatus::CreationFailed => "CreationFailed",
            DomainStatus::CreationInProgress => "CreationInProgress",
            DomainStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Active", "CreationFailed", "CreationInProgress"]
    }
}
impl AsRef<str> for DomainStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A list of items that represent cases.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchCasesResponseItem {
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
    /// <p>List of case field values.</p>
    #[doc(hidden)]
    pub fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl SearchCasesResponseItem {
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<&str> {
        self.case_id.as_deref()
    }
    /// <p>A unique identifier of a template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
    /// <p>List of case field values.</p>
    pub fn fields(&self) -> std::option::Option<&[crate::model::FieldValue]> {
        self.fields.as_deref()
    }
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    > {
        self.tags.as_ref()
    }
}
impl SearchCasesResponseItem {
    /// Creates a new builder-style object to manufacture [`SearchCasesResponseItem`](crate::model::SearchCasesResponseItem).
    pub fn builder() -> crate::model::search_cases_response_item::Builder {
        crate::model::search_cases_response_item::Builder::default()
    }
}

/// See [`SearchCasesResponseItem`](crate::model::SearchCasesResponseItem).
pub mod search_cases_response_item {

    /// A builder for [`SearchCasesResponseItem`](crate::model::SearchCasesResponseItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
        pub(crate) fields: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::option::Option<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input;
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Appends an item to `fields`.
        ///
        /// To override the contents of this collection use [`set_fields`](Self::set_fields).
        ///
        /// <p>List of case field values.</p>
        pub fn fields(mut self, input: crate::model::FieldValue) -> Self {
            let mut v = self.fields.unwrap_or_default();
            v.push(input);
            self.fields = Some(v);
            self
        }
        /// <p>List of case field values.</p>
        pub fn set_fields(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FieldValue>>,
        ) -> Self {
            self.fields = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: std::option::Option<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchCasesResponseItem`](crate::model::SearchCasesResponseItem).
        pub fn build(self) -> crate::model::SearchCasesResponseItem {
            crate::model::SearchCasesResponseItem {
                case_id: self.case_id,
                template_id: self.template_id,
                fields: self.fields,
                tags: self.tags,
            }
        }
    }
}

/// <p>Object for case field values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FieldValue {
    /// <p>Unique identifier of a field.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Union of potential field value types.</p>
    #[doc(hidden)]
    pub value: std::option::Option<crate::model::FieldValueUnion>,
}
impl FieldValue {
    /// <p>Unique identifier of a field.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Union of potential field value types.</p>
    pub fn value(&self) -> std::option::Option<&crate::model::FieldValueUnion> {
        self.value.as_ref()
    }
}
impl FieldValue {
    /// Creates a new builder-style object to manufacture [`FieldValue`](crate::model::FieldValue).
    pub fn builder() -> crate::model::field_value::Builder {
        crate::model::field_value::Builder::default()
    }
}

/// See [`FieldValue`](crate::model::FieldValue).
pub mod field_value {

    /// A builder for [`FieldValue`](crate::model::FieldValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<crate::model::FieldValueUnion>,
    }
    impl Builder {
        /// <p>Unique identifier of a field.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>Unique identifier of a field.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Union of potential field value types.</p>
        pub fn value(mut self, input: crate::model::FieldValueUnion) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>Union of potential field value types.</p>
        pub fn set_value(
            mut self,
            input: std::option::Option<crate::model::FieldValueUnion>,
        ) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`FieldValue`](crate::model::FieldValue).
        pub fn build(self) -> crate::model::FieldValue {
            crate::model::FieldValue {
                id: self.id,
                value: self.value,
            }
        }
    }
}

/// <p>Object to store union of Field values.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum FieldValueUnion {
    /// <p>Can be either null, or have a Boolean value type. Only one value can be provided.</p>
    BooleanValue(bool),
    /// <p>Can be either null, or have a Double number value type. Only one value can be provided.</p>
    DoubleValue(f64),
    /// <p>String value type.</p>
    StringValue(std::string::String),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl FieldValueUnion {
    /// Tries to convert the enum instance into [`BooleanValue`](crate::model::FieldValueUnion::BooleanValue), extracting the inner [`bool`](bool).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_boolean_value(&self) -> std::result::Result<&bool, &Self> {
        if let FieldValueUnion::BooleanValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`BooleanValue`](crate::model::FieldValueUnion::BooleanValue).
    pub fn is_boolean_value(&self) -> bool {
        self.as_boolean_value().is_ok()
    }
    /// Tries to convert the enum instance into [`DoubleValue`](crate::model::FieldValueUnion::DoubleValue), extracting the inner [`f64`](f64).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_double_value(&self) -> std::result::Result<&f64, &Self> {
        if let FieldValueUnion::DoubleValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`DoubleValue`](crate::model::FieldValueUnion::DoubleValue).
    pub fn is_double_value(&self) -> bool {
        self.as_double_value().is_ok()
    }
    /// Tries to convert the enum instance into [`StringValue`](crate::model::FieldValueUnion::StringValue), extracting the inner [`String`](std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_string_value(&self) -> std::result::Result<&std::string::String, &Self> {
        if let FieldValueUnion::StringValue(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`StringValue`](crate::model::FieldValueUnion::StringValue).
    pub fn is_string_value(&self) -> bool {
        self.as_string_value().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A structured set of sort terms.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Sort {
    /// <p>Unique identifier of a field.</p>
    #[doc(hidden)]
    pub field_id: std::option::Option<std::string::String>,
    /// <p>A structured set of sort terms</p>
    #[doc(hidden)]
    pub sort_order: std::option::Option<crate::model::Order>,
}
impl Sort {
    /// <p>Unique identifier of a field.</p>
    pub fn field_id(&self) -> std::option::Option<&str> {
        self.field_id.as_deref()
    }
    /// <p>A structured set of sort terms</p>
    pub fn sort_order(&self) -> std::option::Option<&crate::model::Order> {
        self.sort_order.as_ref()
    }
}
impl Sort {
    /// Creates a new builder-style object to manufacture [`Sort`](crate::model::Sort).
    pub fn builder() -> crate::model::sort::Builder {
        crate::model::sort::Builder::default()
    }
}

/// See [`Sort`](crate::model::Sort).
pub mod sort {

    /// A builder for [`Sort`](crate::model::Sort).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) field_id: std::option::Option<std::string::String>,
        pub(crate) sort_order: std::option::Option<crate::model::Order>,
    }
    impl Builder {
        /// <p>Unique identifier of a field.</p>
        pub fn field_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.field_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of a field.</p>
        pub fn set_field_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field_id = input;
            self
        }
        /// <p>A structured set of sort terms</p>
        pub fn sort_order(mut self, input: crate::model::Order) -> Self {
            self.sort_order = Some(input);
            self
        }
        /// <p>A structured set of sort terms</p>
        pub fn set_sort_order(mut self, input: std::option::Option<crate::model::Order>) -> Self {
            self.sort_order = input;
            self
        }
        /// Consumes the builder and constructs a [`Sort`](crate::model::Sort).
        pub fn build(self) -> crate::model::Sort {
            crate::model::Sort {
                field_id: self.field_id,
                sort_order: self.sort_order,
            }
        }
    }
}

/// When writing a match expression against `Order`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let order = unimplemented!();
/// match order {
///     Order::Ascending => { /* ... */ },
///     Order::Descending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `order` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Order::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Order::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Order::NewFeature` is defined.
/// Specifically, when `order` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Order::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Order {
    #[allow(missing_docs)] // documentation missing in model
    Ascending,
    #[allow(missing_docs)] // documentation missing in model
    Descending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Order {
    fn from(s: &str) -> Self {
        match s {
            "Asc" => Order::Ascending,
            "Desc" => Order::Descending,
            other => Order::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Order {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Order::from(s))
    }
}
impl Order {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Order::Ascending => "Asc",
            Order::Descending => "Desc",
            Order::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Asc", "Desc"]
    }
}
impl AsRef<str> for Order {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A filter for cases. Only one value can be provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum CaseFilter {
    /// <p>Provides "and all" filtering.</p>
    AndAll(std::vec::Vec<crate::model::CaseFilter>),
    /// <p>A list of fields to filter on.</p>
    Field(crate::model::FieldFilter),
    /// <p>A filter for cases. Only one value can be provided.</p>
    Not(std::boxed::Box<crate::model::CaseFilter>),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl CaseFilter {
    /// Tries to convert the enum instance into [`AndAll`](crate::model::CaseFilter::AndAll), extracting the inner [`Vec`](std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_and_all(
        &self,
    ) -> std::result::Result<&std::vec::Vec<crate::model::CaseFilter>, &Self> {
        if let CaseFilter::AndAll(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`AndAll`](crate::model::CaseFilter::AndAll).
    pub fn is_and_all(&self) -> bool {
        self.as_and_all().is_ok()
    }
    /// Tries to convert the enum instance into [`Field`](crate::model::CaseFilter::Field), extracting the inner [`FieldFilter`](crate::model::FieldFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_field(&self) -> std::result::Result<&crate::model::FieldFilter, &Self> {
        if let CaseFilter::Field(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Field`](crate::model::CaseFilter::Field).
    pub fn is_field(&self) -> bool {
        self.as_field().is_ok()
    }
    /// Tries to convert the enum instance into [`Not`](crate::model::CaseFilter::Not), extracting the inner [`CaseFilter`](crate::model::CaseFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_not(&self) -> std::result::Result<&std::boxed::Box<crate::model::CaseFilter>, &Self> {
        if let CaseFilter::Not(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Not`](crate::model::CaseFilter::Not).
    pub fn is_not(&self) -> bool {
        self.as_not().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A filter for fields. Only one value can be provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum FieldFilter {
    /// <p>Object containing field identifier and value information.</p>
    Contains(crate::model::FieldValue),
    /// <p>Object containing field identifier and value information.</p>
    EqualTo(crate::model::FieldValue),
    /// <p>Object containing field identifier and value information.</p>
    GreaterThan(crate::model::FieldValue),
    /// <p>Object containing field identifier and value information.</p>
    GreaterThanOrEqualTo(crate::model::FieldValue),
    /// <p>Object containing field identifier and value information.</p>
    LessThan(crate::model::FieldValue),
    /// <p>Object containing field identifier and value information. </p>
    LessThanOrEqualTo(crate::model::FieldValue),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl FieldFilter {
    /// Tries to convert the enum instance into [`Contains`](crate::model::FieldFilter::Contains), extracting the inner [`FieldValue`](crate::model::FieldValue).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_contains(&self) -> std::result::Result<&crate::model::FieldValue, &Self> {
        if let FieldFilter::Contains(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Contains`](crate::model::FieldFilter::Contains).
    pub fn is_contains(&self) -> bool {
        self.as_contains().is_ok()
    }
    /// Tries to convert the enum instance into [`EqualTo`](crate::model::FieldFilter::EqualTo), extracting the inner [`FieldValue`](crate::model::FieldValue).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_equal_to(&self) -> std::result::Result<&crate::model::FieldValue, &Self> {
        if let FieldFilter::EqualTo(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`EqualTo`](crate::model::FieldFilter::EqualTo).
    pub fn is_equal_to(&self) -> bool {
        self.as_equal_to().is_ok()
    }
    /// Tries to convert the enum instance into [`GreaterThan`](crate::model::FieldFilter::GreaterThan), extracting the inner [`FieldValue`](crate::model::FieldValue).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_greater_than(&self) -> std::result::Result<&crate::model::FieldValue, &Self> {
        if let FieldFilter::GreaterThan(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`GreaterThan`](crate::model::FieldFilter::GreaterThan).
    pub fn is_greater_than(&self) -> bool {
        self.as_greater_than().is_ok()
    }
    /// Tries to convert the enum instance into [`GreaterThanOrEqualTo`](crate::model::FieldFilter::GreaterThanOrEqualTo), extracting the inner [`FieldValue`](crate::model::FieldValue).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_greater_than_or_equal_to(
        &self,
    ) -> std::result::Result<&crate::model::FieldValue, &Self> {
        if let FieldFilter::GreaterThanOrEqualTo(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`GreaterThanOrEqualTo`](crate::model::FieldFilter::GreaterThanOrEqualTo).
    pub fn is_greater_than_or_equal_to(&self) -> bool {
        self.as_greater_than_or_equal_to().is_ok()
    }
    /// Tries to convert the enum instance into [`LessThan`](crate::model::FieldFilter::LessThan), extracting the inner [`FieldValue`](crate::model::FieldValue).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_less_than(&self) -> std::result::Result<&crate::model::FieldValue, &Self> {
        if let FieldFilter::LessThan(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`LessThan`](crate::model::FieldFilter::LessThan).
    pub fn is_less_than(&self) -> bool {
        self.as_less_than().is_ok()
    }
    /// Tries to convert the enum instance into [`LessThanOrEqualTo`](crate::model::FieldFilter::LessThanOrEqualTo), extracting the inner [`FieldValue`](crate::model::FieldValue).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_less_than_or_equal_to(
        &self,
    ) -> std::result::Result<&crate::model::FieldValue, &Self> {
        if let FieldFilter::LessThanOrEqualTo(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`LessThanOrEqualTo`](crate::model::FieldFilter::LessThanOrEqualTo).
    pub fn is_less_than_or_equal_to(&self) -> bool {
        self.as_less_than_or_equal_to().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Case summary information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CaseSummary {
    /// <p>A unique identifier of the case.</p>
    #[doc(hidden)]
    pub case_id: std::option::Option<std::string::String>,
    /// <p>A unique identifier of a template.</p>
    #[doc(hidden)]
    pub template_id: std::option::Option<std::string::String>,
}
impl CaseSummary {
    /// <p>A unique identifier of the case.</p>
    pub fn case_id(&self) -> std::option::Option<&str> {
        self.case_id.as_deref()
    }
    /// <p>A unique identifier of a template.</p>
    pub fn template_id(&self) -> std::option::Option<&str> {
        self.template_id.as_deref()
    }
}
impl CaseSummary {
    /// Creates a new builder-style object to manufacture [`CaseSummary`](crate::model::CaseSummary).
    pub fn builder() -> crate::model::case_summary::Builder {
        crate::model::case_summary::Builder::default()
    }
}

/// See [`CaseSummary`](crate::model::CaseSummary).
pub mod case_summary {

    /// A builder for [`CaseSummary`](crate::model::CaseSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) case_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier of the case.</p>
        pub fn case_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.case_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of the case.</p>
        pub fn set_case_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.case_id = input;
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>A unique identifier of a template.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CaseSummary`](crate::model::CaseSummary).
        pub fn build(self) -> crate::model::CaseSummary {
            crate::model::CaseSummary {
                case_id: self.case_id,
                template_id: self.template_id,
            }
        }
    }
}

/// <p>A list of items that represent RelatedItems.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SearchRelatedItemsResponseItem {
    /// <p>Unique identifier of a related item.</p>
    #[doc(hidden)]
    pub related_item_id: std::option::Option<std::string::String>,
    /// <p>Type of a related item.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::RelatedItemType>,
    /// <p>Time at which a related item was associated with a case.</p>
    #[doc(hidden)]
    pub association_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Represents the content of a particular type of related item.</p>
    #[doc(hidden)]
    pub content: std::option::Option<crate::model::RelatedItemContent>,
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<
        std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    >,
}
impl SearchRelatedItemsResponseItem {
    /// <p>Unique identifier of a related item.</p>
    pub fn related_item_id(&self) -> std::option::Option<&str> {
        self.related_item_id.as_deref()
    }
    /// <p>Type of a related item.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::RelatedItemType> {
        self.r#type.as_ref()
    }
    /// <p>Time at which a related item was associated with a case.</p>
    pub fn association_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.association_time.as_ref()
    }
    /// <p>Represents the content of a particular type of related item.</p>
    pub fn content(&self) -> std::option::Option<&crate::model::RelatedItemContent> {
        self.content.as_ref()
    }
    /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, std::option::Option<std::string::String>>,
    > {
        self.tags.as_ref()
    }
}
impl SearchRelatedItemsResponseItem {
    /// Creates a new builder-style object to manufacture [`SearchRelatedItemsResponseItem`](crate::model::SearchRelatedItemsResponseItem).
    pub fn builder() -> crate::model::search_related_items_response_item::Builder {
        crate::model::search_related_items_response_item::Builder::default()
    }
}

/// See [`SearchRelatedItemsResponseItem`](crate::model::SearchRelatedItemsResponseItem).
pub mod search_related_items_response_item {

    /// A builder for [`SearchRelatedItemsResponseItem`](crate::model::SearchRelatedItemsResponseItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) related_item_id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::RelatedItemType>,
        pub(crate) association_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) content: std::option::Option<crate::model::RelatedItemContent>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::option::Option<std::string::String>,
            >,
        >,
    }
    impl Builder {
        /// <p>Unique identifier of a related item.</p>
        pub fn related_item_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.related_item_id = Some(input.into());
            self
        }
        /// <p>Unique identifier of a related item.</p>
        pub fn set_related_item_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.related_item_id = input;
            self
        }
        /// <p>Type of a related item.</p>
        pub fn r#type(mut self, input: crate::model::RelatedItemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Type of a related item.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::RelatedItemType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Time at which a related item was associated with a case.</p>
        pub fn association_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.association_time = Some(input);
            self
        }
        /// <p>Time at which a related item was associated with a case.</p>
        pub fn set_association_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.association_time = input;
            self
        }
        /// <p>Represents the content of a particular type of related item.</p>
        pub fn content(mut self, input: crate::model::RelatedItemContent) -> Self {
            self.content = Some(input);
            self
        }
        /// <p>Represents the content of a particular type of related item.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<crate::model::RelatedItemContent>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: std::option::Option<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map of of key-value pairs that represent tags on a resource. Tags are used to organize, track, or control access for this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::option::Option<std::string::String>,
                >,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`SearchRelatedItemsResponseItem`](crate::model::SearchRelatedItemsResponseItem).
        pub fn build(self) -> crate::model::SearchRelatedItemsResponseItem {
            crate::model::SearchRelatedItemsResponseItem {
                related_item_id: self.related_item_id,
                r#type: self.r#type,
                association_time: self.association_time,
                content: self.content,
                tags: self.tags,
            }
        }
    }
}

/// <p>Represents the content of a particular type of related item.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum RelatedItemContent {
    /// <p>Represents the content of a comment to be returned to agents.</p>
    Comment(crate::model::CommentContent),
    /// <p>Represents the content of a contact to be returned to agents.</p>
    Contact(crate::model::ContactContent),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl RelatedItemContent {
    /// Tries to convert the enum instance into [`Comment`](crate::model::RelatedItemContent::Comment), extracting the inner [`CommentContent`](crate::model::CommentContent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_comment(&self) -> std::result::Result<&crate::model::CommentContent, &Self> {
        if let RelatedItemContent::Comment(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Comment`](crate::model::RelatedItemContent::Comment).
    pub fn is_comment(&self) -> bool {
        self.as_comment().is_ok()
    }
    /// Tries to convert the enum instance into [`Contact`](crate::model::RelatedItemContent::Contact), extracting the inner [`ContactContent`](crate::model::ContactContent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_contact(&self) -> std::result::Result<&crate::model::ContactContent, &Self> {
        if let RelatedItemContent::Contact(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Contact`](crate::model::RelatedItemContent::Contact).
    pub fn is_contact(&self) -> bool {
        self.as_contact().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>Represents the content of a <code>Comment</code> to be returned to agents.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentContent {
    /// <p>Text in the body of a <code>Comment</code> on a case.</p>
    #[doc(hidden)]
    pub body: std::option::Option<std::string::String>,
    /// <p>Type of the text in the box of a <code>Comment</code> on a case.</p>
    #[doc(hidden)]
    pub content_type: std::option::Option<crate::model::CommentBodyTextType>,
}
impl CommentContent {
    /// <p>Text in the body of a <code>Comment</code> on a case.</p>
    pub fn body(&self) -> std::option::Option<&str> {
        self.body.as_deref()
    }
    /// <p>Type of the text in the box of a <code>Comment</code> on a case.</p>
    pub fn content_type(&self) -> std::option::Option<&crate::model::CommentBodyTextType> {
        self.content_type.as_ref()
    }
}
impl CommentContent {
    /// Creates a new builder-style object to manufacture [`CommentContent`](crate::model::CommentContent).
    pub fn builder() -> crate::model::comment_content::Builder {
        crate::model::comment_content::Builder::default()
    }
}

/// See [`CommentContent`](crate::model::CommentContent).
pub mod comment_content {

    /// A builder for [`CommentContent`](crate::model::CommentContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) content_type: std::option::Option<crate::model::CommentBodyTextType>,
    }
    impl Builder {
        /// <p>Text in the body of a <code>Comment</code> on a case.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>Text in the body of a <code>Comment</code> on a case.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>Type of the text in the box of a <code>Comment</code> on a case.</p>
        pub fn content_type(mut self, input: crate::model::CommentBodyTextType) -> Self {
            self.content_type = Some(input);
            self
        }
        /// <p>Type of the text in the box of a <code>Comment</code> on a case.</p>
        pub fn set_content_type(
            mut self,
            input: std::option::Option<crate::model::CommentBodyTextType>,
        ) -> Self {
            self.content_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentContent`](crate::model::CommentContent).
        pub fn build(self) -> crate::model::CommentContent {
            crate::model::CommentContent {
                body: self.body,
                content_type: self.content_type,
            }
        }
    }
}

/// When writing a match expression against `CommentBodyTextType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let commentbodytexttype = unimplemented!();
/// match commentbodytexttype {
///     CommentBodyTextType::Plaintext => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `commentbodytexttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CommentBodyTextType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CommentBodyTextType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CommentBodyTextType::NewFeature` is defined.
/// Specifically, when `commentbodytexttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CommentBodyTextType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CommentBodyTextType {
    #[allow(missing_docs)] // documentation missing in model
    Plaintext,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CommentBodyTextType {
    fn from(s: &str) -> Self {
        match s {
            "Text/Plain" => CommentBodyTextType::Plaintext,
            other => {
                CommentBodyTextType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for CommentBodyTextType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CommentBodyTextType::from(s))
    }
}
impl CommentBodyTextType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CommentBodyTextType::Plaintext => "Text/Plain",
            CommentBodyTextType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Text/Plain"]
    }
}
impl AsRef<str> for CommentBodyTextType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object that represents a content of an Amazon Connect contact object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactContent {
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    #[doc(hidden)]
    pub contact_arn: std::option::Option<std::string::String>,
    /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<std::string::String>,
    /// <p>The difference between the <code>InitiationTimestamp</code> and the <code>DisconnectTimestamp</code> of the contact.</p>
    #[doc(hidden)]
    pub connected_to_system_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl ContactContent {
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    pub fn contact_arn(&self) -> std::option::Option<&str> {
        self.contact_arn.as_deref()
    }
    /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
    pub fn channel(&self) -> std::option::Option<&str> {
        self.channel.as_deref()
    }
    /// <p>The difference between the <code>InitiationTimestamp</code> and the <code>DisconnectTimestamp</code> of the contact.</p>
    pub fn connected_to_system_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.connected_to_system_time.as_ref()
    }
}
impl ContactContent {
    /// Creates a new builder-style object to manufacture [`ContactContent`](crate::model::ContactContent).
    pub fn builder() -> crate::model::contact_content::Builder {
        crate::model::contact_content::Builder::default()
    }
}

/// See [`ContactContent`](crate::model::ContactContent).
pub mod contact_content {

    /// A builder for [`ContactContent`](crate::model::ContactContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_arn: std::option::Option<std::string::String>,
        pub(crate) channel: std::option::Option<std::string::String>,
        pub(crate) connected_to_system_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn contact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_arn = Some(input.into());
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn set_contact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_arn = input;
            self
        }
        /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
        pub fn channel(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel = Some(input.into());
            self
        }
        /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
        pub fn set_channel(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel = input;
            self
        }
        /// <p>The difference between the <code>InitiationTimestamp</code> and the <code>DisconnectTimestamp</code> of the contact.</p>
        pub fn connected_to_system_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.connected_to_system_time = Some(input);
            self
        }
        /// <p>The difference between the <code>InitiationTimestamp</code> and the <code>DisconnectTimestamp</code> of the contact.</p>
        pub fn set_connected_to_system_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.connected_to_system_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactContent`](crate::model::ContactContent).
        pub fn build(self) -> crate::model::ContactContent {
            crate::model::ContactContent {
                contact_arn: self.contact_arn,
                channel: self.channel,
                connected_to_system_time: self.connected_to_system_time,
            }
        }
    }
}

/// When writing a match expression against `RelatedItemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let relateditemtype = unimplemented!();
/// match relateditemtype {
///     RelatedItemType::Comment => { /* ... */ },
///     RelatedItemType::Contact => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `relateditemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RelatedItemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RelatedItemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RelatedItemType::NewFeature` is defined.
/// Specifically, when `relateditemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RelatedItemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RelatedItemType {
    #[allow(missing_docs)] // documentation missing in model
    Comment,
    #[allow(missing_docs)] // documentation missing in model
    Contact,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RelatedItemType {
    fn from(s: &str) -> Self {
        match s {
            "Comment" => RelatedItemType::Comment,
            "Contact" => RelatedItemType::Contact,
            other => RelatedItemType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RelatedItemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RelatedItemType::from(s))
    }
}
impl RelatedItemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RelatedItemType::Comment => "Comment",
            RelatedItemType::Contact => "Contact",
            RelatedItemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Comment", "Contact"]
    }
}
impl AsRef<str> for RelatedItemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The list of types of related items and their parameters to use for filtering.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum RelatedItemTypeFilter {
    /// <p>A filter for related items of type <code>Comment</code>.</p>
    Comment(crate::model::CommentFilter),
    /// <p>A filter for related items of type <code>Contact</code>.</p>
    Contact(crate::model::ContactFilter),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl RelatedItemTypeFilter {
    /// Tries to convert the enum instance into [`Comment`](crate::model::RelatedItemTypeFilter::Comment), extracting the inner [`CommentFilter`](crate::model::CommentFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_comment(&self) -> std::result::Result<&crate::model::CommentFilter, &Self> {
        if let RelatedItemTypeFilter::Comment(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Comment`](crate::model::RelatedItemTypeFilter::Comment).
    pub fn is_comment(&self) -> bool {
        self.as_comment().is_ok()
    }
    /// Tries to convert the enum instance into [`Contact`](crate::model::RelatedItemTypeFilter::Contact), extracting the inner [`ContactFilter`](crate::model::ContactFilter).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_contact(&self) -> std::result::Result<&crate::model::ContactFilter, &Self> {
        if let RelatedItemTypeFilter::Contact(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Contact`](crate::model::RelatedItemTypeFilter::Contact).
    pub fn is_contact(&self) -> bool {
        self.as_contact().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>A filter for related items of type <code>Comment</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentFilter {}
impl CommentFilter {
    /// Creates a new builder-style object to manufacture [`CommentFilter`](crate::model::CommentFilter).
    pub fn builder() -> crate::model::comment_filter::Builder {
        crate::model::comment_filter::Builder::default()
    }
}

/// See [`CommentFilter`](crate::model::CommentFilter).
pub mod comment_filter {

    /// A builder for [`CommentFilter`](crate::model::CommentFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`CommentFilter`](crate::model::CommentFilter).
        pub fn build(self) -> crate::model::CommentFilter {
            crate::model::CommentFilter {}
        }
    }
}

/// <p>A filter for related items of type <code>Contact</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ContactFilter {
    /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
    #[doc(hidden)]
    pub channel: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    #[doc(hidden)]
    pub contact_arn: std::option::Option<std::string::String>,
}
impl ContactFilter {
    /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
    pub fn channel(&self) -> std::option::Option<&[std::string::String]> {
        self.channel.as_deref()
    }
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    pub fn contact_arn(&self) -> std::option::Option<&str> {
        self.contact_arn.as_deref()
    }
}
impl ContactFilter {
    /// Creates a new builder-style object to manufacture [`ContactFilter`](crate::model::ContactFilter).
    pub fn builder() -> crate::model::contact_filter::Builder {
        crate::model::contact_filter::Builder::default()
    }
}

/// See [`ContactFilter`](crate::model::ContactFilter).
pub mod contact_filter {

    /// A builder for [`ContactFilter`](crate::model::ContactFilter).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) contact_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `channel`.
        ///
        /// To override the contents of this collection use [`set_channel`](Self::set_channel).
        ///
        /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
        pub fn channel(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.channel.unwrap_or_default();
            v.push(input.into());
            self.channel = Some(v);
            self
        }
        /// <p>A list of channels to filter on for related items of type <code>Contact</code>.</p>
        pub fn set_channel(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.channel = input;
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn contact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_arn = Some(input.into());
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn set_contact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactFilter`](crate::model::ContactFilter).
        pub fn build(self) -> crate::model::ContactFilter {
            crate::model::ContactFilter {
                channel: self.channel,
                contact_arn: self.contact_arn,
            }
        }
    }
}

/// <p>Represents the content of a related item to be created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum RelatedItemInputContent {
    /// <p>Represents the content of a comment to be returned to agents.</p>
    Comment(crate::model::CommentContent),
    /// <p>Object representing a contact in Amazon Connect as an API request field.</p>
    Contact(crate::model::Contact),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl RelatedItemInputContent {
    /// Tries to convert the enum instance into [`Comment`](crate::model::RelatedItemInputContent::Comment), extracting the inner [`CommentContent`](crate::model::CommentContent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_comment(&self) -> std::result::Result<&crate::model::CommentContent, &Self> {
        if let RelatedItemInputContent::Comment(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Comment`](crate::model::RelatedItemInputContent::Comment).
    pub fn is_comment(&self) -> bool {
        self.as_comment().is_ok()
    }
    /// Tries to convert the enum instance into [`Contact`](crate::model::RelatedItemInputContent::Contact), extracting the inner [`Contact`](crate::model::Contact).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_contact(&self) -> std::result::Result<&crate::model::Contact, &Self> {
        if let RelatedItemInputContent::Contact(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Contact`](crate::model::RelatedItemInputContent::Contact).
    pub fn is_contact(&self) -> bool {
        self.as_contact().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>An object that represents an Amazon Connect contact object. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Contact {
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    #[doc(hidden)]
    pub contact_arn: std::option::Option<std::string::String>,
}
impl Contact {
    /// <p>A unique identifier of a contact in Amazon Connect.</p>
    pub fn contact_arn(&self) -> std::option::Option<&str> {
        self.contact_arn.as_deref()
    }
}
impl Contact {
    /// Creates a new builder-style object to manufacture [`Contact`](crate::model::Contact).
    pub fn builder() -> crate::model::contact::Builder {
        crate::model::contact::Builder::default()
    }
}

/// See [`Contact`](crate::model::Contact).
pub mod contact {

    /// A builder for [`Contact`](crate::model::Contact).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) contact_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn contact_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.contact_arn = Some(input.into());
            self
        }
        /// <p>A unique identifier of a contact in Amazon Connect.</p>
        pub fn set_contact_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.contact_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Contact`](crate::model::Contact).
        pub fn build(self) -> crate::model::Contact {
            crate::model::Contact {
                contact_arn: self.contact_arn,
            }
        }
    }
}
