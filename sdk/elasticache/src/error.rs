// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AddTagsToResourceError {
    pub kind: AddTagsToResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToResourceErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    InvalidArnFault(crate::error::InvalidArnFault),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    ReservedCacheNodeNotFoundFault(crate::error::ReservedCacheNodeNotFoundFault),
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AddTagsToResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AddTagsToResourceErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::CacheParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::CacheSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::InvalidArnFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::InvalidReplicationGroupStateFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::ReservedCacheNodeNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            AddTagsToResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AddTagsToResourceError {
    fn code(&self) -> Option<&str> {
        AddTagsToResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToResourceError {
    pub fn new(kind: AddTagsToResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AddTagsToResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_arn_fault(&self) -> bool {
        matches!(&self.kind, AddTagsToResourceErrorKind::InvalidArnFault(_))
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_reserved_cache_node_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::ReservedCacheNodeNotFoundFault(_)
        )
    }
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::SnapshotNotFoundFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AddTagsToResourceErrorKind::UserGroupNotFoundFault(_)
        )
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(&self.kind, AddTagsToResourceErrorKind::UserNotFoundFault(_))
    }
}
impl std::error::Error for AddTagsToResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AddTagsToResourceErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::CacheParameterGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::CacheSecurityGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::InvalidArnFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::ReservedCacheNodeNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::SnapshotNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            AddTagsToResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AuthorizeCacheSecurityGroupIngressError {
    pub kind: AuthorizeCacheSecurityGroupIngressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AuthorizeCacheSecurityGroupIngressErrorKind {
    AuthorizationAlreadyExistsFault(crate::error::AuthorizationAlreadyExistsFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    InvalidCacheSecurityGroupStateFault(crate::error::InvalidCacheSecurityGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AuthorizeCacheSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AuthorizeCacheSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(
                _inner,
            ) => _inner.fmt(f),
            AuthorizeCacheSecurityGroupIngressErrorKind::CacheSecurityGroupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidCacheSecurityGroupStateFault(
                _inner,
            ) => _inner.fmt(f),
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => _inner.fmt(f),
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            AuthorizeCacheSecurityGroupIngressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AuthorizeCacheSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        AuthorizeCacheSecurityGroupIngressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AuthorizeCacheSecurityGroupIngressError {
    pub fn new(
        kind: AuthorizeCacheSecurityGroupIngressErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AuthorizeCacheSecurityGroupIngressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AuthorizeCacheSecurityGroupIngressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeCacheSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeCacheSecurityGroupIngressErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidCacheSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for AuthorizeCacheSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AuthorizeCacheSecurityGroupIngressErrorKind::AuthorizationAlreadyExistsFault(
                _inner,
            ) => Some(_inner),
            AuthorizeCacheSecurityGroupIngressErrorKind::CacheSecurityGroupNotFoundFault(
                _inner,
            ) => Some(_inner),
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidCacheSecurityGroupStateFault(
                _inner,
            ) => Some(_inner),
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => Some(_inner),
            AuthorizeCacheSecurityGroupIngressErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            AuthorizeCacheSecurityGroupIngressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchApplyUpdateActionError {
    pub kind: BatchApplyUpdateActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchApplyUpdateActionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUpdateNotFoundFault(crate::error::ServiceUpdateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchApplyUpdateActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchApplyUpdateActionErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            BatchApplyUpdateActionErrorKind::ServiceUpdateNotFoundFault(_inner) => _inner.fmt(f),
            BatchApplyUpdateActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchApplyUpdateActionError {
    fn code(&self) -> Option<&str> {
        BatchApplyUpdateActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchApplyUpdateActionError {
    pub fn new(kind: BatchApplyUpdateActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchApplyUpdateActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchApplyUpdateActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchApplyUpdateActionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_update_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            BatchApplyUpdateActionErrorKind::ServiceUpdateNotFoundFault(_)
        )
    }
}
impl std::error::Error for BatchApplyUpdateActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchApplyUpdateActionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            BatchApplyUpdateActionErrorKind::ServiceUpdateNotFoundFault(_inner) => Some(_inner),
            BatchApplyUpdateActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchStopUpdateActionError {
    pub kind: BatchStopUpdateActionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchStopUpdateActionErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUpdateNotFoundFault(crate::error::ServiceUpdateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchStopUpdateActionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchStopUpdateActionErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            BatchStopUpdateActionErrorKind::ServiceUpdateNotFoundFault(_inner) => _inner.fmt(f),
            BatchStopUpdateActionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchStopUpdateActionError {
    fn code(&self) -> Option<&str> {
        BatchStopUpdateActionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchStopUpdateActionError {
    pub fn new(kind: BatchStopUpdateActionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchStopUpdateActionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchStopUpdateActionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchStopUpdateActionErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_update_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            BatchStopUpdateActionErrorKind::ServiceUpdateNotFoundFault(_)
        )
    }
}
impl std::error::Error for BatchStopUpdateActionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchStopUpdateActionErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            BatchStopUpdateActionErrorKind::ServiceUpdateNotFoundFault(_inner) => Some(_inner),
            BatchStopUpdateActionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CompleteMigrationError {
    pub kind: CompleteMigrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CompleteMigrationErrorKind {
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    ReplicationGroupNotUnderMigrationFault(crate::error::ReplicationGroupNotUnderMigrationFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CompleteMigrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CompleteMigrationErrorKind::InvalidReplicationGroupStateFault(_inner) => _inner.fmt(f),
            CompleteMigrationErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            CompleteMigrationErrorKind::ReplicationGroupNotUnderMigrationFault(_inner) => {
                _inner.fmt(f)
            }
            CompleteMigrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CompleteMigrationError {
    fn code(&self) -> Option<&str> {
        CompleteMigrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CompleteMigrationError {
    pub fn new(kind: CompleteMigrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CompleteMigrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CompleteMigrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CompleteMigrationErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CompleteMigrationErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_replication_group_not_under_migration_fault(&self) -> bool {
        matches!(
            &self.kind,
            CompleteMigrationErrorKind::ReplicationGroupNotUnderMigrationFault(_)
        )
    }
}
impl std::error::Error for CompleteMigrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CompleteMigrationErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            CompleteMigrationErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            CompleteMigrationErrorKind::ReplicationGroupNotUnderMigrationFault(_inner) => {
                Some(_inner)
            }
            CompleteMigrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CopySnapshotError {
    pub kind: CopySnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CopySnapshotErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidSnapshotStateFault(crate::error::InvalidSnapshotStateFault),
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CopySnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CopySnapshotErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::InvalidSnapshotStateFault(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CopySnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CopySnapshotError {
    fn code(&self) -> Option<&str> {
        CopySnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CopySnapshotError {
    pub fn new(kind: CopySnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CopySnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CopySnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::InvalidSnapshotStateFault(_)
        )
    }
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::SnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(&self.kind, CopySnapshotErrorKind::SnapshotNotFoundFault(_))
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CopySnapshotErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for CopySnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CopySnapshotErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            CopySnapshotErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CopySnapshotErrorKind::InvalidSnapshotStateFault(_inner) => Some(_inner),
            CopySnapshotErrorKind::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            CopySnapshotErrorKind::SnapshotNotFoundFault(_inner) => Some(_inner),
            CopySnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CopySnapshotErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CopySnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCacheClusterError {
    pub kind: CreateCacheClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCacheClusterErrorKind {
    CacheClusterAlreadyExistsFault(crate::error::CacheClusterAlreadyExistsFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    ClusterQuotaForCustomerExceededFault(crate::error::ClusterQuotaForCustomerExceededFault),
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeQuotaForClusterExceededFault(crate::error::NodeQuotaForClusterExceededFault),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCacheClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCacheClusterErrorKind::CacheClusterAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::CacheParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::CacheSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheClusterErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheClusterErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheClusterErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::InvalidReplicationGroupStateFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::NodeQuotaForClusterExceededFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::NodeQuotaForCustomerExceededFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateCacheClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCacheClusterError {
    fn code(&self) -> Option<&str> {
        CreateCacheClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCacheClusterError {
    pub fn new(kind: CreateCacheClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCacheClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCacheClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::CacheClusterAlreadyExistsFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_cluster_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::ClusterQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::InsufficientCacheClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_quota_for_cluster_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::NodeQuotaForClusterExceededFault(_)
        )
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheClusterErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for CreateCacheClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCacheClusterErrorKind::CacheClusterAlreadyExistsFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::CacheParameterGroupNotFoundFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::CacheSecurityGroupNotFoundFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            CreateCacheClusterErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            CreateCacheClusterErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            CreateCacheClusterErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::NodeQuotaForClusterExceededFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::NodeQuotaForCustomerExceededFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateCacheClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCacheParameterGroupError {
    pub kind: CreateCacheParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCacheParameterGroupErrorKind {
    CacheParameterGroupAlreadyExistsFault(crate::error::CacheParameterGroupAlreadyExistsFault),
    CacheParameterGroupQuotaExceededFault(crate::error::CacheParameterGroupQuotaExceededFault),
    InvalidCacheParameterGroupStateFault(crate::error::InvalidCacheParameterGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCacheParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCacheParameterGroupErrorKind::CacheParameterGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheParameterGroupErrorKind::CacheParameterGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheParameterGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCacheParameterGroupError {
    fn code(&self) -> Option<&str> {
        CreateCacheParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCacheParameterGroupError {
    pub fn new(kind: CreateCacheParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCacheParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCacheParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_parameter_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheParameterGroupErrorKind::CacheParameterGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_cache_parameter_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheParameterGroupErrorKind::CacheParameterGroupQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_cache_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheParameterGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheParameterGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheParameterGroupErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for CreateCacheParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCacheParameterGroupErrorKind::CacheParameterGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateCacheParameterGroupErrorKind::CacheParameterGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            CreateCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            CreateCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateCacheParameterGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateCacheParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCacheSecurityGroupError {
    pub kind: CreateCacheSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCacheSecurityGroupErrorKind {
    CacheSecurityGroupAlreadyExistsFault(crate::error::CacheSecurityGroupAlreadyExistsFault),
    CacheSecurityGroupQuotaExceededFault(crate::error::CacheSecurityGroupQuotaExceededFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCacheSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCacheSecurityGroupErrorKind::CacheSecurityGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheSecurityGroupErrorKind::CacheSecurityGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheSecurityGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheSecurityGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheSecurityGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateCacheSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCacheSecurityGroupError {
    fn code(&self) -> Option<&str> {
        CreateCacheSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCacheSecurityGroupError {
    pub fn new(kind: CreateCacheSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCacheSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCacheSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_security_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSecurityGroupErrorKind::CacheSecurityGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_cache_security_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSecurityGroupErrorKind::CacheSecurityGroupQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSecurityGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSecurityGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSecurityGroupErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for CreateCacheSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCacheSecurityGroupErrorKind::CacheSecurityGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateCacheSecurityGroupErrorKind::CacheSecurityGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateCacheSecurityGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            CreateCacheSecurityGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateCacheSecurityGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateCacheSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCacheSubnetGroupError {
    pub kind: CreateCacheSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCacheSubnetGroupErrorKind {
    CacheSubnetGroupAlreadyExistsFault(crate::error::CacheSubnetGroupAlreadyExistsFault),
    CacheSubnetGroupQuotaExceededFault(crate::error::CacheSubnetGroupQuotaExceededFault),
    CacheSubnetQuotaExceededFault(crate::error::CacheSubnetQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    SubnetNotAllowedFault(crate::error::SubnetNotAllowedFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCacheSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCacheSubnetGroupErrorKind::CacheSubnetGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheSubnetGroupErrorKind::CacheSubnetGroupQuotaExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateCacheSubnetGroupErrorKind::CacheSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateCacheSubnetGroupErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            CreateCacheSubnetGroupErrorKind::SubnetNotAllowedFault(_inner) => _inner.fmt(f),
            CreateCacheSubnetGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateCacheSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCacheSubnetGroupError {
    fn code(&self) -> Option<&str> {
        CreateCacheSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCacheSubnetGroupError {
    pub fn new(kind: CreateCacheSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCacheSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCacheSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_subnet_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSubnetGroupErrorKind::CacheSubnetGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_cache_subnet_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSubnetGroupErrorKind::CacheSubnetGroupQuotaExceededFault(_)
        )
    }
    pub fn is_cache_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSubnetGroupErrorKind::CacheSubnetQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSubnetGroupErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_subnet_not_allowed_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSubnetGroupErrorKind::SubnetNotAllowedFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateCacheSubnetGroupErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for CreateCacheSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCacheSubnetGroupErrorKind::CacheSubnetGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateCacheSubnetGroupErrorKind::CacheSubnetGroupQuotaExceededFault(_inner) => {
                Some(_inner)
            }
            CreateCacheSubnetGroupErrorKind::CacheSubnetQuotaExceededFault(_inner) => Some(_inner),
            CreateCacheSubnetGroupErrorKind::InvalidSubnet(_inner) => Some(_inner),
            CreateCacheSubnetGroupErrorKind::SubnetNotAllowedFault(_inner) => Some(_inner),
            CreateCacheSubnetGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateCacheSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateGlobalReplicationGroupError {
    pub kind: CreateGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupAlreadyExistsFault(
        crate::error::GlobalReplicationGroupAlreadyExistsFault,
    ),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateGlobalReplicationGroupErrorKind::GlobalReplicationGroupAlreadyExistsFault(
                _inner,
            ) => _inner.fmt(f),
            CreateGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateGlobalReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateGlobalReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateGlobalReplicationGroupErrorKind::ServiceLinkedRoleNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateGlobalReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        CreateGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateGlobalReplicationGroupError {
    pub fn new(kind: CreateGlobalReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalReplicationGroupErrorKind::GlobalReplicationGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateGlobalReplicationGroupErrorKind::ServiceLinkedRoleNotFoundFault(_)
        )
    }
}
impl std::error::Error for CreateGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateGlobalReplicationGroupErrorKind::GlobalReplicationGroupAlreadyExistsFault(
                _inner,
            ) => Some(_inner),
            CreateGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            CreateGlobalReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            CreateGlobalReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateGlobalReplicationGroupErrorKind::ServiceLinkedRoleNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateGlobalReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateReplicationGroupError {
    pub kind: CreateReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateReplicationGroupErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    ClusterQuotaForCustomerExceededFault(crate::error::ClusterQuotaForCustomerExceededFault),
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidUserGroupStateFault(crate::error::InvalidUserGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeGroupsPerReplicationGroupQuotaExceededFault(
        crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault,
    ),
    NodeQuotaForClusterExceededFault(crate::error::NodeQuotaForClusterExceededFault),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    ReplicationGroupAlreadyExistsFault(crate::error::ReplicationGroupAlreadyExistsFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateReplicationGroupErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::InvalidUserGroupStateFault(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(
                _inner,
            ) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::NodeQuotaForClusterExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::ReplicationGroupAlreadyExistsFault(_inner) => {
                _inner.fmt(f)
            }
            CreateReplicationGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateReplicationGroupError {
    fn code(&self) -> Option<&str> {
        CreateReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateReplicationGroupError {
    pub fn new(kind: CreateReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_cluster_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::ClusterQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InsufficientCacheClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_user_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InvalidUserGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_groups_per_replication_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(_)
        )
    }
    pub fn is_node_quota_for_cluster_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::NodeQuotaForClusterExceededFault(_)
        )
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_replication_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::ReplicationGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateReplicationGroupErrorKind::UserGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for CreateReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateReplicationGroupErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::InvalidUserGroupStateFault(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(
                _inner,
            ) => Some(_inner),
            CreateReplicationGroupErrorKind::NodeQuotaForClusterExceededFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::ReplicationGroupAlreadyExistsFault(_inner) => {
                Some(_inner)
            }
            CreateReplicationGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            CreateReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSnapshotError {
    pub kind: CreateSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSnapshotErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    SnapshotFeatureNotSupportedFault(crate::error::SnapshotFeatureNotSupportedFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSnapshotErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::InvalidReplicationGroupStateFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::SnapshotFeatureNotSupportedFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSnapshotError {
    fn code(&self) -> Option<&str> {
        CreateSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSnapshotError {
    pub fn new(kind: CreateSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::SnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_snapshot_feature_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::SnapshotFeatureNotSupportedFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateSnapshotErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for CreateSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSnapshotErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            CreateSnapshotErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateSnapshotErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::SnapshotFeatureNotSupportedFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            CreateSnapshotErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserError {
    pub kind: CreateUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserErrorKind {
    DuplicateUserNameFault(crate::error::DuplicateUserNameFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    UserAlreadyExistsFault(crate::error::UserAlreadyExistsFault),
    UserQuotaExceededFault(crate::error::UserQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserErrorKind::DuplicateUserNameFault(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateUserErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateUserErrorKind::UserAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateUserErrorKind::UserQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserError {
    fn code(&self) -> Option<&str> {
        CreateUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserError {
    pub fn new(kind: CreateUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_duplicate_user_name_fault(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::DuplicateUserNameFault(_))
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
    pub fn is_user_already_exists_fault(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::UserAlreadyExistsFault(_))
    }
    pub fn is_user_quota_exceeded_fault(&self) -> bool {
        matches!(&self.kind, CreateUserErrorKind::UserQuotaExceededFault(_))
    }
}
impl std::error::Error for CreateUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserErrorKind::DuplicateUserNameFault(_inner) => Some(_inner),
            CreateUserErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            CreateUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateUserErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateUserErrorKind::UserAlreadyExistsFault(_inner) => Some(_inner),
            CreateUserErrorKind::UserQuotaExceededFault(_inner) => Some(_inner),
            CreateUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserGroupError {
    pub kind: CreateUserGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserGroupErrorKind {
    DefaultUserRequired(crate::error::DefaultUserRequired),
    DuplicateUserNameFault(crate::error::DuplicateUserNameFault),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    UserGroupAlreadyExistsFault(crate::error::UserGroupAlreadyExistsFault),
    UserGroupQuotaExceededFault(crate::error::UserGroupQuotaExceededFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserGroupErrorKind::DefaultUserRequired(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::DuplicateUserNameFault(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::UserGroupAlreadyExistsFault(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::UserGroupQuotaExceededFault(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            CreateUserGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserGroupError {
    fn code(&self) -> Option<&str> {
        CreateUserGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserGroupError {
    pub fn new(kind: CreateUserGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_default_user_required(&self) -> bool {
        matches!(&self.kind, CreateUserGroupErrorKind::DefaultUserRequired(_))
    }
    pub fn is_duplicate_user_name_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserGroupErrorKind::DuplicateUserNameFault(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserGroupErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
    pub fn is_user_group_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserGroupErrorKind::UserGroupAlreadyExistsFault(_)
        )
    }
    pub fn is_user_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserGroupErrorKind::UserGroupQuotaExceededFault(_)
        )
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(&self.kind, CreateUserGroupErrorKind::UserNotFoundFault(_))
    }
}
impl std::error::Error for CreateUserGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserGroupErrorKind::DefaultUserRequired(_inner) => Some(_inner),
            CreateUserGroupErrorKind::DuplicateUserNameFault(_inner) => Some(_inner),
            CreateUserGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            CreateUserGroupErrorKind::TagQuotaPerResourceExceeded(_inner) => Some(_inner),
            CreateUserGroupErrorKind::UserGroupAlreadyExistsFault(_inner) => Some(_inner),
            CreateUserGroupErrorKind::UserGroupQuotaExceededFault(_inner) => Some(_inner),
            CreateUserGroupErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            CreateUserGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DecreaseNodeGroupsInGlobalReplicationGroupError {
    pub kind: DecreaseNodeGroupsInGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DecreaseNodeGroupsInGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DecreaseNodeGroupsInGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) =>
            _inner.fmt(f)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DecreaseNodeGroupsInGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        DecreaseNodeGroupsInGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DecreaseNodeGroupsInGlobalReplicationGroupError {
    pub fn new(
        kind: DecreaseNodeGroupsInGlobalReplicationGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(&self.kind, DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_))
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(&self.kind, DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_))
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(&self.kind, DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DecreaseNodeGroupsInGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            Some(_inner)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) =>
            Some(_inner)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            DecreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DecreaseReplicaCountError {
    pub kind: DecreaseReplicaCountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DecreaseReplicaCountErrorKind {
    ClusterQuotaForCustomerExceededFault(crate::error::ClusterQuotaForCustomerExceededFault),
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeGroupsPerReplicationGroupQuotaExceededFault(
        crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault,
    ),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    NoOperationFault(crate::error::NoOperationFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    ServiceLinkedRoleNotFoundFault(crate::error::ServiceLinkedRoleNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DecreaseReplicaCountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DecreaseReplicaCountErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            DecreaseReplicaCountErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            DecreaseReplicaCountErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DecreaseReplicaCountErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DecreaseReplicaCountErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(
                _inner,
            ) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            DecreaseReplicaCountErrorKind::NoOperationFault(_inner) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::ServiceLinkedRoleNotFoundFault(_inner) => _inner.fmt(f),
            DecreaseReplicaCountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DecreaseReplicaCountError {
    fn code(&self) -> Option<&str> {
        DecreaseReplicaCountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DecreaseReplicaCountError {
    pub fn new(kind: DecreaseReplicaCountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DecreaseReplicaCountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DecreaseReplicaCountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::ClusterQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::InsufficientCacheClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_groups_per_replication_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(_)
        )
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_no_operation_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::NoOperationFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_service_linked_role_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DecreaseReplicaCountErrorKind::ServiceLinkedRoleNotFoundFault(_)
        )
    }
}
impl std::error::Error for DecreaseReplicaCountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DecreaseReplicaCountErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            DecreaseReplicaCountErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            DecreaseReplicaCountErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            DecreaseReplicaCountErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DecreaseReplicaCountErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DecreaseReplicaCountErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            DecreaseReplicaCountErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            DecreaseReplicaCountErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(
                _inner,
            ) => Some(_inner),
            DecreaseReplicaCountErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            DecreaseReplicaCountErrorKind::NoOperationFault(_inner) => Some(_inner),
            DecreaseReplicaCountErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            DecreaseReplicaCountErrorKind::ServiceLinkedRoleNotFoundFault(_inner) => Some(_inner),
            DecreaseReplicaCountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCacheClusterError {
    pub kind: DeleteCacheClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCacheClusterErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    SnapshotFeatureNotSupportedFault(crate::error::SnapshotFeatureNotSupportedFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCacheClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCacheClusterErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            DeleteCacheClusterErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            DeleteCacheClusterErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheClusterErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteCacheClusterErrorKind::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            DeleteCacheClusterErrorKind::SnapshotFeatureNotSupportedFault(_inner) => _inner.fmt(f),
            DeleteCacheClusterErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            DeleteCacheClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCacheClusterError {
    fn code(&self) -> Option<&str> {
        DeleteCacheClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCacheClusterError {
    pub fn new(kind: DeleteCacheClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCacheClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCacheClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::SnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_snapshot_feature_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::SnapshotFeatureNotSupportedFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheClusterErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for DeleteCacheClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCacheClusterErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            DeleteCacheClusterErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            DeleteCacheClusterErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DeleteCacheClusterErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteCacheClusterErrorKind::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            DeleteCacheClusterErrorKind::SnapshotFeatureNotSupportedFault(_inner) => Some(_inner),
            DeleteCacheClusterErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            DeleteCacheClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCacheParameterGroupError {
    pub kind: DeleteCacheParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCacheParameterGroupErrorKind {
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    InvalidCacheParameterGroupStateFault(crate::error::InvalidCacheParameterGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCacheParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCacheParameterGroupError {
    fn code(&self) -> Option<&str> {
        DeleteCacheParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCacheParameterGroupError {
    pub fn new(kind: DeleteCacheParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCacheParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCacheParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheParameterGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheParameterGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DeleteCacheParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DeleteCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteCacheParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCacheSecurityGroupError {
    pub kind: DeleteCacheSecurityGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCacheSecurityGroupErrorKind {
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    InvalidCacheSecurityGroupStateFault(crate::error::InvalidCacheSecurityGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCacheSecurityGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCacheSecurityGroupErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheSecurityGroupErrorKind::InvalidCacheSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheSecurityGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheSecurityGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteCacheSecurityGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCacheSecurityGroupError {
    fn code(&self) -> Option<&str> {
        DeleteCacheSecurityGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCacheSecurityGroupError {
    pub fn new(kind: DeleteCacheSecurityGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCacheSecurityGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCacheSecurityGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheSecurityGroupErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheSecurityGroupErrorKind::InvalidCacheSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheSecurityGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheSecurityGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DeleteCacheSecurityGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCacheSecurityGroupErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteCacheSecurityGroupErrorKind::InvalidCacheSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteCacheSecurityGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DeleteCacheSecurityGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteCacheSecurityGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCacheSubnetGroupError {
    pub kind: DeleteCacheSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCacheSubnetGroupErrorKind {
    CacheSubnetGroupInUse(crate::error::CacheSubnetGroupInUse),
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCacheSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCacheSubnetGroupErrorKind::CacheSubnetGroupInUse(_inner) => _inner.fmt(f),
            DeleteCacheSubnetGroupErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteCacheSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCacheSubnetGroupError {
    fn code(&self) -> Option<&str> {
        DeleteCacheSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCacheSubnetGroupError {
    pub fn new(kind: DeleteCacheSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCacheSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCacheSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_subnet_group_in_use(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheSubnetGroupErrorKind::CacheSubnetGroupInUse(_)
        )
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCacheSubnetGroupErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteCacheSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCacheSubnetGroupErrorKind::CacheSubnetGroupInUse(_inner) => Some(_inner),
            DeleteCacheSubnetGroupErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            DeleteCacheSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGlobalReplicationGroupError {
    pub kind: DeleteGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(
                _inner,
            ) => _inner.fmt(f),
            DeleteGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteGlobalReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        DeleteGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGlobalReplicationGroupError {
    pub fn new(kind: DeleteGlobalReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DeleteGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DeleteGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(
                _inner,
            ) => Some(_inner),
            DeleteGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DeleteGlobalReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteReplicationGroupError {
    pub kind: DeleteReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteReplicationGroupErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    SnapshotAlreadyExistsFault(crate::error::SnapshotAlreadyExistsFault),
    SnapshotFeatureNotSupportedFault(crate::error::SnapshotFeatureNotSupportedFault),
    SnapshotQuotaExceededFault(crate::error::SnapshotQuotaExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DeleteReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteReplicationGroupErrorKind::SnapshotAlreadyExistsFault(_inner) => _inner.fmt(f),
            DeleteReplicationGroupErrorKind::SnapshotFeatureNotSupportedFault(_inner) => {
                _inner.fmt(f)
            }
            DeleteReplicationGroupErrorKind::SnapshotQuotaExceededFault(_inner) => _inner.fmt(f),
            DeleteReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteReplicationGroupError {
    fn code(&self) -> Option<&str> {
        DeleteReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteReplicationGroupError {
    pub fn new(kind: DeleteReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_snapshot_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::SnapshotAlreadyExistsFault(_)
        )
    }
    pub fn is_snapshot_feature_not_supported_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::SnapshotFeatureNotSupportedFault(_)
        )
    }
    pub fn is_snapshot_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteReplicationGroupErrorKind::SnapshotQuotaExceededFault(_)
        )
    }
}
impl std::error::Error for DeleteReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DeleteReplicationGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            DeleteReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            DeleteReplicationGroupErrorKind::SnapshotAlreadyExistsFault(_inner) => Some(_inner),
            DeleteReplicationGroupErrorKind::SnapshotFeatureNotSupportedFault(_inner) => {
                Some(_inner)
            }
            DeleteReplicationGroupErrorKind::SnapshotQuotaExceededFault(_inner) => Some(_inner),
            DeleteReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSnapshotError {
    pub kind: DeleteSnapshotErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSnapshotErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidSnapshotStateFault(crate::error::InvalidSnapshotStateFault),
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSnapshotError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSnapshotErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            DeleteSnapshotErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteSnapshotErrorKind::InvalidSnapshotStateFault(_inner) => _inner.fmt(f),
            DeleteSnapshotErrorKind::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DeleteSnapshotErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSnapshotError {
    fn code(&self) -> Option<&str> {
        DeleteSnapshotError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSnapshotError {
    pub fn new(kind: DeleteSnapshotErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSnapshotErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSnapshotErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSnapshotErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSnapshotErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_snapshot_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSnapshotErrorKind::InvalidSnapshotStateFault(_)
        )
    }
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSnapshotErrorKind::SnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteSnapshotError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSnapshotErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            DeleteSnapshotErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteSnapshotErrorKind::InvalidSnapshotStateFault(_inner) => Some(_inner),
            DeleteSnapshotErrorKind::SnapshotNotFoundFault(_inner) => Some(_inner),
            DeleteSnapshotErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserError {
    pub kind: DeleteUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserErrorKind {
    DefaultUserAssociatedToUserGroupFault(crate::error::DefaultUserAssociatedToUserGroupFault),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidUserStateFault(crate::error::InvalidUserStateFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserErrorKind::DefaultUserAssociatedToUserGroupFault(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::InvalidUserStateFault(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            DeleteUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserError {
    fn code(&self) -> Option<&str> {
        DeleteUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserError {
    pub fn new(kind: DeleteUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_default_user_associated_to_user_group_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::DefaultUserAssociatedToUserGroupFault(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_user_state_fault(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::InvalidUserStateFault(_))
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(&self.kind, DeleteUserErrorKind::UserNotFoundFault(_))
    }
}
impl std::error::Error for DeleteUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserErrorKind::DefaultUserAssociatedToUserGroupFault(_inner) => Some(_inner),
            DeleteUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteUserErrorKind::InvalidUserStateFault(_inner) => Some(_inner),
            DeleteUserErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            DeleteUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserGroupError {
    pub kind: DeleteUserGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserGroupErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidUserGroupStateFault(crate::error::InvalidUserGroupStateFault),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DeleteUserGroupErrorKind::InvalidUserGroupStateFault(_inner) => _inner.fmt(f),
            DeleteUserGroupErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            DeleteUserGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserGroupError {
    fn code(&self) -> Option<&str> {
        DeleteUserGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserGroupError {
    pub fn new(kind: DeleteUserGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_user_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserGroupErrorKind::InvalidUserGroupStateFault(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserGroupErrorKind::UserGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DeleteUserGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DeleteUserGroupErrorKind::InvalidUserGroupStateFault(_inner) => Some(_inner),
            DeleteUserGroupErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            DeleteUserGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheClustersError {
    pub kind: DescribeCacheClustersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheClustersErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheClustersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheClustersErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeCacheClustersErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheClustersErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeCacheClustersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheClustersError {
    fn code(&self) -> Option<&str> {
        DescribeCacheClustersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheClustersError {
    pub fn new(kind: DescribeCacheClustersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheClustersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheClustersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheClustersErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheClustersErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheClustersErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeCacheClustersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheClustersErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            DescribeCacheClustersErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeCacheClustersErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeCacheClustersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheEngineVersionsError {
    pub kind: DescribeCacheEngineVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheEngineVersionsErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheEngineVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheEngineVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheEngineVersionsError {
    fn code(&self) -> Option<&str> {
        DescribeCacheEngineVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheEngineVersionsError {
    pub fn new(kind: DescribeCacheEngineVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheEngineVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheEngineVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for DescribeCacheEngineVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheEngineVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheParameterGroupsError {
    pub kind: DescribeCacheParameterGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheParameterGroupsErrorKind {
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheParameterGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheParameterGroupsErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheParameterGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheParameterGroupsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheParameterGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheParameterGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeCacheParameterGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheParameterGroupsError {
    pub fn new(kind: DescribeCacheParameterGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheParameterGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheParameterGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheParameterGroupsErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheParameterGroupsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheParameterGroupsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeCacheParameterGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheParameterGroupsErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeCacheParameterGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeCacheParameterGroupsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeCacheParameterGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheParametersError {
    pub kind: DescribeCacheParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheParametersErrorKind {
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheParametersErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheParametersErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheParametersErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheParametersError {
    fn code(&self) -> Option<&str> {
        DescribeCacheParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheParametersError {
    pub fn new(kind: DescribeCacheParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheParametersErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheParametersErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheParametersErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeCacheParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheParametersErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeCacheParametersErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeCacheParametersErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeCacheParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheSecurityGroupsError {
    pub kind: DescribeCacheSecurityGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheSecurityGroupsErrorKind {
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheSecurityGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheSecurityGroupsErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheSecurityGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheSecurityGroupsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheSecurityGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheSecurityGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeCacheSecurityGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheSecurityGroupsError {
    pub fn new(kind: DescribeCacheSecurityGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheSecurityGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheSecurityGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheSecurityGroupsErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheSecurityGroupsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheSecurityGroupsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeCacheSecurityGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheSecurityGroupsErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeCacheSecurityGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeCacheSecurityGroupsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeCacheSecurityGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeCacheSubnetGroupsError {
    pub kind: DescribeCacheSubnetGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeCacheSubnetGroupsErrorKind {
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeCacheSubnetGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeCacheSubnetGroupsErrorKind::CacheSubnetGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeCacheSubnetGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeCacheSubnetGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeCacheSubnetGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeCacheSubnetGroupsError {
    pub fn new(kind: DescribeCacheSubnetGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeCacheSubnetGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeCacheSubnetGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeCacheSubnetGroupsErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeCacheSubnetGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeCacheSubnetGroupsErrorKind::CacheSubnetGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeCacheSubnetGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEngineDefaultParametersError {
    pub kind: DescribeEngineDefaultParametersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEngineDefaultParametersErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEngineDefaultParametersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEngineDefaultParametersErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => _inner.fmt(f),
            DescribeEngineDefaultParametersErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeEngineDefaultParametersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEngineDefaultParametersError {
    fn code(&self) -> Option<&str> {
        DescribeEngineDefaultParametersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEngineDefaultParametersError {
    pub fn new(kind: DescribeEngineDefaultParametersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEngineDefaultParametersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEngineDefaultParametersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEngineDefaultParametersErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEngineDefaultParametersErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeEngineDefaultParametersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEngineDefaultParametersErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => Some(_inner),
            DescribeEngineDefaultParametersErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeEngineDefaultParametersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeEventsError {
    pub kind: DescribeEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeEventsErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeEventsErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            DescribeEventsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeEventsError {
    fn code(&self) -> Option<&str> {
        DescribeEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeEventsError {
    pub fn new(kind: DescribeEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeEventsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeEventsErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            DescribeEventsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeGlobalReplicationGroupsError {
    pub kind: DescribeGlobalReplicationGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeGlobalReplicationGroupsErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeGlobalReplicationGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeGlobalReplicationGroupsErrorKind::GlobalReplicationGroupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            DescribeGlobalReplicationGroupsErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => _inner.fmt(f),
            DescribeGlobalReplicationGroupsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeGlobalReplicationGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeGlobalReplicationGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeGlobalReplicationGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeGlobalReplicationGroupsError {
    pub fn new(kind: DescribeGlobalReplicationGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeGlobalReplicationGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeGlobalReplicationGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalReplicationGroupsErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalReplicationGroupsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeGlobalReplicationGroupsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeGlobalReplicationGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeGlobalReplicationGroupsErrorKind::GlobalReplicationGroupNotFoundFault(
                _inner,
            ) => Some(_inner),
            DescribeGlobalReplicationGroupsErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => Some(_inner),
            DescribeGlobalReplicationGroupsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeGlobalReplicationGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReplicationGroupsError {
    pub kind: DescribeReplicationGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReplicationGroupsErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReplicationGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReplicationGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeReplicationGroupsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeReplicationGroupsErrorKind::ReplicationGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeReplicationGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReplicationGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeReplicationGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReplicationGroupsError {
    pub fn new(kind: DescribeReplicationGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReplicationGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReplicationGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReplicationGroupsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReplicationGroupsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReplicationGroupsErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeReplicationGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReplicationGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeReplicationGroupsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeReplicationGroupsErrorKind::ReplicationGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeReplicationGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservedCacheNodesError {
    pub kind: DescribeReservedCacheNodesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedCacheNodesErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ReservedCacheNodeNotFoundFault(crate::error::ReservedCacheNodeNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservedCacheNodesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservedCacheNodesErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeReservedCacheNodesErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeReservedCacheNodesErrorKind::ReservedCacheNodeNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            DescribeReservedCacheNodesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservedCacheNodesError {
    fn code(&self) -> Option<&str> {
        DescribeReservedCacheNodesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedCacheNodesError {
    pub fn new(kind: DescribeReservedCacheNodesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservedCacheNodesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservedCacheNodesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedCacheNodesErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedCacheNodesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_reserved_cache_node_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedCacheNodesErrorKind::ReservedCacheNodeNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeReservedCacheNodesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservedCacheNodesErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeReservedCacheNodesErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            DescribeReservedCacheNodesErrorKind::ReservedCacheNodeNotFoundFault(_inner) => {
                Some(_inner)
            }
            DescribeReservedCacheNodesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeReservedCacheNodesOfferingsError {
    pub kind: DescribeReservedCacheNodesOfferingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeReservedCacheNodesOfferingsErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ReservedCacheNodesOfferingNotFoundFault(crate::error::ReservedCacheNodesOfferingNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeReservedCacheNodesOfferingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeReservedCacheNodesOfferingsErrorKind::InvalidParameterCombinationException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeReservedCacheNodesOfferingsErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeReservedCacheNodesOfferingsErrorKind::ReservedCacheNodesOfferingNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DescribeReservedCacheNodesOfferingsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeReservedCacheNodesOfferingsError {
    fn code(&self) -> Option<&str> {
        DescribeReservedCacheNodesOfferingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeReservedCacheNodesOfferingsError {
    pub fn new(
        kind: DescribeReservedCacheNodesOfferingsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeReservedCacheNodesOfferingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeReservedCacheNodesOfferingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedCacheNodesOfferingsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedCacheNodesOfferingsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_reserved_cache_nodes_offering_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeReservedCacheNodesOfferingsErrorKind::ReservedCacheNodesOfferingNotFoundFault(
                _
            )
        )
    }
}
impl std::error::Error for DescribeReservedCacheNodesOfferingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeReservedCacheNodesOfferingsErrorKind::InvalidParameterCombinationException(_inner) =>
            Some(_inner)
            ,
            DescribeReservedCacheNodesOfferingsErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            DescribeReservedCacheNodesOfferingsErrorKind::ReservedCacheNodesOfferingNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DescribeReservedCacheNodesOfferingsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeServiceUpdatesError {
    pub kind: DescribeServiceUpdatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeServiceUpdatesErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ServiceUpdateNotFoundFault(crate::error::ServiceUpdateNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeServiceUpdatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeServiceUpdatesErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeServiceUpdatesErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            DescribeServiceUpdatesErrorKind::ServiceUpdateNotFoundFault(_inner) => _inner.fmt(f),
            DescribeServiceUpdatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeServiceUpdatesError {
    fn code(&self) -> Option<&str> {
        DescribeServiceUpdatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeServiceUpdatesError {
    pub fn new(kind: DescribeServiceUpdatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeServiceUpdatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeServiceUpdatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServiceUpdatesErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServiceUpdatesErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_service_update_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeServiceUpdatesErrorKind::ServiceUpdateNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeServiceUpdatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeServiceUpdatesErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeServiceUpdatesErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeServiceUpdatesErrorKind::ServiceUpdateNotFoundFault(_inner) => Some(_inner),
            DescribeServiceUpdatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSnapshotsError {
    pub kind: DescribeSnapshotsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSnapshotsErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSnapshotsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSnapshotsErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            DescribeSnapshotsErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeSnapshotsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeSnapshotsErrorKind::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            DescribeSnapshotsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSnapshotsError {
    fn code(&self) -> Option<&str> {
        DescribeSnapshotsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSnapshotsError {
    pub fn new(kind: DescribeSnapshotsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSnapshotsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSnapshotsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSnapshotsErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSnapshotsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSnapshotsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSnapshotsErrorKind::SnapshotNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeSnapshotsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSnapshotsErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            DescribeSnapshotsErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeSnapshotsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeSnapshotsErrorKind::SnapshotNotFoundFault(_inner) => Some(_inner),
            DescribeSnapshotsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUpdateActionsError {
    pub kind: DescribeUpdateActionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUpdateActionsErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUpdateActionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUpdateActionsErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeUpdateActionsErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            DescribeUpdateActionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUpdateActionsError {
    fn code(&self) -> Option<&str> {
        DescribeUpdateActionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUpdateActionsError {
    pub fn new(kind: DescribeUpdateActionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUpdateActionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUpdateActionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUpdateActionsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUpdateActionsErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DescribeUpdateActionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUpdateActionsErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeUpdateActionsErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            DescribeUpdateActionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserGroupsError {
    pub kind: DescribeUserGroupsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserGroupsErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            DescribeUserGroupsErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            DescribeUserGroupsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserGroupsError {
    fn code(&self) -> Option<&str> {
        DescribeUserGroupsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserGroupsError {
    pub fn new(kind: DescribeUserGroupsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserGroupsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserGroupsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserGroupsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserGroupsErrorKind::UserGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for DescribeUserGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserGroupsErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            DescribeUserGroupsErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            DescribeUserGroupsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUsersError {
    pub kind: DescribeUsersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUsersErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUsersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUsersErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            DescribeUsersErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            DescribeUsersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUsersError {
    fn code(&self) -> Option<&str> {
        DescribeUsersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUsersError {
    pub fn new(kind: DescribeUsersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUsersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUsersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUsersErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(&self.kind, DescribeUsersErrorKind::UserNotFoundFault(_))
    }
}
impl std::error::Error for DescribeUsersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUsersErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            DescribeUsersErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            DescribeUsersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateGlobalReplicationGroupError {
    pub kind: DisassociateGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        DisassociateGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateGlobalReplicationGroupError {
    pub fn new(
        kind: DisassociateGlobalReplicationGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for DisassociateGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            DisassociateGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            Some(_inner)
            ,
            DisassociateGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) =>
            Some(_inner)
            ,
            DisassociateGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            DisassociateGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct FailoverGlobalReplicationGroupError {
    pub kind: FailoverGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum FailoverGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for FailoverGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            FailoverGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(
                _inner,
            ) => _inner.fmt(f),
            FailoverGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(
                _inner,
            ) => _inner.fmt(f),
            FailoverGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => _inner.fmt(f),
            FailoverGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            FailoverGlobalReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for FailoverGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        FailoverGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl FailoverGlobalReplicationGroupError {
    pub fn new(kind: FailoverGlobalReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: FailoverGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: FailoverGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            FailoverGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for FailoverGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            FailoverGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(
                _inner,
            ) => Some(_inner),
            FailoverGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(
                _inner,
            ) => Some(_inner),
            FailoverGlobalReplicationGroupErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => Some(_inner),
            FailoverGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            FailoverGlobalReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct IncreaseNodeGroupsInGlobalReplicationGroupError {
    pub kind: IncreaseNodeGroupsInGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum IncreaseNodeGroupsInGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for IncreaseNodeGroupsInGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for IncreaseNodeGroupsInGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        IncreaseNodeGroupsInGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl IncreaseNodeGroupsInGlobalReplicationGroupError {
    pub fn new(
        kind: IncreaseNodeGroupsInGlobalReplicationGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(&self.kind, IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_))
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(&self.kind, IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for IncreaseNodeGroupsInGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            Some(_inner)
            ,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            IncreaseNodeGroupsInGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct IncreaseReplicaCountError {
    pub kind: IncreaseReplicaCountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum IncreaseReplicaCountErrorKind {
    ClusterQuotaForCustomerExceededFault(crate::error::ClusterQuotaForCustomerExceededFault),
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidKmsKeyFault(crate::error::InvalidKmsKeyFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeGroupsPerReplicationGroupQuotaExceededFault(
        crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault,
    ),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    NoOperationFault(crate::error::NoOperationFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for IncreaseReplicaCountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            IncreaseReplicaCountErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            IncreaseReplicaCountErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            IncreaseReplicaCountErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::InvalidKmsKeyFault(_inner) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            IncreaseReplicaCountErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            IncreaseReplicaCountErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(
                _inner,
            ) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            IncreaseReplicaCountErrorKind::NoOperationFault(_inner) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            IncreaseReplicaCountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for IncreaseReplicaCountError {
    fn code(&self) -> Option<&str> {
        IncreaseReplicaCountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl IncreaseReplicaCountError {
    pub fn new(kind: IncreaseReplicaCountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: IncreaseReplicaCountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: IncreaseReplicaCountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cluster_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::ClusterQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InsufficientCacheClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_kms_key_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InvalidKmsKeyFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_groups_per_replication_group_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(_)
        )
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_no_operation_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::NoOperationFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            IncreaseReplicaCountErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for IncreaseReplicaCountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            IncreaseReplicaCountErrorKind::ClusterQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            IncreaseReplicaCountErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            IncreaseReplicaCountErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            IncreaseReplicaCountErrorKind::InvalidKmsKeyFault(_inner) => Some(_inner),
            IncreaseReplicaCountErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            IncreaseReplicaCountErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            IncreaseReplicaCountErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            IncreaseReplicaCountErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            IncreaseReplicaCountErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(
                _inner,
            ) => Some(_inner),
            IncreaseReplicaCountErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            IncreaseReplicaCountErrorKind::NoOperationFault(_inner) => Some(_inner),
            IncreaseReplicaCountErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            IncreaseReplicaCountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAllowedNodeTypeModificationsError {
    pub kind: ListAllowedNodeTypeModificationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAllowedNodeTypeModificationsErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAllowedNodeTypeModificationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAllowedNodeTypeModificationsErrorKind::CacheClusterNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ListAllowedNodeTypeModificationsErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => _inner.fmt(f),
            ListAllowedNodeTypeModificationsErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ListAllowedNodeTypeModificationsErrorKind::ReplicationGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ListAllowedNodeTypeModificationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListAllowedNodeTypeModificationsError {
    fn code(&self) -> Option<&str> {
        ListAllowedNodeTypeModificationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAllowedNodeTypeModificationsError {
    pub fn new(kind: ListAllowedNodeTypeModificationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAllowedNodeTypeModificationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAllowedNodeTypeModificationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListAllowedNodeTypeModificationsErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAllowedNodeTypeModificationsErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAllowedNodeTypeModificationsErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListAllowedNodeTypeModificationsErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for ListAllowedNodeTypeModificationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAllowedNodeTypeModificationsErrorKind::CacheClusterNotFoundFault(_inner) => {
                Some(_inner)
            }
            ListAllowedNodeTypeModificationsErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => Some(_inner),
            ListAllowedNodeTypeModificationsErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ListAllowedNodeTypeModificationsErrorKind::ReplicationGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ListAllowedNodeTypeModificationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    InvalidArnFault(crate::error::InvalidArnFault),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    ReservedCacheNodeNotFoundFault(crate::error::ReservedCacheNodeNotFoundFault),
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::CacheParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::CacheSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidArnFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ListTagsForResourceErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ReservedCacheNodeNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_arn_fault(&self) -> bool {
        matches!(&self.kind, ListTagsForResourceErrorKind::InvalidArnFault(_))
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_reserved_cache_node_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ReservedCacheNodeNotFoundFault(_)
        )
    }
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::SnapshotNotFoundFault(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::UserGroupNotFoundFault(_)
        )
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::UserNotFoundFault(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::CacheParameterGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::CacheSecurityGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidArnFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ReservedCacheNodeNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::SnapshotNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCacheClusterError {
    pub kind: ModifyCacheClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCacheClusterErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidCacheSecurityGroupStateFault(crate::error::InvalidCacheSecurityGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeQuotaForClusterExceededFault(crate::error::NodeQuotaForClusterExceededFault),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCacheClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCacheClusterErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::CacheParameterGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::CacheSecurityGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheClusterErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::InvalidCacheSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheClusterErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheClusterErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::NodeQuotaForClusterExceededFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::NodeQuotaForCustomerExceededFault(_inner) => _inner.fmt(f),
            ModifyCacheClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCacheClusterError {
    fn code(&self) -> Option<&str> {
        ModifyCacheClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCacheClusterError {
    pub fn new(kind: ModifyCacheClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCacheClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCacheClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::InsufficientCacheClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_cache_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::InvalidCacheSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_quota_for_cluster_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::NodeQuotaForClusterExceededFault(_)
        )
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheClusterErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
}
impl std::error::Error for ModifyCacheClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCacheClusterErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::CacheParameterGroupNotFoundFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::CacheSecurityGroupNotFoundFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            ModifyCacheClusterErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::InvalidCacheSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyCacheClusterErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            ModifyCacheClusterErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::NodeQuotaForClusterExceededFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::NodeQuotaForCustomerExceededFault(_inner) => Some(_inner),
            ModifyCacheClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCacheParameterGroupError {
    pub kind: ModifyCacheParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCacheParameterGroupErrorKind {
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    InvalidCacheParameterGroupStateFault(crate::error::InvalidCacheParameterGroupStateFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCacheParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheParameterGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ModifyCacheParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCacheParameterGroupError {
    fn code(&self) -> Option<&str> {
        ModifyCacheParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCacheParameterGroupError {
    pub fn new(kind: ModifyCacheParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCacheParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCacheParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheParameterGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheParameterGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheParameterGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for ModifyCacheParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyCacheParameterGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            ModifyCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ModifyCacheParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyCacheSubnetGroupError {
    pub kind: ModifyCacheSubnetGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyCacheSubnetGroupErrorKind {
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    CacheSubnetQuotaExceededFault(crate::error::CacheSubnetQuotaExceededFault),
    InvalidSubnet(crate::error::InvalidSubnet),
    SubnetInUse(crate::error::SubnetInUse),
    SubnetNotAllowedFault(crate::error::SubnetNotAllowedFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyCacheSubnetGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyCacheSubnetGroupErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyCacheSubnetGroupErrorKind::CacheSubnetQuotaExceededFault(_inner) => _inner.fmt(f),
            ModifyCacheSubnetGroupErrorKind::InvalidSubnet(_inner) => _inner.fmt(f),
            ModifyCacheSubnetGroupErrorKind::SubnetInUse(_inner) => _inner.fmt(f),
            ModifyCacheSubnetGroupErrorKind::SubnetNotAllowedFault(_inner) => _inner.fmt(f),
            ModifyCacheSubnetGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyCacheSubnetGroupError {
    fn code(&self) -> Option<&str> {
        ModifyCacheSubnetGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyCacheSubnetGroupError {
    pub fn new(kind: ModifyCacheSubnetGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyCacheSubnetGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyCacheSubnetGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheSubnetGroupErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_subnet_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheSubnetGroupErrorKind::CacheSubnetQuotaExceededFault(_)
        )
    }
    pub fn is_invalid_subnet(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheSubnetGroupErrorKind::InvalidSubnet(_)
        )
    }
    pub fn is_subnet_in_use(&self) -> bool {
        matches!(&self.kind, ModifyCacheSubnetGroupErrorKind::SubnetInUse(_))
    }
    pub fn is_subnet_not_allowed_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyCacheSubnetGroupErrorKind::SubnetNotAllowedFault(_)
        )
    }
}
impl std::error::Error for ModifyCacheSubnetGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyCacheSubnetGroupErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            ModifyCacheSubnetGroupErrorKind::CacheSubnetQuotaExceededFault(_inner) => Some(_inner),
            ModifyCacheSubnetGroupErrorKind::InvalidSubnet(_inner) => Some(_inner),
            ModifyCacheSubnetGroupErrorKind::SubnetInUse(_inner) => Some(_inner),
            ModifyCacheSubnetGroupErrorKind::SubnetNotAllowedFault(_inner) => Some(_inner),
            ModifyCacheSubnetGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyGlobalReplicationGroupError {
    pub kind: ModifyGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(
                _inner,
            ) => _inner.fmt(f),
            ModifyGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ModifyGlobalReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        ModifyGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyGlobalReplicationGroupError {
    pub fn new(kind: ModifyGlobalReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for ModifyGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(
                _inner,
            ) => Some(_inner),
            ModifyGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ModifyGlobalReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyReplicationGroupError {
    pub kind: ModifyReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyReplicationGroupErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidCacheSecurityGroupStateFault(crate::error::InvalidCacheSecurityGroupStateFault),
    InvalidKmsKeyFault(crate::error::InvalidKmsKeyFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    InvalidUserGroupStateFault(crate::error::InvalidUserGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeQuotaForClusterExceededFault(crate::error::NodeQuotaForClusterExceededFault),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyReplicationGroupErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::InvalidCacheSecurityGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::InvalidKmsKeyFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::InvalidUserGroupStateFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::InvalidVpcNetworkStateFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::NodeQuotaForClusterExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                _inner.fmt(f)
            }
            ModifyReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyReplicationGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyReplicationGroupError {
    fn code(&self) -> Option<&str> {
        ModifyReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyReplicationGroupError {
    pub fn new(kind: ModifyReplicationGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InsufficientCacheClusterCapacityFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_cache_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidCacheSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_kms_key_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidKmsKeyFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_user_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidUserGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_quota_for_cluster_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::NodeQuotaForClusterExceededFault(_)
        )
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupErrorKind::UserGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyReplicationGroupErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::InsufficientCacheClusterCapacityFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::InvalidCacheSecurityGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::InvalidKmsKeyFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::InvalidUserGroupStateFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::InvalidVpcNetworkStateFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::NodeQuotaForClusterExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::NodeQuotaForCustomerExceededFault(_inner) => {
                Some(_inner)
            }
            ModifyReplicationGroupErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            ModifyReplicationGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyReplicationGroupShardConfigurationError {
    pub kind: ModifyReplicationGroupShardConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyReplicationGroupShardConfigurationErrorKind {
    InsufficientCacheClusterCapacityFault(crate::error::InsufficientCacheClusterCapacityFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidKmsKeyFault(crate::error::InvalidKmsKeyFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    InvalidVpcNetworkStateFault(crate::error::InvalidVpcNetworkStateFault),
    NodeGroupsPerReplicationGroupQuotaExceededFault(
        crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault,
    ),
    NodeQuotaForCustomerExceededFault(crate::error::NodeQuotaForCustomerExceededFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyReplicationGroupShardConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyReplicationGroupShardConfigurationErrorKind::InsufficientCacheClusterCapacityFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidCacheClusterStateFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidKmsKeyFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidParameterCombinationException(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidReplicationGroupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidVpcNetworkStateFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::NodeQuotaForCustomerExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::ReplicationGroupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyReplicationGroupShardConfigurationError {
    fn code(&self) -> Option<&str> {
        ModifyReplicationGroupShardConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyReplicationGroupShardConfigurationError {
    pub fn new(
        kind: ModifyReplicationGroupShardConfigurationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyReplicationGroupShardConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyReplicationGroupShardConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_insufficient_cache_cluster_capacity_fault(&self) -> bool {
        matches!(&self.kind, ModifyReplicationGroupShardConfigurationErrorKind::InsufficientCacheClusterCapacityFault(_))
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_kms_key_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidKmsKeyFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidParameterCombinationException(
                _
            )
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_vpc_network_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidVpcNetworkStateFault(_)
        )
    }
    pub fn is_node_groups_per_replication_group_quota_exceeded_fault(&self) -> bool {
        matches!(&self.kind, ModifyReplicationGroupShardConfigurationErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(_))
    }
    pub fn is_node_quota_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::NodeQuotaForCustomerExceededFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyReplicationGroupShardConfigurationErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for ModifyReplicationGroupShardConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyReplicationGroupShardConfigurationErrorKind::InsufficientCacheClusterCapacityFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidCacheClusterStateFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidKmsKeyFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidParameterCombinationException(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidReplicationGroupStateFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::InvalidVpcNetworkStateFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::NodeGroupsPerReplicationGroupQuotaExceededFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::NodeQuotaForCustomerExceededFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::ReplicationGroupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            ModifyReplicationGroupShardConfigurationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyUserError {
    pub kind: ModifyUserErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyUserErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidUserStateFault(crate::error::InvalidUserStateFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyUserError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyUserErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            ModifyUserErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ModifyUserErrorKind::InvalidUserStateFault(_inner) => _inner.fmt(f),
            ModifyUserErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            ModifyUserErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyUserError {
    fn code(&self) -> Option<&str> {
        ModifyUserError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyUserError {
    pub fn new(kind: ModifyUserErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyUserErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyUserErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_user_state_fault(&self) -> bool {
        matches!(&self.kind, ModifyUserErrorKind::InvalidUserStateFault(_))
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(&self.kind, ModifyUserErrorKind::UserNotFoundFault(_))
    }
}
impl std::error::Error for ModifyUserError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyUserErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            ModifyUserErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ModifyUserErrorKind::InvalidUserStateFault(_inner) => Some(_inner),
            ModifyUserErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            ModifyUserErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ModifyUserGroupError {
    pub kind: ModifyUserGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ModifyUserGroupErrorKind {
    DefaultUserRequired(crate::error::DefaultUserRequired),
    DuplicateUserNameFault(crate::error::DuplicateUserNameFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidUserGroupStateFault(crate::error::InvalidUserGroupStateFault),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ModifyUserGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ModifyUserGroupErrorKind::DefaultUserRequired(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::DuplicateUserNameFault(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::InvalidUserGroupStateFault(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            ModifyUserGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ModifyUserGroupError {
    fn code(&self) -> Option<&str> {
        ModifyUserGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ModifyUserGroupError {
    pub fn new(kind: ModifyUserGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ModifyUserGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ModifyUserGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_default_user_required(&self) -> bool {
        matches!(&self.kind, ModifyUserGroupErrorKind::DefaultUserRequired(_))
    }
    pub fn is_duplicate_user_name_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserGroupErrorKind::DuplicateUserNameFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserGroupErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_user_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserGroupErrorKind::InvalidUserGroupStateFault(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ModifyUserGroupErrorKind::UserGroupNotFoundFault(_)
        )
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(&self.kind, ModifyUserGroupErrorKind::UserNotFoundFault(_))
    }
}
impl std::error::Error for ModifyUserGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ModifyUserGroupErrorKind::DefaultUserRequired(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::DuplicateUserNameFault(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::InvalidUserGroupStateFault(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            ModifyUserGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PurchaseReservedCacheNodesOfferingError {
    pub kind: PurchaseReservedCacheNodesOfferingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PurchaseReservedCacheNodesOfferingErrorKind {
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    ReservedCacheNodeAlreadyExistsFault(crate::error::ReservedCacheNodeAlreadyExistsFault),
    ReservedCacheNodeQuotaExceededFault(crate::error::ReservedCacheNodeQuotaExceededFault),
    ReservedCacheNodesOfferingNotFoundFault(crate::error::ReservedCacheNodesOfferingNotFoundFault),
    TagQuotaPerResourceExceeded(crate::error::TagQuotaPerResourceExceeded),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PurchaseReservedCacheNodesOfferingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PurchaseReservedCacheNodesOfferingErrorKind::InvalidParameterCombinationException(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodeAlreadyExistsFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodeQuotaExceededFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodesOfferingNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::TagQuotaPerResourceExceeded(_inner) =>
            _inner.fmt(f)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PurchaseReservedCacheNodesOfferingError {
    fn code(&self) -> Option<&str> {
        PurchaseReservedCacheNodesOfferingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PurchaseReservedCacheNodesOfferingError {
    pub fn new(
        kind: PurchaseReservedCacheNodesOfferingErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PurchaseReservedCacheNodesOfferingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PurchaseReservedCacheNodesOfferingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedCacheNodesOfferingErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedCacheNodesOfferingErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_reserved_cache_node_already_exists_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodeAlreadyExistsFault(_)
        )
    }
    pub fn is_reserved_cache_node_quota_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodeQuotaExceededFault(_)
        )
    }
    pub fn is_reserved_cache_nodes_offering_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodesOfferingNotFoundFault(_)
        )
    }
    pub fn is_tag_quota_per_resource_exceeded(&self) -> bool {
        matches!(
            &self.kind,
            PurchaseReservedCacheNodesOfferingErrorKind::TagQuotaPerResourceExceeded(_)
        )
    }
}
impl std::error::Error for PurchaseReservedCacheNodesOfferingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PurchaseReservedCacheNodesOfferingErrorKind::InvalidParameterCombinationException(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodeAlreadyExistsFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodeQuotaExceededFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::ReservedCacheNodesOfferingNotFoundFault(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::TagQuotaPerResourceExceeded(_inner) =>
            Some(_inner)
            ,
            PurchaseReservedCacheNodesOfferingErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebalanceSlotsInGlobalReplicationGroupError {
    pub kind: RebalanceSlotsInGlobalReplicationGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebalanceSlotsInGlobalReplicationGroupErrorKind {
    GlobalReplicationGroupNotFoundFault(crate::error::GlobalReplicationGroupNotFoundFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebalanceSlotsInGlobalReplicationGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebalanceSlotsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            _inner.fmt(f)
            ,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            _inner.fmt(f)
            ,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            _inner.fmt(f)
            ,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebalanceSlotsInGlobalReplicationGroupError {
    fn code(&self) -> Option<&str> {
        RebalanceSlotsInGlobalReplicationGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebalanceSlotsInGlobalReplicationGroupError {
    pub fn new(
        kind: RebalanceSlotsInGlobalReplicationGroupErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebalanceSlotsInGlobalReplicationGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebalanceSlotsInGlobalReplicationGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_global_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(&self.kind, RebalanceSlotsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_))
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for RebalanceSlotsInGlobalReplicationGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebalanceSlotsInGlobalReplicationGroupErrorKind::GlobalReplicationGroupNotFoundFault(_inner) =>
            Some(_inner)
            ,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) =>
            Some(_inner)
            ,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::InvalidParameterValueException(_inner) =>
            Some(_inner)
            ,
            RebalanceSlotsInGlobalReplicationGroupErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RebootCacheClusterError {
    pub kind: RebootCacheClusterErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RebootCacheClusterErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RebootCacheClusterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RebootCacheClusterErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            RebootCacheClusterErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            RebootCacheClusterErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RebootCacheClusterError {
    fn code(&self) -> Option<&str> {
        RebootCacheClusterError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RebootCacheClusterError {
    pub fn new(kind: RebootCacheClusterErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RebootCacheClusterErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RebootCacheClusterErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebootCacheClusterErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RebootCacheClusterErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
}
impl std::error::Error for RebootCacheClusterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RebootCacheClusterErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            RebootCacheClusterErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            RebootCacheClusterErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveTagsFromResourceError {
    pub kind: RemoveTagsFromResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromResourceErrorKind {
    CacheClusterNotFoundFault(crate::error::CacheClusterNotFoundFault),
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    CacheSubnetGroupNotFoundFault(crate::error::CacheSubnetGroupNotFoundFault),
    InvalidArnFault(crate::error::InvalidArnFault),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    ReservedCacheNodeNotFoundFault(crate::error::ReservedCacheNodeNotFoundFault),
    SnapshotNotFoundFault(crate::error::SnapshotNotFoundFault),
    TagNotFoundFault(crate::error::TagNotFoundFault),
    UserGroupNotFoundFault(crate::error::UserGroupNotFoundFault),
    UserNotFoundFault(crate::error::UserNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveTagsFromResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::CacheClusterNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::CacheSubnetGroupNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::InvalidArnFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::ReservedCacheNodeNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RemoveTagsFromResourceErrorKind::SnapshotNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::TagNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::UserGroupNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::UserNotFoundFault(_inner) => _inner.fmt(f),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveTagsFromResourceError {
    fn code(&self) -> Option<&str> {
        RemoveTagsFromResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromResourceError {
    pub fn new(kind: RemoveTagsFromResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveTagsFromResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_cluster_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::CacheClusterNotFoundFault(_)
        )
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_cache_subnet_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::CacheSubnetGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_arn_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InvalidArnFault(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_reserved_cache_node_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::ReservedCacheNodeNotFoundFault(_)
        )
    }
    pub fn is_snapshot_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::SnapshotNotFoundFault(_)
        )
    }
    pub fn is_tag_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::TagNotFoundFault(_)
        )
    }
    pub fn is_user_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::UserGroupNotFoundFault(_)
        )
    }
    pub fn is_user_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RemoveTagsFromResourceErrorKind::UserNotFoundFault(_)
        )
    }
}
impl std::error::Error for RemoveTagsFromResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveTagsFromResourceErrorKind::CacheClusterNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveTagsFromResourceErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RemoveTagsFromResourceErrorKind::CacheSubnetGroupNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::InvalidArnFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::InvalidReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            RemoveTagsFromResourceErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::ReservedCacheNodeNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::SnapshotNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::TagNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::UserGroupNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::UserNotFoundFault(_inner) => Some(_inner),
            RemoveTagsFromResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetCacheParameterGroupError {
    pub kind: ResetCacheParameterGroupErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetCacheParameterGroupErrorKind {
    CacheParameterGroupNotFoundFault(crate::error::CacheParameterGroupNotFoundFault),
    InvalidCacheParameterGroupStateFault(crate::error::InvalidCacheParameterGroupStateFault),
    InvalidGlobalReplicationGroupStateFault(crate::error::InvalidGlobalReplicationGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetCacheParameterGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            ResetCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ResetCacheParameterGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) => {
                _inner.fmt(f)
            }
            ResetCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                _inner.fmt(f)
            }
            ResetCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            ResetCacheParameterGroupErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetCacheParameterGroupError {
    fn code(&self) -> Option<&str> {
        ResetCacheParameterGroupError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetCacheParameterGroupError {
    pub fn new(kind: ResetCacheParameterGroupErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetCacheParameterGroupErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetCacheParameterGroupErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_cache_parameter_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_parameter_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_)
        )
    }
    pub fn is_invalid_global_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            ResetCacheParameterGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetCacheParameterGroupErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetCacheParameterGroupErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for ResetCacheParameterGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetCacheParameterGroupErrorKind::CacheParameterGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            ResetCacheParameterGroupErrorKind::InvalidCacheParameterGroupStateFault(_inner) => {
                Some(_inner)
            }
            ResetCacheParameterGroupErrorKind::InvalidGlobalReplicationGroupStateFault(_inner) => {
                Some(_inner)
            }
            ResetCacheParameterGroupErrorKind::InvalidParameterCombinationException(_inner) => {
                Some(_inner)
            }
            ResetCacheParameterGroupErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            ResetCacheParameterGroupErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RevokeCacheSecurityGroupIngressError {
    pub kind: RevokeCacheSecurityGroupIngressErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RevokeCacheSecurityGroupIngressErrorKind {
    AuthorizationNotFoundFault(crate::error::AuthorizationNotFoundFault),
    CacheSecurityGroupNotFoundFault(crate::error::CacheSecurityGroupNotFoundFault),
    InvalidCacheSecurityGroupStateFault(crate::error::InvalidCacheSecurityGroupStateFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RevokeCacheSecurityGroupIngressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RevokeCacheSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeCacheSecurityGroupIngressErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                _inner.fmt(f)
            }
            RevokeCacheSecurityGroupIngressErrorKind::InvalidCacheSecurityGroupStateFault(
                _inner,
            ) => _inner.fmt(f),
            RevokeCacheSecurityGroupIngressErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => _inner.fmt(f),
            RevokeCacheSecurityGroupIngressErrorKind::InvalidParameterValueException(_inner) => {
                _inner.fmt(f)
            }
            RevokeCacheSecurityGroupIngressErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RevokeCacheSecurityGroupIngressError {
    fn code(&self) -> Option<&str> {
        RevokeCacheSecurityGroupIngressError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RevokeCacheSecurityGroupIngressError {
    pub fn new(kind: RevokeCacheSecurityGroupIngressErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RevokeCacheSecurityGroupIngressErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RevokeCacheSecurityGroupIngressErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_authorization_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCacheSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_)
        )
    }
    pub fn is_cache_security_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCacheSecurityGroupIngressErrorKind::CacheSecurityGroupNotFoundFault(_)
        )
    }
    pub fn is_invalid_cache_security_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCacheSecurityGroupIngressErrorKind::InvalidCacheSecurityGroupStateFault(_)
        )
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCacheSecurityGroupIngressErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            RevokeCacheSecurityGroupIngressErrorKind::InvalidParameterValueException(_)
        )
    }
}
impl std::error::Error for RevokeCacheSecurityGroupIngressError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RevokeCacheSecurityGroupIngressErrorKind::AuthorizationNotFoundFault(_inner) => {
                Some(_inner)
            }
            RevokeCacheSecurityGroupIngressErrorKind::CacheSecurityGroupNotFoundFault(_inner) => {
                Some(_inner)
            }
            RevokeCacheSecurityGroupIngressErrorKind::InvalidCacheSecurityGroupStateFault(
                _inner,
            ) => Some(_inner),
            RevokeCacheSecurityGroupIngressErrorKind::InvalidParameterCombinationException(
                _inner,
            ) => Some(_inner),
            RevokeCacheSecurityGroupIngressErrorKind::InvalidParameterValueException(_inner) => {
                Some(_inner)
            }
            RevokeCacheSecurityGroupIngressErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartMigrationError {
    pub kind: StartMigrationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartMigrationErrorKind {
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    ReplicationGroupAlreadyUnderMigrationFault(
        crate::error::ReplicationGroupAlreadyUnderMigrationFault,
    ),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartMigrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartMigrationErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::InvalidReplicationGroupStateFault(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::ReplicationGroupAlreadyUnderMigrationFault(_inner) => {
                _inner.fmt(f)
            }
            StartMigrationErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            StartMigrationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartMigrationError {
    fn code(&self) -> Option<&str> {
        StartMigrationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartMigrationError {
    pub fn new(kind: StartMigrationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartMigrationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartMigrationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_replication_group_already_under_migration_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::ReplicationGroupAlreadyUnderMigrationFault(_)
        )
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            StartMigrationErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
}
impl std::error::Error for StartMigrationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartMigrationErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            StartMigrationErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            StartMigrationErrorKind::ReplicationGroupAlreadyUnderMigrationFault(_inner) => {
                Some(_inner)
            }
            StartMigrationErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            StartMigrationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestFailoverError {
    pub kind: TestFailoverErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestFailoverErrorKind {
    ApiCallRateForCustomerExceededFault(crate::error::ApiCallRateForCustomerExceededFault),
    InvalidCacheClusterStateFault(crate::error::InvalidCacheClusterStateFault),
    InvalidKmsKeyFault(crate::error::InvalidKmsKeyFault),
    InvalidParameterCombinationException(crate::error::InvalidParameterCombinationException),
    InvalidParameterValueException(crate::error::InvalidParameterValueException),
    InvalidReplicationGroupStateFault(crate::error::InvalidReplicationGroupStateFault),
    NodeGroupNotFoundFault(crate::error::NodeGroupNotFoundFault),
    ReplicationGroupNotFoundFault(crate::error::ReplicationGroupNotFoundFault),
    TestFailoverNotAvailableFault(crate::error::TestFailoverNotAvailableFault),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestFailoverError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestFailoverErrorKind::ApiCallRateForCustomerExceededFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::InvalidCacheClusterStateFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::InvalidKmsKeyFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::InvalidParameterCombinationException(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::InvalidParameterValueException(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::InvalidReplicationGroupStateFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::NodeGroupNotFoundFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::ReplicationGroupNotFoundFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::TestFailoverNotAvailableFault(_inner) => _inner.fmt(f),
            TestFailoverErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestFailoverError {
    fn code(&self) -> Option<&str> {
        TestFailoverError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestFailoverError {
    pub fn new(kind: TestFailoverErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestFailoverErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestFailoverErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_api_call_rate_for_customer_exceeded_fault(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::ApiCallRateForCustomerExceededFault(_)
        )
    }
    pub fn is_invalid_cache_cluster_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::InvalidCacheClusterStateFault(_)
        )
    }
    pub fn is_invalid_kms_key_fault(&self) -> bool {
        matches!(&self.kind, TestFailoverErrorKind::InvalidKmsKeyFault(_))
    }
    pub fn is_invalid_parameter_combination_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::InvalidParameterCombinationException(_)
        )
    }
    pub fn is_invalid_parameter_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::InvalidParameterValueException(_)
        )
    }
    pub fn is_invalid_replication_group_state_fault(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::InvalidReplicationGroupStateFault(_)
        )
    }
    pub fn is_node_group_not_found_fault(&self) -> bool {
        matches!(&self.kind, TestFailoverErrorKind::NodeGroupNotFoundFault(_))
    }
    pub fn is_replication_group_not_found_fault(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::ReplicationGroupNotFoundFault(_)
        )
    }
    pub fn is_test_failover_not_available_fault(&self) -> bool {
        matches!(
            &self.kind,
            TestFailoverErrorKind::TestFailoverNotAvailableFault(_)
        )
    }
}
impl std::error::Error for TestFailoverError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestFailoverErrorKind::ApiCallRateForCustomerExceededFault(_inner) => Some(_inner),
            TestFailoverErrorKind::InvalidCacheClusterStateFault(_inner) => Some(_inner),
            TestFailoverErrorKind::InvalidKmsKeyFault(_inner) => Some(_inner),
            TestFailoverErrorKind::InvalidParameterCombinationException(_inner) => Some(_inner),
            TestFailoverErrorKind::InvalidParameterValueException(_inner) => Some(_inner),
            TestFailoverErrorKind::InvalidReplicationGroupStateFault(_inner) => Some(_inner),
            TestFailoverErrorKind::NodeGroupNotFoundFault(_inner) => Some(_inner),
            TestFailoverErrorKind::ReplicationGroupNotFoundFault(_inner) => Some(_inner),
            TestFailoverErrorKind::TestFailoverNotAvailableFault(_inner) => Some(_inner),
            TestFailoverErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The <code>TestFailover</code> action is not available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TestFailoverNotAvailableFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TestFailoverNotAvailableFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TestFailoverNotAvailableFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TestFailoverNotAvailableFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TestFailoverNotAvailableFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TestFailoverNotAvailableFault")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TestFailoverNotAvailableFault {}
/// See [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault)
pub mod test_failover_not_available_fault {
    /// A builder for [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault)
        pub fn build(self) -> crate::error::TestFailoverNotAvailableFault {
            crate::error::TestFailoverNotAvailableFault {
                message: self.message,
            }
        }
    }
}
impl TestFailoverNotAvailableFault {
    /// Creates a new builder-style object to manufacture [`TestFailoverNotAvailableFault`](crate::error::TestFailoverNotAvailableFault)
    pub fn builder() -> crate::error::test_failover_not_available_fault::Builder {
        crate::error::test_failover_not_available_fault::Builder::default()
    }
}

/// <p>The specified replication group does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicationGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplicationGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplicationGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicationGroupNotFoundFault")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplicationGroupNotFoundFault {}
/// See [`ReplicationGroupNotFoundFault`](crate::error::ReplicationGroupNotFoundFault)
pub mod replication_group_not_found_fault {
    /// A builder for [`ReplicationGroupNotFoundFault`](crate::error::ReplicationGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationGroupNotFoundFault`](crate::error::ReplicationGroupNotFoundFault)
        pub fn build(self) -> crate::error::ReplicationGroupNotFoundFault {
            crate::error::ReplicationGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReplicationGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReplicationGroupNotFoundFault`](crate::error::ReplicationGroupNotFoundFault)
    pub fn builder() -> crate::error::replication_group_not_found_fault::Builder {
        crate::error::replication_group_not_found_fault::Builder::default()
    }
}

/// <p>The node group specified by the <code>NodeGroupId</code> parameter could not be found.
/// Please verify that the node group exists and that you spelled the <code>NodeGroupId</code> value correctly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NodeGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NodeGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NodeGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NodeGroupNotFoundFault")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for NodeGroupNotFoundFault {}
/// See [`NodeGroupNotFoundFault`](crate::error::NodeGroupNotFoundFault)
pub mod node_group_not_found_fault {
    /// A builder for [`NodeGroupNotFoundFault`](crate::error::NodeGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeGroupNotFoundFault`](crate::error::NodeGroupNotFoundFault)
        pub fn build(self) -> crate::error::NodeGroupNotFoundFault {
            crate::error::NodeGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl NodeGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`NodeGroupNotFoundFault`](crate::error::NodeGroupNotFoundFault)
    pub fn builder() -> crate::error::node_group_not_found_fault::Builder {
        crate::error::node_group_not_found_fault::Builder::default()
    }
}

/// <p>The requested replication group is not in the <code>available</code> state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReplicationGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReplicationGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReplicationGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReplicationGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplicationGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplicationGroupStateFault")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplicationGroupStateFault {}
/// See [`InvalidReplicationGroupStateFault`](crate::error::InvalidReplicationGroupStateFault)
pub mod invalid_replication_group_state_fault {
    /// A builder for [`InvalidReplicationGroupStateFault`](crate::error::InvalidReplicationGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplicationGroupStateFault`](crate::error::InvalidReplicationGroupStateFault)
        pub fn build(self) -> crate::error::InvalidReplicationGroupStateFault {
            crate::error::InvalidReplicationGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidReplicationGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidReplicationGroupStateFault`](crate::error::InvalidReplicationGroupStateFault)
    pub fn builder() -> crate::error::invalid_replication_group_state_fault::Builder {
        crate::error::invalid_replication_group_state_fault::Builder::default()
    }
}

/// <p>The value for a parameter is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterValueException {
    /// <p>A parameter value is invalid.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterValueException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterValueException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterValueException {}
/// See [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
pub mod invalid_parameter_value_exception {
    /// A builder for [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A parameter value is invalid.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
        pub fn build(self) -> crate::error::InvalidParameterValueException {
            crate::error::InvalidParameterValueException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterValueException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterValueException`](crate::error::InvalidParameterValueException)
    pub fn builder() -> crate::error::invalid_parameter_value_exception::Builder {
        crate::error::invalid_parameter_value_exception::Builder::default()
    }
}

/// <p>Two or more incompatible parameters were specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterCombinationException {
    /// <p>Two or more parameters that must not be used together were used together.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterCombinationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterCombinationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterCombinationException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterCombinationException {}
/// See [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
pub mod invalid_parameter_combination_exception {
    /// A builder for [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Two or more parameters that must not be used together were used together.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
        pub fn build(self) -> crate::error::InvalidParameterCombinationException {
            crate::error::InvalidParameterCombinationException {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterCombinationException {
    /// Creates a new builder-style object to manufacture [`InvalidParameterCombinationException`](crate::error::InvalidParameterCombinationException)
    pub fn builder() -> crate::error::invalid_parameter_combination_exception::Builder {
        crate::error::invalid_parameter_combination_exception::Builder::default()
    }
}

/// <p>The KMS key supplied is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidKmsKeyFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidKmsKeyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidKmsKeyFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidKmsKeyFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKmsKeyFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKmsKeyFault [InvalidKMSKeyFault]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKmsKeyFault {}
/// See [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault)
pub mod invalid_kms_key_fault {
    /// A builder for [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault)
        pub fn build(self) -> crate::error::InvalidKmsKeyFault {
            crate::error::InvalidKmsKeyFault {
                message: self.message,
            }
        }
    }
}
impl InvalidKmsKeyFault {
    /// Creates a new builder-style object to manufacture [`InvalidKmsKeyFault`](crate::error::InvalidKmsKeyFault)
    pub fn builder() -> crate::error::invalid_kms_key_fault::Builder {
        crate::error::invalid_kms_key_fault::Builder::default()
    }
}

/// <p>The requested cluster is not in the <code>available</code> state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCacheClusterStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCacheClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCacheClusterStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCacheClusterStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCacheClusterStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCacheClusterStateFault")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCacheClusterStateFault {}
/// See [`InvalidCacheClusterStateFault`](crate::error::InvalidCacheClusterStateFault)
pub mod invalid_cache_cluster_state_fault {
    /// A builder for [`InvalidCacheClusterStateFault`](crate::error::InvalidCacheClusterStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCacheClusterStateFault`](crate::error::InvalidCacheClusterStateFault)
        pub fn build(self) -> crate::error::InvalidCacheClusterStateFault {
            crate::error::InvalidCacheClusterStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidCacheClusterStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidCacheClusterStateFault`](crate::error::InvalidCacheClusterStateFault)
    pub fn builder() -> crate::error::invalid_cache_cluster_state_fault::Builder {
        crate::error::invalid_cache_cluster_state_fault::Builder::default()
    }
}

/// <p>The customer has exceeded the allowed rate of API calls.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApiCallRateForCustomerExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApiCallRateForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApiCallRateForCustomerExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApiCallRateForCustomerExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApiCallRateForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "ApiCallRateForCustomerExceededFault [APICallRateForCustomerExceededFault]"
        )?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApiCallRateForCustomerExceededFault {}
/// See [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault)
pub mod api_call_rate_for_customer_exceeded_fault {
    /// A builder for [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault)
        pub fn build(self) -> crate::error::ApiCallRateForCustomerExceededFault {
            crate::error::ApiCallRateForCustomerExceededFault {
                message: self.message,
            }
        }
    }
}
impl ApiCallRateForCustomerExceededFault {
    /// Creates a new builder-style object to manufacture [`ApiCallRateForCustomerExceededFault`](crate::error::ApiCallRateForCustomerExceededFault)
    pub fn builder() -> crate::error::api_call_rate_for_customer_exceeded_fault::Builder {
        crate::error::api_call_rate_for_customer_exceeded_fault::Builder::default()
    }
}

/// <p>The targeted replication group is not available. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationGroupAlreadyUnderMigrationFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicationGroupAlreadyUnderMigrationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationGroupAlreadyUnderMigrationFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplicationGroupAlreadyUnderMigrationFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplicationGroupAlreadyUnderMigrationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicationGroupAlreadyUnderMigrationFault")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplicationGroupAlreadyUnderMigrationFault {}
/// See [`ReplicationGroupAlreadyUnderMigrationFault`](crate::error::ReplicationGroupAlreadyUnderMigrationFault)
pub mod replication_group_already_under_migration_fault {
    /// A builder for [`ReplicationGroupAlreadyUnderMigrationFault`](crate::error::ReplicationGroupAlreadyUnderMigrationFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationGroupAlreadyUnderMigrationFault`](crate::error::ReplicationGroupAlreadyUnderMigrationFault)
        pub fn build(self) -> crate::error::ReplicationGroupAlreadyUnderMigrationFault {
            crate::error::ReplicationGroupAlreadyUnderMigrationFault {
                message: self.message,
            }
        }
    }
}
impl ReplicationGroupAlreadyUnderMigrationFault {
    /// Creates a new builder-style object to manufacture [`ReplicationGroupAlreadyUnderMigrationFault`](crate::error::ReplicationGroupAlreadyUnderMigrationFault)
    pub fn builder() -> crate::error::replication_group_already_under_migration_fault::Builder {
        crate::error::replication_group_already_under_migration_fault::Builder::default()
    }
}

/// <p>The current state of the cache security group does not allow deletion.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCacheSecurityGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCacheSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCacheSecurityGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCacheSecurityGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCacheSecurityGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCacheSecurityGroupStateFault")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCacheSecurityGroupStateFault {}
/// See [`InvalidCacheSecurityGroupStateFault`](crate::error::InvalidCacheSecurityGroupStateFault)
pub mod invalid_cache_security_group_state_fault {
    /// A builder for [`InvalidCacheSecurityGroupStateFault`](crate::error::InvalidCacheSecurityGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCacheSecurityGroupStateFault`](crate::error::InvalidCacheSecurityGroupStateFault)
        pub fn build(self) -> crate::error::InvalidCacheSecurityGroupStateFault {
            crate::error::InvalidCacheSecurityGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidCacheSecurityGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidCacheSecurityGroupStateFault`](crate::error::InvalidCacheSecurityGroupStateFault)
    pub fn builder() -> crate::error::invalid_cache_security_group_state_fault::Builder {
        crate::error::invalid_cache_security_group_state_fault::Builder::default()
    }
}

/// <p>The requested cache security group name does not refer to an existing cache security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSecurityGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSecurityGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSecurityGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSecurityGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSecurityGroupNotFoundFault")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSecurityGroupNotFoundFault {}
/// See [`CacheSecurityGroupNotFoundFault`](crate::error::CacheSecurityGroupNotFoundFault)
pub mod cache_security_group_not_found_fault {
    /// A builder for [`CacheSecurityGroupNotFoundFault`](crate::error::CacheSecurityGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSecurityGroupNotFoundFault`](crate::error::CacheSecurityGroupNotFoundFault)
        pub fn build(self) -> crate::error::CacheSecurityGroupNotFoundFault {
            crate::error::CacheSecurityGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CacheSecurityGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CacheSecurityGroupNotFoundFault`](crate::error::CacheSecurityGroupNotFoundFault)
    pub fn builder() -> crate::error::cache_security_group_not_found_fault::Builder {
        crate::error::cache_security_group_not_found_fault::Builder::default()
    }
}

/// <p>The specified Amazon EC2 security group is not authorized for the specified cache security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationNotFoundFault")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationNotFoundFault {}
/// See [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
pub mod authorization_not_found_fault {
    /// A builder for [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
        pub fn build(self) -> crate::error::AuthorizationNotFoundFault {
            crate::error::AuthorizationNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationNotFoundFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationNotFoundFault`](crate::error::AuthorizationNotFoundFault)
    pub fn builder() -> crate::error::authorization_not_found_fault::Builder {
        crate::error::authorization_not_found_fault::Builder::default()
    }
}

/// <p>The Global datastore is not available or in primary-only state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidGlobalReplicationGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidGlobalReplicationGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidGlobalReplicationGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidGlobalReplicationGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGlobalReplicationGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGlobalReplicationGroupStateFault")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGlobalReplicationGroupStateFault {}
/// See [`InvalidGlobalReplicationGroupStateFault`](crate::error::InvalidGlobalReplicationGroupStateFault)
pub mod invalid_global_replication_group_state_fault {
    /// A builder for [`InvalidGlobalReplicationGroupStateFault`](crate::error::InvalidGlobalReplicationGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGlobalReplicationGroupStateFault`](crate::error::InvalidGlobalReplicationGroupStateFault)
        pub fn build(self) -> crate::error::InvalidGlobalReplicationGroupStateFault {
            crate::error::InvalidGlobalReplicationGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidGlobalReplicationGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidGlobalReplicationGroupStateFault`](crate::error::InvalidGlobalReplicationGroupStateFault)
    pub fn builder() -> crate::error::invalid_global_replication_group_state_fault::Builder {
        crate::error::invalid_global_replication_group_state_fault::Builder::default()
    }
}

/// <p>The current state of the cache parameter group does not allow the requested operation to occur.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCacheParameterGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCacheParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCacheParameterGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCacheParameterGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCacheParameterGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCacheParameterGroupStateFault")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCacheParameterGroupStateFault {}
/// See [`InvalidCacheParameterGroupStateFault`](crate::error::InvalidCacheParameterGroupStateFault)
pub mod invalid_cache_parameter_group_state_fault {
    /// A builder for [`InvalidCacheParameterGroupStateFault`](crate::error::InvalidCacheParameterGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCacheParameterGroupStateFault`](crate::error::InvalidCacheParameterGroupStateFault)
        pub fn build(self) -> crate::error::InvalidCacheParameterGroupStateFault {
            crate::error::InvalidCacheParameterGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidCacheParameterGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidCacheParameterGroupStateFault`](crate::error::InvalidCacheParameterGroupStateFault)
    pub fn builder() -> crate::error::invalid_cache_parameter_group_state_fault::Builder {
        crate::error::invalid_cache_parameter_group_state_fault::Builder::default()
    }
}

/// <p>The requested cache parameter group name does not refer to an existing cache parameter group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheParameterGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheParameterGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheParameterGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheParameterGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheParameterGroupNotFoundFault")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheParameterGroupNotFoundFault {}
/// See [`CacheParameterGroupNotFoundFault`](crate::error::CacheParameterGroupNotFoundFault)
pub mod cache_parameter_group_not_found_fault {
    /// A builder for [`CacheParameterGroupNotFoundFault`](crate::error::CacheParameterGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheParameterGroupNotFoundFault`](crate::error::CacheParameterGroupNotFoundFault)
        pub fn build(self) -> crate::error::CacheParameterGroupNotFoundFault {
            crate::error::CacheParameterGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CacheParameterGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CacheParameterGroupNotFoundFault`](crate::error::CacheParameterGroupNotFoundFault)
    pub fn builder() -> crate::error::cache_parameter_group_not_found_fault::Builder {
        crate::error::cache_parameter_group_not_found_fault::Builder::default()
    }
}

/// <p>The user does not exist or could not be found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserNotFoundFault")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserNotFoundFault {}
/// See [`UserNotFoundFault`](crate::error::UserNotFoundFault)
pub mod user_not_found_fault {
    /// A builder for [`UserNotFoundFault`](crate::error::UserNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserNotFoundFault`](crate::error::UserNotFoundFault)
        pub fn build(self) -> crate::error::UserNotFoundFault {
            crate::error::UserNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl UserNotFoundFault {
    /// Creates a new builder-style object to manufacture [`UserNotFoundFault`](crate::error::UserNotFoundFault)
    pub fn builder() -> crate::error::user_not_found_fault::Builder {
        crate::error::user_not_found_fault::Builder::default()
    }
}

/// <p>The user group was not found or does not exist</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserGroupNotFoundFault")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserGroupNotFoundFault {}
/// See [`UserGroupNotFoundFault`](crate::error::UserGroupNotFoundFault)
pub mod user_group_not_found_fault {
    /// A builder for [`UserGroupNotFoundFault`](crate::error::UserGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserGroupNotFoundFault`](crate::error::UserGroupNotFoundFault)
        pub fn build(self) -> crate::error::UserGroupNotFoundFault {
            crate::error::UserGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl UserGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`UserGroupNotFoundFault`](crate::error::UserGroupNotFoundFault)
    pub fn builder() -> crate::error::user_group_not_found_fault::Builder {
        crate::error::user_group_not_found_fault::Builder::default()
    }
}

/// <p>The requested tag was not found on this resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagNotFoundFault")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagNotFoundFault {}
/// See [`TagNotFoundFault`](crate::error::TagNotFoundFault)
pub mod tag_not_found_fault {
    /// A builder for [`TagNotFoundFault`](crate::error::TagNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagNotFoundFault`](crate::error::TagNotFoundFault)
        pub fn build(self) -> crate::error::TagNotFoundFault {
            crate::error::TagNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl TagNotFoundFault {
    /// Creates a new builder-style object to manufacture [`TagNotFoundFault`](crate::error::TagNotFoundFault)
    pub fn builder() -> crate::error::tag_not_found_fault::Builder {
        crate::error::tag_not_found_fault::Builder::default()
    }
}

/// <p>The requested snapshot name does not refer to an existing snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnapshotNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotNotFoundFault")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotNotFoundFault {}
/// See [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault)
pub mod snapshot_not_found_fault {
    /// A builder for [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault)
        pub fn build(self) -> crate::error::SnapshotNotFoundFault {
            crate::error::SnapshotNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl SnapshotNotFoundFault {
    /// Creates a new builder-style object to manufacture [`SnapshotNotFoundFault`](crate::error::SnapshotNotFoundFault)
    pub fn builder() -> crate::error::snapshot_not_found_fault::Builder {
        crate::error::snapshot_not_found_fault::Builder::default()
    }
}

/// <p>The requested reserved cache node was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedCacheNodeNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedCacheNodeNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedCacheNodeNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedCacheNodeNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedCacheNodeNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedCacheNodeNotFoundFault")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedCacheNodeNotFoundFault {}
/// See [`ReservedCacheNodeNotFoundFault`](crate::error::ReservedCacheNodeNotFoundFault)
pub mod reserved_cache_node_not_found_fault {
    /// A builder for [`ReservedCacheNodeNotFoundFault`](crate::error::ReservedCacheNodeNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedCacheNodeNotFoundFault`](crate::error::ReservedCacheNodeNotFoundFault)
        pub fn build(self) -> crate::error::ReservedCacheNodeNotFoundFault {
            crate::error::ReservedCacheNodeNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReservedCacheNodeNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedCacheNodeNotFoundFault`](crate::error::ReservedCacheNodeNotFoundFault)
    pub fn builder() -> crate::error::reserved_cache_node_not_found_fault::Builder {
        crate::error::reserved_cache_node_not_found_fault::Builder::default()
    }
}

/// <p>The requested Amazon Resource Name (ARN) does not refer to an existing resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidArnFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidArnFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidArnFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidArnFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArnFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnFault [InvalidARNFault]")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArnFault {}
/// See [`InvalidArnFault`](crate::error::InvalidArnFault)
pub mod invalid_arn_fault {
    /// A builder for [`InvalidArnFault`](crate::error::InvalidArnFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnFault`](crate::error::InvalidArnFault)
        pub fn build(self) -> crate::error::InvalidArnFault {
            crate::error::InvalidArnFault {
                message: self.message,
            }
        }
    }
}
impl InvalidArnFault {
    /// Creates a new builder-style object to manufacture [`InvalidArnFault`](crate::error::InvalidArnFault)
    pub fn builder() -> crate::error::invalid_arn_fault::Builder {
        crate::error::invalid_arn_fault::Builder::default()
    }
}

/// <p>The requested cache subnet group name does not refer to an existing cache subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSubnetGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSubnetGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSubnetGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSubnetGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSubnetGroupNotFoundFault")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSubnetGroupNotFoundFault {}
/// See [`CacheSubnetGroupNotFoundFault`](crate::error::CacheSubnetGroupNotFoundFault)
pub mod cache_subnet_group_not_found_fault {
    /// A builder for [`CacheSubnetGroupNotFoundFault`](crate::error::CacheSubnetGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSubnetGroupNotFoundFault`](crate::error::CacheSubnetGroupNotFoundFault)
        pub fn build(self) -> crate::error::CacheSubnetGroupNotFoundFault {
            crate::error::CacheSubnetGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CacheSubnetGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CacheSubnetGroupNotFoundFault`](crate::error::CacheSubnetGroupNotFoundFault)
    pub fn builder() -> crate::error::cache_subnet_group_not_found_fault::Builder {
        crate::error::cache_subnet_group_not_found_fault::Builder::default()
    }
}

/// <p>The requested cluster ID does not refer to an existing cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheClusterNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheClusterNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheClusterNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheClusterNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheClusterNotFoundFault")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheClusterNotFoundFault {}
/// See [`CacheClusterNotFoundFault`](crate::error::CacheClusterNotFoundFault)
pub mod cache_cluster_not_found_fault {
    /// A builder for [`CacheClusterNotFoundFault`](crate::error::CacheClusterNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheClusterNotFoundFault`](crate::error::CacheClusterNotFoundFault)
        pub fn build(self) -> crate::error::CacheClusterNotFoundFault {
            crate::error::CacheClusterNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl CacheClusterNotFoundFault {
    /// Creates a new builder-style object to manufacture [`CacheClusterNotFoundFault`](crate::error::CacheClusterNotFoundFault)
    pub fn builder() -> crate::error::cache_cluster_not_found_fault::Builder {
        crate::error::cache_cluster_not_found_fault::Builder::default()
    }
}

/// <p>The Global datastore does not exist</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalReplicationGroupNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalReplicationGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalReplicationGroupNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalReplicationGroupNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalReplicationGroupNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalReplicationGroupNotFoundFault")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalReplicationGroupNotFoundFault {}
/// See [`GlobalReplicationGroupNotFoundFault`](crate::error::GlobalReplicationGroupNotFoundFault)
pub mod global_replication_group_not_found_fault {
    /// A builder for [`GlobalReplicationGroupNotFoundFault`](crate::error::GlobalReplicationGroupNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalReplicationGroupNotFoundFault`](crate::error::GlobalReplicationGroupNotFoundFault)
        pub fn build(self) -> crate::error::GlobalReplicationGroupNotFoundFault {
            crate::error::GlobalReplicationGroupNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl GlobalReplicationGroupNotFoundFault {
    /// Creates a new builder-style object to manufacture [`GlobalReplicationGroupNotFoundFault`](crate::error::GlobalReplicationGroupNotFoundFault)
    pub fn builder() -> crate::error::global_replication_group_not_found_fault::Builder {
        crate::error::global_replication_group_not_found_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would cause the resource to have more than the allowed number of tags. The maximum number of tags permitted on a resource is 50.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagQuotaPerResourceExceeded {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagQuotaPerResourceExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagQuotaPerResourceExceeded");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagQuotaPerResourceExceeded {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagQuotaPerResourceExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagQuotaPerResourceExceeded")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagQuotaPerResourceExceeded {}
/// See [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded)
pub mod tag_quota_per_resource_exceeded {
    /// A builder for [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded)
        pub fn build(self) -> crate::error::TagQuotaPerResourceExceeded {
            crate::error::TagQuotaPerResourceExceeded {
                message: self.message,
            }
        }
    }
}
impl TagQuotaPerResourceExceeded {
    /// Creates a new builder-style object to manufacture [`TagQuotaPerResourceExceeded`](crate::error::TagQuotaPerResourceExceeded)
    pub fn builder() -> crate::error::tag_quota_per_resource_exceeded::Builder {
        crate::error::tag_quota_per_resource_exceeded::Builder::default()
    }
}

/// <p>The requested cache node offering does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedCacheNodesOfferingNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedCacheNodesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedCacheNodesOfferingNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedCacheNodesOfferingNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedCacheNodesOfferingNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedCacheNodesOfferingNotFoundFault")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedCacheNodesOfferingNotFoundFault {}
/// See [`ReservedCacheNodesOfferingNotFoundFault`](crate::error::ReservedCacheNodesOfferingNotFoundFault)
pub mod reserved_cache_nodes_offering_not_found_fault {
    /// A builder for [`ReservedCacheNodesOfferingNotFoundFault`](crate::error::ReservedCacheNodesOfferingNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedCacheNodesOfferingNotFoundFault`](crate::error::ReservedCacheNodesOfferingNotFoundFault)
        pub fn build(self) -> crate::error::ReservedCacheNodesOfferingNotFoundFault {
            crate::error::ReservedCacheNodesOfferingNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ReservedCacheNodesOfferingNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ReservedCacheNodesOfferingNotFoundFault`](crate::error::ReservedCacheNodesOfferingNotFoundFault)
    pub fn builder() -> crate::error::reserved_cache_nodes_offering_not_found_fault::Builder {
        crate::error::reserved_cache_nodes_offering_not_found_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the user's cache node quota.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedCacheNodeQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedCacheNodeQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedCacheNodeQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedCacheNodeQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedCacheNodeQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedCacheNodeQuotaExceededFault")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedCacheNodeQuotaExceededFault {}
/// See [`ReservedCacheNodeQuotaExceededFault`](crate::error::ReservedCacheNodeQuotaExceededFault)
pub mod reserved_cache_node_quota_exceeded_fault {
    /// A builder for [`ReservedCacheNodeQuotaExceededFault`](crate::error::ReservedCacheNodeQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedCacheNodeQuotaExceededFault`](crate::error::ReservedCacheNodeQuotaExceededFault)
        pub fn build(self) -> crate::error::ReservedCacheNodeQuotaExceededFault {
            crate::error::ReservedCacheNodeQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl ReservedCacheNodeQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`ReservedCacheNodeQuotaExceededFault`](crate::error::ReservedCacheNodeQuotaExceededFault)
    pub fn builder() -> crate::error::reserved_cache_node_quota_exceeded_fault::Builder {
        crate::error::reserved_cache_node_quota_exceeded_fault::Builder::default()
    }
}

/// <p>You already have a reservation with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReservedCacheNodeAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReservedCacheNodeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReservedCacheNodeAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReservedCacheNodeAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReservedCacheNodeAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReservedCacheNodeAlreadyExistsFault")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReservedCacheNodeAlreadyExistsFault {}
/// See [`ReservedCacheNodeAlreadyExistsFault`](crate::error::ReservedCacheNodeAlreadyExistsFault)
pub mod reserved_cache_node_already_exists_fault {
    /// A builder for [`ReservedCacheNodeAlreadyExistsFault`](crate::error::ReservedCacheNodeAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReservedCacheNodeAlreadyExistsFault`](crate::error::ReservedCacheNodeAlreadyExistsFault)
        pub fn build(self) -> crate::error::ReservedCacheNodeAlreadyExistsFault {
            crate::error::ReservedCacheNodeAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl ReservedCacheNodeAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ReservedCacheNodeAlreadyExistsFault`](crate::error::ReservedCacheNodeAlreadyExistsFault)
    pub fn builder() -> crate::error::reserved_cache_node_already_exists_fault::Builder {
        crate::error::reserved_cache_node_already_exists_fault::Builder::default()
    }
}

/// <p>The user group is not in an active state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidUserGroupStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidUserGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidUserGroupStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidUserGroupStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUserGroupStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUserGroupStateFault")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUserGroupStateFault {}
/// See [`InvalidUserGroupStateFault`](crate::error::InvalidUserGroupStateFault)
pub mod invalid_user_group_state_fault {
    /// A builder for [`InvalidUserGroupStateFault`](crate::error::InvalidUserGroupStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUserGroupStateFault`](crate::error::InvalidUserGroupStateFault)
        pub fn build(self) -> crate::error::InvalidUserGroupStateFault {
            crate::error::InvalidUserGroupStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidUserGroupStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidUserGroupStateFault`](crate::error::InvalidUserGroupStateFault)
    pub fn builder() -> crate::error::invalid_user_group_state_fault::Builder {
        crate::error::invalid_user_group_state_fault::Builder::default()
    }
}

/// <p>A user with this username already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateUserNameFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateUserNameFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateUserNameFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateUserNameFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateUserNameFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateUserNameFault")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateUserNameFault {}
/// See [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault)
pub mod duplicate_user_name_fault {
    /// A builder for [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault)
        pub fn build(self) -> crate::error::DuplicateUserNameFault {
            crate::error::DuplicateUserNameFault {
                message: self.message,
            }
        }
    }
}
impl DuplicateUserNameFault {
    /// Creates a new builder-style object to manufacture [`DuplicateUserNameFault`](crate::error::DuplicateUserNameFault)
    pub fn builder() -> crate::error::duplicate_user_name_fault::Builder {
        crate::error::duplicate_user_name_fault::Builder::default()
    }
}

/// <p>You must add default user to a user group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultUserRequired {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultUserRequired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultUserRequired");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DefaultUserRequired {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultUserRequired {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultUserRequired")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for DefaultUserRequired {}
/// See [`DefaultUserRequired`](crate::error::DefaultUserRequired)
pub mod default_user_required {
    /// A builder for [`DefaultUserRequired`](crate::error::DefaultUserRequired)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultUserRequired`](crate::error::DefaultUserRequired)
        pub fn build(self) -> crate::error::DefaultUserRequired {
            crate::error::DefaultUserRequired {
                message: self.message,
            }
        }
    }
}
impl DefaultUserRequired {
    /// Creates a new builder-style object to manufacture [`DefaultUserRequired`](crate::error::DefaultUserRequired)
    pub fn builder() -> crate::error::default_user_required::Builder {
        crate::error::default_user_required::Builder::default()
    }
}

/// <p>The user is not in active state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidUserStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidUserStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidUserStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidUserStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUserStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUserStateFault")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUserStateFault {}
/// See [`InvalidUserStateFault`](crate::error::InvalidUserStateFault)
pub mod invalid_user_state_fault {
    /// A builder for [`InvalidUserStateFault`](crate::error::InvalidUserStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUserStateFault`](crate::error::InvalidUserStateFault)
        pub fn build(self) -> crate::error::InvalidUserStateFault {
            crate::error::InvalidUserStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidUserStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidUserStateFault`](crate::error::InvalidUserStateFault)
    pub fn builder() -> crate::error::invalid_user_state_fault::Builder {
        crate::error::invalid_user_state_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of cache nodes per customer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeQuotaForCustomerExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NodeQuotaForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeQuotaForCustomerExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NodeQuotaForCustomerExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NodeQuotaForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NodeQuotaForCustomerExceededFault")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for NodeQuotaForCustomerExceededFault {}
/// See [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault)
pub mod node_quota_for_customer_exceeded_fault {
    /// A builder for [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault)
        pub fn build(self) -> crate::error::NodeQuotaForCustomerExceededFault {
            crate::error::NodeQuotaForCustomerExceededFault {
                message: self.message,
            }
        }
    }
}
impl NodeQuotaForCustomerExceededFault {
    /// Creates a new builder-style object to manufacture [`NodeQuotaForCustomerExceededFault`](crate::error::NodeQuotaForCustomerExceededFault)
    pub fn builder() -> crate::error::node_quota_for_customer_exceeded_fault::Builder {
        crate::error::node_quota_for_customer_exceeded_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the maximum allowed number
/// of node groups (shards) in a single replication group. The default maximum is 90</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeGroupsPerReplicationGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NodeGroupsPerReplicationGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeGroupsPerReplicationGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NodeGroupsPerReplicationGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NodeGroupsPerReplicationGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NodeGroupsPerReplicationGroupQuotaExceededFault")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for NodeGroupsPerReplicationGroupQuotaExceededFault {}
/// See [`NodeGroupsPerReplicationGroupQuotaExceededFault`](crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault)
pub mod node_groups_per_replication_group_quota_exceeded_fault {
    /// A builder for [`NodeGroupsPerReplicationGroupQuotaExceededFault`](crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeGroupsPerReplicationGroupQuotaExceededFault`](crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault {
            crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl NodeGroupsPerReplicationGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`NodeGroupsPerReplicationGroupQuotaExceededFault`](crate::error::NodeGroupsPerReplicationGroupQuotaExceededFault)
    pub fn builder() -> crate::error::node_groups_per_replication_group_quota_exceeded_fault::Builder
    {
        crate::error::node_groups_per_replication_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The VPC network is in an invalid state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidVpcNetworkStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidVpcNetworkStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidVpcNetworkStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidVpcNetworkStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidVpcNetworkStateFault [InvalidVPCNetworkStateFault]"
        )?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidVpcNetworkStateFault {}
/// See [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
pub mod invalid_vpc_network_state_fault {
    /// A builder for [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
        pub fn build(self) -> crate::error::InvalidVpcNetworkStateFault {
            crate::error::InvalidVpcNetworkStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidVpcNetworkStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidVpcNetworkStateFault`](crate::error::InvalidVpcNetworkStateFault)
    pub fn builder() -> crate::error::invalid_vpc_network_state_fault::Builder {
        crate::error::invalid_vpc_network_state_fault::Builder::default()
    }
}

/// <p>The requested cache node type is not available in the specified Availability Zone.
/// For more information, see <a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/ErrorMessages.html#ErrorMessages.INSUFFICIENT_CACHE_CLUSTER_CAPACITY">InsufficientCacheClusterCapacity</a> in the ElastiCache User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InsufficientCacheClusterCapacityFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InsufficientCacheClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InsufficientCacheClusterCapacityFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InsufficientCacheClusterCapacityFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InsufficientCacheClusterCapacityFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InsufficientCacheClusterCapacityFault")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for InsufficientCacheClusterCapacityFault {}
/// See [`InsufficientCacheClusterCapacityFault`](crate::error::InsufficientCacheClusterCapacityFault)
pub mod insufficient_cache_cluster_capacity_fault {
    /// A builder for [`InsufficientCacheClusterCapacityFault`](crate::error::InsufficientCacheClusterCapacityFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InsufficientCacheClusterCapacityFault`](crate::error::InsufficientCacheClusterCapacityFault)
        pub fn build(self) -> crate::error::InsufficientCacheClusterCapacityFault {
            crate::error::InsufficientCacheClusterCapacityFault {
                message: self.message,
            }
        }
    }
}
impl InsufficientCacheClusterCapacityFault {
    /// Creates a new builder-style object to manufacture [`InsufficientCacheClusterCapacityFault`](crate::error::InsufficientCacheClusterCapacityFault)
    pub fn builder() -> crate::error::insufficient_cache_cluster_capacity_fault::Builder {
        crate::error::insufficient_cache_cluster_capacity_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of cache nodes in a single cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NodeQuotaForClusterExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NodeQuotaForClusterExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NodeQuotaForClusterExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NodeQuotaForClusterExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NodeQuotaForClusterExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NodeQuotaForClusterExceededFault")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for NodeQuotaForClusterExceededFault {}
/// See [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault)
pub mod node_quota_for_cluster_exceeded_fault {
    /// A builder for [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault)
        pub fn build(self) -> crate::error::NodeQuotaForClusterExceededFault {
            crate::error::NodeQuotaForClusterExceededFault {
                message: self.message,
            }
        }
    }
}
impl NodeQuotaForClusterExceededFault {
    /// Creates a new builder-style object to manufacture [`NodeQuotaForClusterExceededFault`](crate::error::NodeQuotaForClusterExceededFault)
    pub fn builder() -> crate::error::node_quota_for_cluster_exceeded_fault::Builder {
        crate::error::node_quota_for_cluster_exceeded_fault::Builder::default()
    }
}

/// <p>At least one subnet ID does not match the other subnet IDs. This mismatch typically occurs when a
/// user sets one subnet ID to a regional Availability Zone and a different one to an outpost. Or when a user sets the subnet ID to an Outpost when not subscribed on this service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetNotAllowedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetNotAllowedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubnetNotAllowedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetNotAllowedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetNotAllowedFault")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubnetNotAllowedFault {}
/// See [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault)
pub mod subnet_not_allowed_fault {
    /// A builder for [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault)
        pub fn build(self) -> crate::error::SubnetNotAllowedFault {
            crate::error::SubnetNotAllowedFault {
                message: self.message,
            }
        }
    }
}
impl SubnetNotAllowedFault {
    /// Creates a new builder-style object to manufacture [`SubnetNotAllowedFault`](crate::error::SubnetNotAllowedFault)
    pub fn builder() -> crate::error::subnet_not_allowed_fault::Builder {
        crate::error::subnet_not_allowed_fault::Builder::default()
    }
}

/// <p>The requested subnet is being used by another cache subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SubnetInUse {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SubnetInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SubnetInUse");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SubnetInUse {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SubnetInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SubnetInUse")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for SubnetInUse {}
/// See [`SubnetInUse`](crate::error::SubnetInUse)
pub mod subnet_in_use {
    /// A builder for [`SubnetInUse`](crate::error::SubnetInUse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SubnetInUse`](crate::error::SubnetInUse)
        pub fn build(self) -> crate::error::SubnetInUse {
            crate::error::SubnetInUse {
                message: self.message,
            }
        }
    }
}
impl SubnetInUse {
    /// Creates a new builder-style object to manufacture [`SubnetInUse`](crate::error::SubnetInUse)
    pub fn builder() -> crate::error::subnet_in_use::Builder {
        crate::error::subnet_in_use::Builder::default()
    }
}

/// <p>An invalid subnet identifier was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSubnet {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSubnet");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSubnet {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSubnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSubnet")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSubnet {}
/// See [`InvalidSubnet`](crate::error::InvalidSubnet)
pub mod invalid_subnet {
    /// A builder for [`InvalidSubnet`](crate::error::InvalidSubnet)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSubnet`](crate::error::InvalidSubnet)
        pub fn build(self) -> crate::error::InvalidSubnet {
            crate::error::InvalidSubnet {
                message: self.message,
            }
        }
    }
}
impl InvalidSubnet {
    /// Creates a new builder-style object to manufacture [`InvalidSubnet`](crate::error::InvalidSubnet)
    pub fn builder() -> crate::error::invalid_subnet::Builder {
        crate::error::invalid_subnet::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of subnets in a cache subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSubnetQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSubnetQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSubnetQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSubnetQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSubnetQuotaExceededFault")?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSubnetQuotaExceededFault {}
/// See [`CacheSubnetQuotaExceededFault`](crate::error::CacheSubnetQuotaExceededFault)
pub mod cache_subnet_quota_exceeded_fault {
    /// A builder for [`CacheSubnetQuotaExceededFault`](crate::error::CacheSubnetQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSubnetQuotaExceededFault`](crate::error::CacheSubnetQuotaExceededFault)
        pub fn build(self) -> crate::error::CacheSubnetQuotaExceededFault {
            crate::error::CacheSubnetQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl CacheSubnetQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`CacheSubnetQuotaExceededFault`](crate::error::CacheSubnetQuotaExceededFault)
    pub fn builder() -> crate::error::cache_subnet_quota_exceeded_fault::Builder {
        crate::error::cache_subnet_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The operation was not performed because no changes were required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoOperationFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoOperationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoOperationFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoOperationFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoOperationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoOperationFault")?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoOperationFault {}
/// See [`NoOperationFault`](crate::error::NoOperationFault)
pub mod no_operation_fault {
    /// A builder for [`NoOperationFault`](crate::error::NoOperationFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoOperationFault`](crate::error::NoOperationFault)
        pub fn build(self) -> crate::error::NoOperationFault {
            crate::error::NoOperationFault {
                message: self.message,
            }
        }
    }
}
impl NoOperationFault {
    /// Creates a new builder-style object to manufacture [`NoOperationFault`](crate::error::NoOperationFault)
    pub fn builder() -> crate::error::no_operation_fault::Builder {
        crate::error::no_operation_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of clusters per customer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClusterQuotaForCustomerExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClusterQuotaForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClusterQuotaForCustomerExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClusterQuotaForCustomerExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClusterQuotaForCustomerExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClusterQuotaForCustomerExceededFault")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClusterQuotaForCustomerExceededFault {}
/// See [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault)
pub mod cluster_quota_for_customer_exceeded_fault {
    /// A builder for [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault)
        pub fn build(self) -> crate::error::ClusterQuotaForCustomerExceededFault {
            crate::error::ClusterQuotaForCustomerExceededFault {
                message: self.message,
            }
        }
    }
}
impl ClusterQuotaForCustomerExceededFault {
    /// Creates a new builder-style object to manufacture [`ClusterQuotaForCustomerExceededFault`](crate::error::ClusterQuotaForCustomerExceededFault)
    pub fn builder() -> crate::error::cluster_quota_for_customer_exceeded_fault::Builder {
        crate::error::cluster_quota_for_customer_exceeded_fault::Builder::default()
    }
}

/// <p>The service update doesn't exist</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUpdateNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceUpdateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUpdateNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceUpdateNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceUpdateNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUpdateNotFoundFault")?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceUpdateNotFoundFault {}
/// See [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault)
pub mod service_update_not_found_fault {
    /// A builder for [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault)
        pub fn build(self) -> crate::error::ServiceUpdateNotFoundFault {
            crate::error::ServiceUpdateNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ServiceUpdateNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ServiceUpdateNotFoundFault`](crate::error::ServiceUpdateNotFoundFault)
    pub fn builder() -> crate::error::service_update_not_found_fault::Builder {
        crate::error::service_update_not_found_fault::Builder::default()
    }
}

/// <p>The default user assigned to the user group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultUserAssociatedToUserGroupFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultUserAssociatedToUserGroupFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultUserAssociatedToUserGroupFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DefaultUserAssociatedToUserGroupFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultUserAssociatedToUserGroupFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultUserAssociatedToUserGroupFault")?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for DefaultUserAssociatedToUserGroupFault {}
/// See [`DefaultUserAssociatedToUserGroupFault`](crate::error::DefaultUserAssociatedToUserGroupFault)
pub mod default_user_associated_to_user_group_fault {
    /// A builder for [`DefaultUserAssociatedToUserGroupFault`](crate::error::DefaultUserAssociatedToUserGroupFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultUserAssociatedToUserGroupFault`](crate::error::DefaultUserAssociatedToUserGroupFault)
        pub fn build(self) -> crate::error::DefaultUserAssociatedToUserGroupFault {
            crate::error::DefaultUserAssociatedToUserGroupFault {
                message: self.message,
            }
        }
    }
}
impl DefaultUserAssociatedToUserGroupFault {
    /// Creates a new builder-style object to manufacture [`DefaultUserAssociatedToUserGroupFault`](crate::error::DefaultUserAssociatedToUserGroupFault)
    pub fn builder() -> crate::error::default_user_associated_to_user_group_fault::Builder {
        crate::error::default_user_associated_to_user_group_fault::Builder::default()
    }
}

/// <p>The current state of the snapshot does not allow the requested operation to occur.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSnapshotStateFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSnapshotStateFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSnapshotStateFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSnapshotStateFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSnapshotStateFault")?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSnapshotStateFault {}
/// See [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault)
pub mod invalid_snapshot_state_fault {
    /// A builder for [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault)
        pub fn build(self) -> crate::error::InvalidSnapshotStateFault {
            crate::error::InvalidSnapshotStateFault {
                message: self.message,
            }
        }
    }
}
impl InvalidSnapshotStateFault {
    /// Creates a new builder-style object to manufacture [`InvalidSnapshotStateFault`](crate::error::InvalidSnapshotStateFault)
    pub fn builder() -> crate::error::invalid_snapshot_state_fault::Builder {
        crate::error::invalid_snapshot_state_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the maximum number of snapshots.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnapshotQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotQuotaExceededFault")?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotQuotaExceededFault {}
/// See [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
pub mod snapshot_quota_exceeded_fault {
    /// A builder for [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
        pub fn build(self) -> crate::error::SnapshotQuotaExceededFault {
            crate::error::SnapshotQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl SnapshotQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`SnapshotQuotaExceededFault`](crate::error::SnapshotQuotaExceededFault)
    pub fn builder() -> crate::error::snapshot_quota_exceeded_fault::Builder {
        crate::error::snapshot_quota_exceeded_fault::Builder::default()
    }
}

/// <p>You attempted one of the following operations:</p>
/// <ul>
/// <li>
/// <p>Creating a snapshot of a Redis cluster running on a <code>cache.t1.micro</code> cache
/// node.</p>
/// </li>
/// <li>
/// <p>Creating a snapshot of a cluster that is running Memcached rather than Redis.</p>
/// </li>
/// </ul>
/// <p>Neither of these are supported by ElastiCache.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotFeatureNotSupportedFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotFeatureNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotFeatureNotSupportedFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnapshotFeatureNotSupportedFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotFeatureNotSupportedFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotFeatureNotSupportedFault")?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotFeatureNotSupportedFault {}
/// See [`SnapshotFeatureNotSupportedFault`](crate::error::SnapshotFeatureNotSupportedFault)
pub mod snapshot_feature_not_supported_fault {
    /// A builder for [`SnapshotFeatureNotSupportedFault`](crate::error::SnapshotFeatureNotSupportedFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotFeatureNotSupportedFault`](crate::error::SnapshotFeatureNotSupportedFault)
        pub fn build(self) -> crate::error::SnapshotFeatureNotSupportedFault {
            crate::error::SnapshotFeatureNotSupportedFault {
                message: self.message,
            }
        }
    }
}
impl SnapshotFeatureNotSupportedFault {
    /// Creates a new builder-style object to manufacture [`SnapshotFeatureNotSupportedFault`](crate::error::SnapshotFeatureNotSupportedFault)
    pub fn builder() -> crate::error::snapshot_feature_not_supported_fault::Builder {
        crate::error::snapshot_feature_not_supported_fault::Builder::default()
    }
}

/// <p>You already have a snapshot with the given name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SnapshotAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SnapshotAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SnapshotAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SnapshotAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SnapshotAlreadyExistsFault")?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for SnapshotAlreadyExistsFault {}
/// See [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault)
pub mod snapshot_already_exists_fault {
    /// A builder for [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault)
        pub fn build(self) -> crate::error::SnapshotAlreadyExistsFault {
            crate::error::SnapshotAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl SnapshotAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`SnapshotAlreadyExistsFault`](crate::error::SnapshotAlreadyExistsFault)
    pub fn builder() -> crate::error::snapshot_already_exists_fault::Builder {
        crate::error::snapshot_already_exists_fault::Builder::default()
    }
}

/// <p>The requested cache subnet group is currently in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSubnetGroupInUse {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSubnetGroupInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSubnetGroupInUse");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSubnetGroupInUse {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSubnetGroupInUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSubnetGroupInUse")?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSubnetGroupInUse {}
/// See [`CacheSubnetGroupInUse`](crate::error::CacheSubnetGroupInUse)
pub mod cache_subnet_group_in_use {
    /// A builder for [`CacheSubnetGroupInUse`](crate::error::CacheSubnetGroupInUse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSubnetGroupInUse`](crate::error::CacheSubnetGroupInUse)
        pub fn build(self) -> crate::error::CacheSubnetGroupInUse {
            crate::error::CacheSubnetGroupInUse {
                message: self.message,
            }
        }
    }
}
impl CacheSubnetGroupInUse {
    /// Creates a new builder-style object to manufacture [`CacheSubnetGroupInUse`](crate::error::CacheSubnetGroupInUse)
    pub fn builder() -> crate::error::cache_subnet_group_in_use::Builder {
        crate::error::cache_subnet_group_in_use::Builder::default()
    }
}

/// <p>The specified service linked role (SLR) was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceLinkedRoleNotFoundFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceLinkedRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceLinkedRoleNotFoundFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ServiceLinkedRoleNotFoundFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceLinkedRoleNotFoundFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceLinkedRoleNotFoundFault")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceLinkedRoleNotFoundFault {}
/// See [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault)
pub mod service_linked_role_not_found_fault {
    /// A builder for [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault)
        pub fn build(self) -> crate::error::ServiceLinkedRoleNotFoundFault {
            crate::error::ServiceLinkedRoleNotFoundFault {
                message: self.message,
            }
        }
    }
}
impl ServiceLinkedRoleNotFoundFault {
    /// Creates a new builder-style object to manufacture [`ServiceLinkedRoleNotFoundFault`](crate::error::ServiceLinkedRoleNotFoundFault)
    pub fn builder() -> crate::error::service_linked_role_not_found_fault::Builder {
        crate::error::service_linked_role_not_found_fault::Builder::default()
    }
}

/// <p>The number of users exceeds the user group limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserGroupQuotaExceededFault")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserGroupQuotaExceededFault {}
/// See [`UserGroupQuotaExceededFault`](crate::error::UserGroupQuotaExceededFault)
pub mod user_group_quota_exceeded_fault {
    /// A builder for [`UserGroupQuotaExceededFault`](crate::error::UserGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserGroupQuotaExceededFault`](crate::error::UserGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::UserGroupQuotaExceededFault {
            crate::error::UserGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl UserGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`UserGroupQuotaExceededFault`](crate::error::UserGroupQuotaExceededFault)
    pub fn builder() -> crate::error::user_group_quota_exceeded_fault::Builder {
        crate::error::user_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The user group with this ID already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserGroupAlreadyExistsFault")?;
        if let Some(inner_54) = &self.message {
            write!(f, ": {}", inner_54)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserGroupAlreadyExistsFault {}
/// See [`UserGroupAlreadyExistsFault`](crate::error::UserGroupAlreadyExistsFault)
pub mod user_group_already_exists_fault {
    /// A builder for [`UserGroupAlreadyExistsFault`](crate::error::UserGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserGroupAlreadyExistsFault`](crate::error::UserGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::UserGroupAlreadyExistsFault {
            crate::error::UserGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl UserGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`UserGroupAlreadyExistsFault`](crate::error::UserGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::user_group_already_exists_fault::Builder {
        crate::error::user_group_already_exists_fault::Builder::default()
    }
}

/// <p>The quota of users has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserQuotaExceededFault")?;
        if let Some(inner_55) = &self.message {
            write!(f, ": {}", inner_55)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserQuotaExceededFault {}
/// See [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault)
pub mod user_quota_exceeded_fault {
    /// A builder for [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault)
        pub fn build(self) -> crate::error::UserQuotaExceededFault {
            crate::error::UserQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl UserQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`UserQuotaExceededFault`](crate::error::UserQuotaExceededFault)
    pub fn builder() -> crate::error::user_quota_exceeded_fault::Builder {
        crate::error::user_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A user with this ID already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserAlreadyExistsFault")?;
        if let Some(inner_56) = &self.message {
            write!(f, ": {}", inner_56)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserAlreadyExistsFault {}
/// See [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault)
pub mod user_already_exists_fault {
    /// A builder for [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault)
        pub fn build(self) -> crate::error::UserAlreadyExistsFault {
            crate::error::UserAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl UserAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`UserAlreadyExistsFault`](crate::error::UserAlreadyExistsFault)
    pub fn builder() -> crate::error::user_already_exists_fault::Builder {
        crate::error::user_already_exists_fault::Builder::default()
    }
}

/// <p>The specified replication group already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicationGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplicationGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplicationGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicationGroupAlreadyExistsFault")?;
        if let Some(inner_57) = &self.message {
            write!(f, ": {}", inner_57)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplicationGroupAlreadyExistsFault {}
/// See [`ReplicationGroupAlreadyExistsFault`](crate::error::ReplicationGroupAlreadyExistsFault)
pub mod replication_group_already_exists_fault {
    /// A builder for [`ReplicationGroupAlreadyExistsFault`](crate::error::ReplicationGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationGroupAlreadyExistsFault`](crate::error::ReplicationGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::ReplicationGroupAlreadyExistsFault {
            crate::error::ReplicationGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl ReplicationGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`ReplicationGroupAlreadyExistsFault`](crate::error::ReplicationGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::replication_group_already_exists_fault::Builder {
        crate::error::replication_group_already_exists_fault::Builder::default()
    }
}

/// <p>The Global datastore name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GlobalReplicationGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GlobalReplicationGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GlobalReplicationGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl GlobalReplicationGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GlobalReplicationGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalReplicationGroupAlreadyExistsFault")?;
        if let Some(inner_58) = &self.message {
            write!(f, ": {}", inner_58)?;
        }
        Ok(())
    }
}
impl std::error::Error for GlobalReplicationGroupAlreadyExistsFault {}
/// See [`GlobalReplicationGroupAlreadyExistsFault`](crate::error::GlobalReplicationGroupAlreadyExistsFault)
pub mod global_replication_group_already_exists_fault {
    /// A builder for [`GlobalReplicationGroupAlreadyExistsFault`](crate::error::GlobalReplicationGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalReplicationGroupAlreadyExistsFault`](crate::error::GlobalReplicationGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::GlobalReplicationGroupAlreadyExistsFault {
            crate::error::GlobalReplicationGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl GlobalReplicationGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`GlobalReplicationGroupAlreadyExistsFault`](crate::error::GlobalReplicationGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::global_replication_group_already_exists_fault::Builder {
        crate::error::global_replication_group_already_exists_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of cache subnet groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSubnetGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSubnetGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSubnetGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSubnetGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSubnetGroupQuotaExceededFault")?;
        if let Some(inner_59) = &self.message {
            write!(f, ": {}", inner_59)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSubnetGroupQuotaExceededFault {}
/// See [`CacheSubnetGroupQuotaExceededFault`](crate::error::CacheSubnetGroupQuotaExceededFault)
pub mod cache_subnet_group_quota_exceeded_fault {
    /// A builder for [`CacheSubnetGroupQuotaExceededFault`](crate::error::CacheSubnetGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSubnetGroupQuotaExceededFault`](crate::error::CacheSubnetGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::CacheSubnetGroupQuotaExceededFault {
            crate::error::CacheSubnetGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl CacheSubnetGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`CacheSubnetGroupQuotaExceededFault`](crate::error::CacheSubnetGroupQuotaExceededFault)
    pub fn builder() -> crate::error::cache_subnet_group_quota_exceeded_fault::Builder {
        crate::error::cache_subnet_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>The requested cache subnet group name is already in use by an existing cache subnet group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSubnetGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSubnetGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSubnetGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSubnetGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSubnetGroupAlreadyExistsFault")?;
        if let Some(inner_60) = &self.message {
            write!(f, ": {}", inner_60)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSubnetGroupAlreadyExistsFault {}
/// See [`CacheSubnetGroupAlreadyExistsFault`](crate::error::CacheSubnetGroupAlreadyExistsFault)
pub mod cache_subnet_group_already_exists_fault {
    /// A builder for [`CacheSubnetGroupAlreadyExistsFault`](crate::error::CacheSubnetGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSubnetGroupAlreadyExistsFault`](crate::error::CacheSubnetGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::CacheSubnetGroupAlreadyExistsFault {
            crate::error::CacheSubnetGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl CacheSubnetGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`CacheSubnetGroupAlreadyExistsFault`](crate::error::CacheSubnetGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::cache_subnet_group_already_exists_fault::Builder {
        crate::error::cache_subnet_group_already_exists_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of cache security groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSecurityGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSecurityGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSecurityGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSecurityGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSecurityGroupQuotaExceededFault")?;
        if let Some(inner_61) = &self.message {
            write!(f, ": {}", inner_61)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSecurityGroupQuotaExceededFault {}
/// See [`CacheSecurityGroupQuotaExceededFault`](crate::error::CacheSecurityGroupQuotaExceededFault)
pub mod cache_security_group_quota_exceeded_fault {
    /// A builder for [`CacheSecurityGroupQuotaExceededFault`](crate::error::CacheSecurityGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSecurityGroupQuotaExceededFault`](crate::error::CacheSecurityGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::CacheSecurityGroupQuotaExceededFault {
            crate::error::CacheSecurityGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl CacheSecurityGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`CacheSecurityGroupQuotaExceededFault`](crate::error::CacheSecurityGroupQuotaExceededFault)
    pub fn builder() -> crate::error::cache_security_group_quota_exceeded_fault::Builder {
        crate::error::cache_security_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A cache security group with the specified name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheSecurityGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheSecurityGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheSecurityGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheSecurityGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheSecurityGroupAlreadyExistsFault")?;
        if let Some(inner_62) = &self.message {
            write!(f, ": {}", inner_62)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheSecurityGroupAlreadyExistsFault {}
/// See [`CacheSecurityGroupAlreadyExistsFault`](crate::error::CacheSecurityGroupAlreadyExistsFault)
pub mod cache_security_group_already_exists_fault {
    /// A builder for [`CacheSecurityGroupAlreadyExistsFault`](crate::error::CacheSecurityGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheSecurityGroupAlreadyExistsFault`](crate::error::CacheSecurityGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::CacheSecurityGroupAlreadyExistsFault {
            crate::error::CacheSecurityGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl CacheSecurityGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`CacheSecurityGroupAlreadyExistsFault`](crate::error::CacheSecurityGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::cache_security_group_already_exists_fault::Builder {
        crate::error::cache_security_group_already_exists_fault::Builder::default()
    }
}

/// <p>The request cannot be processed because it would exceed the maximum number of cache security groups.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheParameterGroupQuotaExceededFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheParameterGroupQuotaExceededFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheParameterGroupQuotaExceededFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheParameterGroupQuotaExceededFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheParameterGroupQuotaExceededFault")?;
        if let Some(inner_63) = &self.message {
            write!(f, ": {}", inner_63)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheParameterGroupQuotaExceededFault {}
/// See [`CacheParameterGroupQuotaExceededFault`](crate::error::CacheParameterGroupQuotaExceededFault)
pub mod cache_parameter_group_quota_exceeded_fault {
    /// A builder for [`CacheParameterGroupQuotaExceededFault`](crate::error::CacheParameterGroupQuotaExceededFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheParameterGroupQuotaExceededFault`](crate::error::CacheParameterGroupQuotaExceededFault)
        pub fn build(self) -> crate::error::CacheParameterGroupQuotaExceededFault {
            crate::error::CacheParameterGroupQuotaExceededFault {
                message: self.message,
            }
        }
    }
}
impl CacheParameterGroupQuotaExceededFault {
    /// Creates a new builder-style object to manufacture [`CacheParameterGroupQuotaExceededFault`](crate::error::CacheParameterGroupQuotaExceededFault)
    pub fn builder() -> crate::error::cache_parameter_group_quota_exceeded_fault::Builder {
        crate::error::cache_parameter_group_quota_exceeded_fault::Builder::default()
    }
}

/// <p>A cache parameter group with the requested name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheParameterGroupAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheParameterGroupAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheParameterGroupAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheParameterGroupAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheParameterGroupAlreadyExistsFault")?;
        if let Some(inner_64) = &self.message {
            write!(f, ": {}", inner_64)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheParameterGroupAlreadyExistsFault {}
/// See [`CacheParameterGroupAlreadyExistsFault`](crate::error::CacheParameterGroupAlreadyExistsFault)
pub mod cache_parameter_group_already_exists_fault {
    /// A builder for [`CacheParameterGroupAlreadyExistsFault`](crate::error::CacheParameterGroupAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheParameterGroupAlreadyExistsFault`](crate::error::CacheParameterGroupAlreadyExistsFault)
        pub fn build(self) -> crate::error::CacheParameterGroupAlreadyExistsFault {
            crate::error::CacheParameterGroupAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl CacheParameterGroupAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`CacheParameterGroupAlreadyExistsFault`](crate::error::CacheParameterGroupAlreadyExistsFault)
    pub fn builder() -> crate::error::cache_parameter_group_already_exists_fault::Builder {
        crate::error::cache_parameter_group_already_exists_fault::Builder::default()
    }
}

/// <p>You already have a cluster with the given identifier.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CacheClusterAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CacheClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CacheClusterAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CacheClusterAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CacheClusterAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CacheClusterAlreadyExistsFault")?;
        if let Some(inner_65) = &self.message {
            write!(f, ": {}", inner_65)?;
        }
        Ok(())
    }
}
impl std::error::Error for CacheClusterAlreadyExistsFault {}
/// See [`CacheClusterAlreadyExistsFault`](crate::error::CacheClusterAlreadyExistsFault)
pub mod cache_cluster_already_exists_fault {
    /// A builder for [`CacheClusterAlreadyExistsFault`](crate::error::CacheClusterAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CacheClusterAlreadyExistsFault`](crate::error::CacheClusterAlreadyExistsFault)
        pub fn build(self) -> crate::error::CacheClusterAlreadyExistsFault {
            crate::error::CacheClusterAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl CacheClusterAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`CacheClusterAlreadyExistsFault`](crate::error::CacheClusterAlreadyExistsFault)
    pub fn builder() -> crate::error::cache_cluster_already_exists_fault::Builder {
        crate::error::cache_cluster_already_exists_fault::Builder::default()
    }
}

/// <p>The designated replication group is not available for data migration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationGroupNotUnderMigrationFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicationGroupNotUnderMigrationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationGroupNotUnderMigrationFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplicationGroupNotUnderMigrationFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplicationGroupNotUnderMigrationFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicationGroupNotUnderMigrationFault")?;
        if let Some(inner_66) = &self.message {
            write!(f, ": {}", inner_66)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplicationGroupNotUnderMigrationFault {}
/// See [`ReplicationGroupNotUnderMigrationFault`](crate::error::ReplicationGroupNotUnderMigrationFault)
pub mod replication_group_not_under_migration_fault {
    /// A builder for [`ReplicationGroupNotUnderMigrationFault`](crate::error::ReplicationGroupNotUnderMigrationFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationGroupNotUnderMigrationFault`](crate::error::ReplicationGroupNotUnderMigrationFault)
        pub fn build(self) -> crate::error::ReplicationGroupNotUnderMigrationFault {
            crate::error::ReplicationGroupNotUnderMigrationFault {
                message: self.message,
            }
        }
    }
}
impl ReplicationGroupNotUnderMigrationFault {
    /// Creates a new builder-style object to manufacture [`ReplicationGroupNotUnderMigrationFault`](crate::error::ReplicationGroupNotUnderMigrationFault)
    pub fn builder() -> crate::error::replication_group_not_under_migration_fault::Builder {
        crate::error::replication_group_not_under_migration_fault::Builder::default()
    }
}

/// <p>The specified Amazon EC2 security group is already authorized for the specified cache security group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationAlreadyExistsFault {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationAlreadyExistsFault");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorizationAlreadyExistsFault {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorizationAlreadyExistsFault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorizationAlreadyExistsFault")?;
        if let Some(inner_67) = &self.message {
            write!(f, ": {}", inner_67)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorizationAlreadyExistsFault {}
/// See [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
pub mod authorization_already_exists_fault {
    /// A builder for [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
        pub fn build(self) -> crate::error::AuthorizationAlreadyExistsFault {
            crate::error::AuthorizationAlreadyExistsFault {
                message: self.message,
            }
        }
    }
}
impl AuthorizationAlreadyExistsFault {
    /// Creates a new builder-style object to manufacture [`AuthorizationAlreadyExistsFault`](crate::error::AuthorizationAlreadyExistsFault)
    pub fn builder() -> crate::error::authorization_already_exists_fault::Builder {
        crate::error::authorization_already_exists_fault::Builder::default()
    }
}
