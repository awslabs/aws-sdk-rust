// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents an individual cache node within a cluster. Each cache node runs its own instance of the cluster's protocol-compliant caching software - either Memcached or Redis.</p>
/// <p>The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts.</p>
/// <ul>
/// <li> <p>General purpose:</p>
/// <ul>
/// <li> <p>Current generation: </p> <p> <b>M6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward): <code>cache.m6g.large</code>, <code>cache.m6g.xlarge</code>, <code>cache.m6g.2xlarge</code>, <code>cache.m6g.4xlarge</code>, <code>cache.m6g.8xlarge</code>, <code>cache.m6g.12xlarge</code>, <code>cache.m6g.16xlarge</code> </p> <note>
/// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
/// </note> <p> <b>M5 node types:</b> <code>cache.m5.large</code>, <code>cache.m5.xlarge</code>, <code>cache.m5.2xlarge</code>, <code>cache.m5.4xlarge</code>, <code>cache.m5.12xlarge</code>, <code>cache.m5.24xlarge</code> </p> <p> <b>M4 node types:</b> <code>cache.m4.large</code>, <code>cache.m4.xlarge</code>, <code>cache.m4.2xlarge</code>, <code>cache.m4.4xlarge</code>, <code>cache.m4.10xlarge</code> </p> <p> <b>T4g node types</b> (available only for Redis engine version 5.0.6 onward and Memcached engine version 1.5.16 onward): <code>cache.t4g.micro</code>, <code>cache.t4g.small</code>, <code>cache.t4g.medium</code> </p> <p> <b>T3 node types:</b> <code>cache.t3.micro</code>, <code>cache.t3.small</code>, <code>cache.t3.medium</code> </p> <p> <b>T2 node types:</b> <code>cache.t2.micro</code>, <code>cache.t2.small</code>, <code>cache.t2.medium</code> </p> </li>
/// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>T1 node types:</b> <code>cache.t1.micro</code> </p> <p> <b>M1 node types:</b> <code>cache.m1.small</code>, <code>cache.m1.medium</code>, <code>cache.m1.large</code>, <code>cache.m1.xlarge</code> </p> <p> <b>M3 node types:</b> <code>cache.m3.medium</code>, <code>cache.m3.large</code>, <code>cache.m3.xlarge</code>, <code>cache.m3.2xlarge</code> </p> </li>
/// </ul> </li>
/// <li> <p>Compute optimized:</p>
/// <ul>
/// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>C1 node types:</b> <code>cache.c1.xlarge</code> </p> </li>
/// </ul> </li>
/// <li> <p>Memory optimized:</p>
/// <ul>
/// <li> <p>Current generation: </p> <p> <b>R6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward).</p> <p> <code>cache.r6g.large</code>, <code>cache.r6g.xlarge</code>, <code>cache.r6g.2xlarge</code>, <code>cache.r6g.4xlarge</code>, <code>cache.r6g.8xlarge</code>, <code>cache.r6g.12xlarge</code>, <code>cache.r6g.16xlarge</code> </p> <note>
/// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
/// </note> <p> <b>R5 node types:</b> <code>cache.r5.large</code>, <code>cache.r5.xlarge</code>, <code>cache.r5.2xlarge</code>, <code>cache.r5.4xlarge</code>, <code>cache.r5.12xlarge</code>, <code>cache.r5.24xlarge</code> </p> <p> <b>R4 node types:</b> <code>cache.r4.large</code>, <code>cache.r4.xlarge</code>, <code>cache.r4.2xlarge</code>, <code>cache.r4.4xlarge</code>, <code>cache.r4.8xlarge</code>, <code>cache.r4.16xlarge</code> </p> </li>
/// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>M2 node types:</b> <code>cache.m2.xlarge</code>, <code>cache.m2.2xlarge</code>, <code>cache.m2.4xlarge</code> </p> <p> <b>R3 node types:</b> <code>cache.r3.large</code>, <code>cache.r3.xlarge</code>, <code>cache.r3.2xlarge</code>, <code>cache.r3.4xlarge</code>, <code>cache.r3.8xlarge</code> </p> </li>
/// </ul> </li>
/// </ul>
/// <p> <b>Additional node type info</b> </p>
/// <ul>
/// <li> <p>All current generation instance types are created in Amazon VPC by default.</p> </li>
/// <li> <p>Redis append-only files (AOF) are not supported for T1 or T2 instances.</p> </li>
/// <li> <p>Redis Multi-AZ with automatic failover is not supported on T1 instances.</p> </li>
/// <li> <p>Redis configuration variables <code>appendonly</code> and <code>appendfsync</code> are not supported on Redis version 2.8.22 and later.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CacheNode {
    /// <p>The cache node identifier. A node ID is a numeric identifier (0001, 0002, etc.). The combination of cluster ID and node ID uniquely identifies every cache node used in a customer's Amazon account.</p>
    #[doc(hidden)]
    pub cache_node_id: std::option::Option<std::string::String>,
    /// <p>The current state of this cache node, one of the following values: <code>available</code>, <code>creating</code>, <code>rebooting</code>, or <code>deleting</code>.</p>
    #[doc(hidden)]
    pub cache_node_status: std::option::Option<std::string::String>,
    /// <p>The date and time when the cache node was created.</p>
    #[doc(hidden)]
    pub cache_node_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The hostname for connecting to this cache node.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<crate::types::Endpoint>,
    /// <p>The status of the parameter group applied to this cache node.</p>
    #[doc(hidden)]
    pub parameter_group_status: std::option::Option<std::string::String>,
    /// <p>The ID of the primary node to which this read replica node is synchronized. If this field is empty, this node is not associated with a primary cluster.</p>
    #[doc(hidden)]
    pub source_cache_node_id: std::option::Option<std::string::String>,
    /// <p>The Availability Zone where this node was created and now resides.</p>
    #[doc(hidden)]
    pub customer_availability_zone: std::option::Option<std::string::String>,
    /// <p>The customer outpost ARN of the cache node.</p>
    #[doc(hidden)]
    pub customer_outpost_arn: std::option::Option<std::string::String>,
}
impl CacheNode {
    /// <p>The cache node identifier. A node ID is a numeric identifier (0001, 0002, etc.). The combination of cluster ID and node ID uniquely identifies every cache node used in a customer's Amazon account.</p>
    pub fn cache_node_id(&self) -> std::option::Option<&str> {
        self.cache_node_id.as_deref()
    }
    /// <p>The current state of this cache node, one of the following values: <code>available</code>, <code>creating</code>, <code>rebooting</code>, or <code>deleting</code>.</p>
    pub fn cache_node_status(&self) -> std::option::Option<&str> {
        self.cache_node_status.as_deref()
    }
    /// <p>The date and time when the cache node was created.</p>
    pub fn cache_node_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.cache_node_create_time.as_ref()
    }
    /// <p>The hostname for connecting to this cache node.</p>
    pub fn endpoint(&self) -> std::option::Option<&crate::types::Endpoint> {
        self.endpoint.as_ref()
    }
    /// <p>The status of the parameter group applied to this cache node.</p>
    pub fn parameter_group_status(&self) -> std::option::Option<&str> {
        self.parameter_group_status.as_deref()
    }
    /// <p>The ID of the primary node to which this read replica node is synchronized. If this field is empty, this node is not associated with a primary cluster.</p>
    pub fn source_cache_node_id(&self) -> std::option::Option<&str> {
        self.source_cache_node_id.as_deref()
    }
    /// <p>The Availability Zone where this node was created and now resides.</p>
    pub fn customer_availability_zone(&self) -> std::option::Option<&str> {
        self.customer_availability_zone.as_deref()
    }
    /// <p>The customer outpost ARN of the cache node.</p>
    pub fn customer_outpost_arn(&self) -> std::option::Option<&str> {
        self.customer_outpost_arn.as_deref()
    }
}
impl CacheNode {
    /// Creates a new builder-style object to manufacture [`CacheNode`](crate::types::CacheNode).
    pub fn builder() -> crate::types::builders::CacheNodeBuilder {
        crate::types::builders::CacheNodeBuilder::default()
    }
}

/// A builder for [`CacheNode`](crate::types::CacheNode).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CacheNodeBuilder {
    pub(crate) cache_node_id: std::option::Option<std::string::String>,
    pub(crate) cache_node_status: std::option::Option<std::string::String>,
    pub(crate) cache_node_create_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) endpoint: std::option::Option<crate::types::Endpoint>,
    pub(crate) parameter_group_status: std::option::Option<std::string::String>,
    pub(crate) source_cache_node_id: std::option::Option<std::string::String>,
    pub(crate) customer_availability_zone: std::option::Option<std::string::String>,
    pub(crate) customer_outpost_arn: std::option::Option<std::string::String>,
}
impl CacheNodeBuilder {
    /// <p>The cache node identifier. A node ID is a numeric identifier (0001, 0002, etc.). The combination of cluster ID and node ID uniquely identifies every cache node used in a customer's Amazon account.</p>
    pub fn cache_node_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_node_id = Some(input.into());
        self
    }
    /// <p>The cache node identifier. A node ID is a numeric identifier (0001, 0002, etc.). The combination of cluster ID and node ID uniquely identifies every cache node used in a customer's Amazon account.</p>
    pub fn set_cache_node_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cache_node_id = input;
        self
    }
    /// <p>The current state of this cache node, one of the following values: <code>available</code>, <code>creating</code>, <code>rebooting</code>, or <code>deleting</code>.</p>
    pub fn cache_node_status(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_node_status = Some(input.into());
        self
    }
    /// <p>The current state of this cache node, one of the following values: <code>available</code>, <code>creating</code>, <code>rebooting</code>, or <code>deleting</code>.</p>
    pub fn set_cache_node_status(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.cache_node_status = input;
        self
    }
    /// <p>The date and time when the cache node was created.</p>
    pub fn cache_node_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.cache_node_create_time = Some(input);
        self
    }
    /// <p>The date and time when the cache node was created.</p>
    pub fn set_cache_node_create_time(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.cache_node_create_time = input;
        self
    }
    /// <p>The hostname for connecting to this cache node.</p>
    pub fn endpoint(mut self, input: crate::types::Endpoint) -> Self {
        self.endpoint = Some(input);
        self
    }
    /// <p>The hostname for connecting to this cache node.</p>
    pub fn set_endpoint(mut self, input: std::option::Option<crate::types::Endpoint>) -> Self {
        self.endpoint = input;
        self
    }
    /// <p>The status of the parameter group applied to this cache node.</p>
    pub fn parameter_group_status(mut self, input: impl Into<std::string::String>) -> Self {
        self.parameter_group_status = Some(input.into());
        self
    }
    /// <p>The status of the parameter group applied to this cache node.</p>
    pub fn set_parameter_group_status(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.parameter_group_status = input;
        self
    }
    /// <p>The ID of the primary node to which this read replica node is synchronized. If this field is empty, this node is not associated with a primary cluster.</p>
    pub fn source_cache_node_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.source_cache_node_id = Some(input.into());
        self
    }
    /// <p>The ID of the primary node to which this read replica node is synchronized. If this field is empty, this node is not associated with a primary cluster.</p>
    pub fn set_source_cache_node_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.source_cache_node_id = input;
        self
    }
    /// <p>The Availability Zone where this node was created and now resides.</p>
    pub fn customer_availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
        self.customer_availability_zone = Some(input.into());
        self
    }
    /// <p>The Availability Zone where this node was created and now resides.</p>
    pub fn set_customer_availability_zone(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.customer_availability_zone = input;
        self
    }
    /// <p>The customer outpost ARN of the cache node.</p>
    pub fn customer_outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.customer_outpost_arn = Some(input.into());
        self
    }
    /// <p>The customer outpost ARN of the cache node.</p>
    pub fn set_customer_outpost_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.customer_outpost_arn = input;
        self
    }
    /// Consumes the builder and constructs a [`CacheNode`](crate::types::CacheNode).
    pub fn build(self) -> crate::types::CacheNode {
        crate::types::CacheNode {
            cache_node_id: self.cache_node_id,
            cache_node_status: self.cache_node_status,
            cache_node_create_time: self.cache_node_create_time,
            endpoint: self.endpoint,
            parameter_group_status: self.parameter_group_status,
            source_cache_node_id: self.source_cache_node_id,
            customer_availability_zone: self.customer_availability_zone,
            customer_outpost_arn: self.customer_outpost_arn,
        }
    }
}
