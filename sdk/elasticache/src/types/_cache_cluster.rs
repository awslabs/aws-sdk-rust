// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains all of the attributes of a specific cluster.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CacheCluster {
    /// <p>The user-supplied identifier of the cluster. This identifier is a unique key that identifies a cluster.</p>
    #[doc(hidden)]
    pub cache_cluster_id: std::option::Option<std::string::String>,
    /// <p>Represents a Memcached cluster endpoint which can be used by an application to connect to any node in the cluster. The configuration endpoint will always have <code>.cfg</code> in it.</p>
    /// <p>Example: <code>mem-3.9dvc4r<u>.cfg</u>.usw2.cache.amazonaws.com:11211</code> </p>
    #[doc(hidden)]
    pub configuration_endpoint: std::option::Option<crate::types::Endpoint>,
    /// <p>The URL of the web page where you can download the latest ElastiCache client library.</p>
    #[doc(hidden)]
    pub client_download_landing_page: std::option::Option<std::string::String>,
    /// <p>The name of the compute and memory capacity node type for the cluster.</p>
    /// <p>The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts.</p>
    /// <ul>
    /// <li> <p>General purpose:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>M6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward): <code>cache.m6g.large</code>, <code>cache.m6g.xlarge</code>, <code>cache.m6g.2xlarge</code>, <code>cache.m6g.4xlarge</code>, <code>cache.m6g.8xlarge</code>, <code>cache.m6g.12xlarge</code>, <code>cache.m6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>M5 node types:</b> <code>cache.m5.large</code>, <code>cache.m5.xlarge</code>, <code>cache.m5.2xlarge</code>, <code>cache.m5.4xlarge</code>, <code>cache.m5.12xlarge</code>, <code>cache.m5.24xlarge</code> </p> <p> <b>M4 node types:</b> <code>cache.m4.large</code>, <code>cache.m4.xlarge</code>, <code>cache.m4.2xlarge</code>, <code>cache.m4.4xlarge</code>, <code>cache.m4.10xlarge</code> </p> <p> <b>T4g node types</b> (available only for Redis engine version 5.0.6 onward and Memcached engine version 1.5.16 onward): <code>cache.t4g.micro</code>, <code>cache.t4g.small</code>, <code>cache.t4g.medium</code> </p> <p> <b>T3 node types:</b> <code>cache.t3.micro</code>, <code>cache.t3.small</code>, <code>cache.t3.medium</code> </p> <p> <b>T2 node types:</b> <code>cache.t2.micro</code>, <code>cache.t2.small</code>, <code>cache.t2.medium</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>T1 node types:</b> <code>cache.t1.micro</code> </p> <p> <b>M1 node types:</b> <code>cache.m1.small</code>, <code>cache.m1.medium</code>, <code>cache.m1.large</code>, <code>cache.m1.xlarge</code> </p> <p> <b>M3 node types:</b> <code>cache.m3.medium</code>, <code>cache.m3.large</code>, <code>cache.m3.xlarge</code>, <code>cache.m3.2xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Compute optimized:</p>
    /// <ul>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>C1 node types:</b> <code>cache.c1.xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Memory optimized:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>R6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward).</p> <p> <code>cache.r6g.large</code>, <code>cache.r6g.xlarge</code>, <code>cache.r6g.2xlarge</code>, <code>cache.r6g.4xlarge</code>, <code>cache.r6g.8xlarge</code>, <code>cache.r6g.12xlarge</code>, <code>cache.r6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>R5 node types:</b> <code>cache.r5.large</code>, <code>cache.r5.xlarge</code>, <code>cache.r5.2xlarge</code>, <code>cache.r5.4xlarge</code>, <code>cache.r5.12xlarge</code>, <code>cache.r5.24xlarge</code> </p> <p> <b>R4 node types:</b> <code>cache.r4.large</code>, <code>cache.r4.xlarge</code>, <code>cache.r4.2xlarge</code>, <code>cache.r4.4xlarge</code>, <code>cache.r4.8xlarge</code>, <code>cache.r4.16xlarge</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>M2 node types:</b> <code>cache.m2.xlarge</code>, <code>cache.m2.2xlarge</code>, <code>cache.m2.4xlarge</code> </p> <p> <b>R3 node types:</b> <code>cache.r3.large</code>, <code>cache.r3.xlarge</code>, <code>cache.r3.2xlarge</code>, <code>cache.r3.4xlarge</code>, <code>cache.r3.8xlarge</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    /// <p> <b>Additional node type info</b> </p>
    /// <ul>
    /// <li> <p>All current generation instance types are created in Amazon VPC by default.</p> </li>
    /// <li> <p>Redis append-only files (AOF) are not supported for T1 or T2 instances.</p> </li>
    /// <li> <p>Redis Multi-AZ with automatic failover is not supported on T1 instances.</p> </li>
    /// <li> <p>Redis configuration variables <code>appendonly</code> and <code>appendfsync</code> are not supported on Redis version 2.8.22 and later.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub cache_node_type: std::option::Option<std::string::String>,
    /// <p>The name of the cache engine (<code>memcached</code> or <code>redis</code>) to be used for this cluster.</p>
    #[doc(hidden)]
    pub engine: std::option::Option<std::string::String>,
    /// <p>The version of the cache engine that is used in this cluster.</p>
    #[doc(hidden)]
    pub engine_version: std::option::Option<std::string::String>,
    /// <p>The current state of this cluster, one of the following values: <code>available</code>, <code>creating</code>, <code>deleted</code>, <code>deleting</code>, <code>incompatible-network</code>, <code>modifying</code>, <code>rebooting cluster nodes</code>, <code>restore-failed</code>, or <code>snapshotting</code>.</p>
    #[doc(hidden)]
    pub cache_cluster_status: std::option::Option<std::string::String>,
    /// <p>The number of cache nodes in the cluster.</p>
    /// <p>For clusters running Redis, this value must be 1. For clusters running Memcached, this value must be between 1 and 40.</p>
    #[doc(hidden)]
    pub num_cache_nodes: std::option::Option<i32>,
    /// <p>The name of the Availability Zone in which the cluster is located or "Multiple" if the cache nodes are located in different Availability Zones.</p>
    #[doc(hidden)]
    pub preferred_availability_zone: std::option::Option<std::string::String>,
    /// <p>The outpost ARN in which the cache cluster is created.</p>
    #[doc(hidden)]
    pub preferred_outpost_arn: std::option::Option<std::string::String>,
    /// <p>The date and time when the cluster was created.</p>
    #[doc(hidden)]
    pub cache_cluster_create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    #[doc(hidden)]
    pub preferred_maintenance_window: std::option::Option<std::string::String>,
    /// <p>A group of settings that are applied to the cluster in the future, or that are currently being applied.</p>
    #[doc(hidden)]
    pub pending_modified_values: std::option::Option<crate::types::PendingModifiedValues>,
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing ElastiCache events to subscribers using Amazon Simple Notification Service (SNS). </p>
    #[doc(hidden)]
    pub notification_configuration: std::option::Option<crate::types::NotificationConfiguration>,
    /// <p>A list of cache security group elements, composed of name and status sub-elements.</p>
    #[doc(hidden)]
    pub cache_security_groups:
        std::option::Option<std::vec::Vec<crate::types::CacheSecurityGroupMembership>>,
    /// <p>Status of the cache parameter group.</p>
    #[doc(hidden)]
    pub cache_parameter_group: std::option::Option<crate::types::CacheParameterGroupStatus>,
    /// <p>The name of the cache subnet group associated with the cluster.</p>
    #[doc(hidden)]
    pub cache_subnet_group_name: std::option::Option<std::string::String>,
    /// <p>A list of cache nodes that are members of the cluster.</p>
    #[doc(hidden)]
    pub cache_nodes: std::option::Option<std::vec::Vec<crate::types::CacheNode>>,
    /// <p>&nbsp;If you are running Redis engine version 6.0 or later, set this parameter to yes if you want to opt-in to the next auto minor version upgrade campaign. This parameter is disabled for previous versions.&nbsp; </p>
    #[doc(hidden)]
    pub auto_minor_version_upgrade: bool,
    /// <p>A list of VPC Security Groups associated with the cluster.</p>
    #[doc(hidden)]
    pub security_groups: std::option::Option<std::vec::Vec<crate::types::SecurityGroupMembership>>,
    /// <p>The replication group to which this cluster belongs. If this field is empty, the cluster is not associated with any replication group.</p>
    #[doc(hidden)]
    pub replication_group_id: std::option::Option<std::string::String>,
    /// <p>The number of days for which ElastiCache retains automatic cluster snapshots before deleting them. For example, if you set <code>SnapshotRetentionLimit</code> to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p> <important>
    /// <p> If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off.</p>
    /// </important>
    #[doc(hidden)]
    pub snapshot_retention_limit: std::option::Option<i32>,
    /// <p>The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your cluster.</p>
    /// <p>Example: <code>05:00-09:00</code> </p>
    #[doc(hidden)]
    pub snapshot_window: std::option::Option<std::string::String>,
    /// <p>A flag that enables using an <code>AuthToken</code> (password) when issuing Redis commands.</p>
    /// <p>Default: <code>false</code> </p>
    #[doc(hidden)]
    pub auth_token_enabled: std::option::Option<bool>,
    /// <p>The date the auth token was last modified</p>
    #[doc(hidden)]
    pub auth_token_last_modified_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A flag that enables in-transit encryption when set to <code>true</code>.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    #[doc(hidden)]
    pub transit_encryption_enabled: std::option::Option<bool>,
    /// <p>A flag that enables encryption at-rest when set to <code>true</code>.</p>
    /// <p>You cannot modify the value of <code>AtRestEncryptionEnabled</code> after the cluster is created. To enable at-rest encryption on a cluster you must set <code>AtRestEncryptionEnabled</code> to <code>true</code> when you create a cluster.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    #[doc(hidden)]
    pub at_rest_encryption_enabled: std::option::Option<bool>,
    /// <p>The ARN (Amazon Resource Name) of the cache cluster.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A boolean value indicating whether log delivery is enabled for the replication group.</p>
    #[doc(hidden)]
    pub replication_group_log_delivery_enabled: bool,
    /// <p>Returns the destination, format and type of the logs.</p>
    #[doc(hidden)]
    pub log_delivery_configurations:
        std::option::Option<std::vec::Vec<crate::types::LogDeliveryConfiguration>>,
    /// <p>Must be either <code>ipv4</code> | <code>ipv6</code> | <code>dual_stack</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    #[doc(hidden)]
    pub network_type: std::option::Option<crate::types::NetworkType>,
    /// <p>The network type associated with the cluster, either <code>ipv4</code> | <code>ipv6</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    #[doc(hidden)]
    pub ip_discovery: std::option::Option<crate::types::IpDiscovery>,
    /// <p>A setting that allows you to migrate your clients to use in-transit encryption, with no downtime.</p>
    #[doc(hidden)]
    pub transit_encryption_mode: std::option::Option<crate::types::TransitEncryptionMode>,
}
impl CacheCluster {
    /// <p>The user-supplied identifier of the cluster. This identifier is a unique key that identifies a cluster.</p>
    pub fn cache_cluster_id(&self) -> std::option::Option<&str> {
        self.cache_cluster_id.as_deref()
    }
    /// <p>Represents a Memcached cluster endpoint which can be used by an application to connect to any node in the cluster. The configuration endpoint will always have <code>.cfg</code> in it.</p>
    /// <p>Example: <code>mem-3.9dvc4r<u>.cfg</u>.usw2.cache.amazonaws.com:11211</code> </p>
    pub fn configuration_endpoint(&self) -> std::option::Option<&crate::types::Endpoint> {
        self.configuration_endpoint.as_ref()
    }
    /// <p>The URL of the web page where you can download the latest ElastiCache client library.</p>
    pub fn client_download_landing_page(&self) -> std::option::Option<&str> {
        self.client_download_landing_page.as_deref()
    }
    /// <p>The name of the compute and memory capacity node type for the cluster.</p>
    /// <p>The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts.</p>
    /// <ul>
    /// <li> <p>General purpose:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>M6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward): <code>cache.m6g.large</code>, <code>cache.m6g.xlarge</code>, <code>cache.m6g.2xlarge</code>, <code>cache.m6g.4xlarge</code>, <code>cache.m6g.8xlarge</code>, <code>cache.m6g.12xlarge</code>, <code>cache.m6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>M5 node types:</b> <code>cache.m5.large</code>, <code>cache.m5.xlarge</code>, <code>cache.m5.2xlarge</code>, <code>cache.m5.4xlarge</code>, <code>cache.m5.12xlarge</code>, <code>cache.m5.24xlarge</code> </p> <p> <b>M4 node types:</b> <code>cache.m4.large</code>, <code>cache.m4.xlarge</code>, <code>cache.m4.2xlarge</code>, <code>cache.m4.4xlarge</code>, <code>cache.m4.10xlarge</code> </p> <p> <b>T4g node types</b> (available only for Redis engine version 5.0.6 onward and Memcached engine version 1.5.16 onward): <code>cache.t4g.micro</code>, <code>cache.t4g.small</code>, <code>cache.t4g.medium</code> </p> <p> <b>T3 node types:</b> <code>cache.t3.micro</code>, <code>cache.t3.small</code>, <code>cache.t3.medium</code> </p> <p> <b>T2 node types:</b> <code>cache.t2.micro</code>, <code>cache.t2.small</code>, <code>cache.t2.medium</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>T1 node types:</b> <code>cache.t1.micro</code> </p> <p> <b>M1 node types:</b> <code>cache.m1.small</code>, <code>cache.m1.medium</code>, <code>cache.m1.large</code>, <code>cache.m1.xlarge</code> </p> <p> <b>M3 node types:</b> <code>cache.m3.medium</code>, <code>cache.m3.large</code>, <code>cache.m3.xlarge</code>, <code>cache.m3.2xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Compute optimized:</p>
    /// <ul>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>C1 node types:</b> <code>cache.c1.xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Memory optimized:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>R6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward).</p> <p> <code>cache.r6g.large</code>, <code>cache.r6g.xlarge</code>, <code>cache.r6g.2xlarge</code>, <code>cache.r6g.4xlarge</code>, <code>cache.r6g.8xlarge</code>, <code>cache.r6g.12xlarge</code>, <code>cache.r6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>R5 node types:</b> <code>cache.r5.large</code>, <code>cache.r5.xlarge</code>, <code>cache.r5.2xlarge</code>, <code>cache.r5.4xlarge</code>, <code>cache.r5.12xlarge</code>, <code>cache.r5.24xlarge</code> </p> <p> <b>R4 node types:</b> <code>cache.r4.large</code>, <code>cache.r4.xlarge</code>, <code>cache.r4.2xlarge</code>, <code>cache.r4.4xlarge</code>, <code>cache.r4.8xlarge</code>, <code>cache.r4.16xlarge</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>M2 node types:</b> <code>cache.m2.xlarge</code>, <code>cache.m2.2xlarge</code>, <code>cache.m2.4xlarge</code> </p> <p> <b>R3 node types:</b> <code>cache.r3.large</code>, <code>cache.r3.xlarge</code>, <code>cache.r3.2xlarge</code>, <code>cache.r3.4xlarge</code>, <code>cache.r3.8xlarge</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    /// <p> <b>Additional node type info</b> </p>
    /// <ul>
    /// <li> <p>All current generation instance types are created in Amazon VPC by default.</p> </li>
    /// <li> <p>Redis append-only files (AOF) are not supported for T1 or T2 instances.</p> </li>
    /// <li> <p>Redis Multi-AZ with automatic failover is not supported on T1 instances.</p> </li>
    /// <li> <p>Redis configuration variables <code>appendonly</code> and <code>appendfsync</code> are not supported on Redis version 2.8.22 and later.</p> </li>
    /// </ul>
    pub fn cache_node_type(&self) -> std::option::Option<&str> {
        self.cache_node_type.as_deref()
    }
    /// <p>The name of the cache engine (<code>memcached</code> or <code>redis</code>) to be used for this cluster.</p>
    pub fn engine(&self) -> std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>The version of the cache engine that is used in this cluster.</p>
    pub fn engine_version(&self) -> std::option::Option<&str> {
        self.engine_version.as_deref()
    }
    /// <p>The current state of this cluster, one of the following values: <code>available</code>, <code>creating</code>, <code>deleted</code>, <code>deleting</code>, <code>incompatible-network</code>, <code>modifying</code>, <code>rebooting cluster nodes</code>, <code>restore-failed</code>, or <code>snapshotting</code>.</p>
    pub fn cache_cluster_status(&self) -> std::option::Option<&str> {
        self.cache_cluster_status.as_deref()
    }
    /// <p>The number of cache nodes in the cluster.</p>
    /// <p>For clusters running Redis, this value must be 1. For clusters running Memcached, this value must be between 1 and 40.</p>
    pub fn num_cache_nodes(&self) -> std::option::Option<i32> {
        self.num_cache_nodes
    }
    /// <p>The name of the Availability Zone in which the cluster is located or "Multiple" if the cache nodes are located in different Availability Zones.</p>
    pub fn preferred_availability_zone(&self) -> std::option::Option<&str> {
        self.preferred_availability_zone.as_deref()
    }
    /// <p>The outpost ARN in which the cache cluster is created.</p>
    pub fn preferred_outpost_arn(&self) -> std::option::Option<&str> {
        self.preferred_outpost_arn.as_deref()
    }
    /// <p>The date and time when the cluster was created.</p>
    pub fn cache_cluster_create_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.cache_cluster_create_time.as_ref()
    }
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    pub fn preferred_maintenance_window(&self) -> std::option::Option<&str> {
        self.preferred_maintenance_window.as_deref()
    }
    /// <p>A group of settings that are applied to the cluster in the future, or that are currently being applied.</p>
    pub fn pending_modified_values(
        &self,
    ) -> std::option::Option<&crate::types::PendingModifiedValues> {
        self.pending_modified_values.as_ref()
    }
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing ElastiCache events to subscribers using Amazon Simple Notification Service (SNS). </p>
    pub fn notification_configuration(
        &self,
    ) -> std::option::Option<&crate::types::NotificationConfiguration> {
        self.notification_configuration.as_ref()
    }
    /// <p>A list of cache security group elements, composed of name and status sub-elements.</p>
    pub fn cache_security_groups(
        &self,
    ) -> std::option::Option<&[crate::types::CacheSecurityGroupMembership]> {
        self.cache_security_groups.as_deref()
    }
    /// <p>Status of the cache parameter group.</p>
    pub fn cache_parameter_group(
        &self,
    ) -> std::option::Option<&crate::types::CacheParameterGroupStatus> {
        self.cache_parameter_group.as_ref()
    }
    /// <p>The name of the cache subnet group associated with the cluster.</p>
    pub fn cache_subnet_group_name(&self) -> std::option::Option<&str> {
        self.cache_subnet_group_name.as_deref()
    }
    /// <p>A list of cache nodes that are members of the cluster.</p>
    pub fn cache_nodes(&self) -> std::option::Option<&[crate::types::CacheNode]> {
        self.cache_nodes.as_deref()
    }
    /// <p>&nbsp;If you are running Redis engine version 6.0 or later, set this parameter to yes if you want to opt-in to the next auto minor version upgrade campaign. This parameter is disabled for previous versions.&nbsp; </p>
    pub fn auto_minor_version_upgrade(&self) -> bool {
        self.auto_minor_version_upgrade
    }
    /// <p>A list of VPC Security Groups associated with the cluster.</p>
    pub fn security_groups(&self) -> std::option::Option<&[crate::types::SecurityGroupMembership]> {
        self.security_groups.as_deref()
    }
    /// <p>The replication group to which this cluster belongs. If this field is empty, the cluster is not associated with any replication group.</p>
    pub fn replication_group_id(&self) -> std::option::Option<&str> {
        self.replication_group_id.as_deref()
    }
    /// <p>The number of days for which ElastiCache retains automatic cluster snapshots before deleting them. For example, if you set <code>SnapshotRetentionLimit</code> to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p> <important>
    /// <p> If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off.</p>
    /// </important>
    pub fn snapshot_retention_limit(&self) -> std::option::Option<i32> {
        self.snapshot_retention_limit
    }
    /// <p>The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your cluster.</p>
    /// <p>Example: <code>05:00-09:00</code> </p>
    pub fn snapshot_window(&self) -> std::option::Option<&str> {
        self.snapshot_window.as_deref()
    }
    /// <p>A flag that enables using an <code>AuthToken</code> (password) when issuing Redis commands.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn auth_token_enabled(&self) -> std::option::Option<bool> {
        self.auth_token_enabled
    }
    /// <p>The date the auth token was last modified</p>
    pub fn auth_token_last_modified_date(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.auth_token_last_modified_date.as_ref()
    }
    /// <p>A flag that enables in-transit encryption when set to <code>true</code>.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn transit_encryption_enabled(&self) -> std::option::Option<bool> {
        self.transit_encryption_enabled
    }
    /// <p>A flag that enables encryption at-rest when set to <code>true</code>.</p>
    /// <p>You cannot modify the value of <code>AtRestEncryptionEnabled</code> after the cluster is created. To enable at-rest encryption on a cluster you must set <code>AtRestEncryptionEnabled</code> to <code>true</code> when you create a cluster.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn at_rest_encryption_enabled(&self) -> std::option::Option<bool> {
        self.at_rest_encryption_enabled
    }
    /// <p>The ARN (Amazon Resource Name) of the cache cluster.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A boolean value indicating whether log delivery is enabled for the replication group.</p>
    pub fn replication_group_log_delivery_enabled(&self) -> bool {
        self.replication_group_log_delivery_enabled
    }
    /// <p>Returns the destination, format and type of the logs.</p>
    pub fn log_delivery_configurations(
        &self,
    ) -> std::option::Option<&[crate::types::LogDeliveryConfiguration]> {
        self.log_delivery_configurations.as_deref()
    }
    /// <p>Must be either <code>ipv4</code> | <code>ipv6</code> | <code>dual_stack</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    pub fn network_type(&self) -> std::option::Option<&crate::types::NetworkType> {
        self.network_type.as_ref()
    }
    /// <p>The network type associated with the cluster, either <code>ipv4</code> | <code>ipv6</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    pub fn ip_discovery(&self) -> std::option::Option<&crate::types::IpDiscovery> {
        self.ip_discovery.as_ref()
    }
    /// <p>A setting that allows you to migrate your clients to use in-transit encryption, with no downtime.</p>
    pub fn transit_encryption_mode(
        &self,
    ) -> std::option::Option<&crate::types::TransitEncryptionMode> {
        self.transit_encryption_mode.as_ref()
    }
}
impl CacheCluster {
    /// Creates a new builder-style object to manufacture [`CacheCluster`](crate::types::CacheCluster).
    pub fn builder() -> crate::types::builders::CacheClusterBuilder {
        crate::types::builders::CacheClusterBuilder::default()
    }
}

/// A builder for [`CacheCluster`](crate::types::CacheCluster).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CacheClusterBuilder {
    pub(crate) cache_cluster_id: std::option::Option<std::string::String>,
    pub(crate) configuration_endpoint: std::option::Option<crate::types::Endpoint>,
    pub(crate) client_download_landing_page: std::option::Option<std::string::String>,
    pub(crate) cache_node_type: std::option::Option<std::string::String>,
    pub(crate) engine: std::option::Option<std::string::String>,
    pub(crate) engine_version: std::option::Option<std::string::String>,
    pub(crate) cache_cluster_status: std::option::Option<std::string::String>,
    pub(crate) num_cache_nodes: std::option::Option<i32>,
    pub(crate) preferred_availability_zone: std::option::Option<std::string::String>,
    pub(crate) preferred_outpost_arn: std::option::Option<std::string::String>,
    pub(crate) cache_cluster_create_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) preferred_maintenance_window: std::option::Option<std::string::String>,
    pub(crate) pending_modified_values: std::option::Option<crate::types::PendingModifiedValues>,
    pub(crate) notification_configuration:
        std::option::Option<crate::types::NotificationConfiguration>,
    pub(crate) cache_security_groups:
        std::option::Option<std::vec::Vec<crate::types::CacheSecurityGroupMembership>>,
    pub(crate) cache_parameter_group: std::option::Option<crate::types::CacheParameterGroupStatus>,
    pub(crate) cache_subnet_group_name: std::option::Option<std::string::String>,
    pub(crate) cache_nodes: std::option::Option<std::vec::Vec<crate::types::CacheNode>>,
    pub(crate) auto_minor_version_upgrade: std::option::Option<bool>,
    pub(crate) security_groups:
        std::option::Option<std::vec::Vec<crate::types::SecurityGroupMembership>>,
    pub(crate) replication_group_id: std::option::Option<std::string::String>,
    pub(crate) snapshot_retention_limit: std::option::Option<i32>,
    pub(crate) snapshot_window: std::option::Option<std::string::String>,
    pub(crate) auth_token_enabled: std::option::Option<bool>,
    pub(crate) auth_token_last_modified_date: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) transit_encryption_enabled: std::option::Option<bool>,
    pub(crate) at_rest_encryption_enabled: std::option::Option<bool>,
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) replication_group_log_delivery_enabled: std::option::Option<bool>,
    pub(crate) log_delivery_configurations:
        std::option::Option<std::vec::Vec<crate::types::LogDeliveryConfiguration>>,
    pub(crate) network_type: std::option::Option<crate::types::NetworkType>,
    pub(crate) ip_discovery: std::option::Option<crate::types::IpDiscovery>,
    pub(crate) transit_encryption_mode: std::option::Option<crate::types::TransitEncryptionMode>,
}
impl CacheClusterBuilder {
    /// <p>The user-supplied identifier of the cluster. This identifier is a unique key that identifies a cluster.</p>
    pub fn cache_cluster_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_cluster_id = Some(input.into());
        self
    }
    /// <p>The user-supplied identifier of the cluster. This identifier is a unique key that identifies a cluster.</p>
    pub fn set_cache_cluster_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cache_cluster_id = input;
        self
    }
    /// <p>Represents a Memcached cluster endpoint which can be used by an application to connect to any node in the cluster. The configuration endpoint will always have <code>.cfg</code> in it.</p>
    /// <p>Example: <code>mem-3.9dvc4r<u>.cfg</u>.usw2.cache.amazonaws.com:11211</code> </p>
    pub fn configuration_endpoint(mut self, input: crate::types::Endpoint) -> Self {
        self.configuration_endpoint = Some(input);
        self
    }
    /// <p>Represents a Memcached cluster endpoint which can be used by an application to connect to any node in the cluster. The configuration endpoint will always have <code>.cfg</code> in it.</p>
    /// <p>Example: <code>mem-3.9dvc4r<u>.cfg</u>.usw2.cache.amazonaws.com:11211</code> </p>
    pub fn set_configuration_endpoint(
        mut self,
        input: std::option::Option<crate::types::Endpoint>,
    ) -> Self {
        self.configuration_endpoint = input;
        self
    }
    /// <p>The URL of the web page where you can download the latest ElastiCache client library.</p>
    pub fn client_download_landing_page(mut self, input: impl Into<std::string::String>) -> Self {
        self.client_download_landing_page = Some(input.into());
        self
    }
    /// <p>The URL of the web page where you can download the latest ElastiCache client library.</p>
    pub fn set_client_download_landing_page(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.client_download_landing_page = input;
        self
    }
    /// <p>The name of the compute and memory capacity node type for the cluster.</p>
    /// <p>The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts.</p>
    /// <ul>
    /// <li> <p>General purpose:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>M6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward): <code>cache.m6g.large</code>, <code>cache.m6g.xlarge</code>, <code>cache.m6g.2xlarge</code>, <code>cache.m6g.4xlarge</code>, <code>cache.m6g.8xlarge</code>, <code>cache.m6g.12xlarge</code>, <code>cache.m6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>M5 node types:</b> <code>cache.m5.large</code>, <code>cache.m5.xlarge</code>, <code>cache.m5.2xlarge</code>, <code>cache.m5.4xlarge</code>, <code>cache.m5.12xlarge</code>, <code>cache.m5.24xlarge</code> </p> <p> <b>M4 node types:</b> <code>cache.m4.large</code>, <code>cache.m4.xlarge</code>, <code>cache.m4.2xlarge</code>, <code>cache.m4.4xlarge</code>, <code>cache.m4.10xlarge</code> </p> <p> <b>T4g node types</b> (available only for Redis engine version 5.0.6 onward and Memcached engine version 1.5.16 onward): <code>cache.t4g.micro</code>, <code>cache.t4g.small</code>, <code>cache.t4g.medium</code> </p> <p> <b>T3 node types:</b> <code>cache.t3.micro</code>, <code>cache.t3.small</code>, <code>cache.t3.medium</code> </p> <p> <b>T2 node types:</b> <code>cache.t2.micro</code>, <code>cache.t2.small</code>, <code>cache.t2.medium</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>T1 node types:</b> <code>cache.t1.micro</code> </p> <p> <b>M1 node types:</b> <code>cache.m1.small</code>, <code>cache.m1.medium</code>, <code>cache.m1.large</code>, <code>cache.m1.xlarge</code> </p> <p> <b>M3 node types:</b> <code>cache.m3.medium</code>, <code>cache.m3.large</code>, <code>cache.m3.xlarge</code>, <code>cache.m3.2xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Compute optimized:</p>
    /// <ul>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>C1 node types:</b> <code>cache.c1.xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Memory optimized:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>R6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward).</p> <p> <code>cache.r6g.large</code>, <code>cache.r6g.xlarge</code>, <code>cache.r6g.2xlarge</code>, <code>cache.r6g.4xlarge</code>, <code>cache.r6g.8xlarge</code>, <code>cache.r6g.12xlarge</code>, <code>cache.r6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>R5 node types:</b> <code>cache.r5.large</code>, <code>cache.r5.xlarge</code>, <code>cache.r5.2xlarge</code>, <code>cache.r5.4xlarge</code>, <code>cache.r5.12xlarge</code>, <code>cache.r5.24xlarge</code> </p> <p> <b>R4 node types:</b> <code>cache.r4.large</code>, <code>cache.r4.xlarge</code>, <code>cache.r4.2xlarge</code>, <code>cache.r4.4xlarge</code>, <code>cache.r4.8xlarge</code>, <code>cache.r4.16xlarge</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>M2 node types:</b> <code>cache.m2.xlarge</code>, <code>cache.m2.2xlarge</code>, <code>cache.m2.4xlarge</code> </p> <p> <b>R3 node types:</b> <code>cache.r3.large</code>, <code>cache.r3.xlarge</code>, <code>cache.r3.2xlarge</code>, <code>cache.r3.4xlarge</code>, <code>cache.r3.8xlarge</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    /// <p> <b>Additional node type info</b> </p>
    /// <ul>
    /// <li> <p>All current generation instance types are created in Amazon VPC by default.</p> </li>
    /// <li> <p>Redis append-only files (AOF) are not supported for T1 or T2 instances.</p> </li>
    /// <li> <p>Redis Multi-AZ with automatic failover is not supported on T1 instances.</p> </li>
    /// <li> <p>Redis configuration variables <code>appendonly</code> and <code>appendfsync</code> are not supported on Redis version 2.8.22 and later.</p> </li>
    /// </ul>
    pub fn cache_node_type(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_node_type = Some(input.into());
        self
    }
    /// <p>The name of the compute and memory capacity node type for the cluster.</p>
    /// <p>The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts.</p>
    /// <ul>
    /// <li> <p>General purpose:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>M6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward): <code>cache.m6g.large</code>, <code>cache.m6g.xlarge</code>, <code>cache.m6g.2xlarge</code>, <code>cache.m6g.4xlarge</code>, <code>cache.m6g.8xlarge</code>, <code>cache.m6g.12xlarge</code>, <code>cache.m6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>M5 node types:</b> <code>cache.m5.large</code>, <code>cache.m5.xlarge</code>, <code>cache.m5.2xlarge</code>, <code>cache.m5.4xlarge</code>, <code>cache.m5.12xlarge</code>, <code>cache.m5.24xlarge</code> </p> <p> <b>M4 node types:</b> <code>cache.m4.large</code>, <code>cache.m4.xlarge</code>, <code>cache.m4.2xlarge</code>, <code>cache.m4.4xlarge</code>, <code>cache.m4.10xlarge</code> </p> <p> <b>T4g node types</b> (available only for Redis engine version 5.0.6 onward and Memcached engine version 1.5.16 onward): <code>cache.t4g.micro</code>, <code>cache.t4g.small</code>, <code>cache.t4g.medium</code> </p> <p> <b>T3 node types:</b> <code>cache.t3.micro</code>, <code>cache.t3.small</code>, <code>cache.t3.medium</code> </p> <p> <b>T2 node types:</b> <code>cache.t2.micro</code>, <code>cache.t2.small</code>, <code>cache.t2.medium</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>T1 node types:</b> <code>cache.t1.micro</code> </p> <p> <b>M1 node types:</b> <code>cache.m1.small</code>, <code>cache.m1.medium</code>, <code>cache.m1.large</code>, <code>cache.m1.xlarge</code> </p> <p> <b>M3 node types:</b> <code>cache.m3.medium</code>, <code>cache.m3.large</code>, <code>cache.m3.xlarge</code>, <code>cache.m3.2xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Compute optimized:</p>
    /// <ul>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>C1 node types:</b> <code>cache.c1.xlarge</code> </p> </li>
    /// </ul> </li>
    /// <li> <p>Memory optimized:</p>
    /// <ul>
    /// <li> <p>Current generation: </p> <p> <b>R6g node types</b> (available only for Redis engine version 5.0.6 onward and for Memcached engine version 1.5.16 onward).</p> <p> <code>cache.r6g.large</code>, <code>cache.r6g.xlarge</code>, <code>cache.r6g.2xlarge</code>, <code>cache.r6g.4xlarge</code>, <code>cache.r6g.8xlarge</code>, <code>cache.r6g.12xlarge</code>, <code>cache.r6g.16xlarge</code> </p> <note>
    /// <p>For region availability, see <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion">Supported Node Types</a> </p>
    /// </note> <p> <b>R5 node types:</b> <code>cache.r5.large</code>, <code>cache.r5.xlarge</code>, <code>cache.r5.2xlarge</code>, <code>cache.r5.4xlarge</code>, <code>cache.r5.12xlarge</code>, <code>cache.r5.24xlarge</code> </p> <p> <b>R4 node types:</b> <code>cache.r4.large</code>, <code>cache.r4.xlarge</code>, <code>cache.r4.2xlarge</code>, <code>cache.r4.4xlarge</code>, <code>cache.r4.8xlarge</code>, <code>cache.r4.16xlarge</code> </p> </li>
    /// <li> <p>Previous generation: (not recommended. Existing clusters are still supported but creation of new clusters is not supported for these types.)</p> <p> <b>M2 node types:</b> <code>cache.m2.xlarge</code>, <code>cache.m2.2xlarge</code>, <code>cache.m2.4xlarge</code> </p> <p> <b>R3 node types:</b> <code>cache.r3.large</code>, <code>cache.r3.xlarge</code>, <code>cache.r3.2xlarge</code>, <code>cache.r3.4xlarge</code>, <code>cache.r3.8xlarge</code> </p> </li>
    /// </ul> </li>
    /// </ul>
    /// <p> <b>Additional node type info</b> </p>
    /// <ul>
    /// <li> <p>All current generation instance types are created in Amazon VPC by default.</p> </li>
    /// <li> <p>Redis append-only files (AOF) are not supported for T1 or T2 instances.</p> </li>
    /// <li> <p>Redis Multi-AZ with automatic failover is not supported on T1 instances.</p> </li>
    /// <li> <p>Redis configuration variables <code>appendonly</code> and <code>appendfsync</code> are not supported on Redis version 2.8.22 and later.</p> </li>
    /// </ul>
    pub fn set_cache_node_type(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.cache_node_type = input;
        self
    }
    /// <p>The name of the cache engine (<code>memcached</code> or <code>redis</code>) to be used for this cluster.</p>
    pub fn engine(mut self, input: impl Into<std::string::String>) -> Self {
        self.engine = Some(input.into());
        self
    }
    /// <p>The name of the cache engine (<code>memcached</code> or <code>redis</code>) to be used for this cluster.</p>
    pub fn set_engine(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.engine = input;
        self
    }
    /// <p>The version of the cache engine that is used in this cluster.</p>
    pub fn engine_version(mut self, input: impl Into<std::string::String>) -> Self {
        self.engine_version = Some(input.into());
        self
    }
    /// <p>The version of the cache engine that is used in this cluster.</p>
    pub fn set_engine_version(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.engine_version = input;
        self
    }
    /// <p>The current state of this cluster, one of the following values: <code>available</code>, <code>creating</code>, <code>deleted</code>, <code>deleting</code>, <code>incompatible-network</code>, <code>modifying</code>, <code>rebooting cluster nodes</code>, <code>restore-failed</code>, or <code>snapshotting</code>.</p>
    pub fn cache_cluster_status(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_cluster_status = Some(input.into());
        self
    }
    /// <p>The current state of this cluster, one of the following values: <code>available</code>, <code>creating</code>, <code>deleted</code>, <code>deleting</code>, <code>incompatible-network</code>, <code>modifying</code>, <code>rebooting cluster nodes</code>, <code>restore-failed</code>, or <code>snapshotting</code>.</p>
    pub fn set_cache_cluster_status(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.cache_cluster_status = input;
        self
    }
    /// <p>The number of cache nodes in the cluster.</p>
    /// <p>For clusters running Redis, this value must be 1. For clusters running Memcached, this value must be between 1 and 40.</p>
    pub fn num_cache_nodes(mut self, input: i32) -> Self {
        self.num_cache_nodes = Some(input);
        self
    }
    /// <p>The number of cache nodes in the cluster.</p>
    /// <p>For clusters running Redis, this value must be 1. For clusters running Memcached, this value must be between 1 and 40.</p>
    pub fn set_num_cache_nodes(mut self, input: std::option::Option<i32>) -> Self {
        self.num_cache_nodes = input;
        self
    }
    /// <p>The name of the Availability Zone in which the cluster is located or "Multiple" if the cache nodes are located in different Availability Zones.</p>
    pub fn preferred_availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
        self.preferred_availability_zone = Some(input.into());
        self
    }
    /// <p>The name of the Availability Zone in which the cluster is located or "Multiple" if the cache nodes are located in different Availability Zones.</p>
    pub fn set_preferred_availability_zone(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.preferred_availability_zone = input;
        self
    }
    /// <p>The outpost ARN in which the cache cluster is created.</p>
    pub fn preferred_outpost_arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.preferred_outpost_arn = Some(input.into());
        self
    }
    /// <p>The outpost ARN in which the cache cluster is created.</p>
    pub fn set_preferred_outpost_arn(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.preferred_outpost_arn = input;
        self
    }
    /// <p>The date and time when the cluster was created.</p>
    pub fn cache_cluster_create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.cache_cluster_create_time = Some(input);
        self
    }
    /// <p>The date and time when the cluster was created.</p>
    pub fn set_cache_cluster_create_time(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.cache_cluster_create_time = input;
        self
    }
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    pub fn preferred_maintenance_window(mut self, input: impl Into<std::string::String>) -> Self {
        self.preferred_maintenance_window = Some(input.into());
        self
    }
    /// <p>Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period.</p>
    /// <p>Valid values for <code>ddd</code> are:</p>
    /// <ul>
    /// <li> <p> <code>sun</code> </p> </li>
    /// <li> <p> <code>mon</code> </p> </li>
    /// <li> <p> <code>tue</code> </p> </li>
    /// <li> <p> <code>wed</code> </p> </li>
    /// <li> <p> <code>thu</code> </p> </li>
    /// <li> <p> <code>fri</code> </p> </li>
    /// <li> <p> <code>sat</code> </p> </li>
    /// </ul>
    /// <p>Example: <code>sun:23:00-mon:01:30</code> </p>
    pub fn set_preferred_maintenance_window(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.preferred_maintenance_window = input;
        self
    }
    /// <p>A group of settings that are applied to the cluster in the future, or that are currently being applied.</p>
    pub fn pending_modified_values(mut self, input: crate::types::PendingModifiedValues) -> Self {
        self.pending_modified_values = Some(input);
        self
    }
    /// <p>A group of settings that are applied to the cluster in the future, or that are currently being applied.</p>
    pub fn set_pending_modified_values(
        mut self,
        input: std::option::Option<crate::types::PendingModifiedValues>,
    ) -> Self {
        self.pending_modified_values = input;
        self
    }
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing ElastiCache events to subscribers using Amazon Simple Notification Service (SNS). </p>
    pub fn notification_configuration(
        mut self,
        input: crate::types::NotificationConfiguration,
    ) -> Self {
        self.notification_configuration = Some(input);
        self
    }
    /// <p>Describes a notification topic and its status. Notification topics are used for publishing ElastiCache events to subscribers using Amazon Simple Notification Service (SNS). </p>
    pub fn set_notification_configuration(
        mut self,
        input: std::option::Option<crate::types::NotificationConfiguration>,
    ) -> Self {
        self.notification_configuration = input;
        self
    }
    /// Appends an item to `cache_security_groups`.
    ///
    /// To override the contents of this collection use [`set_cache_security_groups`](Self::set_cache_security_groups).
    ///
    /// <p>A list of cache security group elements, composed of name and status sub-elements.</p>
    pub fn cache_security_groups(
        mut self,
        input: crate::types::CacheSecurityGroupMembership,
    ) -> Self {
        let mut v = self.cache_security_groups.unwrap_or_default();
        v.push(input);
        self.cache_security_groups = Some(v);
        self
    }
    /// <p>A list of cache security group elements, composed of name and status sub-elements.</p>
    pub fn set_cache_security_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::CacheSecurityGroupMembership>>,
    ) -> Self {
        self.cache_security_groups = input;
        self
    }
    /// <p>Status of the cache parameter group.</p>
    pub fn cache_parameter_group(mut self, input: crate::types::CacheParameterGroupStatus) -> Self {
        self.cache_parameter_group = Some(input);
        self
    }
    /// <p>Status of the cache parameter group.</p>
    pub fn set_cache_parameter_group(
        mut self,
        input: std::option::Option<crate::types::CacheParameterGroupStatus>,
    ) -> Self {
        self.cache_parameter_group = input;
        self
    }
    /// <p>The name of the cache subnet group associated with the cluster.</p>
    pub fn cache_subnet_group_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.cache_subnet_group_name = Some(input.into());
        self
    }
    /// <p>The name of the cache subnet group associated with the cluster.</p>
    pub fn set_cache_subnet_group_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.cache_subnet_group_name = input;
        self
    }
    /// Appends an item to `cache_nodes`.
    ///
    /// To override the contents of this collection use [`set_cache_nodes`](Self::set_cache_nodes).
    ///
    /// <p>A list of cache nodes that are members of the cluster.</p>
    pub fn cache_nodes(mut self, input: crate::types::CacheNode) -> Self {
        let mut v = self.cache_nodes.unwrap_or_default();
        v.push(input);
        self.cache_nodes = Some(v);
        self
    }
    /// <p>A list of cache nodes that are members of the cluster.</p>
    pub fn set_cache_nodes(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::CacheNode>>,
    ) -> Self {
        self.cache_nodes = input;
        self
    }
    /// <p>&nbsp;If you are running Redis engine version 6.0 or later, set this parameter to yes if you want to opt-in to the next auto minor version upgrade campaign. This parameter is disabled for previous versions.&nbsp; </p>
    pub fn auto_minor_version_upgrade(mut self, input: bool) -> Self {
        self.auto_minor_version_upgrade = Some(input);
        self
    }
    /// <p>&nbsp;If you are running Redis engine version 6.0 or later, set this parameter to yes if you want to opt-in to the next auto minor version upgrade campaign. This parameter is disabled for previous versions.&nbsp; </p>
    pub fn set_auto_minor_version_upgrade(mut self, input: std::option::Option<bool>) -> Self {
        self.auto_minor_version_upgrade = input;
        self
    }
    /// Appends an item to `security_groups`.
    ///
    /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
    ///
    /// <p>A list of VPC Security Groups associated with the cluster.</p>
    pub fn security_groups(mut self, input: crate::types::SecurityGroupMembership) -> Self {
        let mut v = self.security_groups.unwrap_or_default();
        v.push(input);
        self.security_groups = Some(v);
        self
    }
    /// <p>A list of VPC Security Groups associated with the cluster.</p>
    pub fn set_security_groups(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::SecurityGroupMembership>>,
    ) -> Self {
        self.security_groups = input;
        self
    }
    /// <p>The replication group to which this cluster belongs. If this field is empty, the cluster is not associated with any replication group.</p>
    pub fn replication_group_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.replication_group_id = Some(input.into());
        self
    }
    /// <p>The replication group to which this cluster belongs. If this field is empty, the cluster is not associated with any replication group.</p>
    pub fn set_replication_group_id(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.replication_group_id = input;
        self
    }
    /// <p>The number of days for which ElastiCache retains automatic cluster snapshots before deleting them. For example, if you set <code>SnapshotRetentionLimit</code> to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p> <important>
    /// <p> If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off.</p>
    /// </important>
    pub fn snapshot_retention_limit(mut self, input: i32) -> Self {
        self.snapshot_retention_limit = Some(input);
        self
    }
    /// <p>The number of days for which ElastiCache retains automatic cluster snapshots before deleting them. For example, if you set <code>SnapshotRetentionLimit</code> to 5, a snapshot that was taken today is retained for 5 days before being deleted.</p> <important>
    /// <p> If the value of SnapshotRetentionLimit is set to zero (0), backups are turned off.</p>
    /// </important>
    pub fn set_snapshot_retention_limit(mut self, input: std::option::Option<i32>) -> Self {
        self.snapshot_retention_limit = input;
        self
    }
    /// <p>The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your cluster.</p>
    /// <p>Example: <code>05:00-09:00</code> </p>
    pub fn snapshot_window(mut self, input: impl Into<std::string::String>) -> Self {
        self.snapshot_window = Some(input.into());
        self
    }
    /// <p>The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your cluster.</p>
    /// <p>Example: <code>05:00-09:00</code> </p>
    pub fn set_snapshot_window(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.snapshot_window = input;
        self
    }
    /// <p>A flag that enables using an <code>AuthToken</code> (password) when issuing Redis commands.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn auth_token_enabled(mut self, input: bool) -> Self {
        self.auth_token_enabled = Some(input);
        self
    }
    /// <p>A flag that enables using an <code>AuthToken</code> (password) when issuing Redis commands.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn set_auth_token_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.auth_token_enabled = input;
        self
    }
    /// <p>The date the auth token was last modified</p>
    pub fn auth_token_last_modified_date(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.auth_token_last_modified_date = Some(input);
        self
    }
    /// <p>The date the auth token was last modified</p>
    pub fn set_auth_token_last_modified_date(
        mut self,
        input: std::option::Option<aws_smithy_types::DateTime>,
    ) -> Self {
        self.auth_token_last_modified_date = input;
        self
    }
    /// <p>A flag that enables in-transit encryption when set to <code>true</code>.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn transit_encryption_enabled(mut self, input: bool) -> Self {
        self.transit_encryption_enabled = Some(input);
        self
    }
    /// <p>A flag that enables in-transit encryption when set to <code>true</code>.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn set_transit_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.transit_encryption_enabled = input;
        self
    }
    /// <p>A flag that enables encryption at-rest when set to <code>true</code>.</p>
    /// <p>You cannot modify the value of <code>AtRestEncryptionEnabled</code> after the cluster is created. To enable at-rest encryption on a cluster you must set <code>AtRestEncryptionEnabled</code> to <code>true</code> when you create a cluster.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn at_rest_encryption_enabled(mut self, input: bool) -> Self {
        self.at_rest_encryption_enabled = Some(input);
        self
    }
    /// <p>A flag that enables encryption at-rest when set to <code>true</code>.</p>
    /// <p>You cannot modify the value of <code>AtRestEncryptionEnabled</code> after the cluster is created. To enable at-rest encryption on a cluster you must set <code>AtRestEncryptionEnabled</code> to <code>true</code> when you create a cluster.</p>
    /// <p> <b>Required:</b> Only available when creating a replication group in an Amazon VPC using redis version <code>3.2.6</code>, <code>4.x</code> or later.</p>
    /// <p>Default: <code>false</code> </p>
    pub fn set_at_rest_encryption_enabled(mut self, input: std::option::Option<bool>) -> Self {
        self.at_rest_encryption_enabled = input;
        self
    }
    /// <p>The ARN (Amazon Resource Name) of the cache cluster.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The ARN (Amazon Resource Name) of the cache cluster.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>A boolean value indicating whether log delivery is enabled for the replication group.</p>
    pub fn replication_group_log_delivery_enabled(mut self, input: bool) -> Self {
        self.replication_group_log_delivery_enabled = Some(input);
        self
    }
    /// <p>A boolean value indicating whether log delivery is enabled for the replication group.</p>
    pub fn set_replication_group_log_delivery_enabled(
        mut self,
        input: std::option::Option<bool>,
    ) -> Self {
        self.replication_group_log_delivery_enabled = input;
        self
    }
    /// Appends an item to `log_delivery_configurations`.
    ///
    /// To override the contents of this collection use [`set_log_delivery_configurations`](Self::set_log_delivery_configurations).
    ///
    /// <p>Returns the destination, format and type of the logs.</p>
    pub fn log_delivery_configurations(
        mut self,
        input: crate::types::LogDeliveryConfiguration,
    ) -> Self {
        let mut v = self.log_delivery_configurations.unwrap_or_default();
        v.push(input);
        self.log_delivery_configurations = Some(v);
        self
    }
    /// <p>Returns the destination, format and type of the logs.</p>
    pub fn set_log_delivery_configurations(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::LogDeliveryConfiguration>>,
    ) -> Self {
        self.log_delivery_configurations = input;
        self
    }
    /// <p>Must be either <code>ipv4</code> | <code>ipv6</code> | <code>dual_stack</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    pub fn network_type(mut self, input: crate::types::NetworkType) -> Self {
        self.network_type = Some(input);
        self
    }
    /// <p>Must be either <code>ipv4</code> | <code>ipv6</code> | <code>dual_stack</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    pub fn set_network_type(
        mut self,
        input: std::option::Option<crate::types::NetworkType>,
    ) -> Self {
        self.network_type = input;
        self
    }
    /// <p>The network type associated with the cluster, either <code>ipv4</code> | <code>ipv6</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    pub fn ip_discovery(mut self, input: crate::types::IpDiscovery) -> Self {
        self.ip_discovery = Some(input);
        self
    }
    /// <p>The network type associated with the cluster, either <code>ipv4</code> | <code>ipv6</code>. IPv6 is supported for workloads using Redis engine version 6.2 onward or Memcached engine version 1.6.6 on all instances built on the <a href="https://aws.amazon.com/ec2/nitro/">Nitro system</a>.</p>
    pub fn set_ip_discovery(
        mut self,
        input: std::option::Option<crate::types::IpDiscovery>,
    ) -> Self {
        self.ip_discovery = input;
        self
    }
    /// <p>A setting that allows you to migrate your clients to use in-transit encryption, with no downtime.</p>
    pub fn transit_encryption_mode(mut self, input: crate::types::TransitEncryptionMode) -> Self {
        self.transit_encryption_mode = Some(input);
        self
    }
    /// <p>A setting that allows you to migrate your clients to use in-transit encryption, with no downtime.</p>
    pub fn set_transit_encryption_mode(
        mut self,
        input: std::option::Option<crate::types::TransitEncryptionMode>,
    ) -> Self {
        self.transit_encryption_mode = input;
        self
    }
    /// Consumes the builder and constructs a [`CacheCluster`](crate::types::CacheCluster).
    pub fn build(self) -> crate::types::CacheCluster {
        crate::types::CacheCluster {
            cache_cluster_id: self.cache_cluster_id,
            configuration_endpoint: self.configuration_endpoint,
            client_download_landing_page: self.client_download_landing_page,
            cache_node_type: self.cache_node_type,
            engine: self.engine,
            engine_version: self.engine_version,
            cache_cluster_status: self.cache_cluster_status,
            num_cache_nodes: self.num_cache_nodes,
            preferred_availability_zone: self.preferred_availability_zone,
            preferred_outpost_arn: self.preferred_outpost_arn,
            cache_cluster_create_time: self.cache_cluster_create_time,
            preferred_maintenance_window: self.preferred_maintenance_window,
            pending_modified_values: self.pending_modified_values,
            notification_configuration: self.notification_configuration,
            cache_security_groups: self.cache_security_groups,
            cache_parameter_group: self.cache_parameter_group,
            cache_subnet_group_name: self.cache_subnet_group_name,
            cache_nodes: self.cache_nodes,
            auto_minor_version_upgrade: self.auto_minor_version_upgrade.unwrap_or_default(),
            security_groups: self.security_groups,
            replication_group_id: self.replication_group_id,
            snapshot_retention_limit: self.snapshot_retention_limit,
            snapshot_window: self.snapshot_window,
            auth_token_enabled: self.auth_token_enabled,
            auth_token_last_modified_date: self.auth_token_last_modified_date,
            transit_encryption_enabled: self.transit_encryption_enabled,
            at_rest_encryption_enabled: self.at_rest_encryption_enabled,
            arn: self.arn,
            replication_group_log_delivery_enabled: self
                .replication_group_log_delivery_enabled
                .unwrap_or_default(),
            log_delivery_configurations: self.log_delivery_configurations,
            network_type: self.network_type,
            ip_discovery: self.ip_discovery,
            transit_encryption_mode: self.transit_encryption_mode,
        }
    }
}
