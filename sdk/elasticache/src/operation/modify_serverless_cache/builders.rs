// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::modify_serverless_cache::_modify_serverless_cache_output::ModifyServerlessCacheOutputBuilder;

pub use crate::operation::modify_serverless_cache::_modify_serverless_cache_input::ModifyServerlessCacheInputBuilder;

impl ModifyServerlessCacheInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::modify_serverless_cache::ModifyServerlessCacheOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::modify_serverless_cache::ModifyServerlessCacheError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.modify_serverless_cache();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ModifyServerlessCache`.
///
/// <p>This API modifies the attributes of a serverless cache.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ModifyServerlessCacheFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::modify_serverless_cache::builders::ModifyServerlessCacheInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::modify_serverless_cache::ModifyServerlessCacheOutput,
        crate::operation::modify_serverless_cache::ModifyServerlessCacheError,
    > for ModifyServerlessCacheFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::modify_serverless_cache::ModifyServerlessCacheOutput,
            crate::operation::modify_serverless_cache::ModifyServerlessCacheError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ModifyServerlessCacheFluentBuilder {
    /// Creates a new `ModifyServerlessCache`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ModifyServerlessCache as a reference.
    pub fn as_input(&self) -> &crate::operation::modify_serverless_cache::builders::ModifyServerlessCacheInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::modify_serverless_cache::ModifyServerlessCacheOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::modify_serverless_cache::ModifyServerlessCacheError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::modify_serverless_cache::ModifyServerlessCache::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::modify_serverless_cache::ModifyServerlessCache::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::modify_serverless_cache::ModifyServerlessCacheOutput,
        crate::operation::modify_serverless_cache::ModifyServerlessCacheError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>User-provided identifier for the serverless cache to be modified.</p>
    pub fn serverless_cache_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.serverless_cache_name(input.into());
        self
    }
    /// <p>User-provided identifier for the serverless cache to be modified.</p>
    pub fn set_serverless_cache_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_serverless_cache_name(input);
        self
    }
    /// <p>User-provided identifier for the serverless cache to be modified.</p>
    pub fn get_serverless_cache_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_serverless_cache_name()
    }
    /// <p>User provided description for the serverless cache. Default = NULL, i.e. the existing description is not removed/modified. The description has a maximum length of 255 characters.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>User provided description for the serverless cache. Default = NULL, i.e. the existing description is not removed/modified. The description has a maximum length of 255 characters.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>User provided description for the serverless cache. Default = NULL, i.e. the existing description is not removed/modified. The description has a maximum length of 255 characters.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>Modify the cache usage limit for the serverless cache.</p>
    pub fn cache_usage_limits(mut self, input: crate::types::CacheUsageLimits) -> Self {
        self.inner = self.inner.cache_usage_limits(input);
        self
    }
    /// <p>Modify the cache usage limit for the serverless cache.</p>
    pub fn set_cache_usage_limits(mut self, input: ::std::option::Option<crate::types::CacheUsageLimits>) -> Self {
        self.inner = self.inner.set_cache_usage_limits(input);
        self
    }
    /// <p>Modify the cache usage limit for the serverless cache.</p>
    pub fn get_cache_usage_limits(&self) -> &::std::option::Option<crate::types::CacheUsageLimits> {
        self.inner.get_cache_usage_limits()
    }
    /// <p>The identifier of the UserGroup to be removed from association with the Redis serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn remove_user_group(mut self, input: bool) -> Self {
        self.inner = self.inner.remove_user_group(input);
        self
    }
    /// <p>The identifier of the UserGroup to be removed from association with the Redis serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn set_remove_user_group(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_remove_user_group(input);
        self
    }
    /// <p>The identifier of the UserGroup to be removed from association with the Redis serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn get_remove_user_group(&self) -> &::std::option::Option<bool> {
        self.inner.get_remove_user_group()
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL - the existing UserGroup is not removed.</p>
    pub fn user_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.user_group_id(input.into());
        self
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL - the existing UserGroup is not removed.</p>
    pub fn set_user_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_user_group_id(input);
        self
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL - the existing UserGroup is not removed.</p>
    pub fn get_user_group_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_user_group_id()
    }
    /// Appends an item to `SecurityGroupIds`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>The new list of VPC security groups to be associated with the serverless cache. Populating this list means the current VPC security groups will be removed. This security group is used to authorize traffic access for the VPC end-point (private-link). Default = NULL - the existing list of VPC security groups is not removed.</p>
    pub fn security_group_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.security_group_ids(input.into());
        self
    }
    /// <p>The new list of VPC security groups to be associated with the serverless cache. Populating this list means the current VPC security groups will be removed. This security group is used to authorize traffic access for the VPC end-point (private-link). Default = NULL - the existing list of VPC security groups is not removed.</p>
    pub fn set_security_group_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_security_group_ids(input);
        self
    }
    /// <p>The new list of VPC security groups to be associated with the serverless cache. Populating this list means the current VPC security groups will be removed. This security group is used to authorize traffic access for the VPC end-point (private-link). Default = NULL - the existing list of VPC security groups is not removed.</p>
    pub fn get_security_group_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_security_group_ids()
    }
    /// <p>The number of days for which Elasticache retains automatic snapshots before deleting them. Available for Redis only. Default = NULL, i.e. the existing snapshot-retention-limit will not be removed or modified. The maximum value allowed is 35 days.</p>
    pub fn snapshot_retention_limit(mut self, input: i32) -> Self {
        self.inner = self.inner.snapshot_retention_limit(input);
        self
    }
    /// <p>The number of days for which Elasticache retains automatic snapshots before deleting them. Available for Redis only. Default = NULL, i.e. the existing snapshot-retention-limit will not be removed or modified. The maximum value allowed is 35 days.</p>
    pub fn set_snapshot_retention_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_snapshot_retention_limit(input);
        self
    }
    /// <p>The number of days for which Elasticache retains automatic snapshots before deleting them. Available for Redis only. Default = NULL, i.e. the existing snapshot-retention-limit will not be removed or modified. The maximum value allowed is 35 days.</p>
    pub fn get_snapshot_retention_limit(&self) -> &::std::option::Option<i32> {
        self.inner.get_snapshot_retention_limit()
    }
    /// <p>The daily time during which Elasticache begins taking a daily snapshot of the serverless cache. Available for Redis only. The default is NULL, i.e. the existing snapshot time configured for the cluster is not removed.</p>
    pub fn daily_snapshot_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.daily_snapshot_time(input.into());
        self
    }
    /// <p>The daily time during which Elasticache begins taking a daily snapshot of the serverless cache. Available for Redis only. The default is NULL, i.e. the existing snapshot time configured for the cluster is not removed.</p>
    pub fn set_daily_snapshot_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_daily_snapshot_time(input);
        self
    }
    /// <p>The daily time during which Elasticache begins taking a daily snapshot of the serverless cache. Available for Redis only. The default is NULL, i.e. the existing snapshot time configured for the cluster is not removed.</p>
    pub fn get_daily_snapshot_time(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_daily_snapshot_time()
    }
}
