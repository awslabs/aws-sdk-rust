// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_serverless_cache::_create_serverless_cache_output::CreateServerlessCacheOutputBuilder;

pub use crate::operation::create_serverless_cache::_create_serverless_cache_input::CreateServerlessCacheInputBuilder;

impl CreateServerlessCacheInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_serverless_cache::CreateServerlessCacheOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_serverless_cache::CreateServerlessCacheError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_serverless_cache();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateServerlessCache`.
///
/// <p>Creates a serverless cache.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateServerlessCacheFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_serverless_cache::builders::CreateServerlessCacheInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_serverless_cache::CreateServerlessCacheOutput,
        crate::operation::create_serverless_cache::CreateServerlessCacheError,
    > for CreateServerlessCacheFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_serverless_cache::CreateServerlessCacheOutput,
            crate::operation::create_serverless_cache::CreateServerlessCacheError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateServerlessCacheFluentBuilder {
    /// Creates a new `CreateServerlessCache`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateServerlessCache as a reference.
    pub fn as_input(&self) -> &crate::operation::create_serverless_cache::builders::CreateServerlessCacheInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_serverless_cache::CreateServerlessCacheOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_serverless_cache::CreateServerlessCacheError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_serverless_cache::CreateServerlessCache::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_serverless_cache::CreateServerlessCache::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_serverless_cache::CreateServerlessCacheOutput,
        crate::operation::create_serverless_cache::CreateServerlessCacheError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub fn serverless_cache_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.serverless_cache_name(input.into());
        self
    }
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub fn set_serverless_cache_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_serverless_cache_name(input);
        self
    }
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub fn get_serverless_cache_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_serverless_cache_name()
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.description(input.into());
        self
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_description(input);
        self
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_description()
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub fn engine(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.engine(input.into());
        self
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub fn set_engine(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_engine(input);
        self
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub fn get_engine(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_engine()
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn major_engine_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.major_engine_version(input.into());
        self
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn set_major_engine_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_major_engine_version(input);
        self
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn get_major_engine_version(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_major_engine_version()
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn cache_usage_limits(mut self, input: crate::types::CacheUsageLimits) -> Self {
        self.inner = self.inner.cache_usage_limits(input);
        self
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn set_cache_usage_limits(mut self, input: ::std::option::Option<crate::types::CacheUsageLimits>) -> Self {
        self.inner = self.inner.set_cache_usage_limits(input);
        self
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn get_cache_usage_limits(&self) -> &::std::option::Option<crate::types::CacheUsageLimits> {
        self.inner.get_cache_usage_limits()
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.kms_key_id(input.into());
        self
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_kms_key_id(input);
        self
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_kms_key_id()
    }
    /// Appends an item to `SecurityGroupIds`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub fn security_group_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.security_group_ids(input.into());
        self
    }
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub fn set_security_group_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_security_group_ids(input);
        self
    }
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub fn get_security_group_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_security_group_ids()
    }
    /// Appends an item to `SnapshotArnsToRestore`.
    ///
    /// To override the contents of this collection use [`set_snapshot_arns_to_restore`](Self::set_snapshot_arns_to_restore).
    ///
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub fn snapshot_arns_to_restore(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.snapshot_arns_to_restore(input.into());
        self
    }
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub fn set_snapshot_arns_to_restore(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_snapshot_arns_to_restore(input);
        self
    }
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub fn get_snapshot_arns_to_restore(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_snapshot_arns_to_restore()
    }
    /// Appends an item to `Tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        self.inner = self.inner.tags(input);
        self
    }
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        self.inner.get_tags()
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn user_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.user_group_id(input.into());
        self
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn set_user_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_user_group_id(input);
        self
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn get_user_group_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_user_group_id()
    }
    /// Appends an item to `SubnetIds`.
    ///
    /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
    ///
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub fn subnet_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.subnet_ids(input.into());
        self
    }
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub fn set_subnet_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.inner = self.inner.set_subnet_ids(input);
        self
    }
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub fn get_subnet_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        self.inner.get_subnet_ids()
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn snapshot_retention_limit(mut self, input: i32) -> Self {
        self.inner = self.inner.snapshot_retention_limit(input);
        self
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn set_snapshot_retention_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_snapshot_retention_limit(input);
        self
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn get_snapshot_retention_limit(&self) -> &::std::option::Option<i32> {
        self.inner.get_snapshot_retention_limit()
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn daily_snapshot_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.daily_snapshot_time(input.into());
        self
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn set_daily_snapshot_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_daily_snapshot_time(input);
        self
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn get_daily_snapshot_time(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_daily_snapshot_time()
    }
}
