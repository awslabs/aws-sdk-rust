// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::test_failover::_test_failover_output::TestFailoverOutputBuilder;

pub use crate::operation::test_failover::_test_failover_input::TestFailoverInputBuilder;

impl crate::operation::test_failover::builders::TestFailoverInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::test_failover::TestFailoverOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::test_failover::TestFailoverError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.test_failover();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `TestFailover`.
///
/// <p>Represents the input of a <code>TestFailover</code> operation which test automatic failover on a specified node group (called shard in the console) in a replication group (called cluster in the console).</p>
/// <p>This API is designed for testing the behavior of your application in case of ElastiCache failover. It is not designed to be an operational tool for initiating a failover to overcome a problem you may have with the cluster. Moreover, in certain conditions such as large-scale operational events, Amazon may block this API.</p>
/// <p class="title"><b>Note the following</b></p>
/// <ul>
/// <li>
/// <p>A customer can use this operation to test automatic failover on up to 5 shards (called node groups in the ElastiCache API and Amazon CLI) in any rolling 24-hour period.</p></li>
/// <li>
/// <p>If calling this operation on shards in different clusters (called replication groups in the API and CLI), the calls can be made concurrently.</p>
/// <p></p></li>
/// <li>
/// <p>If calling this operation multiple times on different shards in the same Redis (cluster mode enabled) replication group, the first node replacement must complete before a subsequent call can be made.</p></li>
/// <li>
/// <p>To determine whether the node replacement is complete you can check Events using the Amazon ElastiCache console, the Amazon CLI, or the ElastiCache API. Look for the following automatic failover related events, listed here in order of occurrance:</p>
/// <ol>
/// <li>
/// <p>Replication group message: <code>Test Failover API called for node group <node-group-id></node-group-id></code></p></li>
/// <li>
/// <p>Cache cluster message: <code>Failover from primary node <primary-node-id>
/// to replica node
/// <node-id>
/// completed
/// </node-id>
/// </primary-node-id></code></p></li>
/// <li>
/// <p>Replication group message: <code>Failover from primary node <primary-node-id>
/// to replica node
/// <node-id>
/// completed
/// </node-id>
/// </primary-node-id></code></p></li>
/// <li>
/// <p>Cache cluster message: <code>Recovering cache nodes <node-id></node-id></code></p></li>
/// <li>
/// <p>Cache cluster message: <code>Finished recovery for cache nodes <node-id></node-id></code></p></li>
/// </ol>
/// <p>For more information see:</p>
/// <ul>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/ECEvents.Viewing.html">Viewing ElastiCache Events</a> in the <i>ElastiCache User Guide</i></p></li>
/// <li>
/// <p><a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/APIReference/API_DescribeEvents.html">DescribeEvents</a> in the ElastiCache API Reference</p></li>
/// </ul></li>
/// </ul>
/// <p>Also see, <a href="https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/AutoFailover.html#auto-failover-test">Testing Multi-AZ </a> in the <i>ElastiCache User Guide</i>.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct TestFailoverFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::test_failover::builders::TestFailoverInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::test_failover::TestFailoverOutput,
        crate::operation::test_failover::TestFailoverError,
    > for TestFailoverFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::test_failover::TestFailoverOutput,
            crate::operation::test_failover::TestFailoverError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl TestFailoverFluentBuilder {
    /// Creates a new `TestFailover`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the TestFailover as a reference.
    pub fn as_input(&self) -> &crate::operation::test_failover::builders::TestFailoverInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::test_failover::TestFailoverOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::test_failover::TestFailoverError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::test_failover::TestFailover::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::test_failover::TestFailover::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::test_failover::TestFailoverOutput,
        crate::operation::test_failover::TestFailoverError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl ::std::convert::Into<crate::config::Builder>) -> Self {
        self.set_config_override(::std::option::Option::Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: ::std::option::Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The name of the replication group (console: cluster) whose automatic failover is being tested by this operation.</p>
    pub fn replication_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.replication_group_id(input.into());
        self
    }
    /// <p>The name of the replication group (console: cluster) whose automatic failover is being tested by this operation.</p>
    pub fn set_replication_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_replication_group_id(input);
        self
    }
    /// <p>The name of the replication group (console: cluster) whose automatic failover is being tested by this operation.</p>
    pub fn get_replication_group_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_replication_group_id()
    }
    /// <p>The name of the node group (called shard in the console) in this replication group on which automatic failover is to be tested. You may test automatic failover on up to 5 node groups in any rolling 24-hour period.</p>
    pub fn node_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.node_group_id(input.into());
        self
    }
    /// <p>The name of the node group (called shard in the console) in this replication group on which automatic failover is to be tested. You may test automatic failover on up to 5 node groups in any rolling 24-hour period.</p>
    pub fn set_node_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_node_group_id(input);
        self
    }
    /// <p>The name of the node group (called shard in the console) in this replication group on which automatic failover is to be tested. You may test automatic failover on up to 5 node groups in any rolling 24-hour period.</p>
    pub fn get_node_group_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_node_group_id()
    }
}
