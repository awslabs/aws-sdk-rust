// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateTeamMemberError {
    pub kind: AssociateTeamMemberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateTeamMemberErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidServiceRoleException(crate::error::InvalidServiceRoleException),
    LimitExceededException(crate::error::LimitExceededException),
    ProjectConfigurationException(crate::error::ProjectConfigurationException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    TeamMemberAlreadyAssociatedException(crate::error::TeamMemberAlreadyAssociatedException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateTeamMemberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateTeamMemberErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            AssociateTeamMemberErrorKind::InvalidServiceRoleException(_inner) => _inner.fmt(f),
            AssociateTeamMemberErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            AssociateTeamMemberErrorKind::ProjectConfigurationException(_inner) => _inner.fmt(f),
            AssociateTeamMemberErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            AssociateTeamMemberErrorKind::TeamMemberAlreadyAssociatedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateTeamMemberErrorKind::ValidationException(_inner) => _inner.fmt(f),
            AssociateTeamMemberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateTeamMemberError {
    fn code(&self) -> Option<&str> {
        AssociateTeamMemberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateTeamMemberError {
    pub fn new(kind: AssociateTeamMemberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateTeamMemberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateTeamMemberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_service_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::InvalidServiceRoleException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_project_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::ProjectConfigurationException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_team_member_already_associated_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::TeamMemberAlreadyAssociatedException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateTeamMemberErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateTeamMemberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateTeamMemberErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            AssociateTeamMemberErrorKind::InvalidServiceRoleException(_inner) => Some(_inner),
            AssociateTeamMemberErrorKind::LimitExceededException(_inner) => Some(_inner),
            AssociateTeamMemberErrorKind::ProjectConfigurationException(_inner) => Some(_inner),
            AssociateTeamMemberErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            AssociateTeamMemberErrorKind::TeamMemberAlreadyAssociatedException(_inner) => {
                Some(_inner)
            }
            AssociateTeamMemberErrorKind::ValidationException(_inner) => Some(_inner),
            AssociateTeamMemberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateProjectError {
    pub kind: CreateProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateProjectErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidServiceRoleException(crate::error::InvalidServiceRoleException),
    LimitExceededException(crate::error::LimitExceededException),
    ProjectAlreadyExistsException(crate::error::ProjectAlreadyExistsException),
    ProjectConfigurationException(crate::error::ProjectConfigurationException),
    ProjectCreationFailedException(crate::error::ProjectCreationFailedException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateProjectErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::InvalidServiceRoleException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ProjectAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ProjectConfigurationException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ProjectCreationFailedException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateProjectError {
    fn code(&self) -> Option<&str> {
        CreateProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateProjectError {
    pub fn new(kind: CreateProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_service_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::InvalidServiceRoleException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_project_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ProjectAlreadyExistsException(_)
        )
    }
    pub fn is_project_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ProjectConfigurationException(_)
        )
    }
    pub fn is_project_creation_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateProjectErrorKind::ProjectCreationFailedException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateProjectErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateProjectErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            CreateProjectErrorKind::InvalidServiceRoleException(_inner) => Some(_inner),
            CreateProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            CreateProjectErrorKind::ProjectAlreadyExistsException(_inner) => Some(_inner),
            CreateProjectErrorKind::ProjectConfigurationException(_inner) => Some(_inner),
            CreateProjectErrorKind::ProjectCreationFailedException(_inner) => Some(_inner),
            CreateProjectErrorKind::ValidationException(_inner) => Some(_inner),
            CreateProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUserProfileError {
    pub kind: CreateUserProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUserProfileErrorKind {
    UserProfileAlreadyExistsException(crate::error::UserProfileAlreadyExistsException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUserProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUserProfileErrorKind::UserProfileAlreadyExistsException(_inner) => _inner.fmt(f),
            CreateUserProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateUserProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUserProfileError {
    fn code(&self) -> Option<&str> {
        CreateUserProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUserProfileError {
    pub fn new(kind: CreateUserProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUserProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUserProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_user_profile_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserProfileErrorKind::UserProfileAlreadyExistsException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUserProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateUserProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUserProfileErrorKind::UserProfileAlreadyExistsException(_inner) => Some(_inner),
            CreateUserProfileErrorKind::ValidationException(_inner) => Some(_inner),
            CreateUserProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteProjectError {
    pub kind: DeleteProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteProjectErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidServiceRoleException(crate::error::InvalidServiceRoleException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteProjectErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::InvalidServiceRoleException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteProjectError {
    fn code(&self) -> Option<&str> {
        DeleteProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteProjectError {
    pub fn new(kind: DeleteProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_service_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteProjectErrorKind::InvalidServiceRoleException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteProjectErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteProjectErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DeleteProjectErrorKind::InvalidServiceRoleException(_inner) => Some(_inner),
            DeleteProjectErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserProfileError {
    pub kind: DeleteUserProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserProfileErrorKind {
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteUserProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserProfileError {
    fn code(&self) -> Option<&str> {
        DeleteUserProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserProfileError {
    pub fn new(kind: DeleteUserProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteUserProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserProfileErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteUserProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeProjectError {
    pub kind: DescribeProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeProjectErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidServiceRoleException(crate::error::InvalidServiceRoleException),
    ProjectConfigurationException(crate::error::ProjectConfigurationException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeProjectErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            DescribeProjectErrorKind::InvalidServiceRoleException(_inner) => _inner.fmt(f),
            DescribeProjectErrorKind::ProjectConfigurationException(_inner) => _inner.fmt(f),
            DescribeProjectErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            DescribeProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeProjectError {
    fn code(&self) -> Option<&str> {
        DescribeProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeProjectError {
    pub fn new(kind: DescribeProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_service_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectErrorKind::InvalidServiceRoleException(_)
        )
    }
    pub fn is_project_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectErrorKind::ProjectConfigurationException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeProjectErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DescribeProjectErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DescribeProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeProjectErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            DescribeProjectErrorKind::InvalidServiceRoleException(_inner) => Some(_inner),
            DescribeProjectErrorKind::ProjectConfigurationException(_inner) => Some(_inner),
            DescribeProjectErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            DescribeProjectErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeUserProfileError {
    pub kind: DescribeUserProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeUserProfileErrorKind {
    UserProfileNotFoundException(crate::error::UserProfileNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeUserProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeUserProfileErrorKind::UserProfileNotFoundException(_inner) => _inner.fmt(f),
            DescribeUserProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DescribeUserProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeUserProfileError {
    fn code(&self) -> Option<&str> {
        DescribeUserProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeUserProfileError {
    pub fn new(kind: DescribeUserProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeUserProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeUserProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_user_profile_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserProfileErrorKind::UserProfileNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeUserProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DescribeUserProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeUserProfileErrorKind::UserProfileNotFoundException(_inner) => Some(_inner),
            DescribeUserProfileErrorKind::ValidationException(_inner) => Some(_inner),
            DescribeUserProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateTeamMemberError {
    pub kind: DisassociateTeamMemberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateTeamMemberErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidServiceRoleException(crate::error::InvalidServiceRoleException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateTeamMemberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateTeamMemberErrorKind::ConcurrentModificationException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateTeamMemberErrorKind::InvalidServiceRoleException(_inner) => _inner.fmt(f),
            DisassociateTeamMemberErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            DisassociateTeamMemberErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DisassociateTeamMemberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateTeamMemberError {
    fn code(&self) -> Option<&str> {
        DisassociateTeamMemberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateTeamMemberError {
    pub fn new(kind: DisassociateTeamMemberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateTeamMemberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateTeamMemberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateTeamMemberErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_service_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateTeamMemberErrorKind::InvalidServiceRoleException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateTeamMemberErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateTeamMemberErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateTeamMemberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateTeamMemberErrorKind::ConcurrentModificationException(_inner) => {
                Some(_inner)
            }
            DisassociateTeamMemberErrorKind::InvalidServiceRoleException(_inner) => Some(_inner),
            DisassociateTeamMemberErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            DisassociateTeamMemberErrorKind::ValidationException(_inner) => Some(_inner),
            DisassociateTeamMemberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListProjectsError {
    pub kind: ListProjectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListProjectsErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListProjectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListProjectsErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListProjectsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListProjectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListProjectsError {
    fn code(&self) -> Option<&str> {
        ListProjectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListProjectsError {
    pub fn new(kind: ListProjectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListProjectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListProjectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListProjectsErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListProjectsErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListProjectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListProjectsErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListProjectsErrorKind::ValidationException(_inner) => Some(_inner),
            ListProjectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListResourcesError {
    pub kind: ListResourcesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListResourcesErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListResourcesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListResourcesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListResourcesErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            ListResourcesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListResourcesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListResourcesError {
    fn code(&self) -> Option<&str> {
        ListResourcesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListResourcesError {
    pub fn new(kind: ListResourcesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListResourcesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListResourcesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourcesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListResourcesErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListResourcesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListResourcesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListResourcesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListResourcesErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            ListResourcesErrorKind::ValidationException(_inner) => Some(_inner),
            ListResourcesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForProjectError {
    pub kind: ListTagsForProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForProjectErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForProjectErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTagsForProjectErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForProjectError {
    fn code(&self) -> Option<&str> {
        ListTagsForProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForProjectError {
    pub fn new(kind: ListTagsForProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForProjectErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForProjectErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForProjectErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForProjectErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTagsForProjectErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            ListTagsForProjectErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTeamMembersError {
    pub kind: ListTeamMembersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTeamMembersErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTeamMembersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTeamMembersErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListTeamMembersErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            ListTeamMembersErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTeamMembersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTeamMembersError {
    fn code(&self) -> Option<&str> {
        ListTeamMembersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTeamMembersError {
    pub fn new(kind: ListTeamMembersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTeamMembersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTeamMembersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTeamMembersErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTeamMembersErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListTeamMembersErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListTeamMembersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTeamMembersErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListTeamMembersErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            ListTeamMembersErrorKind::ValidationException(_inner) => Some(_inner),
            ListTeamMembersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListUserProfilesError {
    pub kind: ListUserProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListUserProfilesErrorKind {
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListUserProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListUserProfilesErrorKind::InvalidNextTokenException(_inner) => _inner.fmt(f),
            ListUserProfilesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListUserProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListUserProfilesError {
    fn code(&self) -> Option<&str> {
        ListUserProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListUserProfilesError {
    pub fn new(kind: ListUserProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListUserProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListUserProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserProfilesErrorKind::InvalidNextTokenException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListUserProfilesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListUserProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListUserProfilesErrorKind::InvalidNextTokenException(_inner) => Some(_inner),
            ListUserProfilesErrorKind::ValidationException(_inner) => Some(_inner),
            ListUserProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagProjectError {
    pub kind: TagProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagProjectErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    LimitExceededException(crate::error::LimitExceededException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagProjectErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            TagProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            TagProjectErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            TagProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagProjectError {
    fn code(&self) -> Option<&str> {
        TagProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagProjectError {
    pub fn new(kind: TagProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagProjectErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, TagProjectErrorKind::LimitExceededException(_))
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(&self.kind, TagProjectErrorKind::ProjectNotFoundException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagProjectErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagProjectErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            TagProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            TagProjectErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            TagProjectErrorKind::ValidationException(_inner) => Some(_inner),
            TagProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagProjectError {
    pub kind: UntagProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagProjectErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    LimitExceededException(crate::error::LimitExceededException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagProjectErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UntagProjectErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UntagProjectErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            UntagProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagProjectError {
    fn code(&self) -> Option<&str> {
        UntagProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagProjectError {
    pub fn new(kind: UntagProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagProjectErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(&self.kind, UntagProjectErrorKind::LimitExceededException(_))
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagProjectErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagProjectErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagProjectErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UntagProjectErrorKind::LimitExceededException(_inner) => Some(_inner),
            UntagProjectErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            UntagProjectErrorKind::ValidationException(_inner) => Some(_inner),
            UntagProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateProjectError {
    pub kind: UpdateProjectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateProjectErrorKind {
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateProjectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateProjectErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            UpdateProjectErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateProjectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateProjectError {
    fn code(&self) -> Option<&str> {
        UpdateProjectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateProjectError {
    pub fn new(kind: UpdateProjectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateProjectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateProjectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateProjectErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateProjectErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateProjectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateProjectErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            UpdateProjectErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateProjectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTeamMemberError {
    pub kind: UpdateTeamMemberErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTeamMemberErrorKind {
    ConcurrentModificationException(crate::error::ConcurrentModificationException),
    InvalidServiceRoleException(crate::error::InvalidServiceRoleException),
    LimitExceededException(crate::error::LimitExceededException),
    ProjectConfigurationException(crate::error::ProjectConfigurationException),
    ProjectNotFoundException(crate::error::ProjectNotFoundException),
    TeamMemberNotFoundException(crate::error::TeamMemberNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTeamMemberError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTeamMemberErrorKind::ConcurrentModificationException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::InvalidServiceRoleException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::LimitExceededException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::ProjectConfigurationException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::ProjectNotFoundException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::TeamMemberNotFoundException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateTeamMemberErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTeamMemberError {
    fn code(&self) -> Option<&str> {
        UpdateTeamMemberError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTeamMemberError {
    pub fn new(kind: UpdateTeamMemberErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTeamMemberErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTeamMemberErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_modification_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::ConcurrentModificationException(_)
        )
    }
    pub fn is_invalid_service_role_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::InvalidServiceRoleException(_)
        )
    }
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::LimitExceededException(_)
        )
    }
    pub fn is_project_configuration_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::ProjectConfigurationException(_)
        )
    }
    pub fn is_project_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::ProjectNotFoundException(_)
        )
    }
    pub fn is_team_member_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::TeamMemberNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTeamMemberErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateTeamMemberError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTeamMemberErrorKind::ConcurrentModificationException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::InvalidServiceRoleException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::LimitExceededException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::ProjectConfigurationException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::ProjectNotFoundException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::TeamMemberNotFoundException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateTeamMemberErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateUserProfileError {
    pub kind: UpdateUserProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateUserProfileErrorKind {
    UserProfileNotFoundException(crate::error::UserProfileNotFoundException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateUserProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateUserProfileErrorKind::UserProfileNotFoundException(_inner) => _inner.fmt(f),
            UpdateUserProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateUserProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateUserProfileError {
    fn code(&self) -> Option<&str> {
        UpdateUserProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateUserProfileError {
    pub fn new(kind: UpdateUserProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateUserProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateUserProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_user_profile_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserProfileErrorKind::UserProfileNotFoundException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateUserProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateUserProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateUserProfileErrorKind::UserProfileNotFoundException(_inner) => Some(_inner),
            UpdateUserProfileErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateUserProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The specified input is either not valid, or it could not be validated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The user profile was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserProfileNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserProfileNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserProfileNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserProfileNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserProfileNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserProfileNotFoundException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserProfileNotFoundException {}
/// See [`UserProfileNotFoundException`](crate::error::UserProfileNotFoundException)
pub mod user_profile_not_found_exception {
    /// A builder for [`UserProfileNotFoundException`](crate::error::UserProfileNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserProfileNotFoundException`](crate::error::UserProfileNotFoundException)
        pub fn build(self) -> crate::error::UserProfileNotFoundException {
            crate::error::UserProfileNotFoundException {
                message: self.message,
            }
        }
    }
}
impl UserProfileNotFoundException {
    /// Creates a new builder-style object to manufacture [`UserProfileNotFoundException`](crate::error::UserProfileNotFoundException)
    pub fn builder() -> crate::error::user_profile_not_found_exception::Builder {
        crate::error::user_profile_not_found_exception::Builder::default()
    }
}

/// <p>The specified team member was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TeamMemberNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TeamMemberNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TeamMemberNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TeamMemberNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TeamMemberNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TeamMemberNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for TeamMemberNotFoundException {}
/// See [`TeamMemberNotFoundException`](crate::error::TeamMemberNotFoundException)
pub mod team_member_not_found_exception {
    /// A builder for [`TeamMemberNotFoundException`](crate::error::TeamMemberNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TeamMemberNotFoundException`](crate::error::TeamMemberNotFoundException)
        pub fn build(self) -> crate::error::TeamMemberNotFoundException {
            crate::error::TeamMemberNotFoundException {
                message: self.message,
            }
        }
    }
}
impl TeamMemberNotFoundException {
    /// Creates a new builder-style object to manufacture [`TeamMemberNotFoundException`](crate::error::TeamMemberNotFoundException)
    pub fn builder() -> crate::error::team_member_not_found_exception::Builder {
        crate::error::team_member_not_found_exception::Builder::default()
    }
}

/// <p>The specified AWS CodeStar project was not found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProjectNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProjectNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProjectNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProjectNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProjectNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProjectNotFoundException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProjectNotFoundException {}
/// See [`ProjectNotFoundException`](crate::error::ProjectNotFoundException)
pub mod project_not_found_exception {
    /// A builder for [`ProjectNotFoundException`](crate::error::ProjectNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectNotFoundException`](crate::error::ProjectNotFoundException)
        pub fn build(self) -> crate::error::ProjectNotFoundException {
            crate::error::ProjectNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ProjectNotFoundException {
    /// Creates a new builder-style object to manufacture [`ProjectNotFoundException`](crate::error::ProjectNotFoundException)
    pub fn builder() -> crate::error::project_not_found_exception::Builder {
        crate::error::project_not_found_exception::Builder::default()
    }
}

/// <p>Project configuration information is required but not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProjectConfigurationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProjectConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProjectConfigurationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProjectConfigurationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProjectConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProjectConfigurationException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProjectConfigurationException {}
/// See [`ProjectConfigurationException`](crate::error::ProjectConfigurationException)
pub mod project_configuration_exception {
    /// A builder for [`ProjectConfigurationException`](crate::error::ProjectConfigurationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectConfigurationException`](crate::error::ProjectConfigurationException)
        pub fn build(self) -> crate::error::ProjectConfigurationException {
            crate::error::ProjectConfigurationException {
                message: self.message,
            }
        }
    }
}
impl ProjectConfigurationException {
    /// Creates a new builder-style object to manufacture [`ProjectConfigurationException`](crate::error::ProjectConfigurationException)
    pub fn builder() -> crate::error::project_configuration_exception::Builder {
        crate::error::project_configuration_exception::Builder::default()
    }
}

/// <p>A resource limit has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededException {}
/// See [`LimitExceededException`](crate::error::LimitExceededException)
pub mod limit_exceeded_exception {
    /// A builder for [`LimitExceededException`](crate::error::LimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededException`](crate::error::LimitExceededException)
        pub fn build(self) -> crate::error::LimitExceededException {
            crate::error::LimitExceededException {
                message: self.message,
            }
        }
    }
}
impl LimitExceededException {
    /// Creates a new builder-style object to manufacture [`LimitExceededException`](crate::error::LimitExceededException)
    pub fn builder() -> crate::error::limit_exceeded_exception::Builder {
        crate::error::limit_exceeded_exception::Builder::default()
    }
}

/// <p>The service role is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidServiceRoleException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidServiceRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidServiceRoleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidServiceRoleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidServiceRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidServiceRoleException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidServiceRoleException {}
/// See [`InvalidServiceRoleException`](crate::error::InvalidServiceRoleException)
pub mod invalid_service_role_exception {
    /// A builder for [`InvalidServiceRoleException`](crate::error::InvalidServiceRoleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidServiceRoleException`](crate::error::InvalidServiceRoleException)
        pub fn build(self) -> crate::error::InvalidServiceRoleException {
            crate::error::InvalidServiceRoleException {
                message: self.message,
            }
        }
    }
}
impl InvalidServiceRoleException {
    /// Creates a new builder-style object to manufacture [`InvalidServiceRoleException`](crate::error::InvalidServiceRoleException)
    pub fn builder() -> crate::error::invalid_service_role_exception::Builder {
        crate::error::invalid_service_role_exception::Builder::default()
    }
}

/// <p>Another modification is being made. That modification must complete before you can make
/// your change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentModificationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentModificationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentModificationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentModificationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentModificationException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentModificationException {}
/// See [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
pub mod concurrent_modification_exception {
    /// A builder for [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
        pub fn build(self) -> crate::error::ConcurrentModificationException {
            crate::error::ConcurrentModificationException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentModificationException {
    /// Creates a new builder-style object to manufacture [`ConcurrentModificationException`](crate::error::ConcurrentModificationException)
    pub fn builder() -> crate::error::concurrent_modification_exception::Builder {
        crate::error::concurrent_modification_exception::Builder::default()
    }
}

/// <p>The next token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
pub mod invalid_next_token_exception {
    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException)
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// <p>A user profile with that name already exists in this region for the AWS account. AWS
/// CodeStar user profile names must be unique within a region for the AWS account. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserProfileAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UserProfileAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserProfileAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl UserProfileAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UserProfileAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UserProfileAlreadyExistsException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for UserProfileAlreadyExistsException {}
/// See [`UserProfileAlreadyExistsException`](crate::error::UserProfileAlreadyExistsException)
pub mod user_profile_already_exists_exception {
    /// A builder for [`UserProfileAlreadyExistsException`](crate::error::UserProfileAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`UserProfileAlreadyExistsException`](crate::error::UserProfileAlreadyExistsException)
        pub fn build(self) -> crate::error::UserProfileAlreadyExistsException {
            crate::error::UserProfileAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl UserProfileAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`UserProfileAlreadyExistsException`](crate::error::UserProfileAlreadyExistsException)
    pub fn builder() -> crate::error::user_profile_already_exists_exception::Builder {
        crate::error::user_profile_already_exists_exception::Builder::default()
    }
}

/// <p>The project creation request was valid, but a nonspecific exception or error occurred
/// during project creation. The project could not be created in AWS CodeStar.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProjectCreationFailedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProjectCreationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProjectCreationFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProjectCreationFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProjectCreationFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProjectCreationFailedException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProjectCreationFailedException {}
/// See [`ProjectCreationFailedException`](crate::error::ProjectCreationFailedException)
pub mod project_creation_failed_exception {
    /// A builder for [`ProjectCreationFailedException`](crate::error::ProjectCreationFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectCreationFailedException`](crate::error::ProjectCreationFailedException)
        pub fn build(self) -> crate::error::ProjectCreationFailedException {
            crate::error::ProjectCreationFailedException {
                message: self.message,
            }
        }
    }
}
impl ProjectCreationFailedException {
    /// Creates a new builder-style object to manufacture [`ProjectCreationFailedException`](crate::error::ProjectCreationFailedException)
    pub fn builder() -> crate::error::project_creation_failed_exception::Builder {
        crate::error::project_creation_failed_exception::Builder::default()
    }
}

/// <p>An AWS CodeStar project with the same ID already exists in this region for the AWS account.
/// AWS CodeStar project IDs must be unique within a region for the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProjectAlreadyExistsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProjectAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProjectAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ProjectAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ProjectAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProjectAlreadyExistsException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for ProjectAlreadyExistsException {}
/// See [`ProjectAlreadyExistsException`](crate::error::ProjectAlreadyExistsException)
pub mod project_already_exists_exception {
    /// A builder for [`ProjectAlreadyExistsException`](crate::error::ProjectAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ProjectAlreadyExistsException`](crate::error::ProjectAlreadyExistsException)
        pub fn build(self) -> crate::error::ProjectAlreadyExistsException {
            crate::error::ProjectAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ProjectAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ProjectAlreadyExistsException`](crate::error::ProjectAlreadyExistsException)
    pub fn builder() -> crate::error::project_already_exists_exception::Builder {
        crate::error::project_already_exists_exception::Builder::default()
    }
}

/// <p>The team member is already associated with a role in this project.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TeamMemberAlreadyAssociatedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TeamMemberAlreadyAssociatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TeamMemberAlreadyAssociatedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TeamMemberAlreadyAssociatedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TeamMemberAlreadyAssociatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TeamMemberAlreadyAssociatedException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for TeamMemberAlreadyAssociatedException {}
/// See [`TeamMemberAlreadyAssociatedException`](crate::error::TeamMemberAlreadyAssociatedException)
pub mod team_member_already_associated_exception {
    /// A builder for [`TeamMemberAlreadyAssociatedException`](crate::error::TeamMemberAlreadyAssociatedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TeamMemberAlreadyAssociatedException`](crate::error::TeamMemberAlreadyAssociatedException)
        pub fn build(self) -> crate::error::TeamMemberAlreadyAssociatedException {
            crate::error::TeamMemberAlreadyAssociatedException {
                message: self.message,
            }
        }
    }
}
impl TeamMemberAlreadyAssociatedException {
    /// Creates a new builder-style object to manufacture [`TeamMemberAlreadyAssociatedException`](crate::error::TeamMemberAlreadyAssociatedException)
    pub fn builder() -> crate::error::team_member_already_associated_exception::Builder {
        crate::error::team_member_already_associated_exception::Builder::default()
    }
}
