// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Use this structure to specify the distribution of On-Demand Instances and Spot Instances and the allocation strategies used to fulfill On-Demand and Spot capacities for a mixed instances policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstancesDistribution {
    /// <p>The allocation strategy to apply to your On-Demand Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Uses price to determine which instance types are the highest priority, launching the lowest priced instance types within an Availability Zone first. This is the default value for Auto Scaling groups that specify <code>InstanceRequirements</code>. </p>
    /// </dd>
    /// <dt>
    /// prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling launches your highest priority instance types first. If all your On-Demand capacity cannot be fulfilled using your highest priority instance type, then Amazon EC2 Auto Scaling launches the remaining capacity using the second priority instance type, and so on. This is the default value for Auto Scaling groups that don't specify <code>InstanceRequirements</code> and cannot be used for groups that do.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub on_demand_allocation_strategy: std::option::Option<std::string::String>,
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is launched first as your group scales.</p>
    /// <p>This number has the same unit of measurement as the group's desired capacity. If you change the default unit of measurement (number of instances) by specifying weighted capacity values in your launch template overrides list, or by changing the default desired capacity type setting of the group, you must specify this number using the same unit of measurement.</p>
    /// <p>Default: 0</p>
    #[doc(hidden)]
    pub on_demand_base_capacity: std::option::Option<i32>,
    /// <p>Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond <code>OnDemandBaseCapacity</code>. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). If set to 100, only On-Demand Instances are used.</p>
    /// <p>Default: 100</p>
    #[doc(hidden)]
    pub on_demand_percentage_above_base_capacity: std::option::Option<i32>,
    /// <p>The allocation strategy to apply to your Spot Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// capacity-optimized
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using pools that are optimally chosen based on the available Spot capacity. This strategy has the lowest risk of interruption. To give certain instance types a higher chance of launching first, use <code>capacity-optimized-prioritized</code>.</p>
    /// </dd>
    /// <dt>
    /// capacity-optimized-prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best effort basis but optimizes for capacity first. Note that if the On-Demand allocation strategy is set to <code>prioritized</code>, the same priority is applied when fulfilling On-Demand capacity. This is not a valid value for Auto Scaling groups that specify <code>InstanceRequirements</code>.</p>
    /// </dd>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using the lowest priced pools within an Availability Zone, across the number of Spot pools that you specify for the <code>SpotInstancePools</code> property. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. This is the default value, but it might lead to high interruption rates because this strategy only considers instance price and not available capacity.</p>
    /// </dd>
    /// <dt>
    /// price-capacity-optimized (recommended)
    /// </dt>
    /// <dd>
    /// <p>The price and capacity optimized allocation strategy looks at both price and capacity to select the Spot Instance pools that are the least likely to be interrupted and have the lowest possible price.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub spot_allocation_strategy: std::option::Option<std::string::String>,
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances. The Spot pools are determined from the different instance types in the overrides. Valid only when the <code>SpotAllocationStrategy</code> is <code>lowest-price</code>. Value must be in the range of 1â€“20.</p>
    /// <p>Default: 2</p>
    #[doc(hidden)]
    pub spot_instance_pools: std::option::Option<i32>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If your maximum price is lower than the Spot price for the instance types that you selected, your Spot Instances are not launched. We do not recommend specifying a maximum price because it can lead to increased interruptions. When Spot Instances launch, you pay the current Spot price. To remove a maximum price that you previously set, include the property but specify an empty string ("") for the value.</p> <important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify one.</p>
    /// </important>
    /// <p>Valid Range: Minimum value of 0.001</p>
    #[doc(hidden)]
    pub spot_max_price: std::option::Option<std::string::String>,
}
impl InstancesDistribution {
    /// <p>The allocation strategy to apply to your On-Demand Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Uses price to determine which instance types are the highest priority, launching the lowest priced instance types within an Availability Zone first. This is the default value for Auto Scaling groups that specify <code>InstanceRequirements</code>. </p>
    /// </dd>
    /// <dt>
    /// prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling launches your highest priority instance types first. If all your On-Demand capacity cannot be fulfilled using your highest priority instance type, then Amazon EC2 Auto Scaling launches the remaining capacity using the second priority instance type, and so on. This is the default value for Auto Scaling groups that don't specify <code>InstanceRequirements</code> and cannot be used for groups that do.</p>
    /// </dd>
    /// </dl>
    pub fn on_demand_allocation_strategy(&self) -> std::option::Option<&str> {
        self.on_demand_allocation_strategy.as_deref()
    }
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is launched first as your group scales.</p>
    /// <p>This number has the same unit of measurement as the group's desired capacity. If you change the default unit of measurement (number of instances) by specifying weighted capacity values in your launch template overrides list, or by changing the default desired capacity type setting of the group, you must specify this number using the same unit of measurement.</p>
    /// <p>Default: 0</p>
    pub fn on_demand_base_capacity(&self) -> std::option::Option<i32> {
        self.on_demand_base_capacity
    }
    /// <p>Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond <code>OnDemandBaseCapacity</code>. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). If set to 100, only On-Demand Instances are used.</p>
    /// <p>Default: 100</p>
    pub fn on_demand_percentage_above_base_capacity(&self) -> std::option::Option<i32> {
        self.on_demand_percentage_above_base_capacity
    }
    /// <p>The allocation strategy to apply to your Spot Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// capacity-optimized
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using pools that are optimally chosen based on the available Spot capacity. This strategy has the lowest risk of interruption. To give certain instance types a higher chance of launching first, use <code>capacity-optimized-prioritized</code>.</p>
    /// </dd>
    /// <dt>
    /// capacity-optimized-prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best effort basis but optimizes for capacity first. Note that if the On-Demand allocation strategy is set to <code>prioritized</code>, the same priority is applied when fulfilling On-Demand capacity. This is not a valid value for Auto Scaling groups that specify <code>InstanceRequirements</code>.</p>
    /// </dd>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using the lowest priced pools within an Availability Zone, across the number of Spot pools that you specify for the <code>SpotInstancePools</code> property. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. This is the default value, but it might lead to high interruption rates because this strategy only considers instance price and not available capacity.</p>
    /// </dd>
    /// <dt>
    /// price-capacity-optimized (recommended)
    /// </dt>
    /// <dd>
    /// <p>The price and capacity optimized allocation strategy looks at both price and capacity to select the Spot Instance pools that are the least likely to be interrupted and have the lowest possible price.</p>
    /// </dd>
    /// </dl>
    pub fn spot_allocation_strategy(&self) -> std::option::Option<&str> {
        self.spot_allocation_strategy.as_deref()
    }
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances. The Spot pools are determined from the different instance types in the overrides. Valid only when the <code>SpotAllocationStrategy</code> is <code>lowest-price</code>. Value must be in the range of 1â€“20.</p>
    /// <p>Default: 2</p>
    pub fn spot_instance_pools(&self) -> std::option::Option<i32> {
        self.spot_instance_pools
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If your maximum price is lower than the Spot price for the instance types that you selected, your Spot Instances are not launched. We do not recommend specifying a maximum price because it can lead to increased interruptions. When Spot Instances launch, you pay the current Spot price. To remove a maximum price that you previously set, include the property but specify an empty string ("") for the value.</p> <important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify one.</p>
    /// </important>
    /// <p>Valid Range: Minimum value of 0.001</p>
    pub fn spot_max_price(&self) -> std::option::Option<&str> {
        self.spot_max_price.as_deref()
    }
}
impl InstancesDistribution {
    /// Creates a new builder-style object to manufacture [`InstancesDistribution`](crate::types::InstancesDistribution).
    pub fn builder() -> crate::types::builders::InstancesDistributionBuilder {
        crate::types::builders::InstancesDistributionBuilder::default()
    }
}

/// A builder for [`InstancesDistribution`](crate::types::InstancesDistribution).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct InstancesDistributionBuilder {
    pub(crate) on_demand_allocation_strategy: std::option::Option<std::string::String>,
    pub(crate) on_demand_base_capacity: std::option::Option<i32>,
    pub(crate) on_demand_percentage_above_base_capacity: std::option::Option<i32>,
    pub(crate) spot_allocation_strategy: std::option::Option<std::string::String>,
    pub(crate) spot_instance_pools: std::option::Option<i32>,
    pub(crate) spot_max_price: std::option::Option<std::string::String>,
}
impl InstancesDistributionBuilder {
    /// <p>The allocation strategy to apply to your On-Demand Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Uses price to determine which instance types are the highest priority, launching the lowest priced instance types within an Availability Zone first. This is the default value for Auto Scaling groups that specify <code>InstanceRequirements</code>. </p>
    /// </dd>
    /// <dt>
    /// prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling launches your highest priority instance types first. If all your On-Demand capacity cannot be fulfilled using your highest priority instance type, then Amazon EC2 Auto Scaling launches the remaining capacity using the second priority instance type, and so on. This is the default value for Auto Scaling groups that don't specify <code>InstanceRequirements</code> and cannot be used for groups that do.</p>
    /// </dd>
    /// </dl>
    pub fn on_demand_allocation_strategy(mut self, input: impl Into<std::string::String>) -> Self {
        self.on_demand_allocation_strategy = Some(input.into());
        self
    }
    /// <p>The allocation strategy to apply to your On-Demand Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Uses price to determine which instance types are the highest priority, launching the lowest priced instance types within an Availability Zone first. This is the default value for Auto Scaling groups that specify <code>InstanceRequirements</code>. </p>
    /// </dd>
    /// <dt>
    /// prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling launches your highest priority instance types first. If all your On-Demand capacity cannot be fulfilled using your highest priority instance type, then Amazon EC2 Auto Scaling launches the remaining capacity using the second priority instance type, and so on. This is the default value for Auto Scaling groups that don't specify <code>InstanceRequirements</code> and cannot be used for groups that do.</p>
    /// </dd>
    /// </dl>
    pub fn set_on_demand_allocation_strategy(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.on_demand_allocation_strategy = input;
        self
    }
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is launched first as your group scales.</p>
    /// <p>This number has the same unit of measurement as the group's desired capacity. If you change the default unit of measurement (number of instances) by specifying weighted capacity values in your launch template overrides list, or by changing the default desired capacity type setting of the group, you must specify this number using the same unit of measurement.</p>
    /// <p>Default: 0</p>
    pub fn on_demand_base_capacity(mut self, input: i32) -> Self {
        self.on_demand_base_capacity = Some(input);
        self
    }
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances. This base portion is launched first as your group scales.</p>
    /// <p>This number has the same unit of measurement as the group's desired capacity. If you change the default unit of measurement (number of instances) by specifying weighted capacity values in your launch template overrides list, or by changing the default desired capacity type setting of the group, you must specify this number using the same unit of measurement.</p>
    /// <p>Default: 0</p>
    pub fn set_on_demand_base_capacity(mut self, input: std::option::Option<i32>) -> Self {
        self.on_demand_base_capacity = input;
        self
    }
    /// <p>Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond <code>OnDemandBaseCapacity</code>. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). If set to 100, only On-Demand Instances are used.</p>
    /// <p>Default: 100</p>
    pub fn on_demand_percentage_above_base_capacity(mut self, input: i32) -> Self {
        self.on_demand_percentage_above_base_capacity = Some(input);
        self
    }
    /// <p>Controls the percentages of On-Demand Instances and Spot Instances for your additional capacity beyond <code>OnDemandBaseCapacity</code>. Expressed as a number (for example, 20 specifies 20% On-Demand Instances, 80% Spot Instances). If set to 100, only On-Demand Instances are used.</p>
    /// <p>Default: 100</p>
    pub fn set_on_demand_percentage_above_base_capacity(
        mut self,
        input: std::option::Option<i32>,
    ) -> Self {
        self.on_demand_percentage_above_base_capacity = input;
        self
    }
    /// <p>The allocation strategy to apply to your Spot Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// capacity-optimized
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using pools that are optimally chosen based on the available Spot capacity. This strategy has the lowest risk of interruption. To give certain instance types a higher chance of launching first, use <code>capacity-optimized-prioritized</code>.</p>
    /// </dd>
    /// <dt>
    /// capacity-optimized-prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best effort basis but optimizes for capacity first. Note that if the On-Demand allocation strategy is set to <code>prioritized</code>, the same priority is applied when fulfilling On-Demand capacity. This is not a valid value for Auto Scaling groups that specify <code>InstanceRequirements</code>.</p>
    /// </dd>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using the lowest priced pools within an Availability Zone, across the number of Spot pools that you specify for the <code>SpotInstancePools</code> property. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. This is the default value, but it might lead to high interruption rates because this strategy only considers instance price and not available capacity.</p>
    /// </dd>
    /// <dt>
    /// price-capacity-optimized (recommended)
    /// </dt>
    /// <dd>
    /// <p>The price and capacity optimized allocation strategy looks at both price and capacity to select the Spot Instance pools that are the least likely to be interrupted and have the lowest possible price.</p>
    /// </dd>
    /// </dl>
    pub fn spot_allocation_strategy(mut self, input: impl Into<std::string::String>) -> Self {
        self.spot_allocation_strategy = Some(input.into());
        self
    }
    /// <p>The allocation strategy to apply to your Spot Instances when they are launched. Possible instance types are determined by the launch template overrides that you specify.</p>
    /// <p>The following lists the valid values:</p>
    /// <dl>
    /// <dt>
    /// capacity-optimized
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using pools that are optimally chosen based on the available Spot capacity. This strategy has the lowest risk of interruption. To give certain instance types a higher chance of launching first, use <code>capacity-optimized-prioritized</code>.</p>
    /// </dd>
    /// <dt>
    /// capacity-optimized-prioritized
    /// </dt>
    /// <dd>
    /// <p>You set the order of instance types for the launch template overrides from highest to lowest priority (from first to last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best effort basis but optimizes for capacity first. Note that if the On-Demand allocation strategy is set to <code>prioritized</code>, the same priority is applied when fulfilling On-Demand capacity. This is not a valid value for Auto Scaling groups that specify <code>InstanceRequirements</code>.</p>
    /// </dd>
    /// <dt>
    /// lowest-price
    /// </dt>
    /// <dd>
    /// <p>Requests Spot Instances using the lowest priced pools within an Availability Zone, across the number of Spot pools that you specify for the <code>SpotInstancePools</code> property. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. This is the default value, but it might lead to high interruption rates because this strategy only considers instance price and not available capacity.</p>
    /// </dd>
    /// <dt>
    /// price-capacity-optimized (recommended)
    /// </dt>
    /// <dd>
    /// <p>The price and capacity optimized allocation strategy looks at both price and capacity to select the Spot Instance pools that are the least likely to be interrupted and have the lowest possible price.</p>
    /// </dd>
    /// </dl>
    pub fn set_spot_allocation_strategy(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.spot_allocation_strategy = input;
        self
    }
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances. The Spot pools are determined from the different instance types in the overrides. Valid only when the <code>SpotAllocationStrategy</code> is <code>lowest-price</code>. Value must be in the range of 1â€“20.</p>
    /// <p>Default: 2</p>
    pub fn spot_instance_pools(mut self, input: i32) -> Self {
        self.spot_instance_pools = Some(input);
        self
    }
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances. The Spot pools are determined from the different instance types in the overrides. Valid only when the <code>SpotAllocationStrategy</code> is <code>lowest-price</code>. Value must be in the range of 1â€“20.</p>
    /// <p>Default: 2</p>
    pub fn set_spot_instance_pools(mut self, input: std::option::Option<i32>) -> Self {
        self.spot_instance_pools = input;
        self
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If your maximum price is lower than the Spot price for the instance types that you selected, your Spot Instances are not launched. We do not recommend specifying a maximum price because it can lead to increased interruptions. When Spot Instances launch, you pay the current Spot price. To remove a maximum price that you previously set, include the property but specify an empty string ("") for the value.</p> <important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify one.</p>
    /// </important>
    /// <p>Valid Range: Minimum value of 0.001</p>
    pub fn spot_max_price(mut self, input: impl Into<std::string::String>) -> Self {
        self.spot_max_price = Some(input.into());
        self
    }
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If your maximum price is lower than the Spot price for the instance types that you selected, your Spot Instances are not launched. We do not recommend specifying a maximum price because it can lead to increased interruptions. When Spot Instances launch, you pay the current Spot price. To remove a maximum price that you previously set, include the property but specify an empty string ("") for the value.</p> <important>
    /// <p>If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify one.</p>
    /// </important>
    /// <p>Valid Range: Minimum value of 0.001</p>
    pub fn set_spot_max_price(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.spot_max_price = input;
        self
    }
    /// Consumes the builder and constructs a [`InstancesDistribution`](crate::types::InstancesDistribution).
    pub fn build(self) -> crate::types::InstancesDistribution {
        crate::types::InstancesDistribution {
            on_demand_allocation_strategy: self.on_demand_allocation_strategy,
            on_demand_base_capacity: self.on_demand_base_capacity,
            on_demand_percentage_above_base_capacity: self.on_demand_percentage_above_base_capacity,
            spot_allocation_strategy: self.spot_allocation_strategy,
            spot_instance_pools: self.spot_instance_pools,
            spot_max_price: self.spot_max_price,
        }
    }
}
