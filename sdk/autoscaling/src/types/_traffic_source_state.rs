// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes the state of a traffic source.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct TrafficSourceState {
    /// <p>This is replaced by <code>Identifier</code>.</p>
    #[deprecated(note = "TrafficSource has been replaced by Identifier")]
    pub traffic_source: ::std::option::Option<::std::string::String>,
    /// <p>Describes the current state of a traffic source.</p>
    /// <p>The state values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p><code>Adding</code> - The Auto Scaling instances are being registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>Added</code> - All Auto Scaling instances are registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>InService</code> - For an Elastic Load Balancing load balancer or target group, at least one Auto Scaling instance passed an <code>ELB</code> health check. For VPC Lattice, at least one Auto Scaling instance passed an <code>VPC_LATTICE</code> health check.</p></li>
    /// <li>
    /// <p><code>Removing</code> - The Auto Scaling instances are being deregistered from the load balancer or target group. If connection draining (deregistration delay) is enabled, Elastic Load Balancing or VPC Lattice waits for in-flight requests to complete before deregistering the instances.</p></li>
    /// <li>
    /// <p><code>Removed</code> - All Auto Scaling instances are deregistered from the load balancer or target group.</p></li>
    /// </ul>
    pub state: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier of the traffic source.</p>
    pub identifier: ::std::option::Option<::std::string::String>,
    /// <p>Provides additional context for the value of <code>Identifier</code>.</p>
    /// <p>The following lists the valid values:</p>
    /// <ul>
    /// <li>
    /// <p><code>elb</code> if <code>Identifier</code> is the name of a Classic Load Balancer.</p></li>
    /// <li>
    /// <p><code>elbv2</code> if <code>Identifier</code> is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.</p></li>
    /// <li>
    /// <p><code>vpc-lattice</code> if <code>Identifier</code> is the ARN of a VPC Lattice target group.</p></li>
    /// </ul>
    /// <p>Required if the identifier is the name of a Classic Load Balancer.</p>
    pub r#type: ::std::option::Option<::std::string::String>,
}
impl TrafficSourceState {
    /// <p>This is replaced by <code>Identifier</code>.</p>
    #[deprecated(note = "TrafficSource has been replaced by Identifier")]
    pub fn traffic_source(&self) -> ::std::option::Option<&str> {
        self.traffic_source.as_deref()
    }
    /// <p>Describes the current state of a traffic source.</p>
    /// <p>The state values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p><code>Adding</code> - The Auto Scaling instances are being registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>Added</code> - All Auto Scaling instances are registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>InService</code> - For an Elastic Load Balancing load balancer or target group, at least one Auto Scaling instance passed an <code>ELB</code> health check. For VPC Lattice, at least one Auto Scaling instance passed an <code>VPC_LATTICE</code> health check.</p></li>
    /// <li>
    /// <p><code>Removing</code> - The Auto Scaling instances are being deregistered from the load balancer or target group. If connection draining (deregistration delay) is enabled, Elastic Load Balancing or VPC Lattice waits for in-flight requests to complete before deregistering the instances.</p></li>
    /// <li>
    /// <p><code>Removed</code> - All Auto Scaling instances are deregistered from the load balancer or target group.</p></li>
    /// </ul>
    pub fn state(&self) -> ::std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The unique identifier of the traffic source.</p>
    pub fn identifier(&self) -> ::std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>Provides additional context for the value of <code>Identifier</code>.</p>
    /// <p>The following lists the valid values:</p>
    /// <ul>
    /// <li>
    /// <p><code>elb</code> if <code>Identifier</code> is the name of a Classic Load Balancer.</p></li>
    /// <li>
    /// <p><code>elbv2</code> if <code>Identifier</code> is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.</p></li>
    /// <li>
    /// <p><code>vpc-lattice</code> if <code>Identifier</code> is the ARN of a VPC Lattice target group.</p></li>
    /// </ul>
    /// <p>Required if the identifier is the name of a Classic Load Balancer.</p>
    pub fn r#type(&self) -> ::std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl TrafficSourceState {
    /// Creates a new builder-style object to manufacture [`TrafficSourceState`](crate::types::TrafficSourceState).
    pub fn builder() -> crate::types::builders::TrafficSourceStateBuilder {
        crate::types::builders::TrafficSourceStateBuilder::default()
    }
}

/// A builder for [`TrafficSourceState`](crate::types::TrafficSourceState).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct TrafficSourceStateBuilder {
    pub(crate) traffic_source: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<::std::string::String>,
    pub(crate) identifier: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<::std::string::String>,
}
impl TrafficSourceStateBuilder {
    /// <p>This is replaced by <code>Identifier</code>.</p>
    #[deprecated(note = "TrafficSource has been replaced by Identifier")]
    pub fn traffic_source(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.traffic_source = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>This is replaced by <code>Identifier</code>.</p>
    #[deprecated(note = "TrafficSource has been replaced by Identifier")]
    pub fn set_traffic_source(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.traffic_source = input;
        self
    }
    /// <p>This is replaced by <code>Identifier</code>.</p>
    #[deprecated(note = "TrafficSource has been replaced by Identifier")]
    pub fn get_traffic_source(&self) -> &::std::option::Option<::std::string::String> {
        &self.traffic_source
    }
    /// <p>Describes the current state of a traffic source.</p>
    /// <p>The state values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p><code>Adding</code> - The Auto Scaling instances are being registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>Added</code> - All Auto Scaling instances are registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>InService</code> - For an Elastic Load Balancing load balancer or target group, at least one Auto Scaling instance passed an <code>ELB</code> health check. For VPC Lattice, at least one Auto Scaling instance passed an <code>VPC_LATTICE</code> health check.</p></li>
    /// <li>
    /// <p><code>Removing</code> - The Auto Scaling instances are being deregistered from the load balancer or target group. If connection draining (deregistration delay) is enabled, Elastic Load Balancing or VPC Lattice waits for in-flight requests to complete before deregistering the instances.</p></li>
    /// <li>
    /// <p><code>Removed</code> - All Auto Scaling instances are deregistered from the load balancer or target group.</p></li>
    /// </ul>
    pub fn state(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.state = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Describes the current state of a traffic source.</p>
    /// <p>The state values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p><code>Adding</code> - The Auto Scaling instances are being registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>Added</code> - All Auto Scaling instances are registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>InService</code> - For an Elastic Load Balancing load balancer or target group, at least one Auto Scaling instance passed an <code>ELB</code> health check. For VPC Lattice, at least one Auto Scaling instance passed an <code>VPC_LATTICE</code> health check.</p></li>
    /// <li>
    /// <p><code>Removing</code> - The Auto Scaling instances are being deregistered from the load balancer or target group. If connection draining (deregistration delay) is enabled, Elastic Load Balancing or VPC Lattice waits for in-flight requests to complete before deregistering the instances.</p></li>
    /// <li>
    /// <p><code>Removed</code> - All Auto Scaling instances are deregistered from the load balancer or target group.</p></li>
    /// </ul>
    pub fn set_state(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.state = input;
        self
    }
    /// <p>Describes the current state of a traffic source.</p>
    /// <p>The state values are as follows:</p>
    /// <ul>
    /// <li>
    /// <p><code>Adding</code> - The Auto Scaling instances are being registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>Added</code> - All Auto Scaling instances are registered with the load balancer or target group.</p></li>
    /// <li>
    /// <p><code>InService</code> - For an Elastic Load Balancing load balancer or target group, at least one Auto Scaling instance passed an <code>ELB</code> health check. For VPC Lattice, at least one Auto Scaling instance passed an <code>VPC_LATTICE</code> health check.</p></li>
    /// <li>
    /// <p><code>Removing</code> - The Auto Scaling instances are being deregistered from the load balancer or target group. If connection draining (deregistration delay) is enabled, Elastic Load Balancing or VPC Lattice waits for in-flight requests to complete before deregistering the instances.</p></li>
    /// <li>
    /// <p><code>Removed</code> - All Auto Scaling instances are deregistered from the load balancer or target group.</p></li>
    /// </ul>
    pub fn get_state(&self) -> &::std::option::Option<::std::string::String> {
        &self.state
    }
    /// <p>The unique identifier of the traffic source.</p>
    pub fn identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier of the traffic source.</p>
    pub fn set_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.identifier = input;
        self
    }
    /// <p>The unique identifier of the traffic source.</p>
    pub fn get_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.identifier
    }
    /// <p>Provides additional context for the value of <code>Identifier</code>.</p>
    /// <p>The following lists the valid values:</p>
    /// <ul>
    /// <li>
    /// <p><code>elb</code> if <code>Identifier</code> is the name of a Classic Load Balancer.</p></li>
    /// <li>
    /// <p><code>elbv2</code> if <code>Identifier</code> is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.</p></li>
    /// <li>
    /// <p><code>vpc-lattice</code> if <code>Identifier</code> is the ARN of a VPC Lattice target group.</p></li>
    /// </ul>
    /// <p>Required if the identifier is the name of a Classic Load Balancer.</p>
    pub fn r#type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.r#type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Provides additional context for the value of <code>Identifier</code>.</p>
    /// <p>The following lists the valid values:</p>
    /// <ul>
    /// <li>
    /// <p><code>elb</code> if <code>Identifier</code> is the name of a Classic Load Balancer.</p></li>
    /// <li>
    /// <p><code>elbv2</code> if <code>Identifier</code> is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.</p></li>
    /// <li>
    /// <p><code>vpc-lattice</code> if <code>Identifier</code> is the ARN of a VPC Lattice target group.</p></li>
    /// </ul>
    /// <p>Required if the identifier is the name of a Classic Load Balancer.</p>
    pub fn set_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>Provides additional context for the value of <code>Identifier</code>.</p>
    /// <p>The following lists the valid values:</p>
    /// <ul>
    /// <li>
    /// <p><code>elb</code> if <code>Identifier</code> is the name of a Classic Load Balancer.</p></li>
    /// <li>
    /// <p><code>elbv2</code> if <code>Identifier</code> is the ARN of an Application Load Balancer, Gateway Load Balancer, or Network Load Balancer target group.</p></li>
    /// <li>
    /// <p><code>vpc-lattice</code> if <code>Identifier</code> is the ARN of a VPC Lattice target group.</p></li>
    /// </ul>
    /// <p>Required if the identifier is the name of a Classic Load Balancer.</p>
    pub fn get_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.r#type
    }
    /// Consumes the builder and constructs a [`TrafficSourceState`](crate::types::TrafficSourceState).
    pub fn build(self) -> crate::types::TrafficSourceState {
        crate::types::TrafficSourceState {
            traffic_source: self.traffic_source,
            state: self.state,
            identifier: self.identifier,
            r#type: self.r#type,
        }
    }
}
