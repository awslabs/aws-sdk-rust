// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Attaches one or more EC2 instances to the specified Auto Scaling group.</p>
/// <p>When you attach instances, Amazon EC2 Auto Scaling increases the desired capacity of the group by the
/// number of instances being attached. If the number of instances being attached plus the
/// desired capacity of the group exceeds the maximum size of the group, the operation
/// fails.</p>
/// <p>If there is a Classic Load Balancer attached to your Auto Scaling group, the instances are
/// also registered with the load balancer. If there are target groups attached to your Auto Scaling
/// group, the instances are also registered with the target groups.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/attach-instance-asg.html">Attach EC2 instances to
/// your Auto Scaling group</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachInstances {
    _private: (),
}
impl AttachInstances {
    /// Creates a new builder-style object to manufacture [`AttachInstancesInput`](crate::input::AttachInstancesInput)
    pub fn builder() -> crate::input::attach_instances_input::Builder {
        crate::input::attach_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachInstances {
    type Output = std::result::Result<
        crate::output::AttachInstancesOutput,
        crate::error::AttachInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_instances_error(response)
        } else {
            crate::operation_deser::parse_attach_instances_response(response)
        }
    }
}

/// <note>
/// <p>To attach an Application Load Balancer, Network Load Balancer, or Gateway Load
/// Balancer, use the <a>AttachLoadBalancerTargetGroups</a> API operation
/// instead.</p>
/// </note>
/// <p>Attaches one or more Classic Load Balancers to the specified Auto Scaling group. Amazon EC2 Auto Scaling
/// registers the running instances with these Classic Load Balancers.</p>
/// <p>To describe the load balancers for an Auto Scaling group, call the <a>DescribeLoadBalancers</a> API. To detach the load balancer from the Auto Scaling
/// group, call the <a>DetachLoadBalancers</a> API.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html">Elastic Load Balancing and
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachLoadBalancers {
    _private: (),
}
impl AttachLoadBalancers {
    /// Creates a new builder-style object to manufacture [`AttachLoadBalancersInput`](crate::input::AttachLoadBalancersInput)
    pub fn builder() -> crate::input::attach_load_balancers_input::Builder {
        crate::input::attach_load_balancers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachLoadBalancers {
    type Output = std::result::Result<
        crate::output::AttachLoadBalancersOutput,
        crate::error::AttachLoadBalancersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_load_balancers_error(response)
        } else {
            crate::operation_deser::parse_attach_load_balancers_response(response)
        }
    }
}

/// <p>Attaches one or more target groups to the specified Auto Scaling group.</p>
/// <p>This operation is used with the following load balancer types: </p>
/// <ul>
/// <li>
/// <p> Application Load Balancer - Operates at the application layer (layer 7) and
/// supports HTTP and HTTPS. </p>
/// </li>
/// <li>
/// <p> Network Load Balancer - Operates at the transport layer (layer 4) and
/// supports TCP, TLS, and UDP. </p>
/// </li>
/// <li>
/// <p> Gateway Load Balancer - Operates at the network layer (layer 3).</p>
/// </li>
/// </ul>
/// <p>To describe the target groups for an Auto Scaling group, call the <a>DescribeLoadBalancerTargetGroups</a> API. To detach the target group from
/// the Auto Scaling group, call the <a>DetachLoadBalancerTargetGroups</a> API.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html">Elastic Load Balancing and
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AttachLoadBalancerTargetGroups {
    _private: (),
}
impl AttachLoadBalancerTargetGroups {
    /// Creates a new builder-style object to manufacture [`AttachLoadBalancerTargetGroupsInput`](crate::input::AttachLoadBalancerTargetGroupsInput)
    pub fn builder() -> crate::input::attach_load_balancer_target_groups_input::Builder {
        crate::input::attach_load_balancer_target_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AttachLoadBalancerTargetGroups {
    type Output = std::result::Result<
        crate::output::AttachLoadBalancerTargetGroupsOutput,
        crate::error::AttachLoadBalancerTargetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_attach_load_balancer_target_groups_error(response)
        } else {
            crate::operation_deser::parse_attach_load_balancer_target_groups_response(response)
        }
    }
}

/// <p>Deletes one or more scheduled actions for the specified Auto Scaling group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteScheduledAction {
    _private: (),
}
impl BatchDeleteScheduledAction {
    /// Creates a new builder-style object to manufacture [`BatchDeleteScheduledActionInput`](crate::input::BatchDeleteScheduledActionInput)
    pub fn builder() -> crate::input::batch_delete_scheduled_action_input::Builder {
        crate::input::batch_delete_scheduled_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteScheduledAction {
    type Output = std::result::Result<
        crate::output::BatchDeleteScheduledActionOutput,
        crate::error::BatchDeleteScheduledActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_scheduled_action_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_scheduled_action_response(response)
        }
    }
}

/// <p>Creates or updates one or more scheduled scaling actions for an Auto Scaling group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchPutScheduledUpdateGroupAction {
    _private: (),
}
impl BatchPutScheduledUpdateGroupAction {
    /// Creates a new builder-style object to manufacture [`BatchPutScheduledUpdateGroupActionInput`](crate::input::BatchPutScheduledUpdateGroupActionInput)
    pub fn builder() -> crate::input::batch_put_scheduled_update_group_action_input::Builder {
        crate::input::batch_put_scheduled_update_group_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchPutScheduledUpdateGroupAction {
    type Output = std::result::Result<
        crate::output::BatchPutScheduledUpdateGroupActionOutput,
        crate::error::BatchPutScheduledUpdateGroupActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_put_scheduled_update_group_action_error(response)
        } else {
            crate::operation_deser::parse_batch_put_scheduled_update_group_action_response(response)
        }
    }
}

/// <p>Cancels an instance refresh operation in progress. Cancellation does not roll back any
/// replacements that have already been completed, but it prevents new replacements from
/// being started. </p>
/// <p>This operation is part of the <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html">instance refresh
/// feature</a> in Amazon EC2 Auto Scaling, which helps you update instances in your Auto Scaling group
/// after you make configuration changes.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelInstanceRefresh {
    _private: (),
}
impl CancelInstanceRefresh {
    /// Creates a new builder-style object to manufacture [`CancelInstanceRefreshInput`](crate::input::CancelInstanceRefreshInput)
    pub fn builder() -> crate::input::cancel_instance_refresh_input::Builder {
        crate::input::cancel_instance_refresh_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelInstanceRefresh {
    type Output = std::result::Result<
        crate::output::CancelInstanceRefreshOutput,
        crate::error::CancelInstanceRefreshError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_instance_refresh_error(response)
        } else {
            crate::operation_deser::parse_cancel_instance_refresh_response(response)
        }
    }
}

/// <p>Completes the lifecycle action for the specified token or instance with the specified
/// result.</p>
/// <p>This step is a part of the procedure for adding a lifecycle hook to an Auto Scaling
/// group:</p>
/// <ol>
/// <li>
/// <p>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to
/// invoke your Lambda function when Amazon EC2 Auto Scaling launches or terminates
/// instances.</p>
/// </li>
/// <li>
/// <p>(Optional) Create a notification target and an IAM role. The target can be
/// either an Amazon SQS queue or an Amazon SNS topic. The role allows Amazon EC2 Auto Scaling to
/// publish lifecycle notifications to the target.</p>
/// </li>
/// <li>
/// <p>Create the lifecycle hook. Specify whether the hook is used when the instances
/// launch or terminate.</p>
/// </li>
/// <li>
/// <p>If you need more time, record the lifecycle action heartbeat to keep the
/// instance in a pending state.</p>
/// </li>
/// <li>
/// <p>
/// <b>If you finish before the timeout period ends, complete the
/// lifecycle action.</b>
/// </p>
/// </li>
/// </ol>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html">Amazon EC2 Auto Scaling lifecycle
/// hooks</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CompleteLifecycleAction {
    _private: (),
}
impl CompleteLifecycleAction {
    /// Creates a new builder-style object to manufacture [`CompleteLifecycleActionInput`](crate::input::CompleteLifecycleActionInput)
    pub fn builder() -> crate::input::complete_lifecycle_action_input::Builder {
        crate::input::complete_lifecycle_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CompleteLifecycleAction {
    type Output = std::result::Result<
        crate::output::CompleteLifecycleActionOutput,
        crate::error::CompleteLifecycleActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_complete_lifecycle_action_error(response)
        } else {
            crate::operation_deser::parse_complete_lifecycle_action_response(response)
        }
    }
}

/// <p>
/// <b>We strongly recommend using a launch template when calling this operation to ensure full functionality for Amazon EC2 Auto Scaling and Amazon EC2.</b>
/// </p>
/// <p>Creates an Auto Scaling group with
/// the specified name and attributes. </p>
/// <p>If you exceed your maximum limit of Auto Scaling groups, the call fails. To query this limit,
/// call the <a>DescribeAccountLimits</a> API. For information about updating
/// this limit, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-account-limits.html">Amazon EC2 Auto Scaling service
/// quotas</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>For introductory exercises for creating an Auto Scaling group, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/GettingStartedTutorial.html">Getting started with
/// Amazon EC2 Auto Scaling</a> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-register-lbs-with-asg.html">Tutorial: Set up a
/// scaled and load-balanced application</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html">Auto Scaling
/// groups</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>Every Auto Scaling group has three size parameters (<code>DesiredCapacity</code>,
/// <code>MaxSize</code>, and <code>MinSize</code>). Usually, you set these sizes based
/// on a specific number of instances. However, if you configure a mixed instances policy
/// that defines weights for the instance types, you must specify these sizes with the same
/// units that you use for weighting instances.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateAutoScalingGroup {
    _private: (),
}
impl CreateAutoScalingGroup {
    /// Creates a new builder-style object to manufacture [`CreateAutoScalingGroupInput`](crate::input::CreateAutoScalingGroupInput)
    pub fn builder() -> crate::input::create_auto_scaling_group_input::Builder {
        crate::input::create_auto_scaling_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateAutoScalingGroup {
    type Output = std::result::Result<
        crate::output::CreateAutoScalingGroupOutput,
        crate::error::CreateAutoScalingGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_auto_scaling_group_error(response)
        } else {
            crate::operation_deser::parse_create_auto_scaling_group_response(response)
        }
    }
}

/// <p>Creates a launch configuration.</p>
/// <p>If you exceed your maximum limit of launch configurations, the call fails. To query
/// this limit, call the <a>DescribeAccountLimits</a> API. For information about
/// updating this limit, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-account-limits.html">Amazon EC2 Auto Scaling service
/// quotas</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/LaunchConfiguration.html">Launch
/// configurations</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateLaunchConfiguration {
    _private: (),
}
impl CreateLaunchConfiguration {
    /// Creates a new builder-style object to manufacture [`CreateLaunchConfigurationInput`](crate::input::CreateLaunchConfigurationInput)
    pub fn builder() -> crate::input::create_launch_configuration_input::Builder {
        crate::input::create_launch_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateLaunchConfiguration {
    type Output = std::result::Result<
        crate::output::CreateLaunchConfigurationOutput,
        crate::error::CreateLaunchConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_launch_configuration_error(response)
        } else {
            crate::operation_deser::parse_create_launch_configuration_response(response)
        }
    }
}

/// <p>Creates or updates tags for the specified Auto Scaling group.</p>
/// <p>When you specify a tag with a key that already exists, the operation overwrites the
/// previous tag definition, and you do not get an error message.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-tagging.html">Tagging Auto Scaling groups and
/// instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateOrUpdateTags {
    _private: (),
}
impl CreateOrUpdateTags {
    /// Creates a new builder-style object to manufacture [`CreateOrUpdateTagsInput`](crate::input::CreateOrUpdateTagsInput)
    pub fn builder() -> crate::input::create_or_update_tags_input::Builder {
        crate::input::create_or_update_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateOrUpdateTags {
    type Output = std::result::Result<
        crate::output::CreateOrUpdateTagsOutput,
        crate::error::CreateOrUpdateTagsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_or_update_tags_error(response)
        } else {
            crate::operation_deser::parse_create_or_update_tags_response(response)
        }
    }
}

/// <p>Deletes the specified Auto Scaling group.</p>
/// <p>If the group has instances or scaling activities in progress, you must specify the
/// option to force the deletion in order for it to succeed.</p>
/// <p>If the group has policies, deleting the group deletes the policies, the underlying
/// alarm actions, and any alarm that no longer has an associated action.</p>
/// <p>To remove instances from the Auto Scaling group before deleting it, call the <a>DetachInstances</a> API with the list of instances and the option to
/// decrement the desired capacity. This ensures that Amazon EC2 Auto Scaling does not launch replacement
/// instances.</p>
/// <p>To terminate all instances before deleting the Auto Scaling group, call the <a>UpdateAutoScalingGroup</a> API and set the minimum size and desired capacity
/// of the Auto Scaling group to zero.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteAutoScalingGroup {
    _private: (),
}
impl DeleteAutoScalingGroup {
    /// Creates a new builder-style object to manufacture [`DeleteAutoScalingGroupInput`](crate::input::DeleteAutoScalingGroupInput)
    pub fn builder() -> crate::input::delete_auto_scaling_group_input::Builder {
        crate::input::delete_auto_scaling_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteAutoScalingGroup {
    type Output = std::result::Result<
        crate::output::DeleteAutoScalingGroupOutput,
        crate::error::DeleteAutoScalingGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_auto_scaling_group_error(response)
        } else {
            crate::operation_deser::parse_delete_auto_scaling_group_response(response)
        }
    }
}

/// <p>Deletes the specified launch configuration.</p>
/// <p>The launch configuration must not be attached to an Auto Scaling group. When this call
/// completes, the launch configuration is no longer available for use.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLaunchConfiguration {
    _private: (),
}
impl DeleteLaunchConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteLaunchConfigurationInput`](crate::input::DeleteLaunchConfigurationInput)
    pub fn builder() -> crate::input::delete_launch_configuration_input::Builder {
        crate::input::delete_launch_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLaunchConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteLaunchConfigurationOutput,
        crate::error::DeleteLaunchConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_launch_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_launch_configuration_response(response)
        }
    }
}

/// <p>Deletes the specified lifecycle hook.</p>
/// <p>If there are any outstanding lifecycle actions, they are completed first
/// (<code>ABANDON</code> for launching instances, <code>CONTINUE</code> for terminating
/// instances).</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLifecycleHook {
    _private: (),
}
impl DeleteLifecycleHook {
    /// Creates a new builder-style object to manufacture [`DeleteLifecycleHookInput`](crate::input::DeleteLifecycleHookInput)
    pub fn builder() -> crate::input::delete_lifecycle_hook_input::Builder {
        crate::input::delete_lifecycle_hook_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLifecycleHook {
    type Output = std::result::Result<
        crate::output::DeleteLifecycleHookOutput,
        crate::error::DeleteLifecycleHookError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_lifecycle_hook_error(response)
        } else {
            crate::operation_deser::parse_delete_lifecycle_hook_response(response)
        }
    }
}

/// <p>Deletes the specified notification.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteNotificationConfiguration {
    _private: (),
}
impl DeleteNotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`DeleteNotificationConfigurationInput`](crate::input::DeleteNotificationConfigurationInput)
    pub fn builder() -> crate::input::delete_notification_configuration_input::Builder {
        crate::input::delete_notification_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteNotificationConfiguration {
    type Output = std::result::Result<
        crate::output::DeleteNotificationConfigurationOutput,
        crate::error::DeleteNotificationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_notification_configuration_error(response)
        } else {
            crate::operation_deser::parse_delete_notification_configuration_response(response)
        }
    }
}

/// <p>Deletes the specified scaling policy.</p>
/// <p>Deleting either a step scaling policy or a simple scaling policy deletes the
/// underlying alarm action, but does not delete the alarm, even if it no longer has an
/// associated action.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/deleting-scaling-policy.html">Deleting a scaling
/// policy</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePolicy {
    _private: (),
}
impl DeletePolicy {
    /// Creates a new builder-style object to manufacture [`DeletePolicyInput`](crate::input::DeletePolicyInput)
    pub fn builder() -> crate::input::delete_policy_input::Builder {
        crate::input::delete_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePolicy {
    type Output =
        std::result::Result<crate::output::DeletePolicyOutput, crate::error::DeletePolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_policy_response(response)
        }
    }
}

/// <p>Deletes the specified scheduled action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteScheduledAction {
    _private: (),
}
impl DeleteScheduledAction {
    /// Creates a new builder-style object to manufacture [`DeleteScheduledActionInput`](crate::input::DeleteScheduledActionInput)
    pub fn builder() -> crate::input::delete_scheduled_action_input::Builder {
        crate::input::delete_scheduled_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteScheduledAction {
    type Output = std::result::Result<
        crate::output::DeleteScheduledActionOutput,
        crate::error::DeleteScheduledActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_scheduled_action_error(response)
        } else {
            crate::operation_deser::parse_delete_scheduled_action_response(response)
        }
    }
}

/// <p>Deletes the specified tags.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTags {
    _private: (),
}
impl DeleteTags {
    /// Creates a new builder-style object to manufacture [`DeleteTagsInput`](crate::input::DeleteTagsInput)
    pub fn builder() -> crate::input::delete_tags_input::Builder {
        crate::input::delete_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTags {
    type Output =
        std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_tags_error(response)
        } else {
            crate::operation_deser::parse_delete_tags_response(response)
        }
    }
}

/// <p>Deletes the warm pool for the specified Auto Scaling group.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-warm-pools.html">Warm pools for
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteWarmPool {
    _private: (),
}
impl DeleteWarmPool {
    /// Creates a new builder-style object to manufacture [`DeleteWarmPoolInput`](crate::input::DeleteWarmPoolInput)
    pub fn builder() -> crate::input::delete_warm_pool_input::Builder {
        crate::input::delete_warm_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteWarmPool {
    type Output =
        std::result::Result<crate::output::DeleteWarmPoolOutput, crate::error::DeleteWarmPoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_warm_pool_error(response)
        } else {
            crate::operation_deser::parse_delete_warm_pool_response(response)
        }
    }
}

/// <p>Describes the current Amazon EC2 Auto Scaling resource quotas for your account.</p>
/// <p>When you establish an Amazon Web Services account, the account has initial quotas on the maximum
/// number of Auto Scaling groups and launch configurations that you can create in a given Region.
/// For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-account-limits.html">Amazon EC2 Auto Scaling service
/// quotas</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountLimits {
    _private: (),
}
impl DescribeAccountLimits {
    /// Creates a new builder-style object to manufacture [`DescribeAccountLimitsInput`](crate::input::DescribeAccountLimitsInput)
    pub fn builder() -> crate::input::describe_account_limits_input::Builder {
        crate::input::describe_account_limits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountLimits {
    type Output = std::result::Result<
        crate::output::DescribeAccountLimitsOutput,
        crate::error::DescribeAccountLimitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_account_limits_error(response)
        } else {
            crate::operation_deser::parse_describe_account_limits_response(response)
        }
    }
}

/// <p>Describes the available adjustment types for step scaling and simple scaling
/// policies.</p>
/// <p>The following adjustment types are supported:</p>
/// <ul>
/// <li>
/// <p>
/// <code>ChangeInCapacity</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>ExactCapacity</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>PercentChangeInCapacity</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAdjustmentTypes {
    _private: (),
}
impl DescribeAdjustmentTypes {
    /// Creates a new builder-style object to manufacture [`DescribeAdjustmentTypesInput`](crate::input::DescribeAdjustmentTypesInput)
    pub fn builder() -> crate::input::describe_adjustment_types_input::Builder {
        crate::input::describe_adjustment_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAdjustmentTypes {
    type Output = std::result::Result<
        crate::output::DescribeAdjustmentTypesOutput,
        crate::error::DescribeAdjustmentTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_adjustment_types_error(response)
        } else {
            crate::operation_deser::parse_describe_adjustment_types_response(response)
        }
    }
}

/// <p>Gets information about the Auto Scaling groups in the account and Region.</p>
/// <p>If you specify Auto Scaling group names, the output includes information for only the
/// specified Auto Scaling groups. If you specify filters, the output includes information for only
/// those Auto Scaling groups that meet the filter criteria. If you do not specify group names or
/// filters, the output includes information for all Auto Scaling groups. </p>
/// <p>This operation also returns information about instances in Auto Scaling groups. To retrieve
/// information about the instances in a warm pool, you must call the <a>DescribeWarmPool</a> API. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAutoScalingGroups {
    _private: (),
}
impl DescribeAutoScalingGroups {
    /// Creates a new builder-style object to manufacture [`DescribeAutoScalingGroupsInput`](crate::input::DescribeAutoScalingGroupsInput)
    pub fn builder() -> crate::input::describe_auto_scaling_groups_input::Builder {
        crate::input::describe_auto_scaling_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAutoScalingGroups {
    type Output = std::result::Result<
        crate::output::DescribeAutoScalingGroupsOutput,
        crate::error::DescribeAutoScalingGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_auto_scaling_groups_error(response)
        } else {
            crate::operation_deser::parse_describe_auto_scaling_groups_response(response)
        }
    }
}

/// <p>Gets information about the Auto Scaling instances in the account and Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAutoScalingInstances {
    _private: (),
}
impl DescribeAutoScalingInstances {
    /// Creates a new builder-style object to manufacture [`DescribeAutoScalingInstancesInput`](crate::input::DescribeAutoScalingInstancesInput)
    pub fn builder() -> crate::input::describe_auto_scaling_instances_input::Builder {
        crate::input::describe_auto_scaling_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAutoScalingInstances {
    type Output = std::result::Result<
        crate::output::DescribeAutoScalingInstancesOutput,
        crate::error::DescribeAutoScalingInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_auto_scaling_instances_error(response)
        } else {
            crate::operation_deser::parse_describe_auto_scaling_instances_response(response)
        }
    }
}

/// <p>Describes the notification types that are supported by Amazon EC2 Auto Scaling.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAutoScalingNotificationTypes {
    _private: (),
}
impl DescribeAutoScalingNotificationTypes {
    /// Creates a new builder-style object to manufacture [`DescribeAutoScalingNotificationTypesInput`](crate::input::DescribeAutoScalingNotificationTypesInput)
    pub fn builder() -> crate::input::describe_auto_scaling_notification_types_input::Builder {
        crate::input::describe_auto_scaling_notification_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAutoScalingNotificationTypes {
    type Output = std::result::Result<
        crate::output::DescribeAutoScalingNotificationTypesOutput,
        crate::error::DescribeAutoScalingNotificationTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_auto_scaling_notification_types_error(response)
        } else {
            crate::operation_deser::parse_describe_auto_scaling_notification_types_response(
                response,
            )
        }
    }
}

/// <p>Gets information about the instance refreshes for the specified Auto Scaling group.</p>
/// <p>This operation is part of the <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html">instance refresh
/// feature</a> in Amazon EC2 Auto Scaling, which helps you update instances in your Auto Scaling group
/// after you make configuration changes.</p>
/// <p>To help you determine the status of an instance refresh, this operation returns
/// information about the instance refreshes you previously initiated, including their
/// status, end time, the percentage of the instance refresh that is complete, and the
/// number of instances remaining to update before the instance refresh is complete.</p>
/// <p>The following are the possible statuses: </p>
/// <ul>
/// <li>
/// <p>
/// <code>Pending</code> - The request was created, but the operation has not
/// started.</p>
/// </li>
/// <li>
/// <p>
/// <code>InProgress</code> - The operation is in progress.</p>
/// </li>
/// <li>
/// <p>
/// <code>Successful</code> - The operation completed successfully.</p>
/// </li>
/// <li>
/// <p>
/// <code>Failed</code> - The operation failed to complete. You can troubleshoot
/// using the status reason and the scaling activities. </p>
/// </li>
/// <li>
/// <p>
/// <code>Cancelling</code> - An ongoing operation is being cancelled.
/// Cancellation does not roll back any replacements that have already been
/// completed, but it prevents new replacements from being started. </p>
/// </li>
/// <li>
/// <p>
/// <code>Cancelled</code> - The operation is cancelled. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeInstanceRefreshes {
    _private: (),
}
impl DescribeInstanceRefreshes {
    /// Creates a new builder-style object to manufacture [`DescribeInstanceRefreshesInput`](crate::input::DescribeInstanceRefreshesInput)
    pub fn builder() -> crate::input::describe_instance_refreshes_input::Builder {
        crate::input::describe_instance_refreshes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeInstanceRefreshes {
    type Output = std::result::Result<
        crate::output::DescribeInstanceRefreshesOutput,
        crate::error::DescribeInstanceRefreshesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_instance_refreshes_error(response)
        } else {
            crate::operation_deser::parse_describe_instance_refreshes_response(response)
        }
    }
}

/// <p>Gets information about the launch configurations in the account and Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLaunchConfigurations {
    _private: (),
}
impl DescribeLaunchConfigurations {
    /// Creates a new builder-style object to manufacture [`DescribeLaunchConfigurationsInput`](crate::input::DescribeLaunchConfigurationsInput)
    pub fn builder() -> crate::input::describe_launch_configurations_input::Builder {
        crate::input::describe_launch_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLaunchConfigurations {
    type Output = std::result::Result<
        crate::output::DescribeLaunchConfigurationsOutput,
        crate::error::DescribeLaunchConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_launch_configurations_error(response)
        } else {
            crate::operation_deser::parse_describe_launch_configurations_response(response)
        }
    }
}

/// <p>Gets information about the lifecycle hooks for the specified Auto Scaling group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLifecycleHooks {
    _private: (),
}
impl DescribeLifecycleHooks {
    /// Creates a new builder-style object to manufacture [`DescribeLifecycleHooksInput`](crate::input::DescribeLifecycleHooksInput)
    pub fn builder() -> crate::input::describe_lifecycle_hooks_input::Builder {
        crate::input::describe_lifecycle_hooks_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLifecycleHooks {
    type Output = std::result::Result<
        crate::output::DescribeLifecycleHooksOutput,
        crate::error::DescribeLifecycleHooksError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_lifecycle_hooks_error(response)
        } else {
            crate::operation_deser::parse_describe_lifecycle_hooks_response(response)
        }
    }
}

/// <p>Describes the available types of lifecycle hooks.</p>
/// <p>The following hook types are supported:</p>
/// <ul>
/// <li>
/// <p>
/// <code>autoscaling:EC2_INSTANCE_LAUNCHING</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>autoscaling:EC2_INSTANCE_TERMINATING</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLifecycleHookTypes {
    _private: (),
}
impl DescribeLifecycleHookTypes {
    /// Creates a new builder-style object to manufacture [`DescribeLifecycleHookTypesInput`](crate::input::DescribeLifecycleHookTypesInput)
    pub fn builder() -> crate::input::describe_lifecycle_hook_types_input::Builder {
        crate::input::describe_lifecycle_hook_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLifecycleHookTypes {
    type Output = std::result::Result<
        crate::output::DescribeLifecycleHookTypesOutput,
        crate::error::DescribeLifecycleHookTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_lifecycle_hook_types_error(response)
        } else {
            crate::operation_deser::parse_describe_lifecycle_hook_types_response(response)
        }
    }
}

/// <p>Gets information about the load balancers for the specified Auto Scaling group.</p>
/// <p>This operation describes only Classic Load Balancers. If you have Application Load
/// Balancers, Network Load Balancers, or Gateway Load Balancers, use the <a>DescribeLoadBalancerTargetGroups</a> API instead.</p>
/// <p>To determine the availability of registered instances, use the <code>State</code>
/// element in the response. When you attach a load balancer to an Auto Scaling group, the initial
/// <code>State</code> value is <code>Adding</code>. The state transitions to
/// <code>Added</code> after all Auto Scaling instances are registered with the load balancer.
/// If Elastic Load Balancing health checks are enabled for the Auto Scaling group, the state transitions to
/// <code>InService</code> after at least one Auto Scaling instance passes the health check.
/// When the load balancer is in the <code>InService</code> state, Amazon EC2 Auto Scaling can terminate
/// and replace any instances that are reported as unhealthy. If no registered instances
/// pass the health checks, the load balancer doesn't enter the <code>InService</code>
/// state. </p>
/// <p>Load balancers also have an <code>InService</code> state if you attach them in the
/// <a>CreateAutoScalingGroup</a> API call. If your load balancer state is
/// <code>InService</code>, but it is not working properly, check the scaling activities
/// by calling <a>DescribeScalingActivities</a> and take any corrective actions
/// necessary.</p>
/// <p>For help with failed health checks, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ts-as-healthchecks.html">Troubleshooting Amazon EC2 Auto Scaling:
/// Health checks</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. For more
/// information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html">Elastic Load Balancing and
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLoadBalancers {
    _private: (),
}
impl DescribeLoadBalancers {
    /// Creates a new builder-style object to manufacture [`DescribeLoadBalancersInput`](crate::input::DescribeLoadBalancersInput)
    pub fn builder() -> crate::input::describe_load_balancers_input::Builder {
        crate::input::describe_load_balancers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLoadBalancers {
    type Output = std::result::Result<
        crate::output::DescribeLoadBalancersOutput,
        crate::error::DescribeLoadBalancersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_load_balancers_error(response)
        } else {
            crate::operation_deser::parse_describe_load_balancers_response(response)
        }
    }
}

/// <p>Gets information about the load balancer target groups for the specified Auto Scaling
/// group.</p>
/// <p>To determine the availability of registered instances, use the <code>State</code>
/// element in the response. When you attach a target group to an Auto Scaling group, the initial
/// <code>State</code> value is <code>Adding</code>. The state transitions to
/// <code>Added</code> after all Auto Scaling instances are registered with the target group. If
/// Elastic Load Balancing health checks are enabled for the Auto Scaling group, the state transitions to
/// <code>InService</code> after at least one Auto Scaling instance passes the health check.
/// When the target group is in the <code>InService</code> state, Amazon EC2 Auto Scaling can terminate and
/// replace any instances that are reported as unhealthy. If no registered instances pass
/// the health checks, the target group doesn't enter the <code>InService</code> state. </p>
/// <p>Target groups also have an <code>InService</code> state if you attach them in the
/// <a>CreateAutoScalingGroup</a> API call. If your target group state is
/// <code>InService</code>, but it is not working properly, check the scaling activities
/// by calling <a>DescribeScalingActivities</a> and take any corrective actions
/// necessary.</p>
/// <p>For help with failed health checks, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ts-as-healthchecks.html">Troubleshooting Amazon EC2 Auto Scaling:
/// Health checks</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. For more
/// information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html">Elastic Load Balancing and
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeLoadBalancerTargetGroups {
    _private: (),
}
impl DescribeLoadBalancerTargetGroups {
    /// Creates a new builder-style object to manufacture [`DescribeLoadBalancerTargetGroupsInput`](crate::input::DescribeLoadBalancerTargetGroupsInput)
    pub fn builder() -> crate::input::describe_load_balancer_target_groups_input::Builder {
        crate::input::describe_load_balancer_target_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeLoadBalancerTargetGroups {
    type Output = std::result::Result<
        crate::output::DescribeLoadBalancerTargetGroupsOutput,
        crate::error::DescribeLoadBalancerTargetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_load_balancer_target_groups_error(response)
        } else {
            crate::operation_deser::parse_describe_load_balancer_target_groups_response(response)
        }
    }
}

/// <p>Describes the available CloudWatch metrics for Amazon EC2 Auto Scaling.</p>
/// <p>The <code>GroupStandbyInstances</code> metric is not returned by default. You must
/// explicitly request this metric when calling the <a>EnableMetricsCollection</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMetricCollectionTypes {
    _private: (),
}
impl DescribeMetricCollectionTypes {
    /// Creates a new builder-style object to manufacture [`DescribeMetricCollectionTypesInput`](crate::input::DescribeMetricCollectionTypesInput)
    pub fn builder() -> crate::input::describe_metric_collection_types_input::Builder {
        crate::input::describe_metric_collection_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMetricCollectionTypes {
    type Output = std::result::Result<
        crate::output::DescribeMetricCollectionTypesOutput,
        crate::error::DescribeMetricCollectionTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_metric_collection_types_error(response)
        } else {
            crate::operation_deser::parse_describe_metric_collection_types_response(response)
        }
    }
}

/// <p>Gets information about the Amazon SNS notifications that are configured for one or more
/// Auto Scaling groups.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeNotificationConfigurations {
    _private: (),
}
impl DescribeNotificationConfigurations {
    /// Creates a new builder-style object to manufacture [`DescribeNotificationConfigurationsInput`](crate::input::DescribeNotificationConfigurationsInput)
    pub fn builder() -> crate::input::describe_notification_configurations_input::Builder {
        crate::input::describe_notification_configurations_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeNotificationConfigurations {
    type Output = std::result::Result<
        crate::output::DescribeNotificationConfigurationsOutput,
        crate::error::DescribeNotificationConfigurationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_notification_configurations_error(response)
        } else {
            crate::operation_deser::parse_describe_notification_configurations_response(response)
        }
    }
}

/// <p>Gets information about the scaling policies in the account and Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePolicies {
    _private: (),
}
impl DescribePolicies {
    /// Creates a new builder-style object to manufacture [`DescribePoliciesInput`](crate::input::DescribePoliciesInput)
    pub fn builder() -> crate::input::describe_policies_input::Builder {
        crate::input::describe_policies_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePolicies {
    type Output = std::result::Result<
        crate::output::DescribePoliciesOutput,
        crate::error::DescribePoliciesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_policies_error(response)
        } else {
            crate::operation_deser::parse_describe_policies_response(response)
        }
    }
}

/// <p>Gets information about the scaling activities in the account and Region.</p>
/// <p>When scaling events occur, you see a record of the scaling activity in the scaling
/// activities. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-verify-scaling-activity.html">Verifying a scaling
/// activity for an Auto Scaling group</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>If the scaling event succeeds, the value of the <code>StatusCode</code> element in the
/// response is <code>Successful</code>. If an attempt to launch instances failed, the
/// <code>StatusCode</code> value is <code>Failed</code> or <code>Cancelled</code> and
/// the <code>StatusMessage</code> element in the response indicates the cause of the
/// failure. For help interpreting the <code>StatusMessage</code>, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/CHAP_Troubleshooting.html">Troubleshooting Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeScalingActivities {
    _private: (),
}
impl DescribeScalingActivities {
    /// Creates a new builder-style object to manufacture [`DescribeScalingActivitiesInput`](crate::input::DescribeScalingActivitiesInput)
    pub fn builder() -> crate::input::describe_scaling_activities_input::Builder {
        crate::input::describe_scaling_activities_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeScalingActivities {
    type Output = std::result::Result<
        crate::output::DescribeScalingActivitiesOutput,
        crate::error::DescribeScalingActivitiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_scaling_activities_error(response)
        } else {
            crate::operation_deser::parse_describe_scaling_activities_response(response)
        }
    }
}

/// <p>Describes the scaling process types for use with the <a>ResumeProcesses</a>
/// and <a>SuspendProcesses</a> APIs.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeScalingProcessTypes {
    _private: (),
}
impl DescribeScalingProcessTypes {
    /// Creates a new builder-style object to manufacture [`DescribeScalingProcessTypesInput`](crate::input::DescribeScalingProcessTypesInput)
    pub fn builder() -> crate::input::describe_scaling_process_types_input::Builder {
        crate::input::describe_scaling_process_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeScalingProcessTypes {
    type Output = std::result::Result<
        crate::output::DescribeScalingProcessTypesOutput,
        crate::error::DescribeScalingProcessTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_scaling_process_types_error(response)
        } else {
            crate::operation_deser::parse_describe_scaling_process_types_response(response)
        }
    }
}

/// <p>Gets information about the scheduled actions that haven't run or that have not reached
/// their end time.</p>
/// <p>To describe the scaling activities for scheduled actions that have already run, call
/// the <a>DescribeScalingActivities</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeScheduledActions {
    _private: (),
}
impl DescribeScheduledActions {
    /// Creates a new builder-style object to manufacture [`DescribeScheduledActionsInput`](crate::input::DescribeScheduledActionsInput)
    pub fn builder() -> crate::input::describe_scheduled_actions_input::Builder {
        crate::input::describe_scheduled_actions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeScheduledActions {
    type Output = std::result::Result<
        crate::output::DescribeScheduledActionsOutput,
        crate::error::DescribeScheduledActionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_scheduled_actions_error(response)
        } else {
            crate::operation_deser::parse_describe_scheduled_actions_response(response)
        }
    }
}

/// <p>Describes the specified tags.</p>
/// <p>You can use filters to limit the results. For example, you can query for the tags for
/// a specific Auto Scaling group. You can specify multiple values for a filter. A tag must match at
/// least one of the specified values for it to be included in the results.</p>
/// <p>You can also specify multiple filters. The result includes information for a
/// particular tag only if it matches all the filters. If there's no match, no special
/// message is returned.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-tagging.html">Tagging Auto Scaling groups and
/// instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTags {
    _private: (),
}
impl DescribeTags {
    /// Creates a new builder-style object to manufacture [`DescribeTagsInput`](crate::input::DescribeTagsInput)
    pub fn builder() -> crate::input::describe_tags_input::Builder {
        crate::input::describe_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTags {
    type Output =
        std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_tags_error(response)
        } else {
            crate::operation_deser::parse_describe_tags_response(response)
        }
    }
}

/// <p>Describes the termination policies supported by Amazon EC2 Auto Scaling.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html">Controlling which Auto Scaling
/// instances terminate during scale in</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTerminationPolicyTypes {
    _private: (),
}
impl DescribeTerminationPolicyTypes {
    /// Creates a new builder-style object to manufacture [`DescribeTerminationPolicyTypesInput`](crate::input::DescribeTerminationPolicyTypesInput)
    pub fn builder() -> crate::input::describe_termination_policy_types_input::Builder {
        crate::input::describe_termination_policy_types_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTerminationPolicyTypes {
    type Output = std::result::Result<
        crate::output::DescribeTerminationPolicyTypesOutput,
        crate::error::DescribeTerminationPolicyTypesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_termination_policy_types_error(response)
        } else {
            crate::operation_deser::parse_describe_termination_policy_types_response(response)
        }
    }
}

/// <p>Gets information about a warm pool and its instances.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-warm-pools.html">Warm pools for
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWarmPool {
    _private: (),
}
impl DescribeWarmPool {
    /// Creates a new builder-style object to manufacture [`DescribeWarmPoolInput`](crate::input::DescribeWarmPoolInput)
    pub fn builder() -> crate::input::describe_warm_pool_input::Builder {
        crate::input::describe_warm_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWarmPool {
    type Output = std::result::Result<
        crate::output::DescribeWarmPoolOutput,
        crate::error::DescribeWarmPoolError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_warm_pool_error(response)
        } else {
            crate::operation_deser::parse_describe_warm_pool_response(response)
        }
    }
}

/// <p>Removes one or more instances from the specified Auto Scaling group.</p>
/// <p>After the instances are detached, you can manage them independent of the Auto Scaling
/// group.</p>
/// <p>If you do not specify the option to decrement the desired capacity, Amazon EC2 Auto Scaling launches
/// instances to replace the ones that are detached.</p>
/// <p>If there is a Classic Load Balancer attached to the Auto Scaling group, the instances are
/// deregistered from the load balancer. If there are target groups attached to the Auto Scaling
/// group, the instances are deregistered from the target groups.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/detach-instance-asg.html">Detach EC2 instances from
/// your Auto Scaling group</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachInstances {
    _private: (),
}
impl DetachInstances {
    /// Creates a new builder-style object to manufacture [`DetachInstancesInput`](crate::input::DetachInstancesInput)
    pub fn builder() -> crate::input::detach_instances_input::Builder {
        crate::input::detach_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachInstances {
    type Output = std::result::Result<
        crate::output::DetachInstancesOutput,
        crate::error::DetachInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_instances_error(response)
        } else {
            crate::operation_deser::parse_detach_instances_response(response)
        }
    }
}

/// <p>Detaches one or more Classic Load Balancers from the specified Auto Scaling group.</p>
/// <p>This operation detaches only Classic Load Balancers. If you have Application Load
/// Balancers, Network Load Balancers, or Gateway Load Balancers, use the <a>DetachLoadBalancerTargetGroups</a> API instead.</p>
/// <p>When you detach a load balancer, it enters the <code>Removing</code> state while
/// deregistering the instances in the group. When all instances are deregistered, then you
/// can no longer describe the load balancer using the <a>DescribeLoadBalancers</a> API call. The instances remain running.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachLoadBalancers {
    _private: (),
}
impl DetachLoadBalancers {
    /// Creates a new builder-style object to manufacture [`DetachLoadBalancersInput`](crate::input::DetachLoadBalancersInput)
    pub fn builder() -> crate::input::detach_load_balancers_input::Builder {
        crate::input::detach_load_balancers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachLoadBalancers {
    type Output = std::result::Result<
        crate::output::DetachLoadBalancersOutput,
        crate::error::DetachLoadBalancersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_load_balancers_error(response)
        } else {
            crate::operation_deser::parse_detach_load_balancers_response(response)
        }
    }
}

/// <p>Detaches one or more target groups from the specified Auto Scaling group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DetachLoadBalancerTargetGroups {
    _private: (),
}
impl DetachLoadBalancerTargetGroups {
    /// Creates a new builder-style object to manufacture [`DetachLoadBalancerTargetGroupsInput`](crate::input::DetachLoadBalancerTargetGroupsInput)
    pub fn builder() -> crate::input::detach_load_balancer_target_groups_input::Builder {
        crate::input::detach_load_balancer_target_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DetachLoadBalancerTargetGroups {
    type Output = std::result::Result<
        crate::output::DetachLoadBalancerTargetGroupsOutput,
        crate::error::DetachLoadBalancerTargetGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_detach_load_balancer_target_groups_error(response)
        } else {
            crate::operation_deser::parse_detach_load_balancer_target_groups_response(response)
        }
    }
}

/// <p>Disables group metrics for the specified Auto Scaling group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisableMetricsCollection {
    _private: (),
}
impl DisableMetricsCollection {
    /// Creates a new builder-style object to manufacture [`DisableMetricsCollectionInput`](crate::input::DisableMetricsCollectionInput)
    pub fn builder() -> crate::input::disable_metrics_collection_input::Builder {
        crate::input::disable_metrics_collection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisableMetricsCollection {
    type Output = std::result::Result<
        crate::output::DisableMetricsCollectionOutput,
        crate::error::DisableMetricsCollectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disable_metrics_collection_error(response)
        } else {
            crate::operation_deser::parse_disable_metrics_collection_response(response)
        }
    }
}

/// <p>Enables group metrics for the specified Auto Scaling group. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-monitoring.html">Monitoring CloudWatch metrics for your Auto Scaling groups and instances</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnableMetricsCollection {
    _private: (),
}
impl EnableMetricsCollection {
    /// Creates a new builder-style object to manufacture [`EnableMetricsCollectionInput`](crate::input::EnableMetricsCollectionInput)
    pub fn builder() -> crate::input::enable_metrics_collection_input::Builder {
        crate::input::enable_metrics_collection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnableMetricsCollection {
    type Output = std::result::Result<
        crate::output::EnableMetricsCollectionOutput,
        crate::error::EnableMetricsCollectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enable_metrics_collection_error(response)
        } else {
            crate::operation_deser::parse_enable_metrics_collection_response(response)
        }
    }
}

/// <p>Moves the specified instances into the standby state.</p>
/// <p>If you choose to decrement the desired capacity of the Auto Scaling group, the instances can
/// enter standby as long as the desired capacity of the Auto Scaling group after the instances are
/// placed into standby is equal to or greater than the minimum capacity of the
/// group.</p>
/// <p>If you choose not to decrement the desired capacity of the Auto Scaling group, the Auto Scaling group
/// launches new instances to replace the instances on standby.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-enter-exit-standby.html">Temporarily removing
/// instances from your Auto Scaling group</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EnterStandby {
    _private: (),
}
impl EnterStandby {
    /// Creates a new builder-style object to manufacture [`EnterStandbyInput`](crate::input::EnterStandbyInput)
    pub fn builder() -> crate::input::enter_standby_input::Builder {
        crate::input::enter_standby_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EnterStandby {
    type Output =
        std::result::Result<crate::output::EnterStandbyOutput, crate::error::EnterStandbyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_enter_standby_error(response)
        } else {
            crate::operation_deser::parse_enter_standby_response(response)
        }
    }
}

/// <p>Executes the specified policy. This can be useful for testing the design of your
/// scaling policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ExecutePolicy {
    _private: (),
}
impl ExecutePolicy {
    /// Creates a new builder-style object to manufacture [`ExecutePolicyInput`](crate::input::ExecutePolicyInput)
    pub fn builder() -> crate::input::execute_policy_input::Builder {
        crate::input::execute_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ExecutePolicy {
    type Output =
        std::result::Result<crate::output::ExecutePolicyOutput, crate::error::ExecutePolicyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_execute_policy_error(response)
        } else {
            crate::operation_deser::parse_execute_policy_response(response)
        }
    }
}

/// <p>Moves the specified instances out of the standby state.</p>
/// <p>After you put the instances back in service, the desired capacity is
/// incremented.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-enter-exit-standby.html">Temporarily removing
/// instances from your Auto Scaling group</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ExitStandby {
    _private: (),
}
impl ExitStandby {
    /// Creates a new builder-style object to manufacture [`ExitStandbyInput`](crate::input::ExitStandbyInput)
    pub fn builder() -> crate::input::exit_standby_input::Builder {
        crate::input::exit_standby_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ExitStandby {
    type Output =
        std::result::Result<crate::output::ExitStandbyOutput, crate::error::ExitStandbyError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_exit_standby_error(response)
        } else {
            crate::operation_deser::parse_exit_standby_response(response)
        }
    }
}

/// <p>Retrieves the forecast data for a predictive scaling policy.</p>
/// <p>Load forecasts are predictions of the hourly load values using historical load data
/// from CloudWatch and an analysis of historical trends. Capacity forecasts are represented as
/// predicted values for the minimum capacity that is needed on an hourly basis, based on
/// the hourly load forecast.</p>
/// <p>A minimum of 24 hours of data is required to create the initial forecasts. However,
/// having a full 14 days of historical data results in more accurate forecasts.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-predictive-scaling.html">Predictive
/// scaling for Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPredictiveScalingForecast {
    _private: (),
}
impl GetPredictiveScalingForecast {
    /// Creates a new builder-style object to manufacture [`GetPredictiveScalingForecastInput`](crate::input::GetPredictiveScalingForecastInput)
    pub fn builder() -> crate::input::get_predictive_scaling_forecast_input::Builder {
        crate::input::get_predictive_scaling_forecast_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPredictiveScalingForecast {
    type Output = std::result::Result<
        crate::output::GetPredictiveScalingForecastOutput,
        crate::error::GetPredictiveScalingForecastError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_predictive_scaling_forecast_error(response)
        } else {
            crate::operation_deser::parse_get_predictive_scaling_forecast_response(response)
        }
    }
}

/// <p>Creates or updates a lifecycle hook for the specified Auto Scaling group.</p>
/// <p>A lifecycle hook tells Amazon EC2 Auto Scaling to perform an action on an instance when the instance
/// launches (before it is put into service) or as the instance terminates (before it is
/// fully terminated).</p>
/// <p>This step is a part of the procedure for adding a lifecycle hook to an Auto Scaling
/// group:</p>
/// <ol>
/// <li>
/// <p>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to
/// invoke your Lambda function when Amazon EC2 Auto Scaling launches or terminates
/// instances.</p>
/// </li>
/// <li>
/// <p>(Optional) Create a notification target and an IAM role. The target can be
/// either an Amazon SQS queue or an Amazon SNS topic. The role allows Amazon EC2 Auto Scaling to
/// publish lifecycle notifications to the target.</p>
/// </li>
/// <li>
/// <p>
/// <b>Create the lifecycle hook. Specify whether the hook is
/// used when the instances launch or terminate.</b>
/// </p>
/// </li>
/// <li>
/// <p>If you need more time, record the lifecycle action heartbeat to keep the
/// instance in a pending state using the <a>RecordLifecycleActionHeartbeat</a> API call.</p>
/// </li>
/// <li>
/// <p>If you finish before the timeout period ends, complete the lifecycle action
/// using the <a>CompleteLifecycleAction</a> API call.</p>
/// </li>
/// </ol>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html">Amazon EC2 Auto Scaling lifecycle
/// hooks</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>If you exceed your maximum limit of lifecycle hooks, which by default is 50 per Auto Scaling
/// group, the call fails.</p>
/// <p>You can view the lifecycle hooks for an Auto Scaling group using the <a>DescribeLifecycleHooks</a> API call. If you are no longer using a lifecycle
/// hook, you can delete it by calling the <a>DeleteLifecycleHook</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutLifecycleHook {
    _private: (),
}
impl PutLifecycleHook {
    /// Creates a new builder-style object to manufacture [`PutLifecycleHookInput`](crate::input::PutLifecycleHookInput)
    pub fn builder() -> crate::input::put_lifecycle_hook_input::Builder {
        crate::input::put_lifecycle_hook_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutLifecycleHook {
    type Output = std::result::Result<
        crate::output::PutLifecycleHookOutput,
        crate::error::PutLifecycleHookError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_lifecycle_hook_error(response)
        } else {
            crate::operation_deser::parse_put_lifecycle_hook_response(response)
        }
    }
}

/// <p>Configures an Auto Scaling group to send notifications when specified events take place.
/// Subscribers to the specified topic can have messages delivered to an endpoint such as a
/// web server or an email address.</p>
/// <p>This configuration overwrites any existing configuration.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ASGettingNotifications.html">Getting Amazon SNS
/// notifications when your Auto Scaling group scales</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>If you exceed your maximum limit of SNS topics, which is 10 per Auto Scaling group, the call
/// fails.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutNotificationConfiguration {
    _private: (),
}
impl PutNotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`PutNotificationConfigurationInput`](crate::input::PutNotificationConfigurationInput)
    pub fn builder() -> crate::input::put_notification_configuration_input::Builder {
        crate::input::put_notification_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutNotificationConfiguration {
    type Output = std::result::Result<
        crate::output::PutNotificationConfigurationOutput,
        crate::error::PutNotificationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_notification_configuration_error(response)
        } else {
            crate::operation_deser::parse_put_notification_configuration_response(response)
        }
    }
}

/// <p>Creates or updates a scaling policy for an Auto Scaling group. Scaling policies are used to
/// scale an Auto Scaling group based on configurable metrics. If no policies are defined, the
/// dynamic scaling and predictive scaling features are not used. </p>
/// <p>For more information about using dynamic scaling, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-target-tracking.html">Target tracking
/// scaling policies</a> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html">Step and simple scaling
/// policies</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>For more information about using predictive scaling, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-predictive-scaling.html">Predictive
/// scaling for Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>You can view the scaling policies for an Auto Scaling group using the <a>DescribePolicies</a> API call. If you are no longer using a scaling policy,
/// you can delete it by calling the <a>DeletePolicy</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutScalingPolicy {
    _private: (),
}
impl PutScalingPolicy {
    /// Creates a new builder-style object to manufacture [`PutScalingPolicyInput`](crate::input::PutScalingPolicyInput)
    pub fn builder() -> crate::input::put_scaling_policy_input::Builder {
        crate::input::put_scaling_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutScalingPolicy {
    type Output = std::result::Result<
        crate::output::PutScalingPolicyOutput,
        crate::error::PutScalingPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_scaling_policy_error(response)
        } else {
            crate::operation_deser::parse_put_scaling_policy_response(response)
        }
    }
}

/// <p>Creates or updates a scheduled scaling action for an Auto Scaling group.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/schedule_time.html">Scheduled scaling</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>You can view the scheduled actions for an Auto Scaling group using the <a>DescribeScheduledActions</a> API call. If you are no longer using a
/// scheduled action, you can delete it by calling the <a>DeleteScheduledAction</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutScheduledUpdateGroupAction {
    _private: (),
}
impl PutScheduledUpdateGroupAction {
    /// Creates a new builder-style object to manufacture [`PutScheduledUpdateGroupActionInput`](crate::input::PutScheduledUpdateGroupActionInput)
    pub fn builder() -> crate::input::put_scheduled_update_group_action_input::Builder {
        crate::input::put_scheduled_update_group_action_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutScheduledUpdateGroupAction {
    type Output = std::result::Result<
        crate::output::PutScheduledUpdateGroupActionOutput,
        crate::error::PutScheduledUpdateGroupActionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_scheduled_update_group_action_error(response)
        } else {
            crate::operation_deser::parse_put_scheduled_update_group_action_response(response)
        }
    }
}

/// <p>Creates or updates a warm pool for the specified Auto Scaling group. A warm pool is a pool of
/// pre-initialized EC2 instances that sits alongside the Auto Scaling group. Whenever your
/// application needs to scale out, the Auto Scaling group can draw on the warm pool to meet its new
/// desired capacity. For more information and example configurations, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-warm-pools.html">Warm pools for
/// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>This operation must be called from the Region in which the Auto Scaling group was created.
/// This operation cannot be called on an Auto Scaling group that has a mixed instances policy or a
/// launch template or launch configuration that requests Spot Instances.</p>
/// <p>You can view the instances in the warm pool using the <a>DescribeWarmPool</a> API call. If you are no longer using a warm pool, you can delete it by calling the
/// <a>DeleteWarmPool</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutWarmPool {
    _private: (),
}
impl PutWarmPool {
    /// Creates a new builder-style object to manufacture [`PutWarmPoolInput`](crate::input::PutWarmPoolInput)
    pub fn builder() -> crate::input::put_warm_pool_input::Builder {
        crate::input::put_warm_pool_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutWarmPool {
    type Output =
        std::result::Result<crate::output::PutWarmPoolOutput, crate::error::PutWarmPoolError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_warm_pool_error(response)
        } else {
            crate::operation_deser::parse_put_warm_pool_response(response)
        }
    }
}

/// <p>Records a heartbeat for the lifecycle action associated with the specified token or
/// instance. This extends the timeout by the length of time defined using the <a>PutLifecycleHook</a> API call.</p>
/// <p>This step is a part of the procedure for adding a lifecycle hook to an Auto Scaling
/// group:</p>
/// <ol>
/// <li>
/// <p>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to
/// invoke your Lambda function when Amazon EC2 Auto Scaling launches or terminates
/// instances.</p>
/// </li>
/// <li>
/// <p>(Optional) Create a notification target and an IAM role. The target can be
/// either an Amazon SQS queue or an Amazon SNS topic. The role allows Amazon EC2 Auto Scaling to
/// publish lifecycle notifications to the target.</p>
/// </li>
/// <li>
/// <p>Create the lifecycle hook. Specify whether the hook is used when the instances
/// launch or terminate.</p>
/// </li>
/// <li>
/// <p>
/// <b>If you need more time, record the lifecycle action
/// heartbeat to keep the instance in a pending state.</b>
/// </p>
/// </li>
/// <li>
/// <p>If you finish before the timeout period ends, complete the lifecycle
/// action.</p>
/// </li>
/// </ol>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html">Amazon EC2 Auto Scaling lifecycle
/// hooks</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RecordLifecycleActionHeartbeat {
    _private: (),
}
impl RecordLifecycleActionHeartbeat {
    /// Creates a new builder-style object to manufacture [`RecordLifecycleActionHeartbeatInput`](crate::input::RecordLifecycleActionHeartbeatInput)
    pub fn builder() -> crate::input::record_lifecycle_action_heartbeat_input::Builder {
        crate::input::record_lifecycle_action_heartbeat_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RecordLifecycleActionHeartbeat {
    type Output = std::result::Result<
        crate::output::RecordLifecycleActionHeartbeatOutput,
        crate::error::RecordLifecycleActionHeartbeatError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_record_lifecycle_action_heartbeat_error(response)
        } else {
            crate::operation_deser::parse_record_lifecycle_action_heartbeat_response(response)
        }
    }
}

/// <p>Resumes the specified suspended auto scaling processes, or all suspended process, for
/// the specified Auto Scaling group.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html">Suspending and
/// resuming scaling processes</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ResumeProcesses {
    _private: (),
}
impl ResumeProcesses {
    /// Creates a new builder-style object to manufacture [`ResumeProcessesInput`](crate::input::ResumeProcessesInput)
    pub fn builder() -> crate::input::resume_processes_input::Builder {
        crate::input::resume_processes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ResumeProcesses {
    type Output = std::result::Result<
        crate::output::ResumeProcessesOutput,
        crate::error::ResumeProcessesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_resume_processes_error(response)
        } else {
            crate::operation_deser::parse_resume_processes_response(response)
        }
    }
}

/// <p>Sets the size of the specified Auto Scaling group.</p>
/// <p>If a scale-in activity occurs as a result of a new <code>DesiredCapacity</code> value
/// that is lower than the current size of the group, the Auto Scaling group uses its termination
/// policy to determine which instances to terminate. </p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-manual-scaling.html">Manual scaling</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetDesiredCapacity {
    _private: (),
}
impl SetDesiredCapacity {
    /// Creates a new builder-style object to manufacture [`SetDesiredCapacityInput`](crate::input::SetDesiredCapacityInput)
    pub fn builder() -> crate::input::set_desired_capacity_input::Builder {
        crate::input::set_desired_capacity_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetDesiredCapacity {
    type Output = std::result::Result<
        crate::output::SetDesiredCapacityOutput,
        crate::error::SetDesiredCapacityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_desired_capacity_error(response)
        } else {
            crate::operation_deser::parse_set_desired_capacity_response(response)
        }
    }
}

/// <p>Sets the health status of the specified instance.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/healthcheck.html">Health checks for Auto Scaling
/// instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetInstanceHealth {
    _private: (),
}
impl SetInstanceHealth {
    /// Creates a new builder-style object to manufacture [`SetInstanceHealthInput`](crate::input::SetInstanceHealthInput)
    pub fn builder() -> crate::input::set_instance_health_input::Builder {
        crate::input::set_instance_health_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetInstanceHealth {
    type Output = std::result::Result<
        crate::output::SetInstanceHealthOutput,
        crate::error::SetInstanceHealthError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_instance_health_error(response)
        } else {
            crate::operation_deser::parse_set_instance_health_response(response)
        }
    }
}

/// <p>Updates the instance protection settings of the specified instances. This operation
/// cannot be called on instances in a warm pool.</p>
/// <p>For more information about preventing instances that are part of an Auto Scaling group from
/// terminating on scale in, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html#instance-protection">Instance scale-in protection</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>If you exceed your maximum limit of instance IDs, which is 50 per Auto Scaling group, the call
/// fails.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetInstanceProtection {
    _private: (),
}
impl SetInstanceProtection {
    /// Creates a new builder-style object to manufacture [`SetInstanceProtectionInput`](crate::input::SetInstanceProtectionInput)
    pub fn builder() -> crate::input::set_instance_protection_input::Builder {
        crate::input::set_instance_protection_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetInstanceProtection {
    type Output = std::result::Result<
        crate::output::SetInstanceProtectionOutput,
        crate::error::SetInstanceProtectionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_instance_protection_error(response)
        } else {
            crate::operation_deser::parse_set_instance_protection_response(response)
        }
    }
}

/// <p>Starts a new instance refresh operation. An instance refresh performs a rolling
/// replacement of all or some instances in an Auto Scaling group. Each instance is terminated first
/// and then replaced, which temporarily reduces the capacity available within your Auto Scaling
/// group.</p>
/// <p>This operation is part of the <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-refresh.html">instance refresh
/// feature</a> in Amazon EC2 Auto Scaling, which helps you update instances in your Auto Scaling group.
/// This feature is helpful, for example, when you have a new AMI or a new user data script.
/// You just need to create a new launch template that specifies the new AMI or user data
/// script. Then start an instance refresh to immediately begin the process of updating
/// instances in the group. </p>
/// <p>If the call succeeds, it creates a new instance refresh request with a unique ID that
/// you can use to track its progress. To query its status, call the <a>DescribeInstanceRefreshes</a> API. To describe the instance refreshes that
/// have already run, call the <a>DescribeInstanceRefreshes</a> API. To cancel an
/// instance refresh operation in progress, use the <a>CancelInstanceRefresh</a>
/// API. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartInstanceRefresh {
    _private: (),
}
impl StartInstanceRefresh {
    /// Creates a new builder-style object to manufacture [`StartInstanceRefreshInput`](crate::input::StartInstanceRefreshInput)
    pub fn builder() -> crate::input::start_instance_refresh_input::Builder {
        crate::input::start_instance_refresh_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartInstanceRefresh {
    type Output = std::result::Result<
        crate::output::StartInstanceRefreshOutput,
        crate::error::StartInstanceRefreshError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_instance_refresh_error(response)
        } else {
            crate::operation_deser::parse_start_instance_refresh_response(response)
        }
    }
}

/// <p>Suspends the specified auto scaling processes, or all processes, for the specified
/// Auto Scaling group.</p>
/// <p>If you suspend either the <code>Launch</code> or <code>Terminate</code> process types,
/// it can prevent other process types from functioning properly. For more information, see
/// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html">Suspending and
/// resuming scaling processes</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
/// <p>To resume processes that have been suspended, call the <a>ResumeProcesses</a> API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SuspendProcesses {
    _private: (),
}
impl SuspendProcesses {
    /// Creates a new builder-style object to manufacture [`SuspendProcessesInput`](crate::input::SuspendProcessesInput)
    pub fn builder() -> crate::input::suspend_processes_input::Builder {
        crate::input::suspend_processes_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SuspendProcesses {
    type Output = std::result::Result<
        crate::output::SuspendProcessesOutput,
        crate::error::SuspendProcessesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_suspend_processes_error(response)
        } else {
            crate::operation_deser::parse_suspend_processes_response(response)
        }
    }
}

/// <p>Terminates the specified instance and optionally adjusts the desired group size. This
/// operation cannot be called on instances in a warm pool.</p>
/// <p>This call simply makes a termination request. The instance is not terminated
/// immediately. When an instance is terminated, the instance status changes to
/// <code>terminated</code>. You can't connect to or start an instance after you've
/// terminated it.</p>
/// <p>If you do not specify the option to decrement the desired capacity, Amazon EC2 Auto Scaling launches
/// instances to replace the ones that are terminated. </p>
/// <p>By default, Amazon EC2 Auto Scaling balances instances across all Availability Zones. If you
/// decrement the desired capacity, your Auto Scaling group can become unbalanced between
/// Availability Zones. Amazon EC2 Auto Scaling tries to rebalance the group, and rebalancing might
/// terminate instances in other zones. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-benefits.html#AutoScalingBehavior.InstanceUsage">Rebalancing activities</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TerminateInstanceInAutoScalingGroup {
    _private: (),
}
impl TerminateInstanceInAutoScalingGroup {
    /// Creates a new builder-style object to manufacture [`TerminateInstanceInAutoScalingGroupInput`](crate::input::TerminateInstanceInAutoScalingGroupInput)
    pub fn builder() -> crate::input::terminate_instance_in_auto_scaling_group_input::Builder {
        crate::input::terminate_instance_in_auto_scaling_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TerminateInstanceInAutoScalingGroup {
    type Output = std::result::Result<
        crate::output::TerminateInstanceInAutoScalingGroupOutput,
        crate::error::TerminateInstanceInAutoScalingGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_terminate_instance_in_auto_scaling_group_error(response)
        } else {
            crate::operation_deser::parse_terminate_instance_in_auto_scaling_group_response(
                response,
            )
        }
    }
}

/// <p>
/// <b>We strongly recommend that all Auto Scaling groups use launch templates to ensure full functionality for Amazon EC2 Auto Scaling and Amazon EC2.</b>
/// </p>
/// <p>Updates the configuration for
/// the specified Auto Scaling group.</p>
/// <p>To update an Auto Scaling group, specify the name of the group and the parameter that you want
/// to change. Any parameters that you don't specify are not changed by this update request.
/// The new settings take effect on any scaling activities after this call returns.
/// </p>
/// <p>If you associate a new launch configuration or template with an Auto Scaling group, all new
/// instances will get the updated configuration. Existing instances continue to run with
/// the configuration that they were originally launched with. When you update a group to
/// specify a mixed instances policy instead of a launch configuration or template, existing
/// instances may be replaced to match the new purchasing options that you specified in the
/// policy. For example, if the group currently has 100% On-Demand capacity and the policy
/// specifies 50% Spot capacity, this means that half of your instances will be gradually
/// terminated and relaunched as Spot Instances. When replacing instances, Amazon EC2 Auto Scaling launches
/// new instances before terminating the old ones, so that updating your group does not
/// compromise the performance or availability of your application.</p>
/// <p>Note the following about changing <code>DesiredCapacity</code>, <code>MaxSize</code>,
/// or <code>MinSize</code>:</p>
/// <ul>
/// <li>
/// <p>If a scale-in activity occurs as a result of a new
/// <code>DesiredCapacity</code> value that is lower than the current size of
/// the group, the Auto Scaling group uses its termination policy to determine which
/// instances to terminate.</p>
/// </li>
/// <li>
/// <p>If you specify a new value for <code>MinSize</code> without specifying a value
/// for <code>DesiredCapacity</code>, and the new <code>MinSize</code> is larger
/// than the current size of the group, this sets the group's
/// <code>DesiredCapacity</code> to the new <code>MinSize</code> value.</p>
/// </li>
/// <li>
/// <p>If you specify a new value for <code>MaxSize</code> without specifying a value
/// for <code>DesiredCapacity</code>, and the new <code>MaxSize</code> is smaller
/// than the current size of the group, this sets the group's
/// <code>DesiredCapacity</code> to the new <code>MaxSize</code> value.</p>
/// </li>
/// </ul>
/// <p>To see which parameters have been set, call the <a>DescribeAutoScalingGroups</a> API. To view the scaling policies for an Auto Scaling
/// group, call the <a>DescribePolicies</a> API. If the group has scaling
/// policies, you can update them by calling the <a>PutScalingPolicy</a>
/// API.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateAutoScalingGroup {
    _private: (),
}
impl UpdateAutoScalingGroup {
    /// Creates a new builder-style object to manufacture [`UpdateAutoScalingGroupInput`](crate::input::UpdateAutoScalingGroupInput)
    pub fn builder() -> crate::input::update_auto_scaling_group_input::Builder {
        crate::input::update_auto_scaling_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateAutoScalingGroup {
    type Output = std::result::Result<
        crate::output::UpdateAutoScalingGroupOutput,
        crate::error::UpdateAutoScalingGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_auto_scaling_group_error(response)
        } else {
            crate::operation_deser::parse_update_auto_scaling_group_response(response)
        }
    }
}
