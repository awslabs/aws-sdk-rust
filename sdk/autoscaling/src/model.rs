// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Describes a mixed instances policy for an Auto Scaling group. With mixed instances, your Auto Scaling
/// group can provision a combination of On-Demand Instances and Spot Instances across
/// multiple instance types. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-purchase-options.html">Auto Scaling groups with multiple
/// instance types and purchase options</a> in the <i>Amazon EC2 Auto Scaling User
/// Guide</i>.</p>
/// <p>You can create a mixed instances policy for a new Auto Scaling group, or you can create it for
/// an existing group by updating the group to specify <code>MixedInstancesPolicy</code> as
/// the top-level property instead of a launch configuration or launch template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MixedInstancesPolicy {
    /// <p>Specifies the launch template to use and optionally the instance types (overrides)
    /// that are used to provision EC2 instances to fulfill On-Demand and Spot capacities.
    /// Required when creating a mixed instances policy.</p>
    pub launch_template: std::option::Option<crate::model::LaunchTemplate>,
    /// <p>Specifies the instances distribution. If not provided, the value for each property in
    /// <code>InstancesDistribution</code> uses a default value.</p>
    pub instances_distribution: std::option::Option<crate::model::InstancesDistribution>,
}
impl std::fmt::Debug for MixedInstancesPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MixedInstancesPolicy");
        formatter.field("launch_template", &self.launch_template);
        formatter.field("instances_distribution", &self.instances_distribution);
        formatter.finish()
    }
}
/// See [`MixedInstancesPolicy`](crate::model::MixedInstancesPolicy)
pub mod mixed_instances_policy {
    /// A builder for [`MixedInstancesPolicy`](crate::model::MixedInstancesPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template: std::option::Option<crate::model::LaunchTemplate>,
        pub(crate) instances_distribution: std::option::Option<crate::model::InstancesDistribution>,
    }
    impl Builder {
        /// <p>Specifies the launch template to use and optionally the instance types (overrides)
        /// that are used to provision EC2 instances to fulfill On-Demand and Spot capacities.
        /// Required when creating a mixed instances policy.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplate) -> Self {
            self.launch_template = Some(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplate>,
        ) -> Self {
            self.launch_template = input;
            self
        }
        /// <p>Specifies the instances distribution. If not provided, the value for each property in
        /// <code>InstancesDistribution</code> uses a default value.</p>
        pub fn instances_distribution(
            mut self,
            input: crate::model::InstancesDistribution,
        ) -> Self {
            self.instances_distribution = Some(input);
            self
        }
        pub fn set_instances_distribution(
            mut self,
            input: std::option::Option<crate::model::InstancesDistribution>,
        ) -> Self {
            self.instances_distribution = input;
            self
        }
        /// Consumes the builder and constructs a [`MixedInstancesPolicy`](crate::model::MixedInstancesPolicy)
        pub fn build(self) -> crate::model::MixedInstancesPolicy {
            crate::model::MixedInstancesPolicy {
                launch_template: self.launch_template,
                instances_distribution: self.instances_distribution,
            }
        }
    }
}
impl MixedInstancesPolicy {
    /// Creates a new builder-style object to manufacture [`MixedInstancesPolicy`](crate::model::MixedInstancesPolicy)
    pub fn builder() -> crate::model::mixed_instances_policy::Builder {
        crate::model::mixed_instances_policy::Builder::default()
    }
}

/// <p>Describes an instances distribution for an Auto Scaling group with a <a>MixedInstancesPolicy</a>.</p>
/// <p>The instances distribution specifies the distribution of On-Demand Instances and Spot
/// Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates
/// instance types to fulfill On-Demand and Spot capacities.</p>
/// <p>When you update <code>SpotAllocationStrategy</code>, <code>SpotInstancePools</code>,
/// or <code>SpotMaxPrice</code>, this update action does not deploy any changes across the
/// running Amazon EC2 instances in the group. Your existing Spot Instances continue to run
/// as long as the maximum price for those instances is higher than the current Spot price.
/// When scale out occurs, Amazon EC2 Auto Scaling launches instances based on the new settings. When scale
/// in occurs, Amazon EC2 Auto Scaling terminates instances according to the group's termination
/// policies.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstancesDistribution {
    /// <p>Indicates how to allocate instance types to fulfill On-Demand capacity. The only valid
    /// value is <code>prioritized</code>, which is also the default value. This strategy uses
    /// the order of instance types in the <code>LaunchTemplateOverrides</code> to define the
    /// launch priority of each instance type. The first instance type in the array is
    /// prioritized higher than the last. If all your On-Demand capacity cannot be fulfilled
    /// using your highest priority instance, then the Auto Scaling groups launches the remaining
    /// capacity using the second priority instance type, and so on.</p>
    pub on_demand_allocation_strategy: std::option::Option<std::string::String>,
    /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand
    /// Instances. This base portion is provisioned first as your group scales. Defaults to 0 if
    /// not specified. If you specify weights for the instance types in the overrides, set the
    /// value of <code>OnDemandBaseCapacity</code> in terms of the number of capacity units, and
    /// not the number of instances.</p>
    pub on_demand_base_capacity: std::option::Option<i32>,
    /// <p>Controls the percentages of On-Demand Instances and Spot Instances for your additional
    /// capacity beyond <code>OnDemandBaseCapacity</code>. Expressed as a number (for example,
    /// 20 specifies 20% On-Demand Instances, 80% Spot Instances). Defaults to 100 if not
    /// specified. If set to 100, only On-Demand Instances are provisioned.</p>
    pub on_demand_percentage_above_base_capacity: std::option::Option<i32>,
    /// <p>Indicates how to allocate instances across Spot Instance pools. </p>
    /// <p>If the allocation strategy is <code>lowest-price</code>, the Auto Scaling group launches
    /// instances using the Spot pools with the lowest price, and evenly allocates your
    /// instances across the number of Spot pools that you specify. Defaults to
    /// <code>lowest-price</code> if not specified.</p>
    /// <p>If the allocation strategy is <code>capacity-optimized</code> (recommended), the Auto Scaling
    /// group launches instances using Spot pools that are optimally chosen based on the
    /// available Spot capacity. Alternatively, you can use
    /// <code>capacity-optimized-prioritized</code> and set the order of instance types in
    /// the list of launch template overrides from highest to lowest priority (from first to
    /// last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best-effort basis
    /// but optimizes for capacity first. </p>
    pub spot_allocation_strategy: std::option::Option<std::string::String>,
    /// <p>The number of Spot Instance pools across which to allocate your Spot Instances. The
    /// Spot pools are determined from the different instance types in the overrides. Valid only
    /// when the Spot allocation strategy is <code>lowest-price</code>. Value must be in the
    /// range of 1 to 20. Defaults to 2 if not specified.</p>
    pub spot_instance_pools: std::option::Option<i32>,
    /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If
    /// you leave the value at its default (empty), Amazon EC2 Auto Scaling uses the On-Demand price as the
    /// maximum Spot price. To remove a value that you previously set, include the property but
    /// specify an empty string ("") for the value.</p>
    pub spot_max_price: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InstancesDistribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstancesDistribution");
        formatter.field(
            "on_demand_allocation_strategy",
            &self.on_demand_allocation_strategy,
        );
        formatter.field("on_demand_base_capacity", &self.on_demand_base_capacity);
        formatter.field(
            "on_demand_percentage_above_base_capacity",
            &self.on_demand_percentage_above_base_capacity,
        );
        formatter.field("spot_allocation_strategy", &self.spot_allocation_strategy);
        formatter.field("spot_instance_pools", &self.spot_instance_pools);
        formatter.field("spot_max_price", &self.spot_max_price);
        formatter.finish()
    }
}
/// See [`InstancesDistribution`](crate::model::InstancesDistribution)
pub mod instances_distribution {
    /// A builder for [`InstancesDistribution`](crate::model::InstancesDistribution)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) on_demand_allocation_strategy: std::option::Option<std::string::String>,
        pub(crate) on_demand_base_capacity: std::option::Option<i32>,
        pub(crate) on_demand_percentage_above_base_capacity: std::option::Option<i32>,
        pub(crate) spot_allocation_strategy: std::option::Option<std::string::String>,
        pub(crate) spot_instance_pools: std::option::Option<i32>,
        pub(crate) spot_max_price: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates how to allocate instance types to fulfill On-Demand capacity. The only valid
        /// value is <code>prioritized</code>, which is also the default value. This strategy uses
        /// the order of instance types in the <code>LaunchTemplateOverrides</code> to define the
        /// launch priority of each instance type. The first instance type in the array is
        /// prioritized higher than the last. If all your On-Demand capacity cannot be fulfilled
        /// using your highest priority instance, then the Auto Scaling groups launches the remaining
        /// capacity using the second priority instance type, and so on.</p>
        pub fn on_demand_allocation_strategy(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.on_demand_allocation_strategy = Some(input.into());
            self
        }
        pub fn set_on_demand_allocation_strategy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.on_demand_allocation_strategy = input;
            self
        }
        /// <p>The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand
        /// Instances. This base portion is provisioned first as your group scales. Defaults to 0 if
        /// not specified. If you specify weights for the instance types in the overrides, set the
        /// value of <code>OnDemandBaseCapacity</code> in terms of the number of capacity units, and
        /// not the number of instances.</p>
        pub fn on_demand_base_capacity(mut self, input: i32) -> Self {
            self.on_demand_base_capacity = Some(input);
            self
        }
        pub fn set_on_demand_base_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.on_demand_base_capacity = input;
            self
        }
        /// <p>Controls the percentages of On-Demand Instances and Spot Instances for your additional
        /// capacity beyond <code>OnDemandBaseCapacity</code>. Expressed as a number (for example,
        /// 20 specifies 20% On-Demand Instances, 80% Spot Instances). Defaults to 100 if not
        /// specified. If set to 100, only On-Demand Instances are provisioned.</p>
        pub fn on_demand_percentage_above_base_capacity(mut self, input: i32) -> Self {
            self.on_demand_percentage_above_base_capacity = Some(input);
            self
        }
        pub fn set_on_demand_percentage_above_base_capacity(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.on_demand_percentage_above_base_capacity = input;
            self
        }
        /// <p>Indicates how to allocate instances across Spot Instance pools. </p>
        /// <p>If the allocation strategy is <code>lowest-price</code>, the Auto Scaling group launches
        /// instances using the Spot pools with the lowest price, and evenly allocates your
        /// instances across the number of Spot pools that you specify. Defaults to
        /// <code>lowest-price</code> if not specified.</p>
        /// <p>If the allocation strategy is <code>capacity-optimized</code> (recommended), the Auto Scaling
        /// group launches instances using Spot pools that are optimally chosen based on the
        /// available Spot capacity. Alternatively, you can use
        /// <code>capacity-optimized-prioritized</code> and set the order of instance types in
        /// the list of launch template overrides from highest to lowest priority (from first to
        /// last in the list). Amazon EC2 Auto Scaling honors the instance type priorities on a best-effort basis
        /// but optimizes for capacity first. </p>
        pub fn spot_allocation_strategy(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_allocation_strategy = Some(input.into());
            self
        }
        pub fn set_spot_allocation_strategy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_allocation_strategy = input;
            self
        }
        /// <p>The number of Spot Instance pools across which to allocate your Spot Instances. The
        /// Spot pools are determined from the different instance types in the overrides. Valid only
        /// when the Spot allocation strategy is <code>lowest-price</code>. Value must be in the
        /// range of 1 to 20. Defaults to 2 if not specified.</p>
        pub fn spot_instance_pools(mut self, input: i32) -> Self {
            self.spot_instance_pools = Some(input);
            self
        }
        pub fn set_spot_instance_pools(mut self, input: std::option::Option<i32>) -> Self {
            self.spot_instance_pools = input;
            self
        }
        /// <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If
        /// you leave the value at its default (empty), Amazon EC2 Auto Scaling uses the On-Demand price as the
        /// maximum Spot price. To remove a value that you previously set, include the property but
        /// specify an empty string ("") for the value.</p>
        pub fn spot_max_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_max_price = Some(input.into());
            self
        }
        pub fn set_spot_max_price(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spot_max_price = input;
            self
        }
        /// Consumes the builder and constructs a [`InstancesDistribution`](crate::model::InstancesDistribution)
        pub fn build(self) -> crate::model::InstancesDistribution {
            crate::model::InstancesDistribution {
                on_demand_allocation_strategy: self.on_demand_allocation_strategy,
                on_demand_base_capacity: self.on_demand_base_capacity,
                on_demand_percentage_above_base_capacity: self
                    .on_demand_percentage_above_base_capacity,
                spot_allocation_strategy: self.spot_allocation_strategy,
                spot_instance_pools: self.spot_instance_pools,
                spot_max_price: self.spot_max_price,
            }
        }
    }
}
impl InstancesDistribution {
    /// Creates a new builder-style object to manufacture [`InstancesDistribution`](crate::model::InstancesDistribution)
    pub fn builder() -> crate::model::instances_distribution::Builder {
        crate::model::instances_distribution::Builder::default()
    }
}

/// <p>Describes a launch template and overrides. </p>
/// <p>You specify these properties as part of a mixed instances policy. </p>
/// <p>When you update the launch template or overrides, existing Amazon EC2 instances continue to
/// run. When scale out occurs, Amazon EC2 Auto Scaling launches instances to match the new settings. When
/// scale in occurs, Amazon EC2 Auto Scaling terminates instances according to the group's termination
/// policies.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplate {
    /// <p>The launch template to use.</p>
    pub launch_template_specification:
        std::option::Option<crate::model::LaunchTemplateSpecification>,
    /// <p>Any properties that you specify override the same properties in the launch template.
    /// If not provided, Amazon EC2 Auto Scaling uses the instance type specified in the launch template when
    /// it launches an instance. </p>
    pub overrides: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateOverrides>>,
}
impl std::fmt::Debug for LaunchTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplate");
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.field("overrides", &self.overrides);
        formatter.finish()
    }
}
/// See [`LaunchTemplate`](crate::model::LaunchTemplate)
pub mod launch_template {
    /// A builder for [`LaunchTemplate`](crate::model::LaunchTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_specification:
            std::option::Option<crate::model::LaunchTemplateSpecification>,
        pub(crate) overrides:
            std::option::Option<std::vec::Vec<crate::model::LaunchTemplateOverrides>>,
    }
    impl Builder {
        /// <p>The launch template to use.</p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::LaunchTemplateSpecification,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        pub fn overrides(
            mut self,
            input: impl Into<crate::model::LaunchTemplateOverrides>,
        ) -> Self {
            let mut v = self.overrides.unwrap_or_default();
            v.push(input.into());
            self.overrides = Some(v);
            self
        }
        pub fn set_overrides(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LaunchTemplateOverrides>>,
        ) -> Self {
            self.overrides = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplate`](crate::model::LaunchTemplate)
        pub fn build(self) -> crate::model::LaunchTemplate {
            crate::model::LaunchTemplate {
                launch_template_specification: self.launch_template_specification,
                overrides: self.overrides,
            }
        }
    }
}
impl LaunchTemplate {
    /// Creates a new builder-style object to manufacture [`LaunchTemplate`](crate::model::LaunchTemplate)
    pub fn builder() -> crate::model::launch_template::Builder {
        crate::model::launch_template::Builder::default()
    }
}

/// <p>Describes an override for a launch template. The maximum number of instance types that
/// can be associated with an Auto Scaling group is 40. The maximum number of distinct launch
/// templates you can define for an Auto Scaling group is 20. For more information about configuring
/// overrides, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-override-options.html">Configuring
/// overrides</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateOverrides {
    /// <p>The instance type, such as <code>m3.xlarge</code>. You must use an instance type that
    /// is supported in your requested Region and Availability Zones. For more information, see
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon Elastic Compute Cloud User
    /// Guide</i>.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The number of capacity units provided by the specified instance type in terms of
    /// virtual CPUs, memory, storage, throughput, or other relative performance characteristic.
    /// When a Spot or On-Demand Instance is provisioned, the capacity units count toward the
    /// desired capacity. Amazon EC2 Auto Scaling provisions instances until the desired capacity is totally
    /// fulfilled, even if this results in an overage. For example, if there are 2 units
    /// remaining to fulfill capacity, and Amazon EC2 Auto Scaling can only provision an instance with a
    /// <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the
    /// desired capacity is exceeded by 3 units. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-weighting.html">Instance weighting for Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.
    /// Value must be in the range of 1 to 999.</p>
    pub weighted_capacity: std::option::Option<std::string::String>,
    /// <p>Provides the launch template to be used when launching the instance type. For example,
    /// some instance types might require a launch template with a different AMI. If not
    /// provided, Amazon EC2 Auto Scaling uses the launch template that's defined for your mixed instances
    /// policy. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-launch-template-overrides.html">Specifying a
    /// different launch template for an instance type</a> in the
    /// <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
    pub launch_template_specification:
        std::option::Option<crate::model::LaunchTemplateSpecification>,
}
impl std::fmt::Debug for LaunchTemplateOverrides {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateOverrides");
        formatter.field("instance_type", &self.instance_type);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.field(
            "launch_template_specification",
            &self.launch_template_specification,
        );
        formatter.finish()
    }
}
/// See [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
pub mod launch_template_overrides {
    /// A builder for [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) weighted_capacity: std::option::Option<std::string::String>,
        pub(crate) launch_template_specification:
            std::option::Option<crate::model::LaunchTemplateSpecification>,
    }
    impl Builder {
        /// <p>The instance type, such as <code>m3.xlarge</code>. You must use an instance type that
        /// is supported in your requested Region and Availability Zones. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance types</a> in the <i>Amazon Elastic Compute Cloud User
        /// Guide</i>.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The number of capacity units provided by the specified instance type in terms of
        /// virtual CPUs, memory, storage, throughput, or other relative performance characteristic.
        /// When a Spot or On-Demand Instance is provisioned, the capacity units count toward the
        /// desired capacity. Amazon EC2 Auto Scaling provisions instances until the desired capacity is totally
        /// fulfilled, even if this results in an overage. For example, if there are 2 units
        /// remaining to fulfill capacity, and Amazon EC2 Auto Scaling can only provision an instance with a
        /// <code>WeightedCapacity</code> of 5 units, the instance is provisioned, and the
        /// desired capacity is exceeded by 3 units. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-instance-weighting.html">Instance weighting for Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.
        /// Value must be in the range of 1 to 999.</p>
        pub fn weighted_capacity(mut self, input: impl Into<std::string::String>) -> Self {
            self.weighted_capacity = Some(input.into());
            self
        }
        pub fn set_weighted_capacity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// <p>Provides the launch template to be used when launching the instance type. For example,
        /// some instance types might require a launch template with a different AMI. If not
        /// provided, Amazon EC2 Auto Scaling uses the launch template that's defined for your mixed instances
        /// policy. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-launch-template-overrides.html">Specifying a
        /// different launch template for an instance type</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
        pub fn launch_template_specification(
            mut self,
            input: crate::model::LaunchTemplateSpecification,
        ) -> Self {
            self.launch_template_specification = Some(input);
            self
        }
        pub fn set_launch_template_specification(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template_specification = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
        pub fn build(self) -> crate::model::LaunchTemplateOverrides {
            crate::model::LaunchTemplateOverrides {
                instance_type: self.instance_type,
                weighted_capacity: self.weighted_capacity,
                launch_template_specification: self.launch_template_specification,
            }
        }
    }
}
impl LaunchTemplateOverrides {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateOverrides`](crate::model::LaunchTemplateOverrides)
    pub fn builder() -> crate::model::launch_template_overrides::Builder {
        crate::model::launch_template_overrides::Builder::default()
    }
}

/// <p>Describes the Amazon EC2 launch template and the launch template version that can be used
/// by an Auto Scaling group to configure Amazon EC2 instances.</p>
/// <p>The launch template that is specified must be configured for use with an Auto Scaling group.
/// For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html">Creating a launch
/// template for an Auto Scaling group</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchTemplateSpecification {
    /// <p>The ID of the launch template. To get the template ID, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html">DescribeLaunchTemplates</a> API operation. New launch templates can be created
    /// using the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html">CreateLaunchTemplate</a> API. </p>
    /// <p>Conditional: You must specify either a <code>LaunchTemplateId</code> or a
    /// <code>LaunchTemplateName</code>.</p>
    pub launch_template_id: std::option::Option<std::string::String>,
    /// <p>The name of the launch template. To get the template name, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html">DescribeLaunchTemplates</a> API operation. New launch templates can be created
    /// using the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html">CreateLaunchTemplate</a> API. </p>
    /// <p>Conditional: You must specify either a <code>LaunchTemplateId</code> or a
    /// <code>LaunchTemplateName</code>.</p>
    pub launch_template_name: std::option::Option<std::string::String>,
    /// <p>The version number, <code>$Latest</code>, or <code>$Default</code>. To get the version
    /// number, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplateVersions.html">DescribeLaunchTemplateVersions</a> API operation. New launch template versions
    /// can be created using the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplateVersion.html">CreateLaunchTemplateVersion</a> API. If the value is <code>$Latest</code>,
    /// Amazon EC2 Auto Scaling selects the latest version of the launch template when launching instances. If
    /// the value is <code>$Default</code>, Amazon EC2 Auto Scaling selects the default version of the launch
    /// template when launching instances. The default value is <code>$Default</code>.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchTemplateSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchTemplateSpecification");
        formatter.field("launch_template_id", &self.launch_template_id);
        formatter.field("launch_template_name", &self.launch_template_name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
pub mod launch_template_specification {
    /// A builder for [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_template_id: std::option::Option<std::string::String>,
        pub(crate) launch_template_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the launch template. To get the template ID, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html">DescribeLaunchTemplates</a> API operation. New launch templates can be created
        /// using the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html">CreateLaunchTemplate</a> API. </p>
        /// <p>Conditional: You must specify either a <code>LaunchTemplateId</code> or a
        /// <code>LaunchTemplateName</code>.</p>
        pub fn launch_template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_id = Some(input.into());
            self
        }
        pub fn set_launch_template_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_id = input;
            self
        }
        /// <p>The name of the launch template. To get the template name, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplates.html">DescribeLaunchTemplates</a> API operation. New launch templates can be created
        /// using the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplate.html">CreateLaunchTemplate</a> API. </p>
        /// <p>Conditional: You must specify either a <code>LaunchTemplateId</code> or a
        /// <code>LaunchTemplateName</code>.</p>
        pub fn launch_template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_template_name = Some(input.into());
            self
        }
        pub fn set_launch_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_template_name = input;
            self
        }
        /// <p>The version number, <code>$Latest</code>, or <code>$Default</code>. To get the version
        /// number, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeLaunchTemplateVersions.html">DescribeLaunchTemplateVersions</a> API operation. New launch template versions
        /// can be created using the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateLaunchTemplateVersion.html">CreateLaunchTemplateVersion</a> API. If the value is <code>$Latest</code>,
        /// Amazon EC2 Auto Scaling selects the latest version of the launch template when launching instances. If
        /// the value is <code>$Default</code>, Amazon EC2 Auto Scaling selects the default version of the launch
        /// template when launching instances. The default value is <code>$Default</code>.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
        pub fn build(self) -> crate::model::LaunchTemplateSpecification {
            crate::model::LaunchTemplateSpecification {
                launch_template_id: self.launch_template_id,
                launch_template_name: self.launch_template_name,
                version: self.version,
            }
        }
    }
}
impl LaunchTemplateSpecification {
    /// Creates a new builder-style object to manufacture [`LaunchTemplateSpecification`](crate::model::LaunchTemplateSpecification)
    pub fn builder() -> crate::model::launch_template_specification::Builder {
        crate::model::launch_template_specification::Builder::default()
    }
}

/// <p>Describes scaling activity, which is a long-running process that represents a change
/// to your Auto Scaling group, such as changing its size or replacing an instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Activity {
    /// <p>The ID of the activity.</p>
    pub activity_id: std::option::Option<std::string::String>,
    /// <p>The name of the Auto Scaling group.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>A friendly, more verbose description of the activity.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The reason the activity began.</p>
    pub cause: std::option::Option<std::string::String>,
    /// <p>The start time of the activity.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The end time of the activity.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The current status of the activity.</p>
    pub status_code: std::option::Option<crate::model::ScalingActivityStatusCode>,
    /// <p>A friendly, more verbose description of the activity status.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>A value between 0 and 100 that indicates the progress of the activity.</p>
    pub progress: i32,
    /// <p>The details about the activity.</p>
    pub details: std::option::Option<std::string::String>,
    /// <p>The state of the Auto Scaling group, which is either <code>InService</code> or
    /// <code>Deleted</code>.</p>
    pub auto_scaling_group_state: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
    pub auto_scaling_group_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Activity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Activity");
        formatter.field("activity_id", &self.activity_id);
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("description", &self.description);
        formatter.field("cause", &self.cause);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("progress", &self.progress);
        formatter.field("details", &self.details);
        formatter.field("auto_scaling_group_state", &self.auto_scaling_group_state);
        formatter.field("auto_scaling_group_arn", &self.auto_scaling_group_arn);
        formatter.finish()
    }
}
/// See [`Activity`](crate::model::Activity)
pub mod activity {
    /// A builder for [`Activity`](crate::model::Activity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activity_id: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) cause: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) status_code: std::option::Option<crate::model::ScalingActivityStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) progress: std::option::Option<i32>,
        pub(crate) details: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_state: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the activity.</p>
        pub fn activity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.activity_id = Some(input.into());
            self
        }
        pub fn set_activity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.activity_id = input;
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>A friendly, more verbose description of the activity.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The reason the activity began.</p>
        pub fn cause(mut self, input: impl Into<std::string::String>) -> Self {
            self.cause = Some(input.into());
            self
        }
        pub fn set_cause(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cause = input;
            self
        }
        /// <p>The start time of the activity.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The end time of the activity.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The current status of the activity.</p>
        pub fn status_code(mut self, input: crate::model::ScalingActivityStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::ScalingActivityStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>A friendly, more verbose description of the activity status.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>A value between 0 and 100 that indicates the progress of the activity.</p>
        pub fn progress(mut self, input: i32) -> Self {
            self.progress = Some(input);
            self
        }
        pub fn set_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.progress = input;
            self
        }
        /// <p>The details about the activity.</p>
        pub fn details(mut self, input: impl Into<std::string::String>) -> Self {
            self.details = Some(input.into());
            self
        }
        pub fn set_details(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.details = input;
            self
        }
        /// <p>The state of the Auto Scaling group, which is either <code>InService</code> or
        /// <code>Deleted</code>.</p>
        pub fn auto_scaling_group_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_state = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_state = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
        pub fn auto_scaling_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_arn = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Activity`](crate::model::Activity)
        pub fn build(self) -> crate::model::Activity {
            crate::model::Activity {
                activity_id: self.activity_id,
                auto_scaling_group_name: self.auto_scaling_group_name,
                description: self.description,
                cause: self.cause,
                start_time: self.start_time,
                end_time: self.end_time,
                status_code: self.status_code,
                status_message: self.status_message,
                progress: self.progress.unwrap_or_default(),
                details: self.details,
                auto_scaling_group_state: self.auto_scaling_group_state,
                auto_scaling_group_arn: self.auto_scaling_group_arn,
            }
        }
    }
}
impl Activity {
    /// Creates a new builder-style object to manufacture [`Activity`](crate::model::Activity)
    pub fn builder() -> crate::model::activity::Builder {
        crate::model::activity::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScalingActivityStatusCode {
    Cancelled,
    Failed,
    InProgress,
    MidLifecycleAction,
    PendingSpotBidPlacement,
    PreInService,
    Successful,
    WaitingForElbConnectionDraining,
    WaitingForInstanceId,
    WaitingForInstanceWarmup,
    WaitingForSpotInstanceId,
    WaitingForSpotInstanceRequestId,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScalingActivityStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => ScalingActivityStatusCode::Cancelled,
            "Failed" => ScalingActivityStatusCode::Failed,
            "InProgress" => ScalingActivityStatusCode::InProgress,
            "MidLifecycleAction" => ScalingActivityStatusCode::MidLifecycleAction,
            "PendingSpotBidPlacement" => ScalingActivityStatusCode::PendingSpotBidPlacement,
            "PreInService" => ScalingActivityStatusCode::PreInService,
            "Successful" => ScalingActivityStatusCode::Successful,
            "WaitingForELBConnectionDraining" => {
                ScalingActivityStatusCode::WaitingForElbConnectionDraining
            }
            "WaitingForInstanceId" => ScalingActivityStatusCode::WaitingForInstanceId,
            "WaitingForInstanceWarmup" => ScalingActivityStatusCode::WaitingForInstanceWarmup,
            "WaitingForSpotInstanceId" => ScalingActivityStatusCode::WaitingForSpotInstanceId,
            "WaitingForSpotInstanceRequestId" => {
                ScalingActivityStatusCode::WaitingForSpotInstanceRequestId
            }
            other => ScalingActivityStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScalingActivityStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScalingActivityStatusCode::from(s))
    }
}
impl ScalingActivityStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            ScalingActivityStatusCode::Cancelled => "Cancelled",
            ScalingActivityStatusCode::Failed => "Failed",
            ScalingActivityStatusCode::InProgress => "InProgress",
            ScalingActivityStatusCode::MidLifecycleAction => "MidLifecycleAction",
            ScalingActivityStatusCode::PendingSpotBidPlacement => "PendingSpotBidPlacement",
            ScalingActivityStatusCode::PreInService => "PreInService",
            ScalingActivityStatusCode::Successful => "Successful",
            ScalingActivityStatusCode::WaitingForElbConnectionDraining => {
                "WaitingForELBConnectionDraining"
            }
            ScalingActivityStatusCode::WaitingForInstanceId => "WaitingForInstanceId",
            ScalingActivityStatusCode::WaitingForInstanceWarmup => "WaitingForInstanceWarmup",
            ScalingActivityStatusCode::WaitingForSpotInstanceId => "WaitingForSpotInstanceId",
            ScalingActivityStatusCode::WaitingForSpotInstanceRequestId => {
                "WaitingForSpotInstanceRequestId"
            }
            ScalingActivityStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Cancelled",
            "Failed",
            "InProgress",
            "MidLifecycleAction",
            "PendingSpotBidPlacement",
            "PreInService",
            "Successful",
            "WaitingForELBConnectionDraining",
            "WaitingForInstanceId",
            "WaitingForInstanceWarmup",
            "WaitingForSpotInstanceId",
            "WaitingForSpotInstanceRequestId",
        ]
    }
}
impl AsRef<str> for ScalingActivityStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes information used to start an instance refresh. </p>
/// <p>All properties are optional. However, if you specify a value for
/// <code>CheckpointDelay</code>, you must also provide a value for
/// <code>CheckpointPercentages</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RefreshPreferences {
    /// <p>The amount of capacity in the Auto Scaling group that must remain healthy during an instance
    /// refresh to allow the operation to continue, as a percentage of the desired capacity of
    /// the Auto Scaling group (rounded up to the nearest integer). The default is <code>90</code>.
    /// </p>
    pub min_healthy_percentage: std::option::Option<i32>,
    /// <p>The number of seconds until a newly launched instance is configured and ready to use.
    /// During this time, Amazon EC2 Auto Scaling does not immediately move on to the next replacement. The
    /// default is to use the value for the health check grace period defined for the
    /// group.</p>
    pub instance_warmup: std::option::Option<i32>,
    /// <p>Threshold values for each checkpoint in ascending order. Each number must be unique.
    /// To replace all instances in the Auto Scaling group, the last number in the array must be
    /// <code>100</code>.</p>
    /// <p>For usage examples, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-adding-checkpoints-instance-refresh.html">Adding
    /// checkpoints to an instance refresh</a> in the
    /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub checkpoint_percentages: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The amount of time, in seconds, to wait after a checkpoint before continuing. This
    /// property is optional, but if you specify a value for it, you must also specify a value
    /// for <code>CheckpointPercentages</code>. If you specify a value for
    /// <code>CheckpointPercentages</code> and not for <code>CheckpointDelay</code>, the
    /// <code>CheckpointDelay</code> defaults to <code>3600</code> (1 hour). </p>
    pub checkpoint_delay: std::option::Option<i32>,
}
impl std::fmt::Debug for RefreshPreferences {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RefreshPreferences");
        formatter.field("min_healthy_percentage", &self.min_healthy_percentage);
        formatter.field("instance_warmup", &self.instance_warmup);
        formatter.field("checkpoint_percentages", &self.checkpoint_percentages);
        formatter.field("checkpoint_delay", &self.checkpoint_delay);
        formatter.finish()
    }
}
/// See [`RefreshPreferences`](crate::model::RefreshPreferences)
pub mod refresh_preferences {
    /// A builder for [`RefreshPreferences`](crate::model::RefreshPreferences)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) min_healthy_percentage: std::option::Option<i32>,
        pub(crate) instance_warmup: std::option::Option<i32>,
        pub(crate) checkpoint_percentages: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) checkpoint_delay: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The amount of capacity in the Auto Scaling group that must remain healthy during an instance
        /// refresh to allow the operation to continue, as a percentage of the desired capacity of
        /// the Auto Scaling group (rounded up to the nearest integer). The default is <code>90</code>.
        /// </p>
        pub fn min_healthy_percentage(mut self, input: i32) -> Self {
            self.min_healthy_percentage = Some(input);
            self
        }
        pub fn set_min_healthy_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.min_healthy_percentage = input;
            self
        }
        /// <p>The number of seconds until a newly launched instance is configured and ready to use.
        /// During this time, Amazon EC2 Auto Scaling does not immediately move on to the next replacement. The
        /// default is to use the value for the health check grace period defined for the
        /// group.</p>
        pub fn instance_warmup(mut self, input: i32) -> Self {
            self.instance_warmup = Some(input);
            self
        }
        pub fn set_instance_warmup(mut self, input: std::option::Option<i32>) -> Self {
            self.instance_warmup = input;
            self
        }
        pub fn checkpoint_percentages(mut self, input: impl Into<i32>) -> Self {
            let mut v = self.checkpoint_percentages.unwrap_or_default();
            v.push(input.into());
            self.checkpoint_percentages = Some(v);
            self
        }
        pub fn set_checkpoint_percentages(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.checkpoint_percentages = input;
            self
        }
        /// <p>The amount of time, in seconds, to wait after a checkpoint before continuing. This
        /// property is optional, but if you specify a value for it, you must also specify a value
        /// for <code>CheckpointPercentages</code>. If you specify a value for
        /// <code>CheckpointPercentages</code> and not for <code>CheckpointDelay</code>, the
        /// <code>CheckpointDelay</code> defaults to <code>3600</code> (1 hour). </p>
        pub fn checkpoint_delay(mut self, input: i32) -> Self {
            self.checkpoint_delay = Some(input);
            self
        }
        pub fn set_checkpoint_delay(mut self, input: std::option::Option<i32>) -> Self {
            self.checkpoint_delay = input;
            self
        }
        /// Consumes the builder and constructs a [`RefreshPreferences`](crate::model::RefreshPreferences)
        pub fn build(self) -> crate::model::RefreshPreferences {
            crate::model::RefreshPreferences {
                min_healthy_percentage: self.min_healthy_percentage,
                instance_warmup: self.instance_warmup,
                checkpoint_percentages: self.checkpoint_percentages,
                checkpoint_delay: self.checkpoint_delay,
            }
        }
    }
}
impl RefreshPreferences {
    /// Creates a new builder-style object to manufacture [`RefreshPreferences`](crate::model::RefreshPreferences)
    pub fn builder() -> crate::model::refresh_preferences::Builder {
        crate::model::refresh_preferences::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RefreshStrategy {
    Rolling,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RefreshStrategy {
    fn from(s: &str) -> Self {
        match s {
            "Rolling" => RefreshStrategy::Rolling,
            other => RefreshStrategy::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RefreshStrategy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RefreshStrategy::from(s))
    }
}
impl RefreshStrategy {
    pub fn as_str(&self) -> &str {
        match self {
            RefreshStrategy::Rolling => "Rolling",
            RefreshStrategy::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Rolling"]
    }
}
impl AsRef<str> for RefreshStrategy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WarmPoolState {
    Running,
    Stopped,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WarmPoolState {
    fn from(s: &str) -> Self {
        match s {
            "Running" => WarmPoolState::Running,
            "Stopped" => WarmPoolState::Stopped,
            other => WarmPoolState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WarmPoolState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WarmPoolState::from(s))
    }
}
impl WarmPoolState {
    pub fn as_str(&self) -> &str {
        match self {
            WarmPoolState::Running => "Running",
            WarmPoolState::Stopped => "Stopped",
            WarmPoolState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Running", "Stopped"]
    }
}
impl AsRef<str> for WarmPoolState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an alarm.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Alarm {
    /// <p>The name of the alarm.</p>
    pub alarm_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
    pub alarm_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Alarm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Alarm");
        formatter.field("alarm_name", &self.alarm_name);
        formatter.field("alarm_arn", &self.alarm_arn);
        formatter.finish()
    }
}
/// See [`Alarm`](crate::model::Alarm)
pub mod alarm {
    /// A builder for [`Alarm`](crate::model::Alarm)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alarm_name: std::option::Option<std::string::String>,
        pub(crate) alarm_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the alarm.</p>
        pub fn alarm_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_name = Some(input.into());
            self
        }
        pub fn set_alarm_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the alarm.</p>
        pub fn alarm_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.alarm_arn = Some(input.into());
            self
        }
        pub fn set_alarm_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alarm_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Alarm`](crate::model::Alarm)
        pub fn build(self) -> crate::model::Alarm {
            crate::model::Alarm {
                alarm_name: self.alarm_name,
                alarm_arn: self.alarm_arn,
            }
        }
    }
}
impl Alarm {
    /// Creates a new builder-style object to manufacture [`Alarm`](crate::model::Alarm)
    pub fn builder() -> crate::model::alarm::Builder {
        crate::model::alarm::Builder::default()
    }
}

/// <p>Represents a predictive scaling policy configuration to use with Amazon EC2 Auto Scaling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredictiveScalingConfiguration {
    /// <p>This structure includes the metrics and target utilization to use for predictive
    /// scaling. </p>
    /// <p>This is an array, but we currently only support a single metric specification. That
    /// is, you can specify a target value and a single metric pair, or a target value and one
    /// scaling metric and one load metric.</p>
    pub metric_specifications:
        std::option::Option<std::vec::Vec<crate::model::PredictiveScalingMetricSpecification>>,
    /// <p>The predictive scaling mode. Defaults to <code>ForecastOnly</code> if not
    /// specified.</p>
    pub mode: std::option::Option<crate::model::PredictiveScalingMode>,
    /// <p>The amount of time, in seconds, by which the instance launch time can be advanced. For
    /// example, the forecast says to add capacity at 10:00 AM, and you choose to pre-launch
    /// instances by 5 minutes. In that case, the instances will be launched at 9:55 AM. The
    /// intention is to give resources time to be provisioned. It can take a few minutes to
    /// launch an EC2 instance. The actual amount of time required depends on several factors,
    /// such as the size of the instance and whether there are startup scripts to complete. </p>
    /// <p>The value must be less than the forecast interval duration of 3600 seconds (60
    /// minutes). Defaults to 300 seconds if not specified. </p>
    pub scheduling_buffer_time: std::option::Option<i32>,
    /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
    /// exceeds the maximum capacity of the Auto Scaling group. Defaults to
    /// <code>HonorMaxCapacity</code> if not specified.</p>
    /// <p>The following are possible values:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>HonorMaxCapacity</code> - Amazon EC2 Auto Scaling cannot scale out capacity higher than
    /// the maximum capacity. The maximum capacity is enforced as a hard limit. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>IncreaseMaxCapacity</code> - Amazon EC2 Auto Scaling can scale out capacity higher than
    /// the maximum capacity when the forecast capacity is close to or exceeds the
    /// maximum capacity. The upper limit is determined by the forecasted capacity and
    /// the value for <code>MaxCapacityBuffer</code>.</p>
    /// </li>
    /// </ul>
    pub max_capacity_breach_behavior:
        std::option::Option<crate::model::PredictiveScalingMaxCapacityBreachBehavior>,
    /// <p>The size of the capacity buffer to use when the forecast capacity is close to or
    /// exceeds the maximum capacity. The value is specified as a percentage relative to the
    /// forecast capacity. For example, if the buffer is 10, this means a 10 percent buffer,
    /// such that if the forecast capacity is 50, and the maximum capacity is 40, then the
    /// effective maximum capacity is 55.</p>
    /// <p>If set to 0, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but
    /// not exceed forecast capacity. </p>
    /// <p>Required if the <code>MaxCapacityBreachBehavior</code> property is set to
    /// <code>IncreaseMaxCapacity</code>, and cannot be used otherwise.</p>
    pub max_capacity_buffer: std::option::Option<i32>,
}
impl std::fmt::Debug for PredictiveScalingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredictiveScalingConfiguration");
        formatter.field("metric_specifications", &self.metric_specifications);
        formatter.field("mode", &self.mode);
        formatter.field("scheduling_buffer_time", &self.scheduling_buffer_time);
        formatter.field(
            "max_capacity_breach_behavior",
            &self.max_capacity_breach_behavior,
        );
        formatter.field("max_capacity_buffer", &self.max_capacity_buffer);
        formatter.finish()
    }
}
/// See [`PredictiveScalingConfiguration`](crate::model::PredictiveScalingConfiguration)
pub mod predictive_scaling_configuration {
    /// A builder for [`PredictiveScalingConfiguration`](crate::model::PredictiveScalingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_specifications:
            std::option::Option<std::vec::Vec<crate::model::PredictiveScalingMetricSpecification>>,
        pub(crate) mode: std::option::Option<crate::model::PredictiveScalingMode>,
        pub(crate) scheduling_buffer_time: std::option::Option<i32>,
        pub(crate) max_capacity_breach_behavior:
            std::option::Option<crate::model::PredictiveScalingMaxCapacityBreachBehavior>,
        pub(crate) max_capacity_buffer: std::option::Option<i32>,
    }
    impl Builder {
        pub fn metric_specifications(
            mut self,
            input: impl Into<crate::model::PredictiveScalingMetricSpecification>,
        ) -> Self {
            let mut v = self.metric_specifications.unwrap_or_default();
            v.push(input.into());
            self.metric_specifications = Some(v);
            self
        }
        pub fn set_metric_specifications(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::PredictiveScalingMetricSpecification>,
            >,
        ) -> Self {
            self.metric_specifications = input;
            self
        }
        /// <p>The predictive scaling mode. Defaults to <code>ForecastOnly</code> if not
        /// specified.</p>
        pub fn mode(mut self, input: crate::model::PredictiveScalingMode) -> Self {
            self.mode = Some(input);
            self
        }
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// <p>The amount of time, in seconds, by which the instance launch time can be advanced. For
        /// example, the forecast says to add capacity at 10:00 AM, and you choose to pre-launch
        /// instances by 5 minutes. In that case, the instances will be launched at 9:55 AM. The
        /// intention is to give resources time to be provisioned. It can take a few minutes to
        /// launch an EC2 instance. The actual amount of time required depends on several factors,
        /// such as the size of the instance and whether there are startup scripts to complete. </p>
        /// <p>The value must be less than the forecast interval duration of 3600 seconds (60
        /// minutes). Defaults to 300 seconds if not specified. </p>
        pub fn scheduling_buffer_time(mut self, input: i32) -> Self {
            self.scheduling_buffer_time = Some(input);
            self
        }
        pub fn set_scheduling_buffer_time(mut self, input: std::option::Option<i32>) -> Self {
            self.scheduling_buffer_time = input;
            self
        }
        /// <p>Defines the behavior that should be applied if the forecast capacity approaches or
        /// exceeds the maximum capacity of the Auto Scaling group. Defaults to
        /// <code>HonorMaxCapacity</code> if not specified.</p>
        /// <p>The following are possible values:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>HonorMaxCapacity</code> - Amazon EC2 Auto Scaling cannot scale out capacity higher than
        /// the maximum capacity. The maximum capacity is enforced as a hard limit. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>IncreaseMaxCapacity</code> - Amazon EC2 Auto Scaling can scale out capacity higher than
        /// the maximum capacity when the forecast capacity is close to or exceeds the
        /// maximum capacity. The upper limit is determined by the forecasted capacity and
        /// the value for <code>MaxCapacityBuffer</code>.</p>
        /// </li>
        /// </ul>
        pub fn max_capacity_breach_behavior(
            mut self,
            input: crate::model::PredictiveScalingMaxCapacityBreachBehavior,
        ) -> Self {
            self.max_capacity_breach_behavior = Some(input);
            self
        }
        pub fn set_max_capacity_breach_behavior(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingMaxCapacityBreachBehavior>,
        ) -> Self {
            self.max_capacity_breach_behavior = input;
            self
        }
        /// <p>The size of the capacity buffer to use when the forecast capacity is close to or
        /// exceeds the maximum capacity. The value is specified as a percentage relative to the
        /// forecast capacity. For example, if the buffer is 10, this means a 10 percent buffer,
        /// such that if the forecast capacity is 50, and the maximum capacity is 40, then the
        /// effective maximum capacity is 55.</p>
        /// <p>If set to 0, Amazon EC2 Auto Scaling may scale capacity higher than the maximum capacity to equal but
        /// not exceed forecast capacity. </p>
        /// <p>Required if the <code>MaxCapacityBreachBehavior</code> property is set to
        /// <code>IncreaseMaxCapacity</code>, and cannot be used otherwise.</p>
        pub fn max_capacity_buffer(mut self, input: i32) -> Self {
            self.max_capacity_buffer = Some(input);
            self
        }
        pub fn set_max_capacity_buffer(mut self, input: std::option::Option<i32>) -> Self {
            self.max_capacity_buffer = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictiveScalingConfiguration`](crate::model::PredictiveScalingConfiguration)
        pub fn build(self) -> crate::model::PredictiveScalingConfiguration {
            crate::model::PredictiveScalingConfiguration {
                metric_specifications: self.metric_specifications,
                mode: self.mode,
                scheduling_buffer_time: self.scheduling_buffer_time,
                max_capacity_breach_behavior: self.max_capacity_breach_behavior,
                max_capacity_buffer: self.max_capacity_buffer,
            }
        }
    }
}
impl PredictiveScalingConfiguration {
    /// Creates a new builder-style object to manufacture [`PredictiveScalingConfiguration`](crate::model::PredictiveScalingConfiguration)
    pub fn builder() -> crate::model::predictive_scaling_configuration::Builder {
        crate::model::predictive_scaling_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredictiveScalingMaxCapacityBreachBehavior {
    HonorMaxCapacity,
    IncreaseMaxCapacity,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredictiveScalingMaxCapacityBreachBehavior {
    fn from(s: &str) -> Self {
        match s {
            "HonorMaxCapacity" => PredictiveScalingMaxCapacityBreachBehavior::HonorMaxCapacity,
            "IncreaseMaxCapacity" => {
                PredictiveScalingMaxCapacityBreachBehavior::IncreaseMaxCapacity
            }
            other => PredictiveScalingMaxCapacityBreachBehavior::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredictiveScalingMaxCapacityBreachBehavior {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredictiveScalingMaxCapacityBreachBehavior::from(s))
    }
}
impl PredictiveScalingMaxCapacityBreachBehavior {
    pub fn as_str(&self) -> &str {
        match self {
            PredictiveScalingMaxCapacityBreachBehavior::HonorMaxCapacity => "HonorMaxCapacity",
            PredictiveScalingMaxCapacityBreachBehavior::IncreaseMaxCapacity => {
                "IncreaseMaxCapacity"
            }
            PredictiveScalingMaxCapacityBreachBehavior::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["HonorMaxCapacity", "IncreaseMaxCapacity"]
    }
}
impl AsRef<str> for PredictiveScalingMaxCapacityBreachBehavior {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredictiveScalingMode {
    ForecastAndScale,
    ForecastOnly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredictiveScalingMode {
    fn from(s: &str) -> Self {
        match s {
            "ForecastAndScale" => PredictiveScalingMode::ForecastAndScale,
            "ForecastOnly" => PredictiveScalingMode::ForecastOnly,
            other => PredictiveScalingMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredictiveScalingMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredictiveScalingMode::from(s))
    }
}
impl PredictiveScalingMode {
    pub fn as_str(&self) -> &str {
        match self {
            PredictiveScalingMode::ForecastAndScale => "ForecastAndScale",
            PredictiveScalingMode::ForecastOnly => "ForecastOnly",
            PredictiveScalingMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ForecastAndScale", "ForecastOnly"]
    }
}
impl AsRef<str> for PredictiveScalingMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>This structure specifies the metrics and target utilization settings for a predictive
/// scaling policy. </p>
/// <p>You must specify either a metric pair, or a load metric and a scaling metric
/// individually. Specifying a metric pair instead of individual metrics provides a simpler
/// way to configure metrics for a scaling policy. You choose the metric pair, and the
/// policy automatically knows the correct sum and average statistics to use for the load
/// metric and the scaling metric.</p>
/// <p>Example</p>
/// <ul>
/// <li>
/// <p>You create a predictive scaling policy and specify
/// <code>ALBRequestCount</code> as the value for the metric pair and
/// <code>1000.0</code> as the target value. For this type of metric, you must
/// provide the metric dimension for the corresponding target group, so you also
/// provide a resource label for the Application Load Balancer target group that is
/// attached to your Auto Scaling group.</p>
/// </li>
/// <li>
/// <p>The number of requests the target group receives per minute provides the load
/// metric, and the request count averaged between the members of the target group
/// provides the scaling metric. In CloudWatch, this refers to the
/// <code>RequestCount</code> and <code>RequestCountPerTarget</code> metrics,
/// respectively.</p>
/// </li>
/// <li>
/// <p>For optimal use of predictive scaling, you adhere to the best practice of
/// using a dynamic scaling policy to automatically scale between the minimum
/// capacity and maximum capacity in response to real-time changes in resource
/// utilization.</p>
/// </li>
/// <li>
/// <p>Amazon EC2 Auto Scaling consumes data points for the load metric over the last 14 days and
/// creates an hourly load forecast for predictive scaling. (A minimum of 24 hours
/// of data is required.)</p>
/// </li>
/// <li>
/// <p>After creating the load forecast, Amazon EC2 Auto Scaling determines when to reduce or
/// increase the capacity of your Auto Scaling group in each hour of the forecast period so
/// that the average number of requests received by each instance is as close to
/// 1000 requests per minute as possible at all times.</p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredictiveScalingMetricSpecification {
    /// <p>Specifies the target utilization.</p>
    pub target_value: std::option::Option<f64>,
    /// <p>The metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling
    /// metric and load metric to use.</p>
    pub predefined_metric_pair_specification:
        std::option::Option<crate::model::PredictiveScalingPredefinedMetricPair>,
    /// <p>The scaling metric specification.</p>
    pub predefined_scaling_metric_specification:
        std::option::Option<crate::model::PredictiveScalingPredefinedScalingMetric>,
    /// <p>The load metric specification.</p>
    pub predefined_load_metric_specification:
        std::option::Option<crate::model::PredictiveScalingPredefinedLoadMetric>,
}
impl std::fmt::Debug for PredictiveScalingMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredictiveScalingMetricSpecification");
        formatter.field("target_value", &self.target_value);
        formatter.field(
            "predefined_metric_pair_specification",
            &self.predefined_metric_pair_specification,
        );
        formatter.field(
            "predefined_scaling_metric_specification",
            &self.predefined_scaling_metric_specification,
        );
        formatter.field(
            "predefined_load_metric_specification",
            &self.predefined_load_metric_specification,
        );
        formatter.finish()
    }
}
/// See [`PredictiveScalingMetricSpecification`](crate::model::PredictiveScalingMetricSpecification)
pub mod predictive_scaling_metric_specification {
    /// A builder for [`PredictiveScalingMetricSpecification`](crate::model::PredictiveScalingMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) target_value: std::option::Option<f64>,
        pub(crate) predefined_metric_pair_specification:
            std::option::Option<crate::model::PredictiveScalingPredefinedMetricPair>,
        pub(crate) predefined_scaling_metric_specification:
            std::option::Option<crate::model::PredictiveScalingPredefinedScalingMetric>,
        pub(crate) predefined_load_metric_specification:
            std::option::Option<crate::model::PredictiveScalingPredefinedLoadMetric>,
    }
    impl Builder {
        /// <p>Specifies the target utilization.</p>
        pub fn target_value(mut self, input: f64) -> Self {
            self.target_value = Some(input);
            self
        }
        pub fn set_target_value(mut self, input: std::option::Option<f64>) -> Self {
            self.target_value = input;
            self
        }
        /// <p>The metric pair specification from which Amazon EC2 Auto Scaling determines the appropriate scaling
        /// metric and load metric to use.</p>
        pub fn predefined_metric_pair_specification(
            mut self,
            input: crate::model::PredictiveScalingPredefinedMetricPair,
        ) -> Self {
            self.predefined_metric_pair_specification = Some(input);
            self
        }
        pub fn set_predefined_metric_pair_specification(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingPredefinedMetricPair>,
        ) -> Self {
            self.predefined_metric_pair_specification = input;
            self
        }
        /// <p>The scaling metric specification.</p>
        pub fn predefined_scaling_metric_specification(
            mut self,
            input: crate::model::PredictiveScalingPredefinedScalingMetric,
        ) -> Self {
            self.predefined_scaling_metric_specification = Some(input);
            self
        }
        pub fn set_predefined_scaling_metric_specification(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingPredefinedScalingMetric>,
        ) -> Self {
            self.predefined_scaling_metric_specification = input;
            self
        }
        /// <p>The load metric specification.</p>
        pub fn predefined_load_metric_specification(
            mut self,
            input: crate::model::PredictiveScalingPredefinedLoadMetric,
        ) -> Self {
            self.predefined_load_metric_specification = Some(input);
            self
        }
        pub fn set_predefined_load_metric_specification(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingPredefinedLoadMetric>,
        ) -> Self {
            self.predefined_load_metric_specification = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictiveScalingMetricSpecification`](crate::model::PredictiveScalingMetricSpecification)
        pub fn build(self) -> crate::model::PredictiveScalingMetricSpecification {
            crate::model::PredictiveScalingMetricSpecification {
                target_value: self.target_value,
                predefined_metric_pair_specification: self.predefined_metric_pair_specification,
                predefined_scaling_metric_specification: self
                    .predefined_scaling_metric_specification,
                predefined_load_metric_specification: self.predefined_load_metric_specification,
            }
        }
    }
}
impl PredictiveScalingMetricSpecification {
    /// Creates a new builder-style object to manufacture [`PredictiveScalingMetricSpecification`](crate::model::PredictiveScalingMetricSpecification)
    pub fn builder() -> crate::model::predictive_scaling_metric_specification::Builder {
        crate::model::predictive_scaling_metric_specification::Builder::default()
    }
}

/// <p>Describes a load metric for a predictive scaling policy.</p>
/// <p>When returned in the output of <code>DescribePolicies</code>, it indicates that a
/// predictive scaling policy uses individually specified load and scaling metrics instead
/// of a metric pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredictiveScalingPredefinedLoadMetric {
    /// <p>The metric type.</p>
    pub predefined_metric_type: std::option::Option<crate::model::PredefinedLoadMetricType>,
    /// <p>A label that uniquely identifies a specific Application Load Balancer target group from which to determine
    /// the request count served by your Auto Scaling group. You can't specify a resource label
    /// unless the target group is attached to the Auto Scaling group.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format of the resource label is:</p>
    /// <p>
    /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
    /// <p>Where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub resource_label: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PredictiveScalingPredefinedLoadMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredictiveScalingPredefinedLoadMetric");
        formatter.field("predefined_metric_type", &self.predefined_metric_type);
        formatter.field("resource_label", &self.resource_label);
        formatter.finish()
    }
}
/// See [`PredictiveScalingPredefinedLoadMetric`](crate::model::PredictiveScalingPredefinedLoadMetric)
pub mod predictive_scaling_predefined_load_metric {
    /// A builder for [`PredictiveScalingPredefinedLoadMetric`](crate::model::PredictiveScalingPredefinedLoadMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_metric_type:
            std::option::Option<crate::model::PredefinedLoadMetricType>,
        pub(crate) resource_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric type.</p>
        pub fn predefined_metric_type(
            mut self,
            input: crate::model::PredefinedLoadMetricType,
        ) -> Self {
            self.predefined_metric_type = Some(input);
            self
        }
        pub fn set_predefined_metric_type(
            mut self,
            input: std::option::Option<crate::model::PredefinedLoadMetricType>,
        ) -> Self {
            self.predefined_metric_type = input;
            self
        }
        /// <p>A label that uniquely identifies a specific Application Load Balancer target group from which to determine
        /// the request count served by your Auto Scaling group. You can't specify a resource label
        /// unless the target group is attached to the Auto Scaling group.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format of the resource label is:</p>
        /// <p>
        /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
        /// <p>Where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn resource_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_label = Some(input.into());
            self
        }
        pub fn set_resource_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_label = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictiveScalingPredefinedLoadMetric`](crate::model::PredictiveScalingPredefinedLoadMetric)
        pub fn build(self) -> crate::model::PredictiveScalingPredefinedLoadMetric {
            crate::model::PredictiveScalingPredefinedLoadMetric {
                predefined_metric_type: self.predefined_metric_type,
                resource_label: self.resource_label,
            }
        }
    }
}
impl PredictiveScalingPredefinedLoadMetric {
    /// Creates a new builder-style object to manufacture [`PredictiveScalingPredefinedLoadMetric`](crate::model::PredictiveScalingPredefinedLoadMetric)
    pub fn builder() -> crate::model::predictive_scaling_predefined_load_metric::Builder {
        crate::model::predictive_scaling_predefined_load_metric::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredefinedLoadMetricType {
    AlbTargetGroupRequestCount,
    AsgTotalCpuUtilization,
    AsgTotalNetworkIn,
    AsgTotalNetworkOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredefinedLoadMetricType {
    fn from(s: &str) -> Self {
        match s {
            "ALBTargetGroupRequestCount" => PredefinedLoadMetricType::AlbTargetGroupRequestCount,
            "ASGTotalCPUUtilization" => PredefinedLoadMetricType::AsgTotalCpuUtilization,
            "ASGTotalNetworkIn" => PredefinedLoadMetricType::AsgTotalNetworkIn,
            "ASGTotalNetworkOut" => PredefinedLoadMetricType::AsgTotalNetworkOut,
            other => PredefinedLoadMetricType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredefinedLoadMetricType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredefinedLoadMetricType::from(s))
    }
}
impl PredefinedLoadMetricType {
    pub fn as_str(&self) -> &str {
        match self {
            PredefinedLoadMetricType::AlbTargetGroupRequestCount => "ALBTargetGroupRequestCount",
            PredefinedLoadMetricType::AsgTotalCpuUtilization => "ASGTotalCPUUtilization",
            PredefinedLoadMetricType::AsgTotalNetworkIn => "ASGTotalNetworkIn",
            PredefinedLoadMetricType::AsgTotalNetworkOut => "ASGTotalNetworkOut",
            PredefinedLoadMetricType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ALBTargetGroupRequestCount",
            "ASGTotalCPUUtilization",
            "ASGTotalNetworkIn",
            "ASGTotalNetworkOut",
        ]
    }
}
impl AsRef<str> for PredefinedLoadMetricType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a scaling metric for a predictive scaling policy.</p>
/// <p>When returned in the output of <code>DescribePolicies</code>, it indicates that a
/// predictive scaling policy uses individually specified load and scaling metrics instead
/// of a metric pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredictiveScalingPredefinedScalingMetric {
    /// <p>The metric type.</p>
    pub predefined_metric_type: std::option::Option<crate::model::PredefinedScalingMetricType>,
    /// <p>A label that uniquely identifies a specific Application Load Balancer target group from which to determine
    /// the average request count served by your Auto Scaling group. You can't specify a resource
    /// label unless the target group is attached to the Auto Scaling group.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format of the resource label is:</p>
    /// <p>
    /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
    /// <p>Where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub resource_label: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PredictiveScalingPredefinedScalingMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredictiveScalingPredefinedScalingMetric");
        formatter.field("predefined_metric_type", &self.predefined_metric_type);
        formatter.field("resource_label", &self.resource_label);
        formatter.finish()
    }
}
/// See [`PredictiveScalingPredefinedScalingMetric`](crate::model::PredictiveScalingPredefinedScalingMetric)
pub mod predictive_scaling_predefined_scaling_metric {
    /// A builder for [`PredictiveScalingPredefinedScalingMetric`](crate::model::PredictiveScalingPredefinedScalingMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_metric_type:
            std::option::Option<crate::model::PredefinedScalingMetricType>,
        pub(crate) resource_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric type.</p>
        pub fn predefined_metric_type(
            mut self,
            input: crate::model::PredefinedScalingMetricType,
        ) -> Self {
            self.predefined_metric_type = Some(input);
            self
        }
        pub fn set_predefined_metric_type(
            mut self,
            input: std::option::Option<crate::model::PredefinedScalingMetricType>,
        ) -> Self {
            self.predefined_metric_type = input;
            self
        }
        /// <p>A label that uniquely identifies a specific Application Load Balancer target group from which to determine
        /// the average request count served by your Auto Scaling group. You can't specify a resource
        /// label unless the target group is attached to the Auto Scaling group.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format of the resource label is:</p>
        /// <p>
        /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
        /// <p>Where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn resource_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_label = Some(input.into());
            self
        }
        pub fn set_resource_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_label = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictiveScalingPredefinedScalingMetric`](crate::model::PredictiveScalingPredefinedScalingMetric)
        pub fn build(self) -> crate::model::PredictiveScalingPredefinedScalingMetric {
            crate::model::PredictiveScalingPredefinedScalingMetric {
                predefined_metric_type: self.predefined_metric_type,
                resource_label: self.resource_label,
            }
        }
    }
}
impl PredictiveScalingPredefinedScalingMetric {
    /// Creates a new builder-style object to manufacture [`PredictiveScalingPredefinedScalingMetric`](crate::model::PredictiveScalingPredefinedScalingMetric)
    pub fn builder() -> crate::model::predictive_scaling_predefined_scaling_metric::Builder {
        crate::model::predictive_scaling_predefined_scaling_metric::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredefinedScalingMetricType {
    AlbRequestCountPerTarget,
    AsgAverageCpuUtilization,
    AsgAverageNetworkIn,
    AsgAverageNetworkOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredefinedScalingMetricType {
    fn from(s: &str) -> Self {
        match s {
            "ALBRequestCountPerTarget" => PredefinedScalingMetricType::AlbRequestCountPerTarget,
            "ASGAverageCPUUtilization" => PredefinedScalingMetricType::AsgAverageCpuUtilization,
            "ASGAverageNetworkIn" => PredefinedScalingMetricType::AsgAverageNetworkIn,
            "ASGAverageNetworkOut" => PredefinedScalingMetricType::AsgAverageNetworkOut,
            other => PredefinedScalingMetricType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredefinedScalingMetricType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredefinedScalingMetricType::from(s))
    }
}
impl PredefinedScalingMetricType {
    pub fn as_str(&self) -> &str {
        match self {
            PredefinedScalingMetricType::AlbRequestCountPerTarget => "ALBRequestCountPerTarget",
            PredefinedScalingMetricType::AsgAverageCpuUtilization => "ASGAverageCPUUtilization",
            PredefinedScalingMetricType::AsgAverageNetworkIn => "ASGAverageNetworkIn",
            PredefinedScalingMetricType::AsgAverageNetworkOut => "ASGAverageNetworkOut",
            PredefinedScalingMetricType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ALBRequestCountPerTarget",
            "ASGAverageCPUUtilization",
            "ASGAverageNetworkIn",
            "ASGAverageNetworkOut",
        ]
    }
}
impl AsRef<str> for PredefinedScalingMetricType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a metric pair for a predictive scaling policy. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredictiveScalingPredefinedMetricPair {
    /// <p>Indicates which metrics to use. There are two different types of metrics for each
    /// metric type: one is a load metric and one is a scaling metric. For example, if the
    /// metric type is <code>ASGCPUUtilization</code>, the Auto Scaling group's total CPU metric is used
    /// as the load metric, and the average CPU metric is used for the scaling metric.</p>
    pub predefined_metric_type: std::option::Option<crate::model::PredefinedMetricPairType>,
    /// <p>A label that uniquely identifies a specific Application Load Balancer target group from which to determine
    /// the total and average request count served by your Auto Scaling group. You can't specify a
    /// resource label unless the target group is attached to the Auto Scaling group.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format of the resource label is:</p>
    /// <p>
    /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
    /// <p>Where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub resource_label: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PredictiveScalingPredefinedMetricPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredictiveScalingPredefinedMetricPair");
        formatter.field("predefined_metric_type", &self.predefined_metric_type);
        formatter.field("resource_label", &self.resource_label);
        formatter.finish()
    }
}
/// See [`PredictiveScalingPredefinedMetricPair`](crate::model::PredictiveScalingPredefinedMetricPair)
pub mod predictive_scaling_predefined_metric_pair {
    /// A builder for [`PredictiveScalingPredefinedMetricPair`](crate::model::PredictiveScalingPredefinedMetricPair)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_metric_type:
            std::option::Option<crate::model::PredefinedMetricPairType>,
        pub(crate) resource_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates which metrics to use. There are two different types of metrics for each
        /// metric type: one is a load metric and one is a scaling metric. For example, if the
        /// metric type is <code>ASGCPUUtilization</code>, the Auto Scaling group's total CPU metric is used
        /// as the load metric, and the average CPU metric is used for the scaling metric.</p>
        pub fn predefined_metric_type(
            mut self,
            input: crate::model::PredefinedMetricPairType,
        ) -> Self {
            self.predefined_metric_type = Some(input);
            self
        }
        pub fn set_predefined_metric_type(
            mut self,
            input: std::option::Option<crate::model::PredefinedMetricPairType>,
        ) -> Self {
            self.predefined_metric_type = input;
            self
        }
        /// <p>A label that uniquely identifies a specific Application Load Balancer target group from which to determine
        /// the total and average request count served by your Auto Scaling group. You can't specify a
        /// resource label unless the target group is attached to the Auto Scaling group.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format of the resource label is:</p>
        /// <p>
        /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
        /// <p>Where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn resource_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_label = Some(input.into());
            self
        }
        pub fn set_resource_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_label = input;
            self
        }
        /// Consumes the builder and constructs a [`PredictiveScalingPredefinedMetricPair`](crate::model::PredictiveScalingPredefinedMetricPair)
        pub fn build(self) -> crate::model::PredictiveScalingPredefinedMetricPair {
            crate::model::PredictiveScalingPredefinedMetricPair {
                predefined_metric_type: self.predefined_metric_type,
                resource_label: self.resource_label,
            }
        }
    }
}
impl PredictiveScalingPredefinedMetricPair {
    /// Creates a new builder-style object to manufacture [`PredictiveScalingPredefinedMetricPair`](crate::model::PredictiveScalingPredefinedMetricPair)
    pub fn builder() -> crate::model::predictive_scaling_predefined_metric_pair::Builder {
        crate::model::predictive_scaling_predefined_metric_pair::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PredefinedMetricPairType {
    AlbRequestCount,
    AsgcpuUtilization,
    AsgNetworkIn,
    AsgNetworkOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for PredefinedMetricPairType {
    fn from(s: &str) -> Self {
        match s {
            "ALBRequestCount" => PredefinedMetricPairType::AlbRequestCount,
            "ASGCPUUtilization" => PredefinedMetricPairType::AsgcpuUtilization,
            "ASGNetworkIn" => PredefinedMetricPairType::AsgNetworkIn,
            "ASGNetworkOut" => PredefinedMetricPairType::AsgNetworkOut,
            other => PredefinedMetricPairType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for PredefinedMetricPairType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PredefinedMetricPairType::from(s))
    }
}
impl PredefinedMetricPairType {
    pub fn as_str(&self) -> &str {
        match self {
            PredefinedMetricPairType::AlbRequestCount => "ALBRequestCount",
            PredefinedMetricPairType::AsgcpuUtilization => "ASGCPUUtilization",
            PredefinedMetricPairType::AsgNetworkIn => "ASGNetworkIn",
            PredefinedMetricPairType::AsgNetworkOut => "ASGNetworkOut",
            PredefinedMetricPairType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ALBRequestCount",
            "ASGCPUUtilization",
            "ASGNetworkIn",
            "ASGNetworkOut",
        ]
    }
}
impl AsRef<str> for PredefinedMetricPairType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a target tracking scaling policy configuration to use with Amazon EC2 Auto Scaling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetTrackingConfiguration {
    /// <p>A predefined metric. You must specify either a predefined metric or a customized
    /// metric.</p>
    pub predefined_metric_specification:
        std::option::Option<crate::model::PredefinedMetricSpecification>,
    /// <p>A customized metric. You must specify either a predefined metric or a customized
    /// metric.</p>
    pub customized_metric_specification:
        std::option::Option<crate::model::CustomizedMetricSpecification>,
    /// <p>The target value for the metric.</p>
    pub target_value: std::option::Option<f64>,
    /// <p>Indicates whether scaling in by the target tracking scaling policy is disabled. If
    /// scaling in is disabled, the target tracking scaling policy doesn't remove instances from
    /// the Auto Scaling group. Otherwise, the target tracking scaling policy can remove instances from
    /// the Auto Scaling group. The default is <code>false</code>.</p>
    pub disable_scale_in: std::option::Option<bool>,
}
impl std::fmt::Debug for TargetTrackingConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetTrackingConfiguration");
        formatter.field(
            "predefined_metric_specification",
            &self.predefined_metric_specification,
        );
        formatter.field(
            "customized_metric_specification",
            &self.customized_metric_specification,
        );
        formatter.field("target_value", &self.target_value);
        formatter.field("disable_scale_in", &self.disable_scale_in);
        formatter.finish()
    }
}
/// See [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
pub mod target_tracking_configuration {
    /// A builder for [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_metric_specification:
            std::option::Option<crate::model::PredefinedMetricSpecification>,
        pub(crate) customized_metric_specification:
            std::option::Option<crate::model::CustomizedMetricSpecification>,
        pub(crate) target_value: std::option::Option<f64>,
        pub(crate) disable_scale_in: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>A predefined metric. You must specify either a predefined metric or a customized
        /// metric.</p>
        pub fn predefined_metric_specification(
            mut self,
            input: crate::model::PredefinedMetricSpecification,
        ) -> Self {
            self.predefined_metric_specification = Some(input);
            self
        }
        pub fn set_predefined_metric_specification(
            mut self,
            input: std::option::Option<crate::model::PredefinedMetricSpecification>,
        ) -> Self {
            self.predefined_metric_specification = input;
            self
        }
        /// <p>A customized metric. You must specify either a predefined metric or a customized
        /// metric.</p>
        pub fn customized_metric_specification(
            mut self,
            input: crate::model::CustomizedMetricSpecification,
        ) -> Self {
            self.customized_metric_specification = Some(input);
            self
        }
        pub fn set_customized_metric_specification(
            mut self,
            input: std::option::Option<crate::model::CustomizedMetricSpecification>,
        ) -> Self {
            self.customized_metric_specification = input;
            self
        }
        /// <p>The target value for the metric.</p>
        pub fn target_value(mut self, input: f64) -> Self {
            self.target_value = Some(input);
            self
        }
        pub fn set_target_value(mut self, input: std::option::Option<f64>) -> Self {
            self.target_value = input;
            self
        }
        /// <p>Indicates whether scaling in by the target tracking scaling policy is disabled. If
        /// scaling in is disabled, the target tracking scaling policy doesn't remove instances from
        /// the Auto Scaling group. Otherwise, the target tracking scaling policy can remove instances from
        /// the Auto Scaling group. The default is <code>false</code>.</p>
        pub fn disable_scale_in(mut self, input: bool) -> Self {
            self.disable_scale_in = Some(input);
            self
        }
        pub fn set_disable_scale_in(mut self, input: std::option::Option<bool>) -> Self {
            self.disable_scale_in = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
        pub fn build(self) -> crate::model::TargetTrackingConfiguration {
            crate::model::TargetTrackingConfiguration {
                predefined_metric_specification: self.predefined_metric_specification,
                customized_metric_specification: self.customized_metric_specification,
                target_value: self.target_value,
                disable_scale_in: self.disable_scale_in,
            }
        }
    }
}
impl TargetTrackingConfiguration {
    /// Creates a new builder-style object to manufacture [`TargetTrackingConfiguration`](crate::model::TargetTrackingConfiguration)
    pub fn builder() -> crate::model::target_tracking_configuration::Builder {
        crate::model::target_tracking_configuration::Builder::default()
    }
}

/// <p>Represents a CloudWatch metric of your choosing for a target tracking scaling policy to use
/// with Amazon EC2 Auto Scaling.</p>
/// <p>To create your customized metric specification:</p>
/// <ul>
/// <li>
/// <p>Add values for each required parameter from CloudWatch. You can use an existing
/// metric, or a new metric that you create. To use your own metric, you must first
/// publish the metric to CloudWatch. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html">Publish
/// Custom Metrics</a> in the <i>Amazon CloudWatch User
/// Guide</i>.</p>
/// </li>
/// <li>
/// <p>Choose a metric that changes proportionally with capacity. The value of the
/// metric should increase or decrease in inverse proportion to the number of
/// capacity units. That is, the value of the metric should decrease when capacity
/// increases.</p>
/// </li>
/// </ul>
/// <p>For more information about CloudWatch, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html">Amazon CloudWatch
/// Concepts</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomizedMetricSpecification {
    /// <p>The name of the metric.</p>
    pub metric_name: std::option::Option<std::string::String>,
    /// <p>The namespace of the metric.</p>
    pub namespace: std::option::Option<std::string::String>,
    /// <p>The dimensions of the metric.</p>
    /// <p>Conditional: If you published your metric with dimensions, you must specify the same
    /// dimensions in your scaling policy.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
    /// <p>The statistic of the metric.</p>
    pub statistic: std::option::Option<crate::model::MetricStatistic>,
    /// <p>The unit of the metric.</p>
    pub unit: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomizedMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomizedMetricSpecification");
        formatter.field("metric_name", &self.metric_name);
        formatter.field("namespace", &self.namespace);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("statistic", &self.statistic);
        formatter.field("unit", &self.unit);
        formatter.finish()
    }
}
/// See [`CustomizedMetricSpecification`](crate::model::CustomizedMetricSpecification)
pub mod customized_metric_specification {
    /// A builder for [`CustomizedMetricSpecification`](crate::model::CustomizedMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_name: std::option::Option<std::string::String>,
        pub(crate) namespace: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
        pub(crate) statistic: std::option::Option<crate::model::MetricStatistic>,
        pub(crate) unit: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the metric.</p>
        pub fn metric_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_name = Some(input.into());
            self
        }
        pub fn set_metric_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric_name = input;
            self
        }
        /// <p>The namespace of the metric.</p>
        pub fn namespace(mut self, input: impl Into<std::string::String>) -> Self {
            self.namespace = Some(input.into());
            self
        }
        pub fn set_namespace(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.namespace = input;
            self
        }
        pub fn dimensions(mut self, input: impl Into<crate::model::MetricDimension>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MetricDimension>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The statistic of the metric.</p>
        pub fn statistic(mut self, input: crate::model::MetricStatistic) -> Self {
            self.statistic = Some(input);
            self
        }
        pub fn set_statistic(
            mut self,
            input: std::option::Option<crate::model::MetricStatistic>,
        ) -> Self {
            self.statistic = input;
            self
        }
        /// <p>The unit of the metric.</p>
        pub fn unit(mut self, input: impl Into<std::string::String>) -> Self {
            self.unit = Some(input.into());
            self
        }
        pub fn set_unit(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.unit = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomizedMetricSpecification`](crate::model::CustomizedMetricSpecification)
        pub fn build(self) -> crate::model::CustomizedMetricSpecification {
            crate::model::CustomizedMetricSpecification {
                metric_name: self.metric_name,
                namespace: self.namespace,
                dimensions: self.dimensions,
                statistic: self.statistic,
                unit: self.unit,
            }
        }
    }
}
impl CustomizedMetricSpecification {
    /// Creates a new builder-style object to manufacture [`CustomizedMetricSpecification`](crate::model::CustomizedMetricSpecification)
    pub fn builder() -> crate::model::customized_metric_specification::Builder {
        crate::model::customized_metric_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricStatistic {
    Average,
    Maximum,
    Minimum,
    SampleCount,
    Sum,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MetricStatistic {
    fn from(s: &str) -> Self {
        match s {
            "Average" => MetricStatistic::Average,
            "Maximum" => MetricStatistic::Maximum,
            "Minimum" => MetricStatistic::Minimum,
            "SampleCount" => MetricStatistic::SampleCount,
            "Sum" => MetricStatistic::Sum,
            other => MetricStatistic::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MetricStatistic {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricStatistic::from(s))
    }
}
impl MetricStatistic {
    pub fn as_str(&self) -> &str {
        match self {
            MetricStatistic::Average => "Average",
            MetricStatistic::Maximum => "Maximum",
            MetricStatistic::Minimum => "Minimum",
            MetricStatistic::SampleCount => "SampleCount",
            MetricStatistic::Sum => "Sum",
            MetricStatistic::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["Average", "Maximum", "Minimum", "SampleCount", "Sum"]
    }
}
impl AsRef<str> for MetricStatistic {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the dimension of a metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricDimension {
    /// <p>The name of the dimension.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value of the dimension.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricDimension");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`MetricDimension`](crate::model::MetricDimension)
pub mod metric_dimension {
    /// A builder for [`MetricDimension`](crate::model::MetricDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the dimension.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value of the dimension.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDimension`](crate::model::MetricDimension)
        pub fn build(self) -> crate::model::MetricDimension {
            crate::model::MetricDimension {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl MetricDimension {
    /// Creates a new builder-style object to manufacture [`MetricDimension`](crate::model::MetricDimension)
    pub fn builder() -> crate::model::metric_dimension::Builder {
        crate::model::metric_dimension::Builder::default()
    }
}

/// <p>Represents a predefined metric for a target tracking scaling policy to use with
/// Amazon EC2 Auto Scaling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PredefinedMetricSpecification {
    /// <p>The metric type. The following predefined metrics are available:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>ASGAverageCPUUtilization</code> - Average CPU utilization of the Auto Scaling
    /// group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ASGAverageNetworkIn</code> - Average number of bytes received on all
    /// network interfaces by the Auto Scaling group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ASGAverageNetworkOut</code> - Average number of bytes sent out on all
    /// network interfaces by the Auto Scaling group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ALBRequestCountPerTarget</code> - Number of requests completed per
    /// target in an Application Load Balancer target group.</p>
    /// </li>
    /// </ul>
    pub predefined_metric_type: std::option::Option<crate::model::MetricType>,
    /// <p>A label that uniquely identifies a specific Application Load Balancer target group
    /// from which to determine the average request count served by your Auto Scaling group. You can't
    /// specify a resource label unless the target group is attached to the Auto Scaling group.</p>
    /// <p>You create the resource label by appending the final portion of the load balancer ARN
    /// and the final portion of the target group ARN into a single value, separated by a forward
    /// slash (/). The format of the resource label is:</p>
    /// <p>
    /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
    /// <p>Where:</p>
    /// <ul>
    /// <li>
    /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
    /// the load balancer ARN</p>
    /// </li>
    /// <li>
    /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
    /// of the target group ARN.</p>
    /// </li>
    /// </ul>
    /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
    /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
    pub resource_label: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PredefinedMetricSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PredefinedMetricSpecification");
        formatter.field("predefined_metric_type", &self.predefined_metric_type);
        formatter.field("resource_label", &self.resource_label);
        formatter.finish()
    }
}
/// See [`PredefinedMetricSpecification`](crate::model::PredefinedMetricSpecification)
pub mod predefined_metric_specification {
    /// A builder for [`PredefinedMetricSpecification`](crate::model::PredefinedMetricSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) predefined_metric_type: std::option::Option<crate::model::MetricType>,
        pub(crate) resource_label: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The metric type. The following predefined metrics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ASGAverageCPUUtilization</code> - Average CPU utilization of the Auto Scaling
        /// group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ASGAverageNetworkIn</code> - Average number of bytes received on all
        /// network interfaces by the Auto Scaling group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ASGAverageNetworkOut</code> - Average number of bytes sent out on all
        /// network interfaces by the Auto Scaling group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALBRequestCountPerTarget</code> - Number of requests completed per
        /// target in an Application Load Balancer target group.</p>
        /// </li>
        /// </ul>
        pub fn predefined_metric_type(mut self, input: crate::model::MetricType) -> Self {
            self.predefined_metric_type = Some(input);
            self
        }
        pub fn set_predefined_metric_type(
            mut self,
            input: std::option::Option<crate::model::MetricType>,
        ) -> Self {
            self.predefined_metric_type = input;
            self
        }
        /// <p>A label that uniquely identifies a specific Application Load Balancer target group
        /// from which to determine the average request count served by your Auto Scaling group. You can't
        /// specify a resource label unless the target group is attached to the Auto Scaling group.</p>
        /// <p>You create the resource label by appending the final portion of the load balancer ARN
        /// and the final portion of the target group ARN into a single value, separated by a forward
        /// slash (/). The format of the resource label is:</p>
        /// <p>
        /// <code>app/my-alb/778d41231b141a0f/targetgroup/my-alb-target-group/943f017f100becff</code>.</p>
        /// <p>Where:</p>
        /// <ul>
        /// <li>
        /// <p>app/<load-balancer-name>/<load-balancer-id> is the final portion of
        /// the load balancer ARN</p>
        /// </li>
        /// <li>
        /// <p>targetgroup/<target-group-name>/<target-group-id> is the final portion
        /// of the target group ARN.</p>
        /// </li>
        /// </ul>
        /// <p>To find the ARN for an Application Load Balancer, use the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html">DescribeLoadBalancers</a> API operation. To find the ARN for the target group, use
        /// the <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn resource_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_label = Some(input.into());
            self
        }
        pub fn set_resource_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_label = input;
            self
        }
        /// Consumes the builder and constructs a [`PredefinedMetricSpecification`](crate::model::PredefinedMetricSpecification)
        pub fn build(self) -> crate::model::PredefinedMetricSpecification {
            crate::model::PredefinedMetricSpecification {
                predefined_metric_type: self.predefined_metric_type,
                resource_label: self.resource_label,
            }
        }
    }
}
impl PredefinedMetricSpecification {
    /// Creates a new builder-style object to manufacture [`PredefinedMetricSpecification`](crate::model::PredefinedMetricSpecification)
    pub fn builder() -> crate::model::predefined_metric_specification::Builder {
        crate::model::predefined_metric_specification::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MetricType {
    AlbRequestCountPerTarget,
    AsgAverageCpuUtilization,
    AsgAverageNetworkIn,
    AsgAverageNetworkOut,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MetricType {
    fn from(s: &str) -> Self {
        match s {
            "ALBRequestCountPerTarget" => MetricType::AlbRequestCountPerTarget,
            "ASGAverageCPUUtilization" => MetricType::AsgAverageCpuUtilization,
            "ASGAverageNetworkIn" => MetricType::AsgAverageNetworkIn,
            "ASGAverageNetworkOut" => MetricType::AsgAverageNetworkOut,
            other => MetricType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MetricType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MetricType::from(s))
    }
}
impl MetricType {
    pub fn as_str(&self) -> &str {
        match self {
            MetricType::AlbRequestCountPerTarget => "ALBRequestCountPerTarget",
            MetricType::AsgAverageCpuUtilization => "ASGAverageCPUUtilization",
            MetricType::AsgAverageNetworkIn => "ASGAverageNetworkIn",
            MetricType::AsgAverageNetworkOut => "ASGAverageNetworkOut",
            MetricType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ALBRequestCountPerTarget",
            "ASGAverageCPUUtilization",
            "ASGAverageNetworkIn",
            "ASGAverageNetworkOut",
        ]
    }
}
impl AsRef<str> for MetricType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes information used to create a step adjustment for a step scaling
/// policy.</p>
/// <p>For the following examples, suppose that you have an alarm with a breach threshold of
/// 50:</p>
/// <ul>
/// <li>
/// <p>To trigger the adjustment when the metric is greater than or equal to 50 and
/// less than 60, specify a lower bound of 0 and an upper bound of 10.</p>
/// </li>
/// <li>
/// <p>To trigger the adjustment when the metric is greater than 40 and less than or
/// equal to 50, specify a lower bound of -10 and an upper bound of 0.</p>
/// </li>
/// </ul>
/// <p>There are a few rules for the step adjustments for your step policy:</p>
/// <ul>
/// <li>
/// <p>The ranges of your step adjustments can't overlap or have a gap.</p>
/// </li>
/// <li>
/// <p>At most, one step adjustment can have a null lower bound. If one step
/// adjustment has a negative lower bound, then there must be a step adjustment with
/// a null lower bound.</p>
/// </li>
/// <li>
/// <p>At most, one step adjustment can have a null upper bound. If one step
/// adjustment has a positive upper bound, then there must be a step adjustment with
/// a null upper bound.</p>
/// </li>
/// <li>
/// <p>The upper and lower bound can't be null in the same step adjustment.</p>
/// </li>
/// </ul>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-steps">Step
/// adjustments</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StepAdjustment {
    /// <p>The lower bound for the difference between the alarm threshold and the CloudWatch metric. If
    /// the metric value is above the breach threshold, the lower bound is inclusive (the metric
    /// must be greater than or equal to the threshold plus the lower bound). Otherwise, it is
    /// exclusive (the metric must be greater than the threshold plus the lower bound). A null
    /// value indicates negative infinity.</p>
    pub metric_interval_lower_bound: std::option::Option<f64>,
    /// <p>The upper bound for the difference between the alarm threshold and the CloudWatch metric. If
    /// the metric value is above the breach threshold, the upper bound is exclusive (the metric
    /// must be less than the threshold plus the upper bound). Otherwise, it is inclusive (the
    /// metric must be less than or equal to the threshold plus the upper bound). A null value
    /// indicates positive infinity.</p>
    /// <p>The upper bound must be greater than the lower bound.</p>
    pub metric_interval_upper_bound: std::option::Option<f64>,
    /// <p>The amount by which to scale, based on the specified adjustment type. A positive value
    /// adds to the current capacity while a negative number removes from the current
    /// capacity.</p>
    pub scaling_adjustment: std::option::Option<i32>,
}
impl std::fmt::Debug for StepAdjustment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StepAdjustment");
        formatter.field(
            "metric_interval_lower_bound",
            &self.metric_interval_lower_bound,
        );
        formatter.field(
            "metric_interval_upper_bound",
            &self.metric_interval_upper_bound,
        );
        formatter.field("scaling_adjustment", &self.scaling_adjustment);
        formatter.finish()
    }
}
/// See [`StepAdjustment`](crate::model::StepAdjustment)
pub mod step_adjustment {
    /// A builder for [`StepAdjustment`](crate::model::StepAdjustment)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric_interval_lower_bound: std::option::Option<f64>,
        pub(crate) metric_interval_upper_bound: std::option::Option<f64>,
        pub(crate) scaling_adjustment: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The lower bound for the difference between the alarm threshold and the CloudWatch metric. If
        /// the metric value is above the breach threshold, the lower bound is inclusive (the metric
        /// must be greater than or equal to the threshold plus the lower bound). Otherwise, it is
        /// exclusive (the metric must be greater than the threshold plus the lower bound). A null
        /// value indicates negative infinity.</p>
        pub fn metric_interval_lower_bound(mut self, input: f64) -> Self {
            self.metric_interval_lower_bound = Some(input);
            self
        }
        pub fn set_metric_interval_lower_bound(mut self, input: std::option::Option<f64>) -> Self {
            self.metric_interval_lower_bound = input;
            self
        }
        /// <p>The upper bound for the difference between the alarm threshold and the CloudWatch metric. If
        /// the metric value is above the breach threshold, the upper bound is exclusive (the metric
        /// must be less than the threshold plus the upper bound). Otherwise, it is inclusive (the
        /// metric must be less than or equal to the threshold plus the upper bound). A null value
        /// indicates positive infinity.</p>
        /// <p>The upper bound must be greater than the lower bound.</p>
        pub fn metric_interval_upper_bound(mut self, input: f64) -> Self {
            self.metric_interval_upper_bound = Some(input);
            self
        }
        pub fn set_metric_interval_upper_bound(mut self, input: std::option::Option<f64>) -> Self {
            self.metric_interval_upper_bound = input;
            self
        }
        /// <p>The amount by which to scale, based on the specified adjustment type. A positive value
        /// adds to the current capacity while a negative number removes from the current
        /// capacity.</p>
        pub fn scaling_adjustment(mut self, input: i32) -> Self {
            self.scaling_adjustment = Some(input);
            self
        }
        pub fn set_scaling_adjustment(mut self, input: std::option::Option<i32>) -> Self {
            self.scaling_adjustment = input;
            self
        }
        /// Consumes the builder and constructs a [`StepAdjustment`](crate::model::StepAdjustment)
        pub fn build(self) -> crate::model::StepAdjustment {
            crate::model::StepAdjustment {
                metric_interval_lower_bound: self.metric_interval_lower_bound,
                metric_interval_upper_bound: self.metric_interval_upper_bound,
                scaling_adjustment: self.scaling_adjustment,
            }
        }
    }
}
impl StepAdjustment {
    /// Creates a new builder-style object to manufacture [`StepAdjustment`](crate::model::StepAdjustment)
    pub fn builder() -> crate::model::step_adjustment::Builder {
        crate::model::step_adjustment::Builder::default()
    }
}

/// <p>A <code>GetPredictiveScalingForecast</code> call returns the capacity forecast for a
/// predictive scaling policy. This structure includes the data points for that capacity
/// forecast, along with the timestamps of those data points. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CapacityForecast {
    /// <p>The time stamps for the data points, in UTC format.</p>
    pub timestamps: std::option::Option<std::vec::Vec<smithy_types::Instant>>,
    /// <p>The values of the data points.</p>
    pub values: std::option::Option<std::vec::Vec<f64>>,
}
impl std::fmt::Debug for CapacityForecast {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CapacityForecast");
        formatter.field("timestamps", &self.timestamps);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`CapacityForecast`](crate::model::CapacityForecast)
pub mod capacity_forecast {
    /// A builder for [`CapacityForecast`](crate::model::CapacityForecast)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamps: std::option::Option<std::vec::Vec<smithy_types::Instant>>,
        pub(crate) values: std::option::Option<std::vec::Vec<f64>>,
    }
    impl Builder {
        pub fn timestamps(mut self, input: impl Into<smithy_types::Instant>) -> Self {
            let mut v = self.timestamps.unwrap_or_default();
            v.push(input.into());
            self.timestamps = Some(v);
            self
        }
        pub fn set_timestamps(
            mut self,
            input: std::option::Option<std::vec::Vec<smithy_types::Instant>>,
        ) -> Self {
            self.timestamps = input;
            self
        }
        pub fn values(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityForecast`](crate::model::CapacityForecast)
        pub fn build(self) -> crate::model::CapacityForecast {
            crate::model::CapacityForecast {
                timestamps: self.timestamps,
                values: self.values,
            }
        }
    }
}
impl CapacityForecast {
    /// Creates a new builder-style object to manufacture [`CapacityForecast`](crate::model::CapacityForecast)
    pub fn builder() -> crate::model::capacity_forecast::Builder {
        crate::model::capacity_forecast::Builder::default()
    }
}

/// <p>A <code>GetPredictiveScalingForecast</code> call returns the load forecast for a
/// predictive scaling policy. This structure includes the data points for that load
/// forecast, along with the timestamps of those data points and the metric specification.
/// </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadForecast {
    /// <p>The time stamps for the data points, in UTC format.</p>
    pub timestamps: std::option::Option<std::vec::Vec<smithy_types::Instant>>,
    /// <p>The values of the data points.</p>
    pub values: std::option::Option<std::vec::Vec<f64>>,
    /// <p>The metric specification for the load forecast.</p>
    pub metric_specification:
        std::option::Option<crate::model::PredictiveScalingMetricSpecification>,
}
impl std::fmt::Debug for LoadForecast {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadForecast");
        formatter.field("timestamps", &self.timestamps);
        formatter.field("values", &self.values);
        formatter.field("metric_specification", &self.metric_specification);
        formatter.finish()
    }
}
/// See [`LoadForecast`](crate::model::LoadForecast)
pub mod load_forecast {
    /// A builder for [`LoadForecast`](crate::model::LoadForecast)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) timestamps: std::option::Option<std::vec::Vec<smithy_types::Instant>>,
        pub(crate) values: std::option::Option<std::vec::Vec<f64>>,
        pub(crate) metric_specification:
            std::option::Option<crate::model::PredictiveScalingMetricSpecification>,
    }
    impl Builder {
        pub fn timestamps(mut self, input: impl Into<smithy_types::Instant>) -> Self {
            let mut v = self.timestamps.unwrap_or_default();
            v.push(input.into());
            self.timestamps = Some(v);
            self
        }
        pub fn set_timestamps(
            mut self,
            input: std::option::Option<std::vec::Vec<smithy_types::Instant>>,
        ) -> Self {
            self.timestamps = input;
            self
        }
        pub fn values(mut self, input: impl Into<f64>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(mut self, input: std::option::Option<std::vec::Vec<f64>>) -> Self {
            self.values = input;
            self
        }
        /// <p>The metric specification for the load forecast.</p>
        pub fn metric_specification(
            mut self,
            input: crate::model::PredictiveScalingMetricSpecification,
        ) -> Self {
            self.metric_specification = Some(input);
            self
        }
        pub fn set_metric_specification(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingMetricSpecification>,
        ) -> Self {
            self.metric_specification = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadForecast`](crate::model::LoadForecast)
        pub fn build(self) -> crate::model::LoadForecast {
            crate::model::LoadForecast {
                timestamps: self.timestamps,
                values: self.values,
                metric_specification: self.metric_specification,
            }
        }
    }
}
impl LoadForecast {
    /// Creates a new builder-style object to manufacture [`LoadForecast`](crate::model::LoadForecast)
    pub fn builder() -> crate::model::load_forecast::Builder {
        crate::model::load_forecast::Builder::default()
    }
}

/// <p>Describes an EC2 instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Instance {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance type of the EC2 instance.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The Availability Zone in which the instance is running.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>A description of the current lifecycle state. The <code>Quarantined</code> state is
    /// not used. For information about lifecycle states, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroupLifecycle.html">Instance
    /// lifecycle</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
    pub lifecycle_state: std::option::Option<crate::model::LifecycleState>,
    /// <p>The last reported health status of the instance. "Healthy" means that the instance is
    /// healthy and should remain in service. "Unhealthy" means that the instance is unhealthy
    /// and that Amazon EC2 Auto Scaling should terminate and replace it.</p>
    pub health_status: std::option::Option<std::string::String>,
    /// <p>The launch configuration associated with the instance.</p>
    pub launch_configuration_name: std::option::Option<std::string::String>,
    /// <p>The launch template for the instance.</p>
    pub launch_template: std::option::Option<crate::model::LaunchTemplateSpecification>,
    /// <p>Indicates whether the instance is protected from termination by Amazon EC2 Auto Scaling when scaling
    /// in.</p>
    pub protected_from_scale_in: std::option::Option<bool>,
    /// <p>The number of capacity units contributed by the instance based on its instance
    /// type.</p>
    /// <p>Valid Range: Minimum value of 1. Maximum value of 999.</p>
    pub weighted_capacity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Instance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Instance");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("lifecycle_state", &self.lifecycle_state);
        formatter.field("health_status", &self.health_status);
        formatter.field("launch_configuration_name", &self.launch_configuration_name);
        formatter.field("launch_template", &self.launch_template);
        formatter.field("protected_from_scale_in", &self.protected_from_scale_in);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.finish()
    }
}
/// See [`Instance`](crate::model::Instance)
pub mod instance {
    /// A builder for [`Instance`](crate::model::Instance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) lifecycle_state: std::option::Option<crate::model::LifecycleState>,
        pub(crate) health_status: std::option::Option<std::string::String>,
        pub(crate) launch_configuration_name: std::option::Option<std::string::String>,
        pub(crate) launch_template: std::option::Option<crate::model::LaunchTemplateSpecification>,
        pub(crate) protected_from_scale_in: std::option::Option<bool>,
        pub(crate) weighted_capacity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance type of the EC2 instance.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The Availability Zone in which the instance is running.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>A description of the current lifecycle state. The <code>Quarantined</code> state is
        /// not used. For information about lifecycle states, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroupLifecycle.html">Instance
        /// lifecycle</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
        pub fn lifecycle_state(mut self, input: crate::model::LifecycleState) -> Self {
            self.lifecycle_state = Some(input);
            self
        }
        pub fn set_lifecycle_state(
            mut self,
            input: std::option::Option<crate::model::LifecycleState>,
        ) -> Self {
            self.lifecycle_state = input;
            self
        }
        /// <p>The last reported health status of the instance. "Healthy" means that the instance is
        /// healthy and should remain in service. "Unhealthy" means that the instance is unhealthy
        /// and that Amazon EC2 Auto Scaling should terminate and replace it.</p>
        pub fn health_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_status = Some(input.into());
            self
        }
        pub fn set_health_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_status = input;
            self
        }
        /// <p>The launch configuration associated with the instance.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_name = Some(input.into());
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_name = input;
            self
        }
        /// <p>The launch template for the instance.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.launch_template = Some(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template = input;
            self
        }
        /// <p>Indicates whether the instance is protected from termination by Amazon EC2 Auto Scaling when scaling
        /// in.</p>
        pub fn protected_from_scale_in(mut self, input: bool) -> Self {
            self.protected_from_scale_in = Some(input);
            self
        }
        pub fn set_protected_from_scale_in(mut self, input: std::option::Option<bool>) -> Self {
            self.protected_from_scale_in = input;
            self
        }
        /// <p>The number of capacity units contributed by the instance based on its instance
        /// type.</p>
        /// <p>Valid Range: Minimum value of 1. Maximum value of 999.</p>
        pub fn weighted_capacity(mut self, input: impl Into<std::string::String>) -> Self {
            self.weighted_capacity = Some(input.into());
            self
        }
        pub fn set_weighted_capacity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`Instance`](crate::model::Instance)
        pub fn build(self) -> crate::model::Instance {
            crate::model::Instance {
                instance_id: self.instance_id,
                instance_type: self.instance_type,
                availability_zone: self.availability_zone,
                lifecycle_state: self.lifecycle_state,
                health_status: self.health_status,
                launch_configuration_name: self.launch_configuration_name,
                launch_template: self.launch_template,
                protected_from_scale_in: self.protected_from_scale_in,
                weighted_capacity: self.weighted_capacity,
            }
        }
    }
}
impl Instance {
    /// Creates a new builder-style object to manufacture [`Instance`](crate::model::Instance)
    pub fn builder() -> crate::model::instance::Builder {
        crate::model::instance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LifecycleState {
    Detached,
    Detaching,
    EnteringStandby,
    InService,
    Pending,
    PendingProceed,
    PendingWait,
    Quarantined,
    Standby,
    Terminated,
    Terminating,
    TerminatingProceed,
    TerminatingWait,
    WarmedPending,
    WarmedPendingProceed,
    WarmedPendingWait,
    WarmedRunning,
    WarmedStopped,
    WarmedTerminated,
    WarmedTerminating,
    WarmedTerminatingProceed,
    WarmedTerminatingWait,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LifecycleState {
    fn from(s: &str) -> Self {
        match s {
            "Detached" => LifecycleState::Detached,
            "Detaching" => LifecycleState::Detaching,
            "EnteringStandby" => LifecycleState::EnteringStandby,
            "InService" => LifecycleState::InService,
            "Pending" => LifecycleState::Pending,
            "Pending:Proceed" => LifecycleState::PendingProceed,
            "Pending:Wait" => LifecycleState::PendingWait,
            "Quarantined" => LifecycleState::Quarantined,
            "Standby" => LifecycleState::Standby,
            "Terminated" => LifecycleState::Terminated,
            "Terminating" => LifecycleState::Terminating,
            "Terminating:Proceed" => LifecycleState::TerminatingProceed,
            "Terminating:Wait" => LifecycleState::TerminatingWait,
            "Warmed:Pending" => LifecycleState::WarmedPending,
            "Warmed:Pending:Proceed" => LifecycleState::WarmedPendingProceed,
            "Warmed:Pending:Wait" => LifecycleState::WarmedPendingWait,
            "Warmed:Running" => LifecycleState::WarmedRunning,
            "Warmed:Stopped" => LifecycleState::WarmedStopped,
            "Warmed:Terminated" => LifecycleState::WarmedTerminated,
            "Warmed:Terminating" => LifecycleState::WarmedTerminating,
            "Warmed:Terminating:Proceed" => LifecycleState::WarmedTerminatingProceed,
            "Warmed:Terminating:Wait" => LifecycleState::WarmedTerminatingWait,
            other => LifecycleState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LifecycleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LifecycleState::from(s))
    }
}
impl LifecycleState {
    pub fn as_str(&self) -> &str {
        match self {
            LifecycleState::Detached => "Detached",
            LifecycleState::Detaching => "Detaching",
            LifecycleState::EnteringStandby => "EnteringStandby",
            LifecycleState::InService => "InService",
            LifecycleState::Pending => "Pending",
            LifecycleState::PendingProceed => "Pending:Proceed",
            LifecycleState::PendingWait => "Pending:Wait",
            LifecycleState::Quarantined => "Quarantined",
            LifecycleState::Standby => "Standby",
            LifecycleState::Terminated => "Terminated",
            LifecycleState::Terminating => "Terminating",
            LifecycleState::TerminatingProceed => "Terminating:Proceed",
            LifecycleState::TerminatingWait => "Terminating:Wait",
            LifecycleState::WarmedPending => "Warmed:Pending",
            LifecycleState::WarmedPendingProceed => "Warmed:Pending:Proceed",
            LifecycleState::WarmedPendingWait => "Warmed:Pending:Wait",
            LifecycleState::WarmedRunning => "Warmed:Running",
            LifecycleState::WarmedStopped => "Warmed:Stopped",
            LifecycleState::WarmedTerminated => "Warmed:Terminated",
            LifecycleState::WarmedTerminating => "Warmed:Terminating",
            LifecycleState::WarmedTerminatingProceed => "Warmed:Terminating:Proceed",
            LifecycleState::WarmedTerminatingWait => "Warmed:Terminating:Wait",
            LifecycleState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Detached",
            "Detaching",
            "EnteringStandby",
            "InService",
            "Pending",
            "Pending:Proceed",
            "Pending:Wait",
            "Quarantined",
            "Standby",
            "Terminated",
            "Terminating",
            "Terminating:Proceed",
            "Terminating:Wait",
            "Warmed:Pending",
            "Warmed:Pending:Proceed",
            "Warmed:Pending:Wait",
            "Warmed:Running",
            "Warmed:Stopped",
            "Warmed:Terminated",
            "Warmed:Terminating",
            "Warmed:Terminating:Proceed",
            "Warmed:Terminating:Wait",
        ]
    }
}
impl AsRef<str> for LifecycleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a warm pool configuration. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WarmPoolConfiguration {
    /// <p>The maximum number of instances that are allowed to be in the warm pool or in any
    /// state except <code>Terminated</code> for the Auto Scaling group.</p>
    pub max_group_prepared_capacity: std::option::Option<i32>,
    /// <p>The minimum number of instances to maintain in the warm pool.</p>
    pub min_size: std::option::Option<i32>,
    /// <p>The instance state to transition to after the lifecycle actions are complete.</p>
    pub pool_state: std::option::Option<crate::model::WarmPoolState>,
    /// <p>The status of a warm pool that is marked for deletion.</p>
    pub status: std::option::Option<crate::model::WarmPoolStatus>,
}
impl std::fmt::Debug for WarmPoolConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WarmPoolConfiguration");
        formatter.field(
            "max_group_prepared_capacity",
            &self.max_group_prepared_capacity,
        );
        formatter.field("min_size", &self.min_size);
        formatter.field("pool_state", &self.pool_state);
        formatter.field("status", &self.status);
        formatter.finish()
    }
}
/// See [`WarmPoolConfiguration`](crate::model::WarmPoolConfiguration)
pub mod warm_pool_configuration {
    /// A builder for [`WarmPoolConfiguration`](crate::model::WarmPoolConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) max_group_prepared_capacity: std::option::Option<i32>,
        pub(crate) min_size: std::option::Option<i32>,
        pub(crate) pool_state: std::option::Option<crate::model::WarmPoolState>,
        pub(crate) status: std::option::Option<crate::model::WarmPoolStatus>,
    }
    impl Builder {
        /// <p>The maximum number of instances that are allowed to be in the warm pool or in any
        /// state except <code>Terminated</code> for the Auto Scaling group.</p>
        pub fn max_group_prepared_capacity(mut self, input: i32) -> Self {
            self.max_group_prepared_capacity = Some(input);
            self
        }
        pub fn set_max_group_prepared_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.max_group_prepared_capacity = input;
            self
        }
        /// <p>The minimum number of instances to maintain in the warm pool.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.min_size = Some(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.min_size = input;
            self
        }
        /// <p>The instance state to transition to after the lifecycle actions are complete.</p>
        pub fn pool_state(mut self, input: crate::model::WarmPoolState) -> Self {
            self.pool_state = Some(input);
            self
        }
        pub fn set_pool_state(
            mut self,
            input: std::option::Option<crate::model::WarmPoolState>,
        ) -> Self {
            self.pool_state = input;
            self
        }
        /// <p>The status of a warm pool that is marked for deletion.</p>
        pub fn status(mut self, input: crate::model::WarmPoolStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::WarmPoolStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// Consumes the builder and constructs a [`WarmPoolConfiguration`](crate::model::WarmPoolConfiguration)
        pub fn build(self) -> crate::model::WarmPoolConfiguration {
            crate::model::WarmPoolConfiguration {
                max_group_prepared_capacity: self.max_group_prepared_capacity,
                min_size: self.min_size,
                pool_state: self.pool_state,
                status: self.status,
            }
        }
    }
}
impl WarmPoolConfiguration {
    /// Creates a new builder-style object to manufacture [`WarmPoolConfiguration`](crate::model::WarmPoolConfiguration)
    pub fn builder() -> crate::model::warm_pool_configuration::Builder {
        crate::model::warm_pool_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WarmPoolStatus {
    PendingDelete,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for WarmPoolStatus {
    fn from(s: &str) -> Self {
        match s {
            "PendingDelete" => WarmPoolStatus::PendingDelete,
            other => WarmPoolStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for WarmPoolStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WarmPoolStatus::from(s))
    }
}
impl WarmPoolStatus {
    pub fn as_str(&self) -> &str {
        match self {
            WarmPoolStatus::PendingDelete => "PendingDelete",
            WarmPoolStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["PendingDelete"]
    }
}
impl AsRef<str> for WarmPoolStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a tag for an Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagDescription {
    /// <p>The name of the group.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource. The only supported value is
    /// <code>auto-scaling-group</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>Determines whether the tag is added to new instances as they are launched in the
    /// group.</p>
    pub propagate_at_launch: std::option::Option<bool>,
}
impl std::fmt::Debug for TagDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagDescription");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.field("propagate_at_launch", &self.propagate_at_launch);
        formatter.finish()
    }
}
/// See [`TagDescription`](crate::model::TagDescription)
pub mod tag_description {
    /// A builder for [`TagDescription`](crate::model::TagDescription)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) propagate_at_launch: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the group.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource. The only supported value is
        /// <code>auto-scaling-group</code>.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Determines whether the tag is added to new instances as they are launched in the
        /// group.</p>
        pub fn propagate_at_launch(mut self, input: bool) -> Self {
            self.propagate_at_launch = Some(input);
            self
        }
        pub fn set_propagate_at_launch(mut self, input: std::option::Option<bool>) -> Self {
            self.propagate_at_launch = input;
            self
        }
        /// Consumes the builder and constructs a [`TagDescription`](crate::model::TagDescription)
        pub fn build(self) -> crate::model::TagDescription {
            crate::model::TagDescription {
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                key: self.key,
                value: self.value,
                propagate_at_launch: self.propagate_at_launch,
            }
        }
    }
}
impl TagDescription {
    /// Creates a new builder-style object to manufacture [`TagDescription`](crate::model::TagDescription)
    pub fn builder() -> crate::model::tag_description::Builder {
        crate::model::tag_description::Builder::default()
    }
}

/// <p>Describes a filter that is used to return a more specific list of results when
/// describing tags.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-tagging.html">Tagging Auto Scaling groups and
/// instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Filter {
    /// <p>The name of the filter. The valid values are: <code>auto-scaling-group</code>,
    /// <code>key</code>, <code>value</code>, and <code>propagate-at-launch</code>.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>One or more filter values. Filter values are case-sensitive.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Filter");
        formatter.field("name", &self.name);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`Filter`](crate::model::Filter)
pub mod filter {
    /// A builder for [`Filter`](crate::model::Filter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The name of the filter. The valid values are: <code>auto-scaling-group</code>,
        /// <code>key</code>, <code>value</code>, and <code>propagate-at-launch</code>.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`Filter`](crate::model::Filter)
        pub fn build(self) -> crate::model::Filter {
            crate::model::Filter {
                name: self.name,
                values: self.values,
            }
        }
    }
}
impl Filter {
    /// Creates a new builder-style object to manufacture [`Filter`](crate::model::Filter)
    pub fn builder() -> crate::model::filter::Builder {
        crate::model::filter::Builder::default()
    }
}

/// <p>Describes a scheduled scaling
/// action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledUpdateGroupAction {
    /// <p>The name of the Auto Scaling group.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the scheduled action.</p>
    pub scheduled_action_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the scheduled action.</p>
    pub scheduled_action_arn: std::option::Option<std::string::String>,
    /// <p>This parameter is no longer used.</p>
    pub time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time in UTC for this action to start. For example,
    /// <code>"2019-06-01T00:00:00Z"</code>.
    /// </p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time in UTC for the recurring schedule to end. For example,
    /// <code>"2019-06-01T00:00:00Z"</code>.
    /// </p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The recurring schedule for the action, in Unix cron syntax format.</p>
    /// <p>When <code>StartTime</code> and <code>EndTime</code> are specified with
    /// <code>Recurrence</code>, they form the boundaries of when the recurring action
    /// starts and stops.</p>
    pub recurrence: std::option::Option<std::string::String>,
    /// <p>The minimum size of the Auto Scaling group.</p>
    pub min_size: std::option::Option<i32>,
    /// <p>The maximum size of the Auto Scaling group.</p>
    pub max_size: std::option::Option<i32>,
    /// <p>The desired capacity is the initial capacity of the Auto Scaling group after the scheduled
    /// action runs and the capacity it attempts to maintain.</p>
    pub desired_capacity: std::option::Option<i32>,
    /// <p>The time zone for the cron expression.</p>
    pub time_zone: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledUpdateGroupAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledUpdateGroupAction");
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("scheduled_action_name", &self.scheduled_action_name);
        formatter.field("scheduled_action_arn", &self.scheduled_action_arn);
        formatter.field("time", &self.time);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("recurrence", &self.recurrence);
        formatter.field("min_size", &self.min_size);
        formatter.field("max_size", &self.max_size);
        formatter.field("desired_capacity", &self.desired_capacity);
        formatter.field("time_zone", &self.time_zone);
        formatter.finish()
    }
}
/// See [`ScheduledUpdateGroupAction`](crate::model::ScheduledUpdateGroupAction)
pub mod scheduled_update_group_action {
    /// A builder for [`ScheduledUpdateGroupAction`](crate::model::ScheduledUpdateGroupAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) scheduled_action_name: std::option::Option<std::string::String>,
        pub(crate) scheduled_action_arn: std::option::Option<std::string::String>,
        pub(crate) time: std::option::Option<smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) recurrence: std::option::Option<std::string::String>,
        pub(crate) min_size: std::option::Option<i32>,
        pub(crate) max_size: std::option::Option<i32>,
        pub(crate) desired_capacity: std::option::Option<i32>,
        pub(crate) time_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The name of the scheduled action.</p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_action_name = Some(input.into());
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_action_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the scheduled action.</p>
        pub fn scheduled_action_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_action_arn = Some(input.into());
            self
        }
        pub fn set_scheduled_action_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_action_arn = input;
            self
        }
        /// <p>This parameter is no longer used.</p>
        pub fn time(mut self, input: smithy_types::Instant) -> Self {
            self.time = Some(input);
            self
        }
        pub fn set_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.time = input;
            self
        }
        /// <p>The date and time in UTC for this action to start. For example,
        /// <code>"2019-06-01T00:00:00Z"</code>.
        /// </p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The date and time in UTC for the recurring schedule to end. For example,
        /// <code>"2019-06-01T00:00:00Z"</code>.
        /// </p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The recurring schedule for the action, in Unix cron syntax format.</p>
        /// <p>When <code>StartTime</code> and <code>EndTime</code> are specified with
        /// <code>Recurrence</code>, they form the boundaries of when the recurring action
        /// starts and stops.</p>
        pub fn recurrence(mut self, input: impl Into<std::string::String>) -> Self {
            self.recurrence = Some(input.into());
            self
        }
        pub fn set_recurrence(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.recurrence = input;
            self
        }
        /// <p>The minimum size of the Auto Scaling group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.min_size = Some(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.min_size = input;
            self
        }
        /// <p>The maximum size of the Auto Scaling group.</p>
        pub fn max_size(mut self, input: i32) -> Self {
            self.max_size = Some(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.max_size = input;
            self
        }
        /// <p>The desired capacity is the initial capacity of the Auto Scaling group after the scheduled
        /// action runs and the capacity it attempts to maintain.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.desired_capacity = Some(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_capacity = input;
            self
        }
        /// <p>The time zone for the cron expression.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_zone = Some(input.into());
            self
        }
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledUpdateGroupAction`](crate::model::ScheduledUpdateGroupAction)
        pub fn build(self) -> crate::model::ScheduledUpdateGroupAction {
            crate::model::ScheduledUpdateGroupAction {
                auto_scaling_group_name: self.auto_scaling_group_name,
                scheduled_action_name: self.scheduled_action_name,
                scheduled_action_arn: self.scheduled_action_arn,
                time: self.time,
                start_time: self.start_time,
                end_time: self.end_time,
                recurrence: self.recurrence,
                min_size: self.min_size,
                max_size: self.max_size,
                desired_capacity: self.desired_capacity,
                time_zone: self.time_zone,
            }
        }
    }
}
impl ScheduledUpdateGroupAction {
    /// Creates a new builder-style object to manufacture [`ScheduledUpdateGroupAction`](crate::model::ScheduledUpdateGroupAction)
    pub fn builder() -> crate::model::scheduled_update_group_action::Builder {
        crate::model::scheduled_update_group_action::Builder::default()
    }
}

/// <p>Describes a process type.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html#process-types">Scaling processes</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ProcessType {
    /// <p>One of the following processes:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Launch</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Terminate</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AddToLoadBalancer</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AlarmNotification</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>AZRebalance</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>HealthCheck</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InstanceRefresh</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ReplaceUnhealthy</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>ScheduledActions</code>
    /// </p>
    /// </li>
    /// </ul>
    pub process_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ProcessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ProcessType");
        formatter.field("process_name", &self.process_name);
        formatter.finish()
    }
}
/// See [`ProcessType`](crate::model::ProcessType)
pub mod process_type {
    /// A builder for [`ProcessType`](crate::model::ProcessType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) process_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One of the following processes:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Launch</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Terminate</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AddToLoadBalancer</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AlarmNotification</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AZRebalance</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HealthCheck</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InstanceRefresh</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReplaceUnhealthy</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ScheduledActions</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn process_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.process_name = Some(input.into());
            self
        }
        pub fn set_process_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.process_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ProcessType`](crate::model::ProcessType)
        pub fn build(self) -> crate::model::ProcessType {
            crate::model::ProcessType {
                process_name: self.process_name,
            }
        }
    }
}
impl ProcessType {
    /// Creates a new builder-style object to manufacture [`ProcessType`](crate::model::ProcessType)
    pub fn builder() -> crate::model::process_type::Builder {
        crate::model::process_type::Builder::default()
    }
}

/// <p>Describes a scaling policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScalingPolicy {
    /// <p>The name of the Auto Scaling group.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The name of the scaling policy.</p>
    pub policy_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the policy.</p>
    pub policy_arn: std::option::Option<std::string::String>,
    /// <p>One of the following policy types: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>TargetTrackingScaling</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>StepScaling</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>SimpleScaling</code> (default)</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>PredictiveScaling</code>
    /// </p>
    /// </li>
    /// </ul>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-target-tracking.html">Target tracking
    /// scaling policies</a> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html">Step and simple scaling
    /// policies</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub policy_type: std::option::Option<std::string::String>,
    /// <p>Specifies how the scaling adjustment is interpreted (for example, an absolute number
    /// or a percentage). The valid values are <code>ChangeInCapacity</code>,
    /// <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>
    pub adjustment_type: std::option::Option<std::string::String>,
    /// <p>Available for backward compatibility. Use <code>MinAdjustmentMagnitude</code>
    /// instead.</p>
    pub min_adjustment_step: std::option::Option<i32>,
    /// <p>The minimum value to scale by when the adjustment type is
    /// <code>PercentChangeInCapacity</code>. </p>
    pub min_adjustment_magnitude: std::option::Option<i32>,
    /// <p>The amount by which to scale, based on the specified adjustment type. A positive value
    /// adds to the current capacity while a negative number removes from the current
    /// capacity.</p>
    pub scaling_adjustment: std::option::Option<i32>,
    /// <p>The duration of the policy's cooldown period, in seconds.</p>
    pub cooldown: std::option::Option<i32>,
    /// <p>A set of adjustments that enable you to scale based on the size of the alarm
    /// breach.</p>
    pub step_adjustments: std::option::Option<std::vec::Vec<crate::model::StepAdjustment>>,
    /// <p>The aggregation type for the CloudWatch metrics. The valid values are <code>Minimum</code>,
    /// <code>Maximum</code>, and <code>Average</code>.</p>
    pub metric_aggregation_type: std::option::Option<std::string::String>,
    /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
    /// CloudWatch metrics.</p>
    pub estimated_instance_warmup: std::option::Option<i32>,
    /// <p>The CloudWatch alarms related to the policy.</p>
    pub alarms: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
    /// <p>A target tracking scaling policy.</p>
    pub target_tracking_configuration:
        std::option::Option<crate::model::TargetTrackingConfiguration>,
    /// <p>Indicates whether the policy is enabled (<code>true</code>) or disabled
    /// (<code>false</code>).</p>
    pub enabled: std::option::Option<bool>,
    /// <p>A predictive scaling policy.</p>
    pub predictive_scaling_configuration:
        std::option::Option<crate::model::PredictiveScalingConfiguration>,
}
impl std::fmt::Debug for ScalingPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScalingPolicy");
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("policy_name", &self.policy_name);
        formatter.field("policy_arn", &self.policy_arn);
        formatter.field("policy_type", &self.policy_type);
        formatter.field("adjustment_type", &self.adjustment_type);
        formatter.field("min_adjustment_step", &self.min_adjustment_step);
        formatter.field("min_adjustment_magnitude", &self.min_adjustment_magnitude);
        formatter.field("scaling_adjustment", &self.scaling_adjustment);
        formatter.field("cooldown", &self.cooldown);
        formatter.field("step_adjustments", &self.step_adjustments);
        formatter.field("metric_aggregation_type", &self.metric_aggregation_type);
        formatter.field("estimated_instance_warmup", &self.estimated_instance_warmup);
        formatter.field("alarms", &self.alarms);
        formatter.field(
            "target_tracking_configuration",
            &self.target_tracking_configuration,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field(
            "predictive_scaling_configuration",
            &self.predictive_scaling_configuration,
        );
        formatter.finish()
    }
}
/// See [`ScalingPolicy`](crate::model::ScalingPolicy)
pub mod scaling_policy {
    /// A builder for [`ScalingPolicy`](crate::model::ScalingPolicy)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) policy_name: std::option::Option<std::string::String>,
        pub(crate) policy_arn: std::option::Option<std::string::String>,
        pub(crate) policy_type: std::option::Option<std::string::String>,
        pub(crate) adjustment_type: std::option::Option<std::string::String>,
        pub(crate) min_adjustment_step: std::option::Option<i32>,
        pub(crate) min_adjustment_magnitude: std::option::Option<i32>,
        pub(crate) scaling_adjustment: std::option::Option<i32>,
        pub(crate) cooldown: std::option::Option<i32>,
        pub(crate) step_adjustments:
            std::option::Option<std::vec::Vec<crate::model::StepAdjustment>>,
        pub(crate) metric_aggregation_type: std::option::Option<std::string::String>,
        pub(crate) estimated_instance_warmup: std::option::Option<i32>,
        pub(crate) alarms: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
        pub(crate) target_tracking_configuration:
            std::option::Option<crate::model::TargetTrackingConfiguration>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) predictive_scaling_configuration:
            std::option::Option<crate::model::PredictiveScalingConfiguration>,
    }
    impl Builder {
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The name of the scaling policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_name = Some(input.into());
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the policy.</p>
        pub fn policy_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_arn = Some(input.into());
            self
        }
        pub fn set_policy_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_arn = input;
            self
        }
        /// <p>One of the following policy types: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TargetTrackingScaling</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>StepScaling</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SimpleScaling</code> (default)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PredictiveScaling</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-target-tracking.html">Target tracking
        /// scaling policies</a> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html">Step and simple scaling
        /// policies</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn policy_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.policy_type = Some(input.into());
            self
        }
        pub fn set_policy_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.policy_type = input;
            self
        }
        /// <p>Specifies how the scaling adjustment is interpreted (for example, an absolute number
        /// or a percentage). The valid values are <code>ChangeInCapacity</code>,
        /// <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>
        pub fn adjustment_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.adjustment_type = Some(input.into());
            self
        }
        pub fn set_adjustment_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.adjustment_type = input;
            self
        }
        /// <p>Available for backward compatibility. Use <code>MinAdjustmentMagnitude</code>
        /// instead.</p>
        pub fn min_adjustment_step(mut self, input: i32) -> Self {
            self.min_adjustment_step = Some(input);
            self
        }
        pub fn set_min_adjustment_step(mut self, input: std::option::Option<i32>) -> Self {
            self.min_adjustment_step = input;
            self
        }
        /// <p>The minimum value to scale by when the adjustment type is
        /// <code>PercentChangeInCapacity</code>. </p>
        pub fn min_adjustment_magnitude(mut self, input: i32) -> Self {
            self.min_adjustment_magnitude = Some(input);
            self
        }
        pub fn set_min_adjustment_magnitude(mut self, input: std::option::Option<i32>) -> Self {
            self.min_adjustment_magnitude = input;
            self
        }
        /// <p>The amount by which to scale, based on the specified adjustment type. A positive value
        /// adds to the current capacity while a negative number removes from the current
        /// capacity.</p>
        pub fn scaling_adjustment(mut self, input: i32) -> Self {
            self.scaling_adjustment = Some(input);
            self
        }
        pub fn set_scaling_adjustment(mut self, input: std::option::Option<i32>) -> Self {
            self.scaling_adjustment = input;
            self
        }
        /// <p>The duration of the policy's cooldown period, in seconds.</p>
        pub fn cooldown(mut self, input: i32) -> Self {
            self.cooldown = Some(input);
            self
        }
        pub fn set_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.cooldown = input;
            self
        }
        pub fn step_adjustments(mut self, input: impl Into<crate::model::StepAdjustment>) -> Self {
            let mut v = self.step_adjustments.unwrap_or_default();
            v.push(input.into());
            self.step_adjustments = Some(v);
            self
        }
        pub fn set_step_adjustments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StepAdjustment>>,
        ) -> Self {
            self.step_adjustments = input;
            self
        }
        /// <p>The aggregation type for the CloudWatch metrics. The valid values are <code>Minimum</code>,
        /// <code>Maximum</code>, and <code>Average</code>.</p>
        pub fn metric_aggregation_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric_aggregation_type = Some(input.into());
            self
        }
        pub fn set_metric_aggregation_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.metric_aggregation_type = input;
            self
        }
        /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
        /// CloudWatch metrics.</p>
        pub fn estimated_instance_warmup(mut self, input: i32) -> Self {
            self.estimated_instance_warmup = Some(input);
            self
        }
        pub fn set_estimated_instance_warmup(mut self, input: std::option::Option<i32>) -> Self {
            self.estimated_instance_warmup = input;
            self
        }
        pub fn alarms(mut self, input: impl Into<crate::model::Alarm>) -> Self {
            let mut v = self.alarms.unwrap_or_default();
            v.push(input.into());
            self.alarms = Some(v);
            self
        }
        pub fn set_alarms(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Alarm>>,
        ) -> Self {
            self.alarms = input;
            self
        }
        /// <p>A target tracking scaling policy.</p>
        pub fn target_tracking_configuration(
            mut self,
            input: crate::model::TargetTrackingConfiguration,
        ) -> Self {
            self.target_tracking_configuration = Some(input);
            self
        }
        pub fn set_target_tracking_configuration(
            mut self,
            input: std::option::Option<crate::model::TargetTrackingConfiguration>,
        ) -> Self {
            self.target_tracking_configuration = input;
            self
        }
        /// <p>Indicates whether the policy is enabled (<code>true</code>) or disabled
        /// (<code>false</code>).</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>A predictive scaling policy.</p>
        pub fn predictive_scaling_configuration(
            mut self,
            input: crate::model::PredictiveScalingConfiguration,
        ) -> Self {
            self.predictive_scaling_configuration = Some(input);
            self
        }
        pub fn set_predictive_scaling_configuration(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingConfiguration>,
        ) -> Self {
            self.predictive_scaling_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ScalingPolicy`](crate::model::ScalingPolicy)
        pub fn build(self) -> crate::model::ScalingPolicy {
            crate::model::ScalingPolicy {
                auto_scaling_group_name: self.auto_scaling_group_name,
                policy_name: self.policy_name,
                policy_arn: self.policy_arn,
                policy_type: self.policy_type,
                adjustment_type: self.adjustment_type,
                min_adjustment_step: self.min_adjustment_step,
                min_adjustment_magnitude: self.min_adjustment_magnitude,
                scaling_adjustment: self.scaling_adjustment,
                cooldown: self.cooldown,
                step_adjustments: self.step_adjustments,
                metric_aggregation_type: self.metric_aggregation_type,
                estimated_instance_warmup: self.estimated_instance_warmup,
                alarms: self.alarms,
                target_tracking_configuration: self.target_tracking_configuration,
                enabled: self.enabled,
                predictive_scaling_configuration: self.predictive_scaling_configuration,
            }
        }
    }
}
impl ScalingPolicy {
    /// Creates a new builder-style object to manufacture [`ScalingPolicy`](crate::model::ScalingPolicy)
    pub fn builder() -> crate::model::scaling_policy::Builder {
        crate::model::scaling_policy::Builder::default()
    }
}

/// <p>Describes a notification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotificationConfiguration {
    /// <p>The name of the Auto Scaling group.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (Amazon SNS)
    /// topic.</p>
    pub topic_arn: std::option::Option<std::string::String>,
    /// <p>One of the following event notification types:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>autoscaling:EC2_INSTANCE_LAUNCH</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>autoscaling:EC2_INSTANCE_LAUNCH_ERROR</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>autoscaling:EC2_INSTANCE_TERMINATE</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>autoscaling:EC2_INSTANCE_TERMINATE_ERROR</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>autoscaling:TEST_NOTIFICATION</code>
    /// </p>
    /// </li>
    /// </ul>
    pub notification_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotificationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotificationConfiguration");
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("topic_arn", &self.topic_arn);
        formatter.field("notification_type", &self.notification_type);
        formatter.finish()
    }
}
/// See [`NotificationConfiguration`](crate::model::NotificationConfiguration)
pub mod notification_configuration {
    /// A builder for [`NotificationConfiguration`](crate::model::NotificationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) topic_arn: std::option::Option<std::string::String>,
        pub(crate) notification_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (Amazon SNS)
        /// topic.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.topic_arn = Some(input.into());
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.topic_arn = input;
            self
        }
        /// <p>One of the following event notification types:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>autoscaling:EC2_INSTANCE_LAUNCH</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>autoscaling:EC2_INSTANCE_LAUNCH_ERROR</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>autoscaling:EC2_INSTANCE_TERMINATE</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>autoscaling:EC2_INSTANCE_TERMINATE_ERROR</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>autoscaling:TEST_NOTIFICATION</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn notification_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_type = Some(input.into());
            self
        }
        pub fn set_notification_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_type = input;
            self
        }
        /// Consumes the builder and constructs a [`NotificationConfiguration`](crate::model::NotificationConfiguration)
        pub fn build(self) -> crate::model::NotificationConfiguration {
            crate::model::NotificationConfiguration {
                auto_scaling_group_name: self.auto_scaling_group_name,
                topic_arn: self.topic_arn,
                notification_type: self.notification_type,
            }
        }
    }
}
impl NotificationConfiguration {
    /// Creates a new builder-style object to manufacture [`NotificationConfiguration`](crate::model::NotificationConfiguration)
    pub fn builder() -> crate::model::notification_configuration::Builder {
        crate::model::notification_configuration::Builder::default()
    }
}

/// <p>Describes a granularity of a metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricGranularityType {
    /// <p>The granularity. The only valid value is <code>1Minute</code>.</p>
    pub granularity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricGranularityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricGranularityType");
        formatter.field("granularity", &self.granularity);
        formatter.finish()
    }
}
/// See [`MetricGranularityType`](crate::model::MetricGranularityType)
pub mod metric_granularity_type {
    /// A builder for [`MetricGranularityType`](crate::model::MetricGranularityType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) granularity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The granularity. The only valid value is <code>1Minute</code>.</p>
        pub fn granularity(mut self, input: impl Into<std::string::String>) -> Self {
            self.granularity = Some(input.into());
            self
        }
        pub fn set_granularity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricGranularityType`](crate::model::MetricGranularityType)
        pub fn build(self) -> crate::model::MetricGranularityType {
            crate::model::MetricGranularityType {
                granularity: self.granularity,
            }
        }
    }
}
impl MetricGranularityType {
    /// Creates a new builder-style object to manufacture [`MetricGranularityType`](crate::model::MetricGranularityType)
    pub fn builder() -> crate::model::metric_granularity_type::Builder {
        crate::model::metric_granularity_type::Builder::default()
    }
}

/// <p>Describes a metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricCollectionType {
    /// <p>One of the following metrics:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>GroupMinSize</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupMaxSize</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupDesiredCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupInServiceInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupPendingInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupStandbyInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTerminatingInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTotalInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupInServiceCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupPendingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupStandbyCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTerminatingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTotalCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolDesiredCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolWarmedCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolPendingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolTerminatingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolTotalCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupAndWarmPoolDesiredCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupAndWarmPoolTotalCapacity</code>
    /// </p>
    /// </li>
    /// </ul>
    pub metric: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MetricCollectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricCollectionType");
        formatter.field("metric", &self.metric);
        formatter.finish()
    }
}
/// See [`MetricCollectionType`](crate::model::MetricCollectionType)
pub mod metric_collection_type {
    /// A builder for [`MetricCollectionType`](crate::model::MetricCollectionType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>GroupMinSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupMaxSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolWarmedCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn metric(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric = Some(input.into());
            self
        }
        pub fn set_metric(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricCollectionType`](crate::model::MetricCollectionType)
        pub fn build(self) -> crate::model::MetricCollectionType {
            crate::model::MetricCollectionType {
                metric: self.metric,
            }
        }
    }
}
impl MetricCollectionType {
    /// Creates a new builder-style object to manufacture [`MetricCollectionType`](crate::model::MetricCollectionType)
    pub fn builder() -> crate::model::metric_collection_type::Builder {
        crate::model::metric_collection_type::Builder::default()
    }
}

/// <p>Describes the state of a target group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadBalancerTargetGroupState {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    pub load_balancer_target_group_arn: std::option::Option<std::string::String>,
    /// <p>The state of the target group.</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Adding</code> - The Auto Scaling instances are being registered with the target
    /// group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Added</code> - All Auto Scaling instances are registered with the target
    /// group.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InService</code> - At least one Auto Scaling instance passed an <code>ELB</code>
    /// health check.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Removing</code> - The Auto Scaling instances are being deregistered from the
    /// target group. If connection draining is enabled, Elastic Load Balancing waits for in-flight
    /// requests to complete before deregistering the instances.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Removed</code> - All Auto Scaling instances are deregistered from the target
    /// group.</p>
    /// </li>
    /// </ul>
    pub state: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LoadBalancerTargetGroupState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadBalancerTargetGroupState");
        formatter.field(
            "load_balancer_target_group_arn",
            &self.load_balancer_target_group_arn,
        );
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`LoadBalancerTargetGroupState`](crate::model::LoadBalancerTargetGroupState)
pub mod load_balancer_target_group_state {
    /// A builder for [`LoadBalancerTargetGroupState`](crate::model::LoadBalancerTargetGroupState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_target_group_arn: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the target group.</p>
        pub fn load_balancer_target_group_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.load_balancer_target_group_arn = Some(input.into());
            self
        }
        pub fn set_load_balancer_target_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_target_group_arn = input;
            self
        }
        /// <p>The state of the target group.</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Adding</code> - The Auto Scaling instances are being registered with the target
        /// group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Added</code> - All Auto Scaling instances are registered with the target
        /// group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InService</code> - At least one Auto Scaling instance passed an <code>ELB</code>
        /// health check.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Removing</code> - The Auto Scaling instances are being deregistered from the
        /// target group. If connection draining is enabled, Elastic Load Balancing waits for in-flight
        /// requests to complete before deregistering the instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Removed</code> - All Auto Scaling instances are deregistered from the target
        /// group.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadBalancerTargetGroupState`](crate::model::LoadBalancerTargetGroupState)
        pub fn build(self) -> crate::model::LoadBalancerTargetGroupState {
            crate::model::LoadBalancerTargetGroupState {
                load_balancer_target_group_arn: self.load_balancer_target_group_arn,
                state: self.state,
            }
        }
    }
}
impl LoadBalancerTargetGroupState {
    /// Creates a new builder-style object to manufacture [`LoadBalancerTargetGroupState`](crate::model::LoadBalancerTargetGroupState)
    pub fn builder() -> crate::model::load_balancer_target_group_state::Builder {
        crate::model::load_balancer_target_group_state::Builder::default()
    }
}

/// <p>Describes the state of a Classic Load Balancer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LoadBalancerState {
    /// <p>The name of the load balancer.</p>
    pub load_balancer_name: std::option::Option<std::string::String>,
    /// <p>One of the following load balancer states:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Adding</code> - The Auto Scaling instances are being registered with the load
    /// balancer.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Added</code> - All Auto Scaling instances are registered with the load
    /// balancer.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InService</code> - At least one Auto Scaling instance passed an <code>ELB</code>
    /// health check.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Removing</code> - The Auto Scaling instances are being deregistered from the
    /// load balancer. If connection draining is enabled, Elastic Load Balancing waits for in-flight
    /// requests to complete before deregistering the instances.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Removed</code> - All Auto Scaling instances are deregistered from the load
    /// balancer.</p>
    /// </li>
    /// </ul>
    pub state: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LoadBalancerState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LoadBalancerState");
        formatter.field("load_balancer_name", &self.load_balancer_name);
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`LoadBalancerState`](crate::model::LoadBalancerState)
pub mod load_balancer_state {
    /// A builder for [`LoadBalancerState`](crate::model::LoadBalancerState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) load_balancer_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the load balancer.</p>
        pub fn load_balancer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.load_balancer_name = Some(input.into());
            self
        }
        pub fn set_load_balancer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.load_balancer_name = input;
            self
        }
        /// <p>One of the following load balancer states:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Adding</code> - The Auto Scaling instances are being registered with the load
        /// balancer.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Added</code> - All Auto Scaling instances are registered with the load
        /// balancer.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InService</code> - At least one Auto Scaling instance passed an <code>ELB</code>
        /// health check.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Removing</code> - The Auto Scaling instances are being deregistered from the
        /// load balancer. If connection draining is enabled, Elastic Load Balancing waits for in-flight
        /// requests to complete before deregistering the instances.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Removed</code> - All Auto Scaling instances are deregistered from the load
        /// balancer.</p>
        /// </li>
        /// </ul>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`LoadBalancerState`](crate::model::LoadBalancerState)
        pub fn build(self) -> crate::model::LoadBalancerState {
            crate::model::LoadBalancerState {
                load_balancer_name: self.load_balancer_name,
                state: self.state,
            }
        }
    }
}
impl LoadBalancerState {
    /// Creates a new builder-style object to manufacture [`LoadBalancerState`](crate::model::LoadBalancerState)
    pub fn builder() -> crate::model::load_balancer_state::Builder {
        crate::model::load_balancer_state::Builder::default()
    }
}

/// <p>Describes a lifecycle hook, which tells Amazon EC2 Auto Scaling that you want to perform an action
/// whenever it launches instances or terminates
/// instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LifecycleHook {
    /// <p>The name of the lifecycle hook.</p>
    pub lifecycle_hook_name: std::option::Option<std::string::String>,
    /// <p>The name of the Auto Scaling group for the lifecycle hook.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The state of the EC2 instance to which to attach the lifecycle hook. The following are
    /// possible values:</p>
    /// <ul>
    /// <li>
    /// <p>autoscaling:EC2_INSTANCE_LAUNCHING</p>
    /// </li>
    /// <li>
    /// <p>autoscaling:EC2_INSTANCE_TERMINATING</p>
    /// </li>
    /// </ul>
    pub lifecycle_transition: std::option::Option<std::string::String>,
    /// <p>The ARN of the target that Amazon EC2 Auto Scaling sends notifications to when an instance is in the
    /// transition state for the lifecycle hook. The notification target can be either an SQS
    /// queue or an SNS topic.</p>
    pub notification_target_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified
    /// notification target.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>Additional information that is included any time Amazon EC2 Auto Scaling sends a message to the
    /// notification target.</p>
    pub notification_metadata: std::option::Option<std::string::String>,
    /// <p>The maximum time, in seconds, that can elapse before the lifecycle hook times out. If
    /// the lifecycle hook times out, Amazon EC2 Auto Scaling performs the action that you specified in the
    /// <code>DefaultResult</code> parameter.</p>
    pub heartbeat_timeout: std::option::Option<i32>,
    /// <p>The maximum time, in seconds, that an instance can remain in a
    /// <code>Pending:Wait</code> or <code>Terminating:Wait</code> state. The maximum is
    /// 172800 seconds (48 hours) or 100 times <code>HeartbeatTimeout</code>, whichever is
    /// smaller.</p>
    pub global_timeout: std::option::Option<i32>,
    /// <p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses
    /// or if an unexpected failure occurs. The possible values are <code>CONTINUE</code> and
    /// <code>ABANDON</code>.</p>
    pub default_result: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LifecycleHook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LifecycleHook");
        formatter.field("lifecycle_hook_name", &self.lifecycle_hook_name);
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("lifecycle_transition", &self.lifecycle_transition);
        formatter.field("notification_target_arn", &self.notification_target_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("notification_metadata", &self.notification_metadata);
        formatter.field("heartbeat_timeout", &self.heartbeat_timeout);
        formatter.field("global_timeout", &self.global_timeout);
        formatter.field("default_result", &self.default_result);
        formatter.finish()
    }
}
/// See [`LifecycleHook`](crate::model::LifecycleHook)
pub mod lifecycle_hook {
    /// A builder for [`LifecycleHook`](crate::model::LifecycleHook)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lifecycle_hook_name: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) lifecycle_transition: std::option::Option<std::string::String>,
        pub(crate) notification_target_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) notification_metadata: std::option::Option<std::string::String>,
        pub(crate) heartbeat_timeout: std::option::Option<i32>,
        pub(crate) global_timeout: std::option::Option<i32>,
        pub(crate) default_result: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the lifecycle hook.</p>
        pub fn lifecycle_hook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_hook_name = Some(input.into());
            self
        }
        pub fn set_lifecycle_hook_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_hook_name = input;
            self
        }
        /// <p>The name of the Auto Scaling group for the lifecycle hook.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The state of the EC2 instance to which to attach the lifecycle hook. The following are
        /// possible values:</p>
        /// <ul>
        /// <li>
        /// <p>autoscaling:EC2_INSTANCE_LAUNCHING</p>
        /// </li>
        /// <li>
        /// <p>autoscaling:EC2_INSTANCE_TERMINATING</p>
        /// </li>
        /// </ul>
        pub fn lifecycle_transition(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_transition = Some(input.into());
            self
        }
        pub fn set_lifecycle_transition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_transition = input;
            self
        }
        /// <p>The ARN of the target that Amazon EC2 Auto Scaling sends notifications to when an instance is in the
        /// transition state for the lifecycle hook. The notification target can be either an SQS
        /// queue or an SNS topic.</p>
        pub fn notification_target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_target_arn = Some(input.into());
            self
        }
        pub fn set_notification_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_target_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified
        /// notification target.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>Additional information that is included any time Amazon EC2 Auto Scaling sends a message to the
        /// notification target.</p>
        pub fn notification_metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_metadata = Some(input.into());
            self
        }
        pub fn set_notification_metadata(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_metadata = input;
            self
        }
        /// <p>The maximum time, in seconds, that can elapse before the lifecycle hook times out. If
        /// the lifecycle hook times out, Amazon EC2 Auto Scaling performs the action that you specified in the
        /// <code>DefaultResult</code> parameter.</p>
        pub fn heartbeat_timeout(mut self, input: i32) -> Self {
            self.heartbeat_timeout = Some(input);
            self
        }
        pub fn set_heartbeat_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.heartbeat_timeout = input;
            self
        }
        /// <p>The maximum time, in seconds, that an instance can remain in a
        /// <code>Pending:Wait</code> or <code>Terminating:Wait</code> state. The maximum is
        /// 172800 seconds (48 hours) or 100 times <code>HeartbeatTimeout</code>, whichever is
        /// smaller.</p>
        pub fn global_timeout(mut self, input: i32) -> Self {
            self.global_timeout = Some(input);
            self
        }
        pub fn set_global_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.global_timeout = input;
            self
        }
        /// <p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses
        /// or if an unexpected failure occurs. The possible values are <code>CONTINUE</code> and
        /// <code>ABANDON</code>.</p>
        pub fn default_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_result = Some(input.into());
            self
        }
        pub fn set_default_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_result = input;
            self
        }
        /// Consumes the builder and constructs a [`LifecycleHook`](crate::model::LifecycleHook)
        pub fn build(self) -> crate::model::LifecycleHook {
            crate::model::LifecycleHook {
                lifecycle_hook_name: self.lifecycle_hook_name,
                auto_scaling_group_name: self.auto_scaling_group_name,
                lifecycle_transition: self.lifecycle_transition,
                notification_target_arn: self.notification_target_arn,
                role_arn: self.role_arn,
                notification_metadata: self.notification_metadata,
                heartbeat_timeout: self.heartbeat_timeout,
                global_timeout: self.global_timeout,
                default_result: self.default_result,
            }
        }
    }
}
impl LifecycleHook {
    /// Creates a new builder-style object to manufacture [`LifecycleHook`](crate::model::LifecycleHook)
    pub fn builder() -> crate::model::lifecycle_hook::Builder {
        crate::model::lifecycle_hook::Builder::default()
    }
}

/// <p>Describes a launch configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchConfiguration {
    /// <p>The name of the launch configuration.</p>
    pub launch_configuration_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the launch configuration.</p>
    pub launch_configuration_arn: std::option::Option<std::string::String>,
    /// <p>The ID of the Amazon Machine Image (AMI) to use to launch your EC2 instances. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html">Finding an AMI</a> in the
    /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The name of the key pair.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html">Amazon EC2 Key Pairs</a> in the
    /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub key_name: std::option::Option<std::string::String>,
    /// <p>A list that contains the security groups to assign to the instances in the Auto Scaling group.
    /// For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html">Security Groups for Your
    /// VPC</a> in the <i>Amazon Virtual Private Cloud User
    /// Guide</i>.</p>
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of a ClassicLink-enabled VPC to link your EC2-Classic instances to. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html">ClassicLink</a> in the
    /// <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html#as-ClassicLink">Linking EC2-Classic
    /// instances to a VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub classic_link_vpc_id: std::option::Option<std::string::String>,
    /// <p>The IDs of one or more security groups for the VPC specified in
    /// <code>ClassicLinkVPCId</code>.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html">ClassicLink</a> in the
    /// <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html#as-ClassicLink">Linking EC2-Classic
    /// instances to a VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub classic_link_vpc_security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The user data to make available to the launched EC2 instances. For more information,
    /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> (Linux) and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html">Instance metadata and
    /// user data</a> (Windows). If you are using a command line tool, base64-encoding
    /// is performed for you, and you can load the text from a file. Otherwise, you must provide
    /// base64-encoded text. User data is limited to 16 KB.</p>
    pub user_data: std::option::Option<std::string::String>,
    /// <p>The instance type for the instances.</p>
    /// <p>For information about available instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#AvailableInstanceTypes">Available
    /// Instance Types</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the kernel associated with the AMI.</p>
    pub kernel_id: std::option::Option<std::string::String>,
    /// <p>The ID of the RAM disk associated with the AMI.</p>
    pub ramdisk_id: std::option::Option<std::string::String>,
    /// <p>A block device mapping, which specifies the block devices for the instance. For more
    /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html">Block Device
    /// Mapping</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub block_device_mappings: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
    /// <p>Controls whether instances in this group are launched with detailed
    /// (<code>true</code>) or basic (<code>false</code>) monitoring.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/latest/userguide/enable-as-instance-metrics.html">Configure
    /// Monitoring for Auto Scaling Instances</a> in the
    /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub instance_monitoring: std::option::Option<crate::model::InstanceMonitoring>,
    /// <p>The maximum hourly price to be paid for any Spot Instance launched to fulfill the
    /// request. Spot Instances are launched when the price you specify exceeds the current Spot
    /// price. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-launch-spot-instances.html">Requesting Spot
    /// Instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub spot_price: std::option::Option<std::string::String>,
    /// <p>The name or the Amazon Resource Name (ARN) of the instance profile associated with the
    /// IAM role for the instance. The instance profile contains the IAM role. For more
    /// information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/us-iam-role.html">IAM role for applications that run
    /// on Amazon EC2 instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub iam_instance_profile: std::option::Option<std::string::String>,
    /// <p>The creation date and time for the launch configuration.</p>
    pub created_time: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies whether the launch configuration is optimized for EBS I/O
    /// (<code>true</code>) or not (<code>false</code>). For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html">Amazon
    /// EBS-Optimized Instances</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub ebs_optimized: std::option::Option<bool>,
    /// <p>For Auto Scaling groups that are running in a VPC, specifies whether to assign a public IP
    /// address to the group's instances. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html">Launching Auto Scaling instances in a
    /// VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub associate_public_ip_address: std::option::Option<bool>,
    /// <p>The tenancy of the instance, either <code>default</code> or <code>dedicated</code>. An
    /// instance with <code>dedicated</code> tenancy runs on isolated, single-tenant hardware
    /// and can only be launched into a VPC.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-dedicated-instances.html">Configuring
    /// instance tenancy with Amazon EC2 Auto Scaling</a> in the
    /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub placement_tenancy: std::option::Option<std::string::String>,
    /// <p>The metadata options for the instances. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-config.html#launch-configurations-imds">Configuring the Instance Metadata Options</a> in the
    /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub metadata_options: std::option::Option<crate::model::InstanceMetadataOptions>,
}
impl std::fmt::Debug for LaunchConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchConfiguration");
        formatter.field("launch_configuration_name", &self.launch_configuration_name);
        formatter.field("launch_configuration_arn", &self.launch_configuration_arn);
        formatter.field("image_id", &self.image_id);
        formatter.field("key_name", &self.key_name);
        formatter.field("security_groups", &self.security_groups);
        formatter.field("classic_link_vpc_id", &self.classic_link_vpc_id);
        formatter.field(
            "classic_link_vpc_security_groups",
            &self.classic_link_vpc_security_groups,
        );
        formatter.field("user_data", &self.user_data);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("kernel_id", &self.kernel_id);
        formatter.field("ramdisk_id", &self.ramdisk_id);
        formatter.field("block_device_mappings", &self.block_device_mappings);
        formatter.field("instance_monitoring", &self.instance_monitoring);
        formatter.field("spot_price", &self.spot_price);
        formatter.field("iam_instance_profile", &self.iam_instance_profile);
        formatter.field("created_time", &self.created_time);
        formatter.field("ebs_optimized", &self.ebs_optimized);
        formatter.field(
            "associate_public_ip_address",
            &self.associate_public_ip_address,
        );
        formatter.field("placement_tenancy", &self.placement_tenancy);
        formatter.field("metadata_options", &self.metadata_options);
        formatter.finish()
    }
}
/// See [`LaunchConfiguration`](crate::model::LaunchConfiguration)
pub mod launch_configuration {
    /// A builder for [`LaunchConfiguration`](crate::model::LaunchConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_configuration_name: std::option::Option<std::string::String>,
        pub(crate) launch_configuration_arn: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) key_name: std::option::Option<std::string::String>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) classic_link_vpc_id: std::option::Option<std::string::String>,
        pub(crate) classic_link_vpc_security_groups:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_data: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) kernel_id: std::option::Option<std::string::String>,
        pub(crate) ramdisk_id: std::option::Option<std::string::String>,
        pub(crate) block_device_mappings:
            std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        pub(crate) instance_monitoring: std::option::Option<crate::model::InstanceMonitoring>,
        pub(crate) spot_price: std::option::Option<std::string::String>,
        pub(crate) iam_instance_profile: std::option::Option<std::string::String>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) ebs_optimized: std::option::Option<bool>,
        pub(crate) associate_public_ip_address: std::option::Option<bool>,
        pub(crate) placement_tenancy: std::option::Option<std::string::String>,
        pub(crate) metadata_options: std::option::Option<crate::model::InstanceMetadataOptions>,
    }
    impl Builder {
        /// <p>The name of the launch configuration.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_name = Some(input.into());
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the launch configuration.</p>
        pub fn launch_configuration_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_arn = Some(input.into());
            self
        }
        pub fn set_launch_configuration_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_arn = input;
            self
        }
        /// <p>The ID of the Amazon Machine Image (AMI) to use to launch your EC2 instances. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html">Finding an AMI</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The name of the key pair.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html">Amazon EC2 Key Pairs</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_name = Some(input.into());
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_name = input;
            self
        }
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>The ID of a ClassicLink-enabled VPC to link your EC2-Classic instances to. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html">ClassicLink</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html#as-ClassicLink">Linking EC2-Classic
        /// instances to a VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn classic_link_vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.classic_link_vpc_id = Some(input.into());
            self
        }
        pub fn set_classic_link_vpc_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classic_link_vpc_id = input;
            self
        }
        pub fn classic_link_vpc_security_groups(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.classic_link_vpc_security_groups.unwrap_or_default();
            v.push(input.into());
            self.classic_link_vpc_security_groups = Some(v);
            self
        }
        pub fn set_classic_link_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.classic_link_vpc_security_groups = input;
            self
        }
        /// <p>The user data to make available to the launched EC2 instances. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> (Linux) and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html">Instance metadata and
        /// user data</a> (Windows). If you are using a command line tool, base64-encoding
        /// is performed for you, and you can load the text from a file. Otherwise, you must provide
        /// base64-encoded text. User data is limited to 16 KB.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_data = Some(input.into());
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_data = input;
            self
        }
        /// <p>The instance type for the instances.</p>
        /// <p>For information about available instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#AvailableInstanceTypes">Available
        /// Instance Types</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The ID of the kernel associated with the AMI.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.kernel_id = Some(input.into());
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kernel_id = input;
            self
        }
        /// <p>The ID of the RAM disk associated with the AMI.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ramdisk_id = Some(input.into());
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ramdisk_id = input;
            self
        }
        pub fn block_device_mappings(
            mut self,
            input: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            let mut v = self.block_device_mappings.unwrap_or_default();
            v.push(input.into());
            self.block_device_mappings = Some(v);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.block_device_mappings = input;
            self
        }
        /// <p>Controls whether instances in this group are launched with detailed
        /// (<code>true</code>) or basic (<code>false</code>) monitoring.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/latest/userguide/enable-as-instance-metrics.html">Configure
        /// Monitoring for Auto Scaling Instances</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn instance_monitoring(mut self, input: crate::model::InstanceMonitoring) -> Self {
            self.instance_monitoring = Some(input);
            self
        }
        pub fn set_instance_monitoring(
            mut self,
            input: std::option::Option<crate::model::InstanceMonitoring>,
        ) -> Self {
            self.instance_monitoring = input;
            self
        }
        /// <p>The maximum hourly price to be paid for any Spot Instance launched to fulfill the
        /// request. Spot Instances are launched when the price you specify exceeds the current Spot
        /// price. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-launch-spot-instances.html">Requesting Spot
        /// Instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.spot_price = Some(input.into());
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.spot_price = input;
            self
        }
        /// <p>The name or the Amazon Resource Name (ARN) of the instance profile associated with the
        /// IAM role for the instance. The instance profile contains the IAM role. For more
        /// information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/us-iam-role.html">IAM role for applications that run
        /// on Amazon EC2 instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn iam_instance_profile(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_instance_profile = Some(input.into());
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iam_instance_profile = input;
            self
        }
        /// <p>The creation date and time for the launch configuration.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        /// <p>Specifies whether the launch configuration is optimized for EBS I/O
        /// (<code>true</code>) or not (<code>false</code>). For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html">Amazon
        /// EBS-Optimized Instances</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.ebs_optimized = Some(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.ebs_optimized = input;
            self
        }
        /// <p>For Auto Scaling groups that are running in a VPC, specifies whether to assign a public IP
        /// address to the group's instances. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html">Launching Auto Scaling instances in a
        /// VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.associate_public_ip_address = Some(input);
            self
        }
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.associate_public_ip_address = input;
            self
        }
        /// <p>The tenancy of the instance, either <code>default</code> or <code>dedicated</code>. An
        /// instance with <code>dedicated</code> tenancy runs on isolated, single-tenant hardware
        /// and can only be launched into a VPC.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-dedicated-instances.html">Configuring
        /// instance tenancy with Amazon EC2 Auto Scaling</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn placement_tenancy(mut self, input: impl Into<std::string::String>) -> Self {
            self.placement_tenancy = Some(input.into());
            self
        }
        pub fn set_placement_tenancy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.placement_tenancy = input;
            self
        }
        /// <p>The metadata options for the instances. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-config.html#launch-configurations-imds">Configuring the Instance Metadata Options</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn metadata_options(mut self, input: crate::model::InstanceMetadataOptions) -> Self {
            self.metadata_options = Some(input);
            self
        }
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataOptions>,
        ) -> Self {
            self.metadata_options = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchConfiguration`](crate::model::LaunchConfiguration)
        pub fn build(self) -> crate::model::LaunchConfiguration {
            crate::model::LaunchConfiguration {
                launch_configuration_name: self.launch_configuration_name,
                launch_configuration_arn: self.launch_configuration_arn,
                image_id: self.image_id,
                key_name: self.key_name,
                security_groups: self.security_groups,
                classic_link_vpc_id: self.classic_link_vpc_id,
                classic_link_vpc_security_groups: self.classic_link_vpc_security_groups,
                user_data: self.user_data,
                instance_type: self.instance_type,
                kernel_id: self.kernel_id,
                ramdisk_id: self.ramdisk_id,
                block_device_mappings: self.block_device_mappings,
                instance_monitoring: self.instance_monitoring,
                spot_price: self.spot_price,
                iam_instance_profile: self.iam_instance_profile,
                created_time: self.created_time,
                ebs_optimized: self.ebs_optimized,
                associate_public_ip_address: self.associate_public_ip_address,
                placement_tenancy: self.placement_tenancy,
                metadata_options: self.metadata_options,
            }
        }
    }
}
impl LaunchConfiguration {
    /// Creates a new builder-style object to manufacture [`LaunchConfiguration`](crate::model::LaunchConfiguration)
    pub fn builder() -> crate::model::launch_configuration::Builder {
        crate::model::launch_configuration::Builder::default()
    }
}

/// <p>The metadata options for the instances. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-config.html#launch-configurations-imds">Configuring the Instance Metadata Options</a> in the
/// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMetadataOptions {
    /// <p>The state of token usage for your instance metadata requests. If the parameter is not
    /// specified in the request, the default state is <code>optional</code>.</p>
    /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
    /// with or without a signed token header on your request. If you retrieve the IAM role
    /// credentials without a token, the version 1.0 role credentials are returned. If you
    /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
    /// credentials are returned.</p>
    /// <p>If the state is <code>required</code>, you must send a signed token header with any
    /// instance metadata retrieval requests. In this state, retrieving the IAM role credentials
    /// always returns the version 2.0 credentials; the version 1.0 credentials are not
    /// available.</p>
    pub http_tokens: std::option::Option<crate::model::InstanceMetadataHttpTokensState>,
    /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
    /// number, the further instance metadata requests can travel.</p>
    /// <p>Default: 1</p>
    pub http_put_response_hop_limit: std::option::Option<i32>,
    /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
    /// the parameter is not specified, the default state is <code>enabled</code>.</p>
    /// <note>
    /// <p>If you specify a value of <code>disabled</code>, you will not be able to access
    /// your instance metadata. </p>
    /// </note>
    pub http_endpoint: std::option::Option<crate::model::InstanceMetadataEndpointState>,
}
impl std::fmt::Debug for InstanceMetadataOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMetadataOptions");
        formatter.field("http_tokens", &self.http_tokens);
        formatter.field(
            "http_put_response_hop_limit",
            &self.http_put_response_hop_limit,
        );
        formatter.field("http_endpoint", &self.http_endpoint);
        formatter.finish()
    }
}
/// See [`InstanceMetadataOptions`](crate::model::InstanceMetadataOptions)
pub mod instance_metadata_options {
    /// A builder for [`InstanceMetadataOptions`](crate::model::InstanceMetadataOptions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) http_tokens: std::option::Option<crate::model::InstanceMetadataHttpTokensState>,
        pub(crate) http_put_response_hop_limit: std::option::Option<i32>,
        pub(crate) http_endpoint: std::option::Option<crate::model::InstanceMetadataEndpointState>,
    }
    impl Builder {
        /// <p>The state of token usage for your instance metadata requests. If the parameter is not
        /// specified in the request, the default state is <code>optional</code>.</p>
        /// <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata
        /// with or without a signed token header on your request. If you retrieve the IAM role
        /// credentials without a token, the version 1.0 role credentials are returned. If you
        /// retrieve the IAM role credentials using a valid signed token, the version 2.0 role
        /// credentials are returned.</p>
        /// <p>If the state is <code>required</code>, you must send a signed token header with any
        /// instance metadata retrieval requests. In this state, retrieving the IAM role credentials
        /// always returns the version 2.0 credentials; the version 1.0 credentials are not
        /// available.</p>
        pub fn http_tokens(mut self, input: crate::model::InstanceMetadataHttpTokensState) -> Self {
            self.http_tokens = Some(input);
            self
        }
        pub fn set_http_tokens(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataHttpTokensState>,
        ) -> Self {
            self.http_tokens = input;
            self
        }
        /// <p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the
        /// number, the further instance metadata requests can travel.</p>
        /// <p>Default: 1</p>
        pub fn http_put_response_hop_limit(mut self, input: i32) -> Self {
            self.http_put_response_hop_limit = Some(input);
            self
        }
        pub fn set_http_put_response_hop_limit(mut self, input: std::option::Option<i32>) -> Self {
            self.http_put_response_hop_limit = input;
            self
        }
        /// <p>This parameter enables or disables the HTTP metadata endpoint on your instances. If
        /// the parameter is not specified, the default state is <code>enabled</code>.</p>
        /// <note>
        /// <p>If you specify a value of <code>disabled</code>, you will not be able to access
        /// your instance metadata. </p>
        /// </note>
        pub fn http_endpoint(mut self, input: crate::model::InstanceMetadataEndpointState) -> Self {
            self.http_endpoint = Some(input);
            self
        }
        pub fn set_http_endpoint(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataEndpointState>,
        ) -> Self {
            self.http_endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMetadataOptions`](crate::model::InstanceMetadataOptions)
        pub fn build(self) -> crate::model::InstanceMetadataOptions {
            crate::model::InstanceMetadataOptions {
                http_tokens: self.http_tokens,
                http_put_response_hop_limit: self.http_put_response_hop_limit,
                http_endpoint: self.http_endpoint,
            }
        }
    }
}
impl InstanceMetadataOptions {
    /// Creates a new builder-style object to manufacture [`InstanceMetadataOptions`](crate::model::InstanceMetadataOptions)
    pub fn builder() -> crate::model::instance_metadata_options::Builder {
        crate::model::instance_metadata_options::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceMetadataEndpointState {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceMetadataEndpointState {
    fn from(s: &str) -> Self {
        match s {
            "disabled" => InstanceMetadataEndpointState::Disabled,
            "enabled" => InstanceMetadataEndpointState::Enabled,
            other => InstanceMetadataEndpointState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceMetadataEndpointState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceMetadataEndpointState::from(s))
    }
}
impl InstanceMetadataEndpointState {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceMetadataEndpointState::Disabled => "disabled",
            InstanceMetadataEndpointState::Enabled => "enabled",
            InstanceMetadataEndpointState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["disabled", "enabled"]
    }
}
impl AsRef<str> for InstanceMetadataEndpointState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceMetadataHttpTokensState {
    Optional,
    Required,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceMetadataHttpTokensState {
    fn from(s: &str) -> Self {
        match s {
            "optional" => InstanceMetadataHttpTokensState::Optional,
            "required" => InstanceMetadataHttpTokensState::Required,
            other => InstanceMetadataHttpTokensState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceMetadataHttpTokensState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceMetadataHttpTokensState::from(s))
    }
}
impl InstanceMetadataHttpTokensState {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceMetadataHttpTokensState::Optional => "optional",
            InstanceMetadataHttpTokensState::Required => "required",
            InstanceMetadataHttpTokensState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["optional", "required"]
    }
}
impl AsRef<str> for InstanceMetadataHttpTokensState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes whether detailed monitoring is enabled for the Auto Scaling instances.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceMonitoring {
    /// <p>If <code>true</code>, detailed monitoring is enabled. Otherwise, basic monitoring is
    /// enabled.</p>
    pub enabled: std::option::Option<bool>,
}
impl std::fmt::Debug for InstanceMonitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceMonitoring");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`InstanceMonitoring`](crate::model::InstanceMonitoring)
pub mod instance_monitoring {
    /// A builder for [`InstanceMonitoring`](crate::model::InstanceMonitoring)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>If <code>true</code>, detailed monitoring is enabled. Otherwise, basic monitoring is
        /// enabled.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceMonitoring`](crate::model::InstanceMonitoring)
        pub fn build(self) -> crate::model::InstanceMonitoring {
            crate::model::InstanceMonitoring {
                enabled: self.enabled,
            }
        }
    }
}
impl InstanceMonitoring {
    /// Creates a new builder-style object to manufacture [`InstanceMonitoring`](crate::model::InstanceMonitoring)
    pub fn builder() -> crate::model::instance_monitoring::Builder {
        crate::model::instance_monitoring::Builder::default()
    }
}

/// <p>Describes a block device mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlockDeviceMapping {
    /// <p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>
    /// <p>You can specify either <code>VirtualName</code> or <code>Ebs</code>, but not
    /// both.</p>
    pub virtual_name: std::option::Option<std::string::String>,
    /// <p>The device name exposed to the EC2 instance (for example, <code>/dev/sdh</code> or
    /// <code>xvdh</code>). For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html">Device Naming on Linux
    /// Instances</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    pub device_name: std::option::Option<std::string::String>,
    /// <p>Parameters used to automatically set up EBS volumes when an instance is
    /// launched.</p>
    /// <p>You can specify either <code>VirtualName</code> or <code>Ebs</code>, but not
    /// both.</p>
    pub ebs: std::option::Option<crate::model::Ebs>,
    /// <p>Setting this value to <code>true</code> suppresses the specified device included in
    /// the block device mapping of the AMI.</p>
    /// <p>If <code>NoDevice</code> is <code>true</code> for the root device, instances might
    /// fail the EC2 health check. In that case, Amazon EC2 Auto Scaling launches replacement instances.</p>
    /// <p>If you specify <code>NoDevice</code>, you cannot specify <code>Ebs</code>.</p>
    pub no_device: std::option::Option<bool>,
}
impl std::fmt::Debug for BlockDeviceMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlockDeviceMapping");
        formatter.field("virtual_name", &self.virtual_name);
        formatter.field("device_name", &self.device_name);
        formatter.field("ebs", &self.ebs);
        formatter.field("no_device", &self.no_device);
        formatter.finish()
    }
}
/// See [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
pub mod block_device_mapping {
    /// A builder for [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) virtual_name: std::option::Option<std::string::String>,
        pub(crate) device_name: std::option::Option<std::string::String>,
        pub(crate) ebs: std::option::Option<crate::model::Ebs>,
        pub(crate) no_device: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the virtual device (for example, <code>ephemeral0</code>).</p>
        /// <p>You can specify either <code>VirtualName</code> or <code>Ebs</code>, but not
        /// both.</p>
        pub fn virtual_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.virtual_name = Some(input.into());
            self
        }
        pub fn set_virtual_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.virtual_name = input;
            self
        }
        /// <p>The device name exposed to the EC2 instance (for example, <code>/dev/sdh</code> or
        /// <code>xvdh</code>). For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html">Device Naming on Linux
        /// Instances</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn device_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_name = Some(input.into());
            self
        }
        pub fn set_device_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_name = input;
            self
        }
        /// <p>Parameters used to automatically set up EBS volumes when an instance is
        /// launched.</p>
        /// <p>You can specify either <code>VirtualName</code> or <code>Ebs</code>, but not
        /// both.</p>
        pub fn ebs(mut self, input: crate::model::Ebs) -> Self {
            self.ebs = Some(input);
            self
        }
        pub fn set_ebs(mut self, input: std::option::Option<crate::model::Ebs>) -> Self {
            self.ebs = input;
            self
        }
        /// <p>Setting this value to <code>true</code> suppresses the specified device included in
        /// the block device mapping of the AMI.</p>
        /// <p>If <code>NoDevice</code> is <code>true</code> for the root device, instances might
        /// fail the EC2 health check. In that case, Amazon EC2 Auto Scaling launches replacement instances.</p>
        /// <p>If you specify <code>NoDevice</code>, you cannot specify <code>Ebs</code>.</p>
        pub fn no_device(mut self, input: bool) -> Self {
            self.no_device = Some(input);
            self
        }
        pub fn set_no_device(mut self, input: std::option::Option<bool>) -> Self {
            self.no_device = input;
            self
        }
        /// Consumes the builder and constructs a [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
        pub fn build(self) -> crate::model::BlockDeviceMapping {
            crate::model::BlockDeviceMapping {
                virtual_name: self.virtual_name,
                device_name: self.device_name,
                ebs: self.ebs,
                no_device: self.no_device,
            }
        }
    }
}
impl BlockDeviceMapping {
    /// Creates a new builder-style object to manufacture [`BlockDeviceMapping`](crate::model::BlockDeviceMapping)
    pub fn builder() -> crate::model::block_device_mapping::Builder {
        crate::model::block_device_mapping::Builder::default()
    }
}

/// <p>Describes information used to set up an Amazon EBS volume specified in a block device
/// mapping.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Ebs {
    /// <p>The snapshot ID of the volume to use.</p>
    /// <p>You must specify either a <code>VolumeSize</code> or a <code>SnapshotId</code>.</p>
    pub snapshot_id: std::option::Option<std::string::String>,
    /// <p>The volume size, in GiBs. The following are the supported volumes sizes for each
    /// volume type: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gp2</code> and <code>gp3</code>: 1-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io1</code>: 4-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>standard</code>: 1-1,024</p>
    /// </li>
    /// </ul>
    /// <p>You must specify either a <code>SnapshotId</code> or a <code>VolumeSize</code>. If you
    /// specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the volume size must
    /// be equal or greater than the size of the snapshot.</p>
    pub volume_size: std::option::Option<i32>,
    /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in
    /// the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
    /// <p>Valid Values: <code>standard</code> | <code>io1</code> | <code>gp2</code> |
    /// <code>st1</code> | <code>sc1</code> | <code>gp3</code>
    /// </p>
    pub volume_type: std::option::Option<std::string::String>,
    /// <p>Indicates whether the volume is deleted on instance termination. For Amazon EC2 Auto Scaling, the
    /// default value is <code>true</code>.</p>
    pub delete_on_termination: std::option::Option<bool>,
    /// <p>The number of input/output (I/O) operations per second (IOPS) to provision for the
    /// volume. For <code>gp3</code> and <code>io1</code> volumes, this represents the number of
    /// IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents
    /// the baseline performance of the volume and the rate at which the volume accumulates I/O
    /// credits for bursting. </p>
    /// <p>The following are the supported values for each volume type: </p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>gp3</code>: 3,000-16,000 IOPS</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>io1</code>: 100-64,000 IOPS</p>
    /// </li>
    /// </ul>
    /// <p>For <code>io1</code> volumes, we guarantee 64,000 IOPS only for <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances
    /// built on the Nitro System</a>. Other instance families guarantee performance up
    /// to 32,000 IOPS. </p>
    /// <p>
    /// <code>Iops</code> is supported when the volume type is <code>gp3</code> or
    /// <code>io1</code> and required only when the volume type is <code>io1</code>. (Not
    /// used with <code>standard</code>, <code>gp2</code>, <code>st1</code>, or <code>sc1</code>
    /// volumes.) </p>
    pub iops: std::option::Option<i32>,
    /// <p>Specifies whether the volume should be encrypted. Encrypted EBS volumes can only be
    /// attached to instances that support Amazon EBS encryption. For more information, see
    /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances">Supported Instance Types</a>. If your AMI uses encrypted volumes, you can also
    /// only launch it on supported instance types.</p>
    /// <note>
    /// <p>If you are creating a volume from a snapshot, you cannot specify an encryption
    /// value. Volumes that are created from encrypted snapshots are automatically
    /// encrypted, and volumes that are created from unencrypted snapshots are automatically
    /// unencrypted. By default, encrypted snapshots use the Amazon Web Services managed CMK that is used
    /// for EBS encryption, but you can specify a custom CMK when you create the snapshot.
    /// The ability to encrypt a snapshot during copying also allows you to apply a new CMK
    /// to an already-encrypted snapshot. Volumes restored from the
    /// resulting copy are only accessible using the new CMK.</p>
    /// <p>Enabling <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default">encryption by default</a> results in all EBS volumes being encrypted with
    /// the Amazon Web Services managed CMK or a customer managed CMK, whether or not the snapshot was
    /// encrypted.</p>
    /// </note>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIEncryption.html">Using Encryption with EBS-Backed
    /// AMIs</a> in the <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/key-policy-requirements-EBS-encryption.html">Required
    /// CMK key policy for use with encrypted volumes</a> in the
    /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
    pub encrypted: std::option::Option<bool>,
    /// <p>The throughput (MiBps) to provision for a <code>gp3</code> volume.</p>
    pub throughput: std::option::Option<i32>,
}
impl std::fmt::Debug for Ebs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Ebs");
        formatter.field("snapshot_id", &self.snapshot_id);
        formatter.field("volume_size", &self.volume_size);
        formatter.field("volume_type", &self.volume_type);
        formatter.field("delete_on_termination", &self.delete_on_termination);
        formatter.field("iops", &self.iops);
        formatter.field("encrypted", &self.encrypted);
        formatter.field("throughput", &self.throughput);
        formatter.finish()
    }
}
/// See [`Ebs`](crate::model::Ebs)
pub mod ebs {
    /// A builder for [`Ebs`](crate::model::Ebs)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_id: std::option::Option<std::string::String>,
        pub(crate) volume_size: std::option::Option<i32>,
        pub(crate) volume_type: std::option::Option<std::string::String>,
        pub(crate) delete_on_termination: std::option::Option<bool>,
        pub(crate) iops: std::option::Option<i32>,
        pub(crate) encrypted: std::option::Option<bool>,
        pub(crate) throughput: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The snapshot ID of the volume to use.</p>
        /// <p>You must specify either a <code>VolumeSize</code> or a <code>SnapshotId</code>.</p>
        pub fn snapshot_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.snapshot_id = Some(input.into());
            self
        }
        pub fn set_snapshot_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.snapshot_id = input;
            self
        }
        /// <p>The volume size, in GiBs. The following are the supported volumes sizes for each
        /// volume type: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp2</code> and <code>gp3</code>: 1-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code>: 4-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>st1</code> and <code>sc1</code>: 125-16,384</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>standard</code>: 1-1,024</p>
        /// </li>
        /// </ul>
        /// <p>You must specify either a <code>SnapshotId</code> or a <code>VolumeSize</code>. If you
        /// specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the volume size must
        /// be equal or greater than the size of the snapshot.</p>
        pub fn volume_size(mut self, input: i32) -> Self {
            self.volume_size = Some(input);
            self
        }
        pub fn set_volume_size(mut self, input: std::option::Option<i32>) -> Self {
            self.volume_size = input;
            self
        }
        /// <p>The volume type. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in
        /// the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        /// <p>Valid Values: <code>standard</code> | <code>io1</code> | <code>gp2</code> |
        /// <code>st1</code> | <code>sc1</code> | <code>gp3</code>
        /// </p>
        pub fn volume_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_type = Some(input.into());
            self
        }
        pub fn set_volume_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.volume_type = input;
            self
        }
        /// <p>Indicates whether the volume is deleted on instance termination. For Amazon EC2 Auto Scaling, the
        /// default value is <code>true</code>.</p>
        pub fn delete_on_termination(mut self, input: bool) -> Self {
            self.delete_on_termination = Some(input);
            self
        }
        pub fn set_delete_on_termination(mut self, input: std::option::Option<bool>) -> Self {
            self.delete_on_termination = input;
            self
        }
        /// <p>The number of input/output (I/O) operations per second (IOPS) to provision for the
        /// volume. For <code>gp3</code> and <code>io1</code> volumes, this represents the number of
        /// IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents
        /// the baseline performance of the volume and the rate at which the volume accumulates I/O
        /// credits for bursting. </p>
        /// <p>The following are the supported values for each volume type: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>gp3</code>: 3,000-16,000 IOPS</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>io1</code>: 100-64,000 IOPS</p>
        /// </li>
        /// </ul>
        /// <p>For <code>io1</code> volumes, we guarantee 64,000 IOPS only for <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances">Instances
        /// built on the Nitro System</a>. Other instance families guarantee performance up
        /// to 32,000 IOPS. </p>
        /// <p>
        /// <code>Iops</code> is supported when the volume type is <code>gp3</code> or
        /// <code>io1</code> and required only when the volume type is <code>io1</code>. (Not
        /// used with <code>standard</code>, <code>gp2</code>, <code>st1</code>, or <code>sc1</code>
        /// volumes.) </p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// <p>Specifies whether the volume should be encrypted. Encrypted EBS volumes can only be
        /// attached to instances that support Amazon EBS encryption. For more information, see
        /// <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances">Supported Instance Types</a>. If your AMI uses encrypted volumes, you can also
        /// only launch it on supported instance types.</p>
        /// <note>
        /// <p>If you are creating a volume from a snapshot, you cannot specify an encryption
        /// value. Volumes that are created from encrypted snapshots are automatically
        /// encrypted, and volumes that are created from unencrypted snapshots are automatically
        /// unencrypted. By default, encrypted snapshots use the Amazon Web Services managed CMK that is used
        /// for EBS encryption, but you can specify a custom CMK when you create the snapshot.
        /// The ability to encrypt a snapshot during copying also allows you to apply a new CMK
        /// to an already-encrypted snapshot. Volumes restored from the
        /// resulting copy are only accessible using the new CMK.</p>
        /// <p>Enabling <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-by-default">encryption by default</a> results in all EBS volumes being encrypted with
        /// the Amazon Web Services managed CMK or a customer managed CMK, whether or not the snapshot was
        /// encrypted.</p>
        /// </note>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIEncryption.html">Using Encryption with EBS-Backed
        /// AMIs</a> in the <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/key-policy-requirements-EBS-encryption.html">Required
        /// CMK key policy for use with encrypted volumes</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.encrypted = Some(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.encrypted = input;
            self
        }
        /// <p>The throughput (MiBps) to provision for a <code>gp3</code> volume.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// Consumes the builder and constructs a [`Ebs`](crate::model::Ebs)
        pub fn build(self) -> crate::model::Ebs {
            crate::model::Ebs {
                snapshot_id: self.snapshot_id,
                volume_size: self.volume_size,
                volume_type: self.volume_type,
                delete_on_termination: self.delete_on_termination,
                iops: self.iops,
                encrypted: self.encrypted,
                throughput: self.throughput,
            }
        }
    }
}
impl Ebs {
    /// Creates a new builder-style object to manufacture [`Ebs`](crate::model::Ebs)
    pub fn builder() -> crate::model::ebs::Builder {
        crate::model::ebs::Builder::default()
    }
}

/// <p>Describes an instance refresh for an Auto Scaling group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceRefresh {
    /// <p>The instance refresh ID.</p>
    pub instance_refresh_id: std::option::Option<std::string::String>,
    /// <p>The name of the Auto Scaling group.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The current status for the instance refresh operation:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>Pending</code> - The request was created, but the operation has not
    /// started.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>InProgress</code> - The operation is in progress.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Successful</code> - The operation completed successfully.</p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Failed</code> - The operation failed to complete. You can troubleshoot
    /// using the status reason and the scaling activities. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Cancelling</code> - An ongoing operation is being cancelled.
    /// Cancellation does not roll back any replacements that have already been
    /// completed, but it prevents new replacements from being started. </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>Cancelled</code> - The operation is cancelled. </p>
    /// </li>
    /// </ul>
    pub status: std::option::Option<crate::model::InstanceRefreshStatus>,
    /// <p>Provides more details about the current status of the instance refresh. </p>
    pub status_reason: std::option::Option<std::string::String>,
    /// <p>The date and time at which the instance refresh began.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time at which the instance refresh ended.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The percentage of the instance refresh that is complete. For each instance
    /// replacement, Amazon EC2 Auto Scaling tracks the instance's health status and warm-up time. When the
    /// instance's health status changes to healthy and the specified warm-up time passes, the
    /// instance is considered updated and is added to the percentage complete.</p>
    pub percentage_complete: std::option::Option<i32>,
    /// <p>The number of instances remaining to update before the instance refresh is
    /// complete.</p>
    pub instances_to_update: std::option::Option<i32>,
    /// <p>Additional progress details for an Auto Scaling group that has a warm pool.</p>
    pub progress_details: std::option::Option<crate::model::InstanceRefreshProgressDetails>,
}
impl std::fmt::Debug for InstanceRefresh {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceRefresh");
        formatter.field("instance_refresh_id", &self.instance_refresh_id);
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("status", &self.status);
        formatter.field("status_reason", &self.status_reason);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("percentage_complete", &self.percentage_complete);
        formatter.field("instances_to_update", &self.instances_to_update);
        formatter.field("progress_details", &self.progress_details);
        formatter.finish()
    }
}
/// See [`InstanceRefresh`](crate::model::InstanceRefresh)
pub mod instance_refresh {
    /// A builder for [`InstanceRefresh`](crate::model::InstanceRefresh)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_refresh_id: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::InstanceRefreshStatus>,
        pub(crate) status_reason: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) percentage_complete: std::option::Option<i32>,
        pub(crate) instances_to_update: std::option::Option<i32>,
        pub(crate) progress_details:
            std::option::Option<crate::model::InstanceRefreshProgressDetails>,
    }
    impl Builder {
        /// <p>The instance refresh ID.</p>
        pub fn instance_refresh_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_refresh_id = Some(input.into());
            self
        }
        pub fn set_instance_refresh_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_refresh_id = input;
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The current status for the instance refresh operation:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Pending</code> - The request was created, but the operation has not
        /// started.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InProgress</code> - The operation is in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Successful</code> - The operation completed successfully.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code> - The operation failed to complete. You can troubleshoot
        /// using the status reason and the scaling activities. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Cancelling</code> - An ongoing operation is being cancelled.
        /// Cancellation does not roll back any replacements that have already been
        /// completed, but it prevents new replacements from being started. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Cancelled</code> - The operation is cancelled. </p>
        /// </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::InstanceRefreshStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::InstanceRefreshStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Provides more details about the current status of the instance refresh. </p>
        pub fn status_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_reason = Some(input.into());
            self
        }
        pub fn set_status_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_reason = input;
            self
        }
        /// <p>The date and time at which the instance refresh began.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The date and time at which the instance refresh ended.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The percentage of the instance refresh that is complete. For each instance
        /// replacement, Amazon EC2 Auto Scaling tracks the instance's health status and warm-up time. When the
        /// instance's health status changes to healthy and the specified warm-up time passes, the
        /// instance is considered updated and is added to the percentage complete.</p>
        pub fn percentage_complete(mut self, input: i32) -> Self {
            self.percentage_complete = Some(input);
            self
        }
        pub fn set_percentage_complete(mut self, input: std::option::Option<i32>) -> Self {
            self.percentage_complete = input;
            self
        }
        /// <p>The number of instances remaining to update before the instance refresh is
        /// complete.</p>
        pub fn instances_to_update(mut self, input: i32) -> Self {
            self.instances_to_update = Some(input);
            self
        }
        pub fn set_instances_to_update(mut self, input: std::option::Option<i32>) -> Self {
            self.instances_to_update = input;
            self
        }
        /// <p>Additional progress details for an Auto Scaling group that has a warm pool.</p>
        pub fn progress_details(
            mut self,
            input: crate::model::InstanceRefreshProgressDetails,
        ) -> Self {
            self.progress_details = Some(input);
            self
        }
        pub fn set_progress_details(
            mut self,
            input: std::option::Option<crate::model::InstanceRefreshProgressDetails>,
        ) -> Self {
            self.progress_details = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceRefresh`](crate::model::InstanceRefresh)
        pub fn build(self) -> crate::model::InstanceRefresh {
            crate::model::InstanceRefresh {
                instance_refresh_id: self.instance_refresh_id,
                auto_scaling_group_name: self.auto_scaling_group_name,
                status: self.status,
                status_reason: self.status_reason,
                start_time: self.start_time,
                end_time: self.end_time,
                percentage_complete: self.percentage_complete,
                instances_to_update: self.instances_to_update,
                progress_details: self.progress_details,
            }
        }
    }
}
impl InstanceRefresh {
    /// Creates a new builder-style object to manufacture [`InstanceRefresh`](crate::model::InstanceRefresh)
    pub fn builder() -> crate::model::instance_refresh::Builder {
        crate::model::instance_refresh::Builder::default()
    }
}

/// <p>Reports the progress of an instance refresh on an Auto Scaling group that has a warm pool.
/// This includes separate details for instances in the warm pool and instances in the Auto Scaling
/// group (the live pool).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceRefreshProgressDetails {
    /// <p>Indicates the progress of an instance refresh on instances that are in the Auto Scaling
    /// group.</p>
    pub live_pool_progress: std::option::Option<crate::model::InstanceRefreshLivePoolProgress>,
    /// <p>Indicates the progress of an instance refresh on instances that are in the warm
    /// pool.</p>
    pub warm_pool_progress: std::option::Option<crate::model::InstanceRefreshWarmPoolProgress>,
}
impl std::fmt::Debug for InstanceRefreshProgressDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceRefreshProgressDetails");
        formatter.field("live_pool_progress", &self.live_pool_progress);
        formatter.field("warm_pool_progress", &self.warm_pool_progress);
        formatter.finish()
    }
}
/// See [`InstanceRefreshProgressDetails`](crate::model::InstanceRefreshProgressDetails)
pub mod instance_refresh_progress_details {
    /// A builder for [`InstanceRefreshProgressDetails`](crate::model::InstanceRefreshProgressDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) live_pool_progress:
            std::option::Option<crate::model::InstanceRefreshLivePoolProgress>,
        pub(crate) warm_pool_progress:
            std::option::Option<crate::model::InstanceRefreshWarmPoolProgress>,
    }
    impl Builder {
        /// <p>Indicates the progress of an instance refresh on instances that are in the Auto Scaling
        /// group.</p>
        pub fn live_pool_progress(
            mut self,
            input: crate::model::InstanceRefreshLivePoolProgress,
        ) -> Self {
            self.live_pool_progress = Some(input);
            self
        }
        pub fn set_live_pool_progress(
            mut self,
            input: std::option::Option<crate::model::InstanceRefreshLivePoolProgress>,
        ) -> Self {
            self.live_pool_progress = input;
            self
        }
        /// <p>Indicates the progress of an instance refresh on instances that are in the warm
        /// pool.</p>
        pub fn warm_pool_progress(
            mut self,
            input: crate::model::InstanceRefreshWarmPoolProgress,
        ) -> Self {
            self.warm_pool_progress = Some(input);
            self
        }
        pub fn set_warm_pool_progress(
            mut self,
            input: std::option::Option<crate::model::InstanceRefreshWarmPoolProgress>,
        ) -> Self {
            self.warm_pool_progress = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceRefreshProgressDetails`](crate::model::InstanceRefreshProgressDetails)
        pub fn build(self) -> crate::model::InstanceRefreshProgressDetails {
            crate::model::InstanceRefreshProgressDetails {
                live_pool_progress: self.live_pool_progress,
                warm_pool_progress: self.warm_pool_progress,
            }
        }
    }
}
impl InstanceRefreshProgressDetails {
    /// Creates a new builder-style object to manufacture [`InstanceRefreshProgressDetails`](crate::model::InstanceRefreshProgressDetails)
    pub fn builder() -> crate::model::instance_refresh_progress_details::Builder {
        crate::model::instance_refresh_progress_details::Builder::default()
    }
}

/// <p>Reports the progress of an instance refresh on instances that are in the warm
/// pool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceRefreshWarmPoolProgress {
    /// <p>The percentage of instances in the warm pool that have been replaced. For each
    /// instance replacement, Amazon EC2 Auto Scaling tracks the instance's health status and warm-up time.
    /// When the instance's health status changes to healthy and the specified warm-up time
    /// passes, the instance is considered updated and is added to the percentage
    /// complete.</p>
    pub percentage_complete: std::option::Option<i32>,
    /// <p>The number of instances remaining to update.</p>
    pub instances_to_update: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceRefreshWarmPoolProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceRefreshWarmPoolProgress");
        formatter.field("percentage_complete", &self.percentage_complete);
        formatter.field("instances_to_update", &self.instances_to_update);
        formatter.finish()
    }
}
/// See [`InstanceRefreshWarmPoolProgress`](crate::model::InstanceRefreshWarmPoolProgress)
pub mod instance_refresh_warm_pool_progress {
    /// A builder for [`InstanceRefreshWarmPoolProgress`](crate::model::InstanceRefreshWarmPoolProgress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentage_complete: std::option::Option<i32>,
        pub(crate) instances_to_update: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The percentage of instances in the warm pool that have been replaced. For each
        /// instance replacement, Amazon EC2 Auto Scaling tracks the instance's health status and warm-up time.
        /// When the instance's health status changes to healthy and the specified warm-up time
        /// passes, the instance is considered updated and is added to the percentage
        /// complete.</p>
        pub fn percentage_complete(mut self, input: i32) -> Self {
            self.percentage_complete = Some(input);
            self
        }
        pub fn set_percentage_complete(mut self, input: std::option::Option<i32>) -> Self {
            self.percentage_complete = input;
            self
        }
        /// <p>The number of instances remaining to update.</p>
        pub fn instances_to_update(mut self, input: i32) -> Self {
            self.instances_to_update = Some(input);
            self
        }
        pub fn set_instances_to_update(mut self, input: std::option::Option<i32>) -> Self {
            self.instances_to_update = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceRefreshWarmPoolProgress`](crate::model::InstanceRefreshWarmPoolProgress)
        pub fn build(self) -> crate::model::InstanceRefreshWarmPoolProgress {
            crate::model::InstanceRefreshWarmPoolProgress {
                percentage_complete: self.percentage_complete,
                instances_to_update: self.instances_to_update,
            }
        }
    }
}
impl InstanceRefreshWarmPoolProgress {
    /// Creates a new builder-style object to manufacture [`InstanceRefreshWarmPoolProgress`](crate::model::InstanceRefreshWarmPoolProgress)
    pub fn builder() -> crate::model::instance_refresh_warm_pool_progress::Builder {
        crate::model::instance_refresh_warm_pool_progress::Builder::default()
    }
}

/// <p>Reports the progress of an instance refresh on instances that are in the Auto Scaling
/// group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InstanceRefreshLivePoolProgress {
    /// <p>The percentage of instances in the Auto Scaling group that have been replaced. For each
    /// instance replacement, Amazon EC2 Auto Scaling tracks the instance's health status and warm-up time.
    /// When the instance's health status changes to healthy and the specified warm-up time
    /// passes, the instance is considered updated and is added to the percentage
    /// complete.</p>
    pub percentage_complete: std::option::Option<i32>,
    /// <p>The number of instances remaining to update.</p>
    pub instances_to_update: std::option::Option<i32>,
}
impl std::fmt::Debug for InstanceRefreshLivePoolProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InstanceRefreshLivePoolProgress");
        formatter.field("percentage_complete", &self.percentage_complete);
        formatter.field("instances_to_update", &self.instances_to_update);
        formatter.finish()
    }
}
/// See [`InstanceRefreshLivePoolProgress`](crate::model::InstanceRefreshLivePoolProgress)
pub mod instance_refresh_live_pool_progress {
    /// A builder for [`InstanceRefreshLivePoolProgress`](crate::model::InstanceRefreshLivePoolProgress)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) percentage_complete: std::option::Option<i32>,
        pub(crate) instances_to_update: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The percentage of instances in the Auto Scaling group that have been replaced. For each
        /// instance replacement, Amazon EC2 Auto Scaling tracks the instance's health status and warm-up time.
        /// When the instance's health status changes to healthy and the specified warm-up time
        /// passes, the instance is considered updated and is added to the percentage
        /// complete.</p>
        pub fn percentage_complete(mut self, input: i32) -> Self {
            self.percentage_complete = Some(input);
            self
        }
        pub fn set_percentage_complete(mut self, input: std::option::Option<i32>) -> Self {
            self.percentage_complete = input;
            self
        }
        /// <p>The number of instances remaining to update.</p>
        pub fn instances_to_update(mut self, input: i32) -> Self {
            self.instances_to_update = Some(input);
            self
        }
        pub fn set_instances_to_update(mut self, input: std::option::Option<i32>) -> Self {
            self.instances_to_update = input;
            self
        }
        /// Consumes the builder and constructs a [`InstanceRefreshLivePoolProgress`](crate::model::InstanceRefreshLivePoolProgress)
        pub fn build(self) -> crate::model::InstanceRefreshLivePoolProgress {
            crate::model::InstanceRefreshLivePoolProgress {
                percentage_complete: self.percentage_complete,
                instances_to_update: self.instances_to_update,
            }
        }
    }
}
impl InstanceRefreshLivePoolProgress {
    /// Creates a new builder-style object to manufacture [`InstanceRefreshLivePoolProgress`](crate::model::InstanceRefreshLivePoolProgress)
    pub fn builder() -> crate::model::instance_refresh_live_pool_progress::Builder {
        crate::model::instance_refresh_live_pool_progress::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum InstanceRefreshStatus {
    Cancelled,
    Cancelling,
    Failed,
    InProgress,
    Pending,
    Successful,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for InstanceRefreshStatus {
    fn from(s: &str) -> Self {
        match s {
            "Cancelled" => InstanceRefreshStatus::Cancelled,
            "Cancelling" => InstanceRefreshStatus::Cancelling,
            "Failed" => InstanceRefreshStatus::Failed,
            "InProgress" => InstanceRefreshStatus::InProgress,
            "Pending" => InstanceRefreshStatus::Pending,
            "Successful" => InstanceRefreshStatus::Successful,
            other => InstanceRefreshStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for InstanceRefreshStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(InstanceRefreshStatus::from(s))
    }
}
impl InstanceRefreshStatus {
    pub fn as_str(&self) -> &str {
        match self {
            InstanceRefreshStatus::Cancelled => "Cancelled",
            InstanceRefreshStatus::Cancelling => "Cancelling",
            InstanceRefreshStatus::Failed => "Failed",
            InstanceRefreshStatus::InProgress => "InProgress",
            InstanceRefreshStatus::Pending => "Pending",
            InstanceRefreshStatus::Successful => "Successful",
            InstanceRefreshStatus::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "Cancelled",
            "Cancelling",
            "Failed",
            "InProgress",
            "Pending",
            "Successful",
        ]
    }
}
impl AsRef<str> for InstanceRefreshStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an EC2 instance associated with an Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingInstanceDetails {
    /// <p>The ID of the instance.</p>
    pub instance_id: std::option::Option<std::string::String>,
    /// <p>The instance type of the EC2 instance.</p>
    pub instance_type: std::option::Option<std::string::String>,
    /// <p>The name of the Auto Scaling group for the instance.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The Availability Zone for the instance.</p>
    pub availability_zone: std::option::Option<std::string::String>,
    /// <p>The lifecycle state for the instance. The <code>Quarantined</code> state is not used.
    /// For information about lifecycle states, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroupLifecycle.html">Instance
    /// lifecycle</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
    /// <p>Valid Values: <code>Pending</code> | <code>Pending:Wait</code> |
    /// <code>Pending:Proceed</code> | <code>Quarantined</code> | <code>InService</code> |
    /// <code>Terminating</code> | <code>Terminating:Wait</code> |
    /// <code>Terminating:Proceed</code> | <code>Terminated</code> | <code>Detaching</code>
    /// | <code>Detached</code> | <code>EnteringStandby</code> | <code>Standby</code> |
    /// <code>Warmed:Pending</code> | <code>Warmed:Pending:Wait</code> |
    /// <code>Warmed:Pending:Proceed</code> | <code>Warmed:Terminating</code> |
    /// <code>Warmed:Terminating:Wait</code> | <code>Warmed:Terminating:Proceed</code> |
    /// <code>Warmed:Terminated</code> | <code>Warmed:Stopped</code> |
    /// <code>Warmed:Running</code>
    /// </p>
    pub lifecycle_state: std::option::Option<std::string::String>,
    /// <p>The last reported health status of this instance. "Healthy" means that the instance is
    /// healthy and should remain in service. "Unhealthy" means that the instance is unhealthy
    /// and Amazon EC2 Auto Scaling should terminate and replace it.</p>
    pub health_status: std::option::Option<std::string::String>,
    /// <p>The launch configuration used to launch the instance. This value is not available if
    /// you attached the instance to the Auto Scaling group.</p>
    pub launch_configuration_name: std::option::Option<std::string::String>,
    /// <p>The launch template for the instance.</p>
    pub launch_template: std::option::Option<crate::model::LaunchTemplateSpecification>,
    /// <p>Indicates whether the instance is protected from termination by Amazon EC2 Auto Scaling when scaling
    /// in.</p>
    pub protected_from_scale_in: std::option::Option<bool>,
    /// <p>The number of capacity units contributed by the instance based on its instance
    /// type.</p>
    /// <p>Valid Range: Minimum value of 1. Maximum value of 999.</p>
    pub weighted_capacity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoScalingInstanceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoScalingInstanceDetails");
        formatter.field("instance_id", &self.instance_id);
        formatter.field("instance_type", &self.instance_type);
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("availability_zone", &self.availability_zone);
        formatter.field("lifecycle_state", &self.lifecycle_state);
        formatter.field("health_status", &self.health_status);
        formatter.field("launch_configuration_name", &self.launch_configuration_name);
        formatter.field("launch_template", &self.launch_template);
        formatter.field("protected_from_scale_in", &self.protected_from_scale_in);
        formatter.field("weighted_capacity", &self.weighted_capacity);
        formatter.finish()
    }
}
/// See [`AutoScalingInstanceDetails`](crate::model::AutoScalingInstanceDetails)
pub mod auto_scaling_instance_details {
    /// A builder for [`AutoScalingInstanceDetails`](crate::model::AutoScalingInstanceDetails)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) instance_id: std::option::Option<std::string::String>,
        pub(crate) instance_type: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) availability_zone: std::option::Option<std::string::String>,
        pub(crate) lifecycle_state: std::option::Option<std::string::String>,
        pub(crate) health_status: std::option::Option<std::string::String>,
        pub(crate) launch_configuration_name: std::option::Option<std::string::String>,
        pub(crate) launch_template: std::option::Option<crate::model::LaunchTemplateSpecification>,
        pub(crate) protected_from_scale_in: std::option::Option<bool>,
        pub(crate) weighted_capacity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_id = Some(input.into());
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.instance_id = input;
            self
        }
        /// <p>The instance type of the EC2 instance.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.instance_type = Some(input.into());
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.instance_type = input;
            self
        }
        /// <p>The name of the Auto Scaling group for the instance.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The Availability Zone for the instance.</p>
        pub fn availability_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.availability_zone = Some(input.into());
            self
        }
        pub fn set_availability_zone(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.availability_zone = input;
            self
        }
        /// <p>The lifecycle state for the instance. The <code>Quarantined</code> state is not used.
        /// For information about lifecycle states, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroupLifecycle.html">Instance
        /// lifecycle</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>. </p>
        /// <p>Valid Values: <code>Pending</code> | <code>Pending:Wait</code> |
        /// <code>Pending:Proceed</code> | <code>Quarantined</code> | <code>InService</code> |
        /// <code>Terminating</code> | <code>Terminating:Wait</code> |
        /// <code>Terminating:Proceed</code> | <code>Terminated</code> | <code>Detaching</code>
        /// | <code>Detached</code> | <code>EnteringStandby</code> | <code>Standby</code> |
        /// <code>Warmed:Pending</code> | <code>Warmed:Pending:Wait</code> |
        /// <code>Warmed:Pending:Proceed</code> | <code>Warmed:Terminating</code> |
        /// <code>Warmed:Terminating:Wait</code> | <code>Warmed:Terminating:Proceed</code> |
        /// <code>Warmed:Terminated</code> | <code>Warmed:Stopped</code> |
        /// <code>Warmed:Running</code>
        /// </p>
        pub fn lifecycle_state(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_state = Some(input.into());
            self
        }
        pub fn set_lifecycle_state(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_state = input;
            self
        }
        /// <p>The last reported health status of this instance. "Healthy" means that the instance is
        /// healthy and should remain in service. "Unhealthy" means that the instance is unhealthy
        /// and Amazon EC2 Auto Scaling should terminate and replace it.</p>
        pub fn health_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_status = Some(input.into());
            self
        }
        pub fn set_health_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_status = input;
            self
        }
        /// <p>The launch configuration used to launch the instance. This value is not available if
        /// you attached the instance to the Auto Scaling group.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_name = Some(input.into());
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_name = input;
            self
        }
        /// <p>The launch template for the instance.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.launch_template = Some(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template = input;
            self
        }
        /// <p>Indicates whether the instance is protected from termination by Amazon EC2 Auto Scaling when scaling
        /// in.</p>
        pub fn protected_from_scale_in(mut self, input: bool) -> Self {
            self.protected_from_scale_in = Some(input);
            self
        }
        pub fn set_protected_from_scale_in(mut self, input: std::option::Option<bool>) -> Self {
            self.protected_from_scale_in = input;
            self
        }
        /// <p>The number of capacity units contributed by the instance based on its instance
        /// type.</p>
        /// <p>Valid Range: Minimum value of 1. Maximum value of 999.</p>
        pub fn weighted_capacity(mut self, input: impl Into<std::string::String>) -> Self {
            self.weighted_capacity = Some(input.into());
            self
        }
        pub fn set_weighted_capacity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.weighted_capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingInstanceDetails`](crate::model::AutoScalingInstanceDetails)
        pub fn build(self) -> crate::model::AutoScalingInstanceDetails {
            crate::model::AutoScalingInstanceDetails {
                instance_id: self.instance_id,
                instance_type: self.instance_type,
                auto_scaling_group_name: self.auto_scaling_group_name,
                availability_zone: self.availability_zone,
                lifecycle_state: self.lifecycle_state,
                health_status: self.health_status,
                launch_configuration_name: self.launch_configuration_name,
                launch_template: self.launch_template,
                protected_from_scale_in: self.protected_from_scale_in,
                weighted_capacity: self.weighted_capacity,
            }
        }
    }
}
impl AutoScalingInstanceDetails {
    /// Creates a new builder-style object to manufacture [`AutoScalingInstanceDetails`](crate::model::AutoScalingInstanceDetails)
    pub fn builder() -> crate::model::auto_scaling_instance_details::Builder {
        crate::model::auto_scaling_instance_details::Builder::default()
    }
}

/// <p>Describes an Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoScalingGroup {
    /// <p>The name of the Auto Scaling group.</p>
    pub auto_scaling_group_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
    pub auto_scaling_group_arn: std::option::Option<std::string::String>,
    /// <p>The name of the associated launch configuration.</p>
    pub launch_configuration_name: std::option::Option<std::string::String>,
    /// <p>The launch template for the group.</p>
    pub launch_template: std::option::Option<crate::model::LaunchTemplateSpecification>,
    /// <p>The mixed instances policy for the group.</p>
    pub mixed_instances_policy: std::option::Option<crate::model::MixedInstancesPolicy>,
    /// <p>The minimum size of the group.</p>
    pub min_size: std::option::Option<i32>,
    /// <p>The maximum size of the group.</p>
    pub max_size: std::option::Option<i32>,
    /// <p>The desired size of the group.</p>
    pub desired_capacity: std::option::Option<i32>,
    /// <p>The predicted capacity of the group when it has a predictive scaling policy.</p>
    pub predicted_capacity: std::option::Option<i32>,
    /// <p>The duration of the default cooldown period, in seconds.</p>
    pub default_cooldown: std::option::Option<i32>,
    /// <p>One or more Availability Zones for the group.</p>
    pub availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>One or more load balancers associated with the group.</p>
    pub load_balancer_names: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The Amazon Resource Names (ARN) of the target groups for your load balancer.</p>
    pub target_group_ar_ns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The service to use for the health checks. The valid values are <code>EC2</code> and
    /// <code>ELB</code>. If you configure an Auto Scaling group to use <code>ELB</code> health
    /// checks, it considers the instance unhealthy if it fails either the EC2 status checks or
    /// the load balancer health checks.</p>
    pub health_check_type: std::option::Option<std::string::String>,
    /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status
    /// of an EC2 instance that has come into service.</p>
    pub health_check_grace_period: std::option::Option<i32>,
    /// <p>The EC2 instances associated with the group.</p>
    pub instances: std::option::Option<std::vec::Vec<crate::model::Instance>>,
    /// <p>The date and time the group was created.</p>
    pub created_time: std::option::Option<smithy_types::Instant>,
    /// <p>The suspended processes associated with the group.</p>
    pub suspended_processes: std::option::Option<std::vec::Vec<crate::model::SuspendedProcess>>,
    /// <p>The name of the placement group into which to launch your instances, if any.</p>
    pub placement_group: std::option::Option<std::string::String>,
    /// <p>One or more subnet IDs, if applicable, separated by commas.</p>
    pub vpc_zone_identifier: std::option::Option<std::string::String>,
    /// <p>The metrics enabled for the group.</p>
    pub enabled_metrics: std::option::Option<std::vec::Vec<crate::model::EnabledMetric>>,
    /// <p>The current state of the group when the <a>DeleteAutoScalingGroup</a>
    /// operation is in progress.</p>
    pub status: std::option::Option<std::string::String>,
    /// <p>The tags for the group.</p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::TagDescription>>,
    /// <p>The termination policies for the group.</p>
    pub termination_policies: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling
    /// when scaling in.</p>
    pub new_instances_protected_from_scale_in: std::option::Option<bool>,
    /// <p>The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to
    /// call other Amazon Web Services on your behalf.</p>
    pub service_linked_role_arn: std::option::Option<std::string::String>,
    /// <p>The maximum amount of time, in seconds, that an instance can be in service.</p>
    /// <p>Valid Range: Minimum value of 0.</p>
    pub max_instance_lifetime: std::option::Option<i32>,
    /// <p>Indicates whether Capacity Rebalancing is enabled.</p>
    pub capacity_rebalance: std::option::Option<bool>,
    /// <p>The warm pool for the group.</p>
    pub warm_pool_configuration: std::option::Option<crate::model::WarmPoolConfiguration>,
    /// <p>The current size of the warm pool.</p>
    pub warm_pool_size: std::option::Option<i32>,
    /// <p>Reserved.</p>
    pub context: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AutoScalingGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoScalingGroup");
        formatter.field("auto_scaling_group_name", &self.auto_scaling_group_name);
        formatter.field("auto_scaling_group_arn", &self.auto_scaling_group_arn);
        formatter.field("launch_configuration_name", &self.launch_configuration_name);
        formatter.field("launch_template", &self.launch_template);
        formatter.field("mixed_instances_policy", &self.mixed_instances_policy);
        formatter.field("min_size", &self.min_size);
        formatter.field("max_size", &self.max_size);
        formatter.field("desired_capacity", &self.desired_capacity);
        formatter.field("predicted_capacity", &self.predicted_capacity);
        formatter.field("default_cooldown", &self.default_cooldown);
        formatter.field("availability_zones", &self.availability_zones);
        formatter.field("load_balancer_names", &self.load_balancer_names);
        formatter.field("target_group_ar_ns", &self.target_group_ar_ns);
        formatter.field("health_check_type", &self.health_check_type);
        formatter.field("health_check_grace_period", &self.health_check_grace_period);
        formatter.field("instances", &self.instances);
        formatter.field("created_time", &self.created_time);
        formatter.field("suspended_processes", &self.suspended_processes);
        formatter.field("placement_group", &self.placement_group);
        formatter.field("vpc_zone_identifier", &self.vpc_zone_identifier);
        formatter.field("enabled_metrics", &self.enabled_metrics);
        formatter.field("status", &self.status);
        formatter.field("tags", &self.tags);
        formatter.field("termination_policies", &self.termination_policies);
        formatter.field(
            "new_instances_protected_from_scale_in",
            &self.new_instances_protected_from_scale_in,
        );
        formatter.field("service_linked_role_arn", &self.service_linked_role_arn);
        formatter.field("max_instance_lifetime", &self.max_instance_lifetime);
        formatter.field("capacity_rebalance", &self.capacity_rebalance);
        formatter.field("warm_pool_configuration", &self.warm_pool_configuration);
        formatter.field("warm_pool_size", &self.warm_pool_size);
        formatter.field("context", &self.context);
        formatter.finish()
    }
}
/// See [`AutoScalingGroup`](crate::model::AutoScalingGroup)
pub mod auto_scaling_group {
    /// A builder for [`AutoScalingGroup`](crate::model::AutoScalingGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_scaling_group_name: std::option::Option<std::string::String>,
        pub(crate) auto_scaling_group_arn: std::option::Option<std::string::String>,
        pub(crate) launch_configuration_name: std::option::Option<std::string::String>,
        pub(crate) launch_template: std::option::Option<crate::model::LaunchTemplateSpecification>,
        pub(crate) mixed_instances_policy: std::option::Option<crate::model::MixedInstancesPolicy>,
        pub(crate) min_size: std::option::Option<i32>,
        pub(crate) max_size: std::option::Option<i32>,
        pub(crate) desired_capacity: std::option::Option<i32>,
        pub(crate) predicted_capacity: std::option::Option<i32>,
        pub(crate) default_cooldown: std::option::Option<i32>,
        pub(crate) availability_zones: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) load_balancer_names: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) target_group_ar_ns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) health_check_type: std::option::Option<std::string::String>,
        pub(crate) health_check_grace_period: std::option::Option<i32>,
        pub(crate) instances: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        pub(crate) created_time: std::option::Option<smithy_types::Instant>,
        pub(crate) suspended_processes:
            std::option::Option<std::vec::Vec<crate::model::SuspendedProcess>>,
        pub(crate) placement_group: std::option::Option<std::string::String>,
        pub(crate) vpc_zone_identifier: std::option::Option<std::string::String>,
        pub(crate) enabled_metrics: std::option::Option<std::vec::Vec<crate::model::EnabledMetric>>,
        pub(crate) status: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::TagDescription>>,
        pub(crate) termination_policies: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) new_instances_protected_from_scale_in: std::option::Option<bool>,
        pub(crate) service_linked_role_arn: std::option::Option<std::string::String>,
        pub(crate) max_instance_lifetime: std::option::Option<i32>,
        pub(crate) capacity_rebalance: std::option::Option<bool>,
        pub(crate) warm_pool_configuration:
            std::option::Option<crate::model::WarmPoolConfiguration>,
        pub(crate) warm_pool_size: std::option::Option<i32>,
        pub(crate) context: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_name = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_name = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Auto Scaling group.</p>
        pub fn auto_scaling_group_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.auto_scaling_group_arn = Some(input.into());
            self
        }
        pub fn set_auto_scaling_group_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.auto_scaling_group_arn = input;
            self
        }
        /// <p>The name of the associated launch configuration.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_configuration_name = Some(input.into());
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_configuration_name = input;
            self
        }
        /// <p>The launch template for the group.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.launch_template = Some(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.launch_template = input;
            self
        }
        /// <p>The mixed instances policy for the group.</p>
        pub fn mixed_instances_policy(mut self, input: crate::model::MixedInstancesPolicy) -> Self {
            self.mixed_instances_policy = Some(input);
            self
        }
        pub fn set_mixed_instances_policy(
            mut self,
            input: std::option::Option<crate::model::MixedInstancesPolicy>,
        ) -> Self {
            self.mixed_instances_policy = input;
            self
        }
        /// <p>The minimum size of the group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.min_size = Some(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.min_size = input;
            self
        }
        /// <p>The maximum size of the group.</p>
        pub fn max_size(mut self, input: i32) -> Self {
            self.max_size = Some(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.max_size = input;
            self
        }
        /// <p>The desired size of the group.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.desired_capacity = Some(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_capacity = input;
            self
        }
        /// <p>The predicted capacity of the group when it has a predictive scaling policy.</p>
        pub fn predicted_capacity(mut self, input: i32) -> Self {
            self.predicted_capacity = Some(input);
            self
        }
        pub fn set_predicted_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.predicted_capacity = input;
            self
        }
        /// <p>The duration of the default cooldown period, in seconds.</p>
        pub fn default_cooldown(mut self, input: i32) -> Self {
            self.default_cooldown = Some(input);
            self
        }
        pub fn set_default_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.default_cooldown = input;
            self
        }
        pub fn availability_zones(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.availability_zones.unwrap_or_default();
            v.push(input.into());
            self.availability_zones = Some(v);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.availability_zones = input;
            self
        }
        pub fn load_balancer_names(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.load_balancer_names.unwrap_or_default();
            v.push(input.into());
            self.load_balancer_names = Some(v);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.load_balancer_names = input;
            self
        }
        pub fn target_group_ar_ns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_group_ar_ns.unwrap_or_default();
            v.push(input.into());
            self.target_group_ar_ns = Some(v);
            self
        }
        pub fn set_target_group_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_group_ar_ns = input;
            self
        }
        /// <p>The service to use for the health checks. The valid values are <code>EC2</code> and
        /// <code>ELB</code>. If you configure an Auto Scaling group to use <code>ELB</code> health
        /// checks, it considers the instance unhealthy if it fails either the EC2 status checks or
        /// the load balancer health checks.</p>
        pub fn health_check_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.health_check_type = Some(input.into());
            self
        }
        pub fn set_health_check_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.health_check_type = input;
            self
        }
        /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status
        /// of an EC2 instance that has come into service.</p>
        pub fn health_check_grace_period(mut self, input: i32) -> Self {
            self.health_check_grace_period = Some(input);
            self
        }
        pub fn set_health_check_grace_period(mut self, input: std::option::Option<i32>) -> Self {
            self.health_check_grace_period = input;
            self
        }
        pub fn instances(mut self, input: impl Into<crate::model::Instance>) -> Self {
            let mut v = self.instances.unwrap_or_default();
            v.push(input.into());
            self.instances = Some(v);
            self
        }
        pub fn set_instances(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Instance>>,
        ) -> Self {
            self.instances = input;
            self
        }
        /// <p>The date and time the group was created.</p>
        pub fn created_time(mut self, input: smithy_types::Instant) -> Self {
            self.created_time = Some(input);
            self
        }
        pub fn set_created_time(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.created_time = input;
            self
        }
        pub fn suspended_processes(
            mut self,
            input: impl Into<crate::model::SuspendedProcess>,
        ) -> Self {
            let mut v = self.suspended_processes.unwrap_or_default();
            v.push(input.into());
            self.suspended_processes = Some(v);
            self
        }
        pub fn set_suspended_processes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SuspendedProcess>>,
        ) -> Self {
            self.suspended_processes = input;
            self
        }
        /// <p>The name of the placement group into which to launch your instances, if any.</p>
        pub fn placement_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.placement_group = Some(input.into());
            self
        }
        pub fn set_placement_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.placement_group = input;
            self
        }
        /// <p>One or more subnet IDs, if applicable, separated by commas.</p>
        pub fn vpc_zone_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.vpc_zone_identifier = Some(input.into());
            self
        }
        pub fn set_vpc_zone_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.vpc_zone_identifier = input;
            self
        }
        pub fn enabled_metrics(mut self, input: impl Into<crate::model::EnabledMetric>) -> Self {
            let mut v = self.enabled_metrics.unwrap_or_default();
            v.push(input.into());
            self.enabled_metrics = Some(v);
            self
        }
        pub fn set_enabled_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EnabledMetric>>,
        ) -> Self {
            self.enabled_metrics = input;
            self
        }
        /// <p>The current state of the group when the <a>DeleteAutoScalingGroup</a>
        /// operation is in progress.</p>
        pub fn status(mut self, input: impl Into<std::string::String>) -> Self {
            self.status = Some(input.into());
            self
        }
        pub fn set_status(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.status = input;
            self
        }
        pub fn tags(mut self, input: impl Into<crate::model::TagDescription>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagDescription>>,
        ) -> Self {
            self.tags = input;
            self
        }
        pub fn termination_policies(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.termination_policies.unwrap_or_default();
            v.push(input.into());
            self.termination_policies = Some(v);
            self
        }
        pub fn set_termination_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.termination_policies = input;
            self
        }
        /// <p>Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling
        /// when scaling in.</p>
        pub fn new_instances_protected_from_scale_in(mut self, input: bool) -> Self {
            self.new_instances_protected_from_scale_in = Some(input);
            self
        }
        pub fn set_new_instances_protected_from_scale_in(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.new_instances_protected_from_scale_in = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to
        /// call other Amazon Web Services on your behalf.</p>
        pub fn service_linked_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_linked_role_arn = Some(input.into());
            self
        }
        pub fn set_service_linked_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_linked_role_arn = input;
            self
        }
        /// <p>The maximum amount of time, in seconds, that an instance can be in service.</p>
        /// <p>Valid Range: Minimum value of 0.</p>
        pub fn max_instance_lifetime(mut self, input: i32) -> Self {
            self.max_instance_lifetime = Some(input);
            self
        }
        pub fn set_max_instance_lifetime(mut self, input: std::option::Option<i32>) -> Self {
            self.max_instance_lifetime = input;
            self
        }
        /// <p>Indicates whether Capacity Rebalancing is enabled.</p>
        pub fn capacity_rebalance(mut self, input: bool) -> Self {
            self.capacity_rebalance = Some(input);
            self
        }
        pub fn set_capacity_rebalance(mut self, input: std::option::Option<bool>) -> Self {
            self.capacity_rebalance = input;
            self
        }
        /// <p>The warm pool for the group.</p>
        pub fn warm_pool_configuration(
            mut self,
            input: crate::model::WarmPoolConfiguration,
        ) -> Self {
            self.warm_pool_configuration = Some(input);
            self
        }
        pub fn set_warm_pool_configuration(
            mut self,
            input: std::option::Option<crate::model::WarmPoolConfiguration>,
        ) -> Self {
            self.warm_pool_configuration = input;
            self
        }
        /// <p>The current size of the warm pool.</p>
        pub fn warm_pool_size(mut self, input: i32) -> Self {
            self.warm_pool_size = Some(input);
            self
        }
        pub fn set_warm_pool_size(mut self, input: std::option::Option<i32>) -> Self {
            self.warm_pool_size = input;
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.context = Some(input.into());
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.context = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoScalingGroup`](crate::model::AutoScalingGroup)
        pub fn build(self) -> crate::model::AutoScalingGroup {
            crate::model::AutoScalingGroup {
                auto_scaling_group_name: self.auto_scaling_group_name,
                auto_scaling_group_arn: self.auto_scaling_group_arn,
                launch_configuration_name: self.launch_configuration_name,
                launch_template: self.launch_template,
                mixed_instances_policy: self.mixed_instances_policy,
                min_size: self.min_size,
                max_size: self.max_size,
                desired_capacity: self.desired_capacity,
                predicted_capacity: self.predicted_capacity,
                default_cooldown: self.default_cooldown,
                availability_zones: self.availability_zones,
                load_balancer_names: self.load_balancer_names,
                target_group_ar_ns: self.target_group_ar_ns,
                health_check_type: self.health_check_type,
                health_check_grace_period: self.health_check_grace_period,
                instances: self.instances,
                created_time: self.created_time,
                suspended_processes: self.suspended_processes,
                placement_group: self.placement_group,
                vpc_zone_identifier: self.vpc_zone_identifier,
                enabled_metrics: self.enabled_metrics,
                status: self.status,
                tags: self.tags,
                termination_policies: self.termination_policies,
                new_instances_protected_from_scale_in: self.new_instances_protected_from_scale_in,
                service_linked_role_arn: self.service_linked_role_arn,
                max_instance_lifetime: self.max_instance_lifetime,
                capacity_rebalance: self.capacity_rebalance,
                warm_pool_configuration: self.warm_pool_configuration,
                warm_pool_size: self.warm_pool_size,
                context: self.context,
            }
        }
    }
}
impl AutoScalingGroup {
    /// Creates a new builder-style object to manufacture [`AutoScalingGroup`](crate::model::AutoScalingGroup)
    pub fn builder() -> crate::model::auto_scaling_group::Builder {
        crate::model::auto_scaling_group::Builder::default()
    }
}

/// <p>Describes an enabled metric.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EnabledMetric {
    /// <p>One of the following metrics:</p>
    /// <ul>
    /// <li>
    /// <p>
    /// <code>GroupMinSize</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupMaxSize</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupDesiredCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupInServiceInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupPendingInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupStandbyInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTerminatingInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTotalInstances</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupInServiceCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupPendingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupStandbyCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTerminatingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupTotalCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolDesiredCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolWarmedCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolPendingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolTerminatingCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>WarmPoolTotalCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupAndWarmPoolDesiredCapacity</code>
    /// </p>
    /// </li>
    /// <li>
    /// <p>
    /// <code>GroupAndWarmPoolTotalCapacity</code>
    /// </p>
    /// </li>
    /// </ul>
    pub metric: std::option::Option<std::string::String>,
    /// <p>The granularity of the metric. The only valid value is <code>1Minute</code>.</p>
    pub granularity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EnabledMetric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EnabledMetric");
        formatter.field("metric", &self.metric);
        formatter.field("granularity", &self.granularity);
        formatter.finish()
    }
}
/// See [`EnabledMetric`](crate::model::EnabledMetric)
pub mod enabled_metric {
    /// A builder for [`EnabledMetric`](crate::model::EnabledMetric)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) metric: std::option::Option<std::string::String>,
        pub(crate) granularity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>GroupMinSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupMaxSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolWarmedCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn metric(mut self, input: impl Into<std::string::String>) -> Self {
            self.metric = Some(input.into());
            self
        }
        pub fn set_metric(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.metric = input;
            self
        }
        /// <p>The granularity of the metric. The only valid value is <code>1Minute</code>.</p>
        pub fn granularity(mut self, input: impl Into<std::string::String>) -> Self {
            self.granularity = Some(input.into());
            self
        }
        pub fn set_granularity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.granularity = input;
            self
        }
        /// Consumes the builder and constructs a [`EnabledMetric`](crate::model::EnabledMetric)
        pub fn build(self) -> crate::model::EnabledMetric {
            crate::model::EnabledMetric {
                metric: self.metric,
                granularity: self.granularity,
            }
        }
    }
}
impl EnabledMetric {
    /// Creates a new builder-style object to manufacture [`EnabledMetric`](crate::model::EnabledMetric)
    pub fn builder() -> crate::model::enabled_metric::Builder {
        crate::model::enabled_metric::Builder::default()
    }
}

/// <p>Describes an auto scaling process that has been suspended.</p>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html#process-types">Scaling processes</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SuspendedProcess {
    /// <p>The name of the suspended process.</p>
    pub process_name: std::option::Option<std::string::String>,
    /// <p>The reason that the process was suspended.</p>
    pub suspension_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SuspendedProcess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SuspendedProcess");
        formatter.field("process_name", &self.process_name);
        formatter.field("suspension_reason", &self.suspension_reason);
        formatter.finish()
    }
}
/// See [`SuspendedProcess`](crate::model::SuspendedProcess)
pub mod suspended_process {
    /// A builder for [`SuspendedProcess`](crate::model::SuspendedProcess)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) process_name: std::option::Option<std::string::String>,
        pub(crate) suspension_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the suspended process.</p>
        pub fn process_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.process_name = Some(input.into());
            self
        }
        pub fn set_process_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.process_name = input;
            self
        }
        /// <p>The reason that the process was suspended.</p>
        pub fn suspension_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.suspension_reason = Some(input.into());
            self
        }
        pub fn set_suspension_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.suspension_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`SuspendedProcess`](crate::model::SuspendedProcess)
        pub fn build(self) -> crate::model::SuspendedProcess {
            crate::model::SuspendedProcess {
                process_name: self.process_name,
                suspension_reason: self.suspension_reason,
            }
        }
    }
}
impl SuspendedProcess {
    /// Creates a new builder-style object to manufacture [`SuspendedProcess`](crate::model::SuspendedProcess)
    pub fn builder() -> crate::model::suspended_process::Builder {
        crate::model::suspended_process::Builder::default()
    }
}

/// <p>Describes a policy adjustment type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdjustmentType {
    /// <p>The policy adjustment type. The valid values are <code>ChangeInCapacity</code>,
    /// <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>
    pub adjustment_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AdjustmentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdjustmentType");
        formatter.field("adjustment_type", &self.adjustment_type);
        formatter.finish()
    }
}
/// See [`AdjustmentType`](crate::model::AdjustmentType)
pub mod adjustment_type {
    /// A builder for [`AdjustmentType`](crate::model::AdjustmentType)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) adjustment_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The policy adjustment type. The valid values are <code>ChangeInCapacity</code>,
        /// <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>
        pub fn adjustment_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.adjustment_type = Some(input.into());
            self
        }
        pub fn set_adjustment_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.adjustment_type = input;
            self
        }
        /// Consumes the builder and constructs a [`AdjustmentType`](crate::model::AdjustmentType)
        pub fn build(self) -> crate::model::AdjustmentType {
            crate::model::AdjustmentType {
                adjustment_type: self.adjustment_type,
            }
        }
    }
}
impl AdjustmentType {
    /// Creates a new builder-style object to manufacture [`AdjustmentType`](crate::model::AdjustmentType)
    pub fn builder() -> crate::model::adjustment_type::Builder {
        crate::model::adjustment_type::Builder::default()
    }
}

/// <p>Describes a tag for an Auto Scaling group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>The name of the Auto Scaling group.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The type of resource. The only supported value is
    /// <code>auto-scaling-group</code>.</p>
    pub resource_type: std::option::Option<std::string::String>,
    /// <p>The tag key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag value.</p>
    pub value: std::option::Option<std::string::String>,
    /// <p>Determines whether the tag is added to new instances as they are launched in the
    /// group.</p>
    pub propagate_at_launch: std::option::Option<bool>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.field("propagate_at_launch", &self.propagate_at_launch);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
        pub(crate) propagate_at_launch: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The name of the Auto Scaling group.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The type of resource. The only supported value is
        /// <code>auto-scaling-group</code>.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The tag key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// <p>Determines whether the tag is added to new instances as they are launched in the
        /// group.</p>
        pub fn propagate_at_launch(mut self, input: bool) -> Self {
            self.propagate_at_launch = Some(input);
            self
        }
        pub fn set_propagate_at_launch(mut self, input: std::option::Option<bool>) -> Self {
            self.propagate_at_launch = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                resource_id: self.resource_id,
                resource_type: self.resource_type,
                key: self.key,
                value: self.value,
                propagate_at_launch: self.propagate_at_launch,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>Describes information used to specify a lifecycle hook for an Auto Scaling
/// group.</p>
/// <p>A lifecycle hook tells Amazon EC2 Auto Scaling to perform an action on an instance when the instance
/// launches (before it is put into service) or as the instance terminates (before it is
/// fully terminated).</p>
/// <p>This step is a part of the procedure for creating a lifecycle hook for an Auto Scaling
/// group:</p>
/// <ol>
/// <li>
/// <p>(Optional) Create a Lambda function and a rule that allows CloudWatch Events to
/// invoke your Lambda function when Amazon EC2 Auto Scaling launches or terminates
/// instances.</p>
/// </li>
/// <li>
/// <p>(Optional) Create a notification target and an IAM role. The target can be
/// either an Amazon SQS queue or an Amazon SNS topic. The role allows Amazon EC2 Auto Scaling to
/// publish lifecycle notifications to the target.</p>
/// </li>
/// <li>
/// <p>
/// <b>Create the lifecycle hook. Specify whether the hook is
/// used when the instances launch or terminate.</b>
/// </p>
/// </li>
/// <li>
/// <p>If you need more time, record the lifecycle action heartbeat to keep the
/// instance in a pending state.</p>
/// </li>
/// <li>
/// <p>If you finish before the timeout period ends, complete the lifecycle
/// action.</p>
/// </li>
/// </ol>
/// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/lifecycle-hooks.html">Amazon EC2 Auto Scaling lifecycle
/// hooks</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LifecycleHookSpecification {
    /// <p>The name of the lifecycle hook.</p>
    pub lifecycle_hook_name: std::option::Option<std::string::String>,
    /// <p>The state of the EC2 instance to which you want to attach the lifecycle hook. The
    /// valid values are:</p>
    /// <ul>
    /// <li>
    /// <p>autoscaling:EC2_INSTANCE_LAUNCHING</p>
    /// </li>
    /// <li>
    /// <p>autoscaling:EC2_INSTANCE_TERMINATING</p>
    /// </li>
    /// </ul>
    pub lifecycle_transition: std::option::Option<std::string::String>,
    /// <p>Additional information that you want to include any time Amazon EC2 Auto Scaling sends a message to
    /// the notification target.</p>
    pub notification_metadata: std::option::Option<std::string::String>,
    /// <p>The maximum time, in seconds, that can elapse before the lifecycle hook times
    /// out.</p>
    /// <p>If the lifecycle hook times out, Amazon EC2 Auto Scaling performs the action that you specified in
    /// the <code>DefaultResult</code> parameter. You can prevent the lifecycle hook from timing
    /// out by calling <a>RecordLifecycleActionHeartbeat</a>.</p>
    pub heartbeat_timeout: std::option::Option<i32>,
    /// <p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses
    /// or if an unexpected failure occurs. The valid values are <code>CONTINUE</code> and
    /// <code>ABANDON</code>. The default value is <code>ABANDON</code>.</p>
    pub default_result: std::option::Option<std::string::String>,
    /// <p>The ARN of the target that Amazon EC2 Auto Scaling sends notifications to when an instance is in the
    /// transition state for the lifecycle hook. The notification target can be either an SQS
    /// queue or an SNS topic.</p>
    pub notification_target_arn: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified
    /// notification target, for example, an Amazon SNS topic or an Amazon SQS queue.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LifecycleHookSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LifecycleHookSpecification");
        formatter.field("lifecycle_hook_name", &self.lifecycle_hook_name);
        formatter.field("lifecycle_transition", &self.lifecycle_transition);
        formatter.field("notification_metadata", &self.notification_metadata);
        formatter.field("heartbeat_timeout", &self.heartbeat_timeout);
        formatter.field("default_result", &self.default_result);
        formatter.field("notification_target_arn", &self.notification_target_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`LifecycleHookSpecification`](crate::model::LifecycleHookSpecification)
pub mod lifecycle_hook_specification {
    /// A builder for [`LifecycleHookSpecification`](crate::model::LifecycleHookSpecification)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lifecycle_hook_name: std::option::Option<std::string::String>,
        pub(crate) lifecycle_transition: std::option::Option<std::string::String>,
        pub(crate) notification_metadata: std::option::Option<std::string::String>,
        pub(crate) heartbeat_timeout: std::option::Option<i32>,
        pub(crate) default_result: std::option::Option<std::string::String>,
        pub(crate) notification_target_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the lifecycle hook.</p>
        pub fn lifecycle_hook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_hook_name = Some(input.into());
            self
        }
        pub fn set_lifecycle_hook_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_hook_name = input;
            self
        }
        /// <p>The state of the EC2 instance to which you want to attach the lifecycle hook. The
        /// valid values are:</p>
        /// <ul>
        /// <li>
        /// <p>autoscaling:EC2_INSTANCE_LAUNCHING</p>
        /// </li>
        /// <li>
        /// <p>autoscaling:EC2_INSTANCE_TERMINATING</p>
        /// </li>
        /// </ul>
        pub fn lifecycle_transition(mut self, input: impl Into<std::string::String>) -> Self {
            self.lifecycle_transition = Some(input.into());
            self
        }
        pub fn set_lifecycle_transition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lifecycle_transition = input;
            self
        }
        /// <p>Additional information that you want to include any time Amazon EC2 Auto Scaling sends a message to
        /// the notification target.</p>
        pub fn notification_metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_metadata = Some(input.into());
            self
        }
        pub fn set_notification_metadata(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_metadata = input;
            self
        }
        /// <p>The maximum time, in seconds, that can elapse before the lifecycle hook times
        /// out.</p>
        /// <p>If the lifecycle hook times out, Amazon EC2 Auto Scaling performs the action that you specified in
        /// the <code>DefaultResult</code> parameter. You can prevent the lifecycle hook from timing
        /// out by calling <a>RecordLifecycleActionHeartbeat</a>.</p>
        pub fn heartbeat_timeout(mut self, input: i32) -> Self {
            self.heartbeat_timeout = Some(input);
            self
        }
        pub fn set_heartbeat_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.heartbeat_timeout = input;
            self
        }
        /// <p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses
        /// or if an unexpected failure occurs. The valid values are <code>CONTINUE</code> and
        /// <code>ABANDON</code>. The default value is <code>ABANDON</code>.</p>
        pub fn default_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_result = Some(input.into());
            self
        }
        pub fn set_default_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_result = input;
            self
        }
        /// <p>The ARN of the target that Amazon EC2 Auto Scaling sends notifications to when an instance is in the
        /// transition state for the lifecycle hook. The notification target can be either an SQS
        /// queue or an SNS topic.</p>
        pub fn notification_target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.notification_target_arn = Some(input.into());
            self
        }
        pub fn set_notification_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.notification_target_arn = input;
            self
        }
        /// <p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified
        /// notification target, for example, an Amazon SNS topic or an Amazon SQS queue.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LifecycleHookSpecification`](crate::model::LifecycleHookSpecification)
        pub fn build(self) -> crate::model::LifecycleHookSpecification {
            crate::model::LifecycleHookSpecification {
                lifecycle_hook_name: self.lifecycle_hook_name,
                lifecycle_transition: self.lifecycle_transition,
                notification_metadata: self.notification_metadata,
                heartbeat_timeout: self.heartbeat_timeout,
                default_result: self.default_result,
                notification_target_arn: self.notification_target_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl LifecycleHookSpecification {
    /// Creates a new builder-style object to manufacture [`LifecycleHookSpecification`](crate::model::LifecycleHookSpecification)
    pub fn builder() -> crate::model::lifecycle_hook_specification::Builder {
        crate::model::lifecycle_hook_specification::Builder::default()
    }
}

/// <p>Describes a scheduled action that could not be created, updated, or deleted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FailedScheduledUpdateGroupActionRequest {
    /// <p>The name of the scheduled action.</p>
    pub scheduled_action_name: std::option::Option<std::string::String>,
    /// <p>The error code.</p>
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The error message accompanying the error code.</p>
    pub error_message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FailedScheduledUpdateGroupActionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FailedScheduledUpdateGroupActionRequest");
        formatter.field("scheduled_action_name", &self.scheduled_action_name);
        formatter.field("error_code", &self.error_code);
        formatter.field("error_message", &self.error_message);
        formatter.finish()
    }
}
/// See [`FailedScheduledUpdateGroupActionRequest`](crate::model::FailedScheduledUpdateGroupActionRequest)
pub mod failed_scheduled_update_group_action_request {
    /// A builder for [`FailedScheduledUpdateGroupActionRequest`](crate::model::FailedScheduledUpdateGroupActionRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_action_name: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the scheduled action.</p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_action_name = Some(input.into());
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_action_name = input;
            self
        }
        /// <p>The error code.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The error message accompanying the error code.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedScheduledUpdateGroupActionRequest`](crate::model::FailedScheduledUpdateGroupActionRequest)
        pub fn build(self) -> crate::model::FailedScheduledUpdateGroupActionRequest {
            crate::model::FailedScheduledUpdateGroupActionRequest {
                scheduled_action_name: self.scheduled_action_name,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl FailedScheduledUpdateGroupActionRequest {
    /// Creates a new builder-style object to manufacture [`FailedScheduledUpdateGroupActionRequest`](crate::model::FailedScheduledUpdateGroupActionRequest)
    pub fn builder() -> crate::model::failed_scheduled_update_group_action_request::Builder {
        crate::model::failed_scheduled_update_group_action_request::Builder::default()
    }
}

/// <p>Describes information used for one or more scheduled scaling action updates in a <a>BatchPutScheduledUpdateGroupAction</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScheduledUpdateGroupActionRequest {
    /// <p>The name of the scaling action.</p>
    pub scheduled_action_name: std::option::Option<std::string::String>,
    /// <p>The date and time for the action to start, in YYYY-MM-DDThh:mm:ssZ format in UTC/GMT
    /// only and in quotes (for example, <code>"2019-06-01T00:00:00Z"</code>).</p>
    /// <p>If you specify <code>Recurrence</code> and <code>StartTime</code>, Amazon EC2 Auto Scaling performs
    /// the action at this time, and then performs the action based on the specified
    /// recurrence.</p>
    /// <p>If you try to schedule the action in the past, Amazon EC2 Auto Scaling returns an error
    /// message.</p>
    pub start_time: std::option::Option<smithy_types::Instant>,
    /// <p>The date and time for the recurring schedule to end, in UTC.</p>
    pub end_time: std::option::Option<smithy_types::Instant>,
    /// <p>The recurring schedule for the action, in Unix cron syntax format. This format
    /// consists of five fields separated by white spaces: [Minute] [Hour] [Day_of_Month]
    /// [Month_of_Year] [Day_of_Week]. The value must be in quotes (for example, <code>"30 0 1
    /// 1,6,12 *"</code>). For more information about this format, see <a href="http://crontab.org">Crontab</a>.</p>
    /// <p>When <code>StartTime</code> and <code>EndTime</code> are specified with
    /// <code>Recurrence</code>, they form the boundaries of when the recurring action
    /// starts and stops.</p>
    /// <p>Cron expressions use Universal Coordinated Time (UTC) by default.</p>
    pub recurrence: std::option::Option<std::string::String>,
    /// <p>The minimum size of the Auto Scaling group.</p>
    pub min_size: std::option::Option<i32>,
    /// <p>The maximum size of the Auto Scaling group.</p>
    pub max_size: std::option::Option<i32>,
    /// <p>The desired capacity is the initial capacity of the Auto Scaling group after the scheduled
    /// action runs and the capacity it attempts to maintain.</p>
    pub desired_capacity: std::option::Option<i32>,
    /// <p>Specifies the time zone for a cron expression. If a time zone is not provided, UTC is
    /// used by default. </p>
    /// <p>Valid values are the canonical names of the IANA time zones, derived from the IANA
    /// Time Zone Database (such as <code>Etc/GMT+9</code> or <code>Pacific/Tahiti</code>). For
    /// more information, see <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p>
    pub time_zone: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScheduledUpdateGroupActionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScheduledUpdateGroupActionRequest");
        formatter.field("scheduled_action_name", &self.scheduled_action_name);
        formatter.field("start_time", &self.start_time);
        formatter.field("end_time", &self.end_time);
        formatter.field("recurrence", &self.recurrence);
        formatter.field("min_size", &self.min_size);
        formatter.field("max_size", &self.max_size);
        formatter.field("desired_capacity", &self.desired_capacity);
        formatter.field("time_zone", &self.time_zone);
        formatter.finish()
    }
}
/// See [`ScheduledUpdateGroupActionRequest`](crate::model::ScheduledUpdateGroupActionRequest)
pub mod scheduled_update_group_action_request {
    /// A builder for [`ScheduledUpdateGroupActionRequest`](crate::model::ScheduledUpdateGroupActionRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scheduled_action_name: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<smithy_types::Instant>,
        pub(crate) end_time: std::option::Option<smithy_types::Instant>,
        pub(crate) recurrence: std::option::Option<std::string::String>,
        pub(crate) min_size: std::option::Option<i32>,
        pub(crate) max_size: std::option::Option<i32>,
        pub(crate) desired_capacity: std::option::Option<i32>,
        pub(crate) time_zone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the scaling action.</p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_action_name = Some(input.into());
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_action_name = input;
            self
        }
        /// <p>The date and time for the action to start, in YYYY-MM-DDThh:mm:ssZ format in UTC/GMT
        /// only and in quotes (for example, <code>"2019-06-01T00:00:00Z"</code>).</p>
        /// <p>If you specify <code>Recurrence</code> and <code>StartTime</code>, Amazon EC2 Auto Scaling performs
        /// the action at this time, and then performs the action based on the specified
        /// recurrence.</p>
        /// <p>If you try to schedule the action in the past, Amazon EC2 Auto Scaling returns an error
        /// message.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The date and time for the recurring schedule to end, in UTC.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The recurring schedule for the action, in Unix cron syntax format. This format
        /// consists of five fields separated by white spaces: [Minute] [Hour] [Day_of_Month]
        /// [Month_of_Year] [Day_of_Week]. The value must be in quotes (for example, <code>"30 0 1
        /// 1,6,12 *"</code>). For more information about this format, see <a href="http://crontab.org">Crontab</a>.</p>
        /// <p>When <code>StartTime</code> and <code>EndTime</code> are specified with
        /// <code>Recurrence</code>, they form the boundaries of when the recurring action
        /// starts and stops.</p>
        /// <p>Cron expressions use Universal Coordinated Time (UTC) by default.</p>
        pub fn recurrence(mut self, input: impl Into<std::string::String>) -> Self {
            self.recurrence = Some(input.into());
            self
        }
        pub fn set_recurrence(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.recurrence = input;
            self
        }
        /// <p>The minimum size of the Auto Scaling group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.min_size = Some(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.min_size = input;
            self
        }
        /// <p>The maximum size of the Auto Scaling group.</p>
        pub fn max_size(mut self, input: i32) -> Self {
            self.max_size = Some(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.max_size = input;
            self
        }
        /// <p>The desired capacity is the initial capacity of the Auto Scaling group after the scheduled
        /// action runs and the capacity it attempts to maintain.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.desired_capacity = Some(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.desired_capacity = input;
            self
        }
        /// <p>Specifies the time zone for a cron expression. If a time zone is not provided, UTC is
        /// used by default. </p>
        /// <p>Valid values are the canonical names of the IANA time zones, derived from the IANA
        /// Time Zone Database (such as <code>Etc/GMT+9</code> or <code>Pacific/Tahiti</code>). For
        /// more information, see <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_zone = Some(input.into());
            self
        }
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_zone = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduledUpdateGroupActionRequest`](crate::model::ScheduledUpdateGroupActionRequest)
        pub fn build(self) -> crate::model::ScheduledUpdateGroupActionRequest {
            crate::model::ScheduledUpdateGroupActionRequest {
                scheduled_action_name: self.scheduled_action_name,
                start_time: self.start_time,
                end_time: self.end_time,
                recurrence: self.recurrence,
                min_size: self.min_size,
                max_size: self.max_size,
                desired_capacity: self.desired_capacity,
                time_zone: self.time_zone,
            }
        }
    }
}
impl ScheduledUpdateGroupActionRequest {
    /// Creates a new builder-style object to manufacture [`ScheduledUpdateGroupActionRequest`](crate::model::ScheduledUpdateGroupActionRequest)
    pub fn builder() -> crate::model::scheduled_update_group_action_request::Builder {
        crate::model::scheduled_update_group_action_request::Builder::default()
    }
}
