// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn attach_instances(&self) -> fluent_builders::AttachInstances<C> {
        fluent_builders::AttachInstances::new(self.handle.clone())
    }
    pub fn attach_load_balancers(&self) -> fluent_builders::AttachLoadBalancers<C> {
        fluent_builders::AttachLoadBalancers::new(self.handle.clone())
    }
    pub fn attach_load_balancer_target_groups(
        &self,
    ) -> fluent_builders::AttachLoadBalancerTargetGroups<C> {
        fluent_builders::AttachLoadBalancerTargetGroups::new(self.handle.clone())
    }
    pub fn batch_delete_scheduled_action(&self) -> fluent_builders::BatchDeleteScheduledAction<C> {
        fluent_builders::BatchDeleteScheduledAction::new(self.handle.clone())
    }
    pub fn batch_put_scheduled_update_group_action(
        &self,
    ) -> fluent_builders::BatchPutScheduledUpdateGroupAction<C> {
        fluent_builders::BatchPutScheduledUpdateGroupAction::new(self.handle.clone())
    }
    pub fn cancel_instance_refresh(&self) -> fluent_builders::CancelInstanceRefresh<C> {
        fluent_builders::CancelInstanceRefresh::new(self.handle.clone())
    }
    pub fn complete_lifecycle_action(&self) -> fluent_builders::CompleteLifecycleAction<C> {
        fluent_builders::CompleteLifecycleAction::new(self.handle.clone())
    }
    pub fn create_auto_scaling_group(&self) -> fluent_builders::CreateAutoScalingGroup<C> {
        fluent_builders::CreateAutoScalingGroup::new(self.handle.clone())
    }
    pub fn create_launch_configuration(&self) -> fluent_builders::CreateLaunchConfiguration<C> {
        fluent_builders::CreateLaunchConfiguration::new(self.handle.clone())
    }
    pub fn create_or_update_tags(&self) -> fluent_builders::CreateOrUpdateTags<C> {
        fluent_builders::CreateOrUpdateTags::new(self.handle.clone())
    }
    pub fn delete_auto_scaling_group(&self) -> fluent_builders::DeleteAutoScalingGroup<C> {
        fluent_builders::DeleteAutoScalingGroup::new(self.handle.clone())
    }
    pub fn delete_launch_configuration(&self) -> fluent_builders::DeleteLaunchConfiguration<C> {
        fluent_builders::DeleteLaunchConfiguration::new(self.handle.clone())
    }
    pub fn delete_lifecycle_hook(&self) -> fluent_builders::DeleteLifecycleHook<C> {
        fluent_builders::DeleteLifecycleHook::new(self.handle.clone())
    }
    pub fn delete_notification_configuration(
        &self,
    ) -> fluent_builders::DeleteNotificationConfiguration<C> {
        fluent_builders::DeleteNotificationConfiguration::new(self.handle.clone())
    }
    pub fn delete_policy(&self) -> fluent_builders::DeletePolicy<C> {
        fluent_builders::DeletePolicy::new(self.handle.clone())
    }
    pub fn delete_scheduled_action(&self) -> fluent_builders::DeleteScheduledAction<C> {
        fluent_builders::DeleteScheduledAction::new(self.handle.clone())
    }
    pub fn delete_tags(&self) -> fluent_builders::DeleteTags<C> {
        fluent_builders::DeleteTags::new(self.handle.clone())
    }
    pub fn delete_warm_pool(&self) -> fluent_builders::DeleteWarmPool<C> {
        fluent_builders::DeleteWarmPool::new(self.handle.clone())
    }
    pub fn describe_account_limits(&self) -> fluent_builders::DescribeAccountLimits<C> {
        fluent_builders::DescribeAccountLimits::new(self.handle.clone())
    }
    pub fn describe_adjustment_types(&self) -> fluent_builders::DescribeAdjustmentTypes<C> {
        fluent_builders::DescribeAdjustmentTypes::new(self.handle.clone())
    }
    pub fn describe_auto_scaling_groups(&self) -> fluent_builders::DescribeAutoScalingGroups<C> {
        fluent_builders::DescribeAutoScalingGroups::new(self.handle.clone())
    }
    pub fn describe_auto_scaling_instances(
        &self,
    ) -> fluent_builders::DescribeAutoScalingInstances<C> {
        fluent_builders::DescribeAutoScalingInstances::new(self.handle.clone())
    }
    pub fn describe_auto_scaling_notification_types(
        &self,
    ) -> fluent_builders::DescribeAutoScalingNotificationTypes<C> {
        fluent_builders::DescribeAutoScalingNotificationTypes::new(self.handle.clone())
    }
    pub fn describe_instance_refreshes(&self) -> fluent_builders::DescribeInstanceRefreshes<C> {
        fluent_builders::DescribeInstanceRefreshes::new(self.handle.clone())
    }
    pub fn describe_launch_configurations(
        &self,
    ) -> fluent_builders::DescribeLaunchConfigurations<C> {
        fluent_builders::DescribeLaunchConfigurations::new(self.handle.clone())
    }
    pub fn describe_lifecycle_hooks(&self) -> fluent_builders::DescribeLifecycleHooks<C> {
        fluent_builders::DescribeLifecycleHooks::new(self.handle.clone())
    }
    pub fn describe_lifecycle_hook_types(&self) -> fluent_builders::DescribeLifecycleHookTypes<C> {
        fluent_builders::DescribeLifecycleHookTypes::new(self.handle.clone())
    }
    pub fn describe_load_balancers(&self) -> fluent_builders::DescribeLoadBalancers<C> {
        fluent_builders::DescribeLoadBalancers::new(self.handle.clone())
    }
    pub fn describe_load_balancer_target_groups(
        &self,
    ) -> fluent_builders::DescribeLoadBalancerTargetGroups<C> {
        fluent_builders::DescribeLoadBalancerTargetGroups::new(self.handle.clone())
    }
    pub fn describe_metric_collection_types(
        &self,
    ) -> fluent_builders::DescribeMetricCollectionTypes<C> {
        fluent_builders::DescribeMetricCollectionTypes::new(self.handle.clone())
    }
    pub fn describe_notification_configurations(
        &self,
    ) -> fluent_builders::DescribeNotificationConfigurations<C> {
        fluent_builders::DescribeNotificationConfigurations::new(self.handle.clone())
    }
    pub fn describe_policies(&self) -> fluent_builders::DescribePolicies<C> {
        fluent_builders::DescribePolicies::new(self.handle.clone())
    }
    pub fn describe_scaling_activities(&self) -> fluent_builders::DescribeScalingActivities<C> {
        fluent_builders::DescribeScalingActivities::new(self.handle.clone())
    }
    pub fn describe_scaling_process_types(
        &self,
    ) -> fluent_builders::DescribeScalingProcessTypes<C> {
        fluent_builders::DescribeScalingProcessTypes::new(self.handle.clone())
    }
    pub fn describe_scheduled_actions(&self) -> fluent_builders::DescribeScheduledActions<C> {
        fluent_builders::DescribeScheduledActions::new(self.handle.clone())
    }
    pub fn describe_tags(&self) -> fluent_builders::DescribeTags<C> {
        fluent_builders::DescribeTags::new(self.handle.clone())
    }
    pub fn describe_termination_policy_types(
        &self,
    ) -> fluent_builders::DescribeTerminationPolicyTypes<C> {
        fluent_builders::DescribeTerminationPolicyTypes::new(self.handle.clone())
    }
    pub fn describe_warm_pool(&self) -> fluent_builders::DescribeWarmPool<C> {
        fluent_builders::DescribeWarmPool::new(self.handle.clone())
    }
    pub fn detach_instances(&self) -> fluent_builders::DetachInstances<C> {
        fluent_builders::DetachInstances::new(self.handle.clone())
    }
    pub fn detach_load_balancers(&self) -> fluent_builders::DetachLoadBalancers<C> {
        fluent_builders::DetachLoadBalancers::new(self.handle.clone())
    }
    pub fn detach_load_balancer_target_groups(
        &self,
    ) -> fluent_builders::DetachLoadBalancerTargetGroups<C> {
        fluent_builders::DetachLoadBalancerTargetGroups::new(self.handle.clone())
    }
    pub fn disable_metrics_collection(&self) -> fluent_builders::DisableMetricsCollection<C> {
        fluent_builders::DisableMetricsCollection::new(self.handle.clone())
    }
    pub fn enable_metrics_collection(&self) -> fluent_builders::EnableMetricsCollection<C> {
        fluent_builders::EnableMetricsCollection::new(self.handle.clone())
    }
    pub fn enter_standby(&self) -> fluent_builders::EnterStandby<C> {
        fluent_builders::EnterStandby::new(self.handle.clone())
    }
    pub fn execute_policy(&self) -> fluent_builders::ExecutePolicy<C> {
        fluent_builders::ExecutePolicy::new(self.handle.clone())
    }
    pub fn exit_standby(&self) -> fluent_builders::ExitStandby<C> {
        fluent_builders::ExitStandby::new(self.handle.clone())
    }
    pub fn get_predictive_scaling_forecast(
        &self,
    ) -> fluent_builders::GetPredictiveScalingForecast<C> {
        fluent_builders::GetPredictiveScalingForecast::new(self.handle.clone())
    }
    pub fn put_lifecycle_hook(&self) -> fluent_builders::PutLifecycleHook<C> {
        fluent_builders::PutLifecycleHook::new(self.handle.clone())
    }
    pub fn put_notification_configuration(
        &self,
    ) -> fluent_builders::PutNotificationConfiguration<C> {
        fluent_builders::PutNotificationConfiguration::new(self.handle.clone())
    }
    pub fn put_scaling_policy(&self) -> fluent_builders::PutScalingPolicy<C> {
        fluent_builders::PutScalingPolicy::new(self.handle.clone())
    }
    pub fn put_scheduled_update_group_action(
        &self,
    ) -> fluent_builders::PutScheduledUpdateGroupAction<C> {
        fluent_builders::PutScheduledUpdateGroupAction::new(self.handle.clone())
    }
    pub fn put_warm_pool(&self) -> fluent_builders::PutWarmPool<C> {
        fluent_builders::PutWarmPool::new(self.handle.clone())
    }
    pub fn record_lifecycle_action_heartbeat(
        &self,
    ) -> fluent_builders::RecordLifecycleActionHeartbeat<C> {
        fluent_builders::RecordLifecycleActionHeartbeat::new(self.handle.clone())
    }
    pub fn resume_processes(&self) -> fluent_builders::ResumeProcesses<C> {
        fluent_builders::ResumeProcesses::new(self.handle.clone())
    }
    pub fn set_desired_capacity(&self) -> fluent_builders::SetDesiredCapacity<C> {
        fluent_builders::SetDesiredCapacity::new(self.handle.clone())
    }
    pub fn set_instance_health(&self) -> fluent_builders::SetInstanceHealth<C> {
        fluent_builders::SetInstanceHealth::new(self.handle.clone())
    }
    pub fn set_instance_protection(&self) -> fluent_builders::SetInstanceProtection<C> {
        fluent_builders::SetInstanceProtection::new(self.handle.clone())
    }
    pub fn start_instance_refresh(&self) -> fluent_builders::StartInstanceRefresh<C> {
        fluent_builders::StartInstanceRefresh::new(self.handle.clone())
    }
    pub fn suspend_processes(&self) -> fluent_builders::SuspendProcesses<C> {
        fluent_builders::SuspendProcesses::new(self.handle.clone())
    }
    pub fn terminate_instance_in_auto_scaling_group(
        &self,
    ) -> fluent_builders::TerminateInstanceInAutoScalingGroup<C> {
        fluent_builders::TerminateInstanceInAutoScalingGroup::new(self.handle.clone())
    }
    pub fn update_auto_scaling_group(&self) -> fluent_builders::UpdateAutoScalingGroup<C> {
        fluent_builders::UpdateAutoScalingGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AttachInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_instances_input::Builder,
    }
    impl<C> AttachInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachInstancesOutput,
            smithy_http::result::SdkError<crate::error::AttachInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances. You can specify up to 20 instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachLoadBalancers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_load_balancers_input::Builder,
    }
    impl<C> AttachLoadBalancers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::AttachLoadBalancersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The names of the load balancers. You can specify up to 10 load balancers.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AttachLoadBalancerTargetGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::attach_load_balancer_target_groups_input::Builder,
    }
    impl<C> AttachLoadBalancerTargetGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AttachLoadBalancerTargetGroupsOutput,
            smithy_http::result::SdkError<crate::error::AttachLoadBalancerTargetGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the target groups. You can specify up to 10 target
        /// groups. To get the ARN of a target group, use the Elastic Load Balancing <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeTargetGroups.html">DescribeTargetGroups</a> API operation.</p>
        pub fn target_group_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_ar_ns(inp);
            self
        }
        pub fn set_target_group_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_group_ar_ns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDeleteScheduledAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_delete_scheduled_action_input::Builder,
    }
    impl<C> BatchDeleteScheduledAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDeleteScheduledActionOutput,
            smithy_http::result::SdkError<crate::error::BatchDeleteScheduledActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The names of the scheduled actions to delete. The maximum number allowed is 50.
        /// </p>
        pub fn scheduled_action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_names(inp);
            self
        }
        pub fn set_scheduled_action_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchPutScheduledUpdateGroupAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_put_scheduled_update_group_action_input::Builder,
    }
    impl<C> BatchPutScheduledUpdateGroupAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchPutScheduledUpdateGroupActionOutput,
            smithy_http::result::SdkError<crate::error::BatchPutScheduledUpdateGroupActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>One or more scheduled actions. The maximum number allowed is 50.</p>
        pub fn scheduled_update_group_actions(
            mut self,
            inp: impl Into<crate::model::ScheduledUpdateGroupActionRequest>,
        ) -> Self {
            self.inner = self.inner.scheduled_update_group_actions(inp);
            self
        }
        pub fn set_scheduled_update_group_actions(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ScheduledUpdateGroupActionRequest>,
            >,
        ) -> Self {
            self.inner = self.inner.set_scheduled_update_group_actions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CancelInstanceRefresh<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::cancel_instance_refresh_input::Builder,
    }
    impl<C> CancelInstanceRefresh<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelInstanceRefreshOutput,
            smithy_http::result::SdkError<crate::error::CancelInstanceRefreshError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CompleteLifecycleAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::complete_lifecycle_action_input::Builder,
    }
    impl<C> CompleteLifecycleAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CompleteLifecycleActionOutput,
            smithy_http::result::SdkError<crate::error::CompleteLifecycleActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the lifecycle hook.</p>
        pub fn lifecycle_hook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_hook_name(input);
            self
        }
        pub fn set_lifecycle_hook_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_hook_name(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>A universally unique identifier (UUID) that identifies a specific lifecycle action
        /// associated with an instance. Amazon EC2 Auto Scaling sends this token to the notification target you
        /// specified when you created the lifecycle hook.</p>
        pub fn lifecycle_action_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_action_token(input);
            self
        }
        pub fn set_lifecycle_action_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_action_token(input);
            self
        }
        /// <p>The action for the group to take. This parameter can be either <code>CONTINUE</code>
        /// or <code>ABANDON</code>.</p>
        pub fn lifecycle_action_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_action_result(input);
            self
        }
        pub fn set_lifecycle_action_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_action_result(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAutoScalingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_auto_scaling_group_input::Builder,
    }
    impl<C> CreateAutoScalingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAutoScalingGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateAutoScalingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group. This name must be unique per Region per account.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name of the launch configuration to use to launch instances. </p>
        /// <p>Conditional: You must specify either a launch template (<code>LaunchTemplate</code> or
        /// <code>MixedInstancesPolicy</code>) or a launch configuration
        /// (<code>LaunchConfigurationName</code> or <code>InstanceId</code>).</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_configuration_name(input);
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_configuration_name(input);
            self
        }
        /// <p>Parameters used to specify the launch template and version to use to launch instances. </p>
        /// <p>Conditional: You must specify either a launch template (<code>LaunchTemplate</code> or
        /// <code>MixedInstancesPolicy</code>) or a launch configuration
        /// (<code>LaunchConfigurationName</code> or <code>InstanceId</code>).</p>
        /// <note>
        /// <p>The launch template that is specified must be configured for use with an Auto Scaling
        /// group. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-template.html">Creating a launch
        /// template for an Auto Scaling group</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// </note>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.inner = self.inner.launch_template(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_template(input);
            self
        }
        /// <p>An embedded object that specifies a mixed instances policy. The required properties
        /// must be specified. If optional properties are unspecified, their default values are
        /// used.</p>
        /// <p>The policy includes properties that not only define the distribution of On-Demand
        /// Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the
        /// Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacities, but also
        /// the properties that specify the instance configuration informationâ€”the launch template
        /// and instance types. The policy can also include a weight for each instance type and
        /// different launch templates for individual instance types. For more information, see
        /// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-purchase-options.html">Auto Scaling groups with multiple
        /// instance types and purchase options</a> in the <i>Amazon EC2 Auto Scaling User
        /// Guide</i>.</p>
        pub fn mixed_instances_policy(mut self, input: crate::model::MixedInstancesPolicy) -> Self {
            self.inner = self.inner.mixed_instances_policy(input);
            self
        }
        pub fn set_mixed_instances_policy(
            mut self,
            input: std::option::Option<crate::model::MixedInstancesPolicy>,
        ) -> Self {
            self.inner = self.inner.set_mixed_instances_policy(input);
            self
        }
        /// <p>The ID of the instance used to base the launch configuration on. If specified, Amazon
        /// EC2 Auto Scaling uses the configuration values from the specified instance to create a
        /// new launch configuration. To get the instance ID, use the Amazon EC2 <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html">DescribeInstances</a> API operation. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-from-instance.html">Creating an Auto Scaling group using an EC2 instance</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The minimum size of the group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.inner = self.inner.min_size(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>The maximum size of the group.</p>
        /// <note>
        /// <p>With a mixed instances policy that uses instance weighting, Amazon EC2 Auto Scaling may need to
        /// go above <code>MaxSize</code> to meet your capacity requirements. In this event,
        /// Amazon EC2 Auto Scaling will never go above <code>MaxSize</code> by more than your largest instance
        /// weight (weights that define how many units each instance contributes to the desired
        /// capacity of the group).</p>
        /// </note>
        pub fn max_size(mut self, input: i32) -> Self {
            self.inner = self.inner.max_size(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_size(input);
            self
        }
        /// <p>The desired capacity is the initial capacity of the Auto Scaling group at the time of its
        /// creation and the capacity it attempts to maintain. It can scale beyond this capacity if
        /// you configure auto scaling. This number must be greater than or equal to the minimum
        /// size of the group and less than or equal to the maximum size of the group. If you do not
        /// specify a desired capacity, the default is the minimum size of the group.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.desired_capacity(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_capacity(input);
            self
        }
        /// <p>The amount of time, in seconds, after a scaling activity completes before another
        /// scaling activity can start. The default value is <code>300</code>. This setting applies
        /// when using simple scaling policies, but not when using other scaling policies or
        /// scheduled scaling. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/Cooldown.html">Scaling cooldowns for Amazon EC2 Auto Scaling</a>
        /// in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn default_cooldown(mut self, input: i32) -> Self {
            self.inner = self.inner.default_cooldown(input);
            self
        }
        pub fn set_default_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_default_cooldown(input);
            self
        }
        /// <p>A list of Availability Zones where instances in the Auto Scaling group can be created. This
        /// parameter is optional if you specify one or more subnets for
        /// <code>VPCZoneIdentifier</code>.</p>
        /// <p>Conditional: If your account supports EC2-Classic and VPC, this parameter is required
        /// to launch instances into EC2-Classic.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// <p>A list of Classic Load Balancers associated with this Auto Scaling group. For
        /// Application Load Balancers, Network Load Balancers, and Gateway Load Balancers, specify
        /// the <code>TargetGroupARNs</code> property instead.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the target groups to associate with the Auto Scaling group.
        /// Instances are registered as targets in a target group, and traffic is routed to the
        /// target group. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-load-balancer.html">Elastic Load Balancing and
        /// Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn target_group_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_ar_ns(inp);
            self
        }
        pub fn set_target_group_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_group_ar_ns(input);
            self
        }
        /// <p>The service to use for the health checks. The valid values are <code>EC2</code>
        /// (default) and <code>ELB</code>. If you configure an Auto Scaling group to use load balancer
        /// (ELB) health checks, it considers the instance unhealthy if it fails either the EC2
        /// status checks or the load balancer health checks. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/healthcheck.html">Health checks
        /// for Auto Scaling instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn health_check_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_type(input);
            self
        }
        pub fn set_health_check_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_type(input);
            self
        }
        /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status
        /// of an EC2 instance that has come into service. During this time, any health check
        /// failures for the instance are ignored. The default value is <code>0</code>. For more
        /// information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/healthcheck.html#health-check-grace-period">Health
        /// check grace period</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>Conditional: Required if you are adding an <code>ELB</code> health check.</p>
        pub fn health_check_grace_period(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_grace_period(input);
            self
        }
        pub fn set_health_check_grace_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_check_grace_period(input);
            self
        }
        /// <p>The name of an existing placement group into which to launch your instances, if any. A
        /// placement group is a logical grouping of instances within a single Availability Zone.
        /// You cannot specify multiple Availability Zones and a placement group. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html">Placement Groups</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn placement_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.placement_group(input);
            self
        }
        pub fn set_placement_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_placement_group(input);
            self
        }
        /// <p>A comma-separated list of subnet IDs for a virtual private cloud (VPC) where instances
        /// in the Auto Scaling group can be created. If you specify <code>VPCZoneIdentifier</code> with
        /// <code>AvailabilityZones</code>, the subnets that you specify for this parameter must
        /// reside in those Availability Zones.</p>
        /// <p>Conditional: If your account supports EC2-Classic and VPC, this parameter is required
        /// to launch instances into a VPC.</p>
        pub fn vpc_zone_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_zone_identifier(input);
            self
        }
        pub fn set_vpc_zone_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_zone_identifier(input);
            self
        }
        /// <p>A policy or a list of policies that are used to select the instance to terminate.
        /// These policies are executed in the order that you list them. For more information, see
        /// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html">Controlling which Auto Scaling
        /// instances terminate during scale in</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn termination_policies(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.termination_policies(inp);
            self
        }
        pub fn set_termination_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_termination_policies(input);
            self
        }
        /// <p>Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling
        /// when scaling in. For more information about preventing instances from terminating on
        /// scale in, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html#instance-protection">Instance scale-in protection</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn new_instances_protected_from_scale_in(mut self, input: bool) -> Self {
            self.inner = self.inner.new_instances_protected_from_scale_in(input);
            self
        }
        pub fn set_new_instances_protected_from_scale_in(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_new_instances_protected_from_scale_in(input);
            self
        }
        /// <p>Indicates whether Capacity Rebalancing is enabled. Otherwise, Capacity Rebalancing is
        /// disabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot
        /// Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of
        /// interruption. After launching a new instance, it then terminates an old instance. For
        /// more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/capacity-rebalance.html">Amazon EC2 Auto Scaling Capacity
        /// Rebalancing</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn capacity_rebalance(mut self, input: bool) -> Self {
            self.inner = self.inner.capacity_rebalance(input);
            self
        }
        pub fn set_capacity_rebalance(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_capacity_rebalance(input);
            self
        }
        /// <p>One or more lifecycle hooks for the group, which specify actions to perform when
        /// Amazon EC2 Auto Scaling launches or terminates instances.</p>
        pub fn lifecycle_hook_specification_list(
            mut self,
            inp: impl Into<crate::model::LifecycleHookSpecification>,
        ) -> Self {
            self.inner = self.inner.lifecycle_hook_specification_list(inp);
            self
        }
        pub fn set_lifecycle_hook_specification_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LifecycleHookSpecification>>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_hook_specification_list(input);
            self
        }
        /// <p>One or more tags. You can tag your Auto Scaling group and propagate the tags to the Amazon EC2
        /// instances it launches. Tags are not propagated to Amazon EBS volumes. To add tags to Amazon EBS
        /// volumes, specify the tags in a launch template but use caution. If the launch template
        /// specifies an instance tag with a key that is also specified for the Auto Scaling group, Amazon EC2 Auto Scaling
        /// overrides the value of that instance tag with the value specified by the Auto Scaling group. For
        /// more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-tagging.html">Tagging Auto Scaling groups and
        /// instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to
        /// call other Amazon Web Services on your behalf. By default, Amazon EC2 Auto Scaling uses a service-linked role
        /// named <code>AWSServiceRoleForAutoScaling</code>, which it creates if it does not exist.
        /// For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-service-linked-role.html">Service-linked
        /// roles</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn service_linked_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_linked_role_arn(input);
            self
        }
        pub fn set_service_linked_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_linked_role_arn(input);
            self
        }
        /// <p>The maximum amount of time, in seconds, that an instance can be in service. The
        /// default is null. If specified, the value must be either 0 or a number equal to or
        /// greater than 86,400 seconds (1 day). For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-max-instance-lifetime.html">Replacing Auto Scaling instances based on maximum instance lifetime</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn max_instance_lifetime(mut self, input: i32) -> Self {
            self.inner = self.inner.max_instance_lifetime(input);
            self
        }
        pub fn set_max_instance_lifetime(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_instance_lifetime(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.context(input);
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_context(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLaunchConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_launch_configuration_input::Builder,
    }
    impl<C> CreateLaunchConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLaunchConfigurationOutput,
            smithy_http::result::SdkError<crate::error::CreateLaunchConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the launch configuration. This name must be unique per Region per
        /// account.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_configuration_name(input);
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_configuration_name(input);
            self
        }
        /// <p>The ID of the Amazon Machine Image (AMI) that was assigned during registration. For
        /// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html">Finding an AMI</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        /// <p>If you do not specify <code>InstanceId</code>, you must specify
        /// <code>ImageId</code>.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.image_id(input);
            self
        }
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_image_id(input);
            self
        }
        /// <p>The name of the key pair. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html">Amazon EC2 Key Pairs</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn key_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.key_name(input);
            self
        }
        pub fn set_key_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_key_name(input);
            self
        }
        /// <p>A list that contains the security groups to assign to the instances in the Auto Scaling
        /// group.</p>
        /// <p>[EC2-VPC] Specify the security group IDs. For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html">Security Groups for Your VPC</a> in the <i>Amazon Virtual Private Cloud
        /// User Guide</i>.</p>
        /// <p>[EC2-Classic] Specify either the security group names or the security group IDs. For
        /// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">Amazon EC2 Security
        /// Groups</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
        /// <p>The ID of a ClassicLink-enabled VPC to link your EC2-Classic instances to. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html">ClassicLink</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html#as-ClassicLink">Linking EC2-Classic
        /// instances to a VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>This parameter can only be used if you are launching EC2-Classic instances.</p>
        pub fn classic_link_vpc_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.classic_link_vpc_id(input);
            self
        }
        pub fn set_classic_link_vpc_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_classic_link_vpc_id(input);
            self
        }
        /// <p>The IDs of one or more security groups for the specified ClassicLink-enabled VPC. For
        /// more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-classiclink.html">ClassicLink</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i> and <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html#as-ClassicLink">Linking EC2-Classic
        /// instances to a VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>If you specify the <code>ClassicLinkVPCId</code> parameter, you must specify this
        /// parameter.</p>
        pub fn classic_link_vpc_security_groups(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.classic_link_vpc_security_groups(inp);
            self
        }
        pub fn set_classic_link_vpc_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_classic_link_vpc_security_groups(input);
            self
        }
        /// <p>The user data to make available to the launched EC2 instances. For more information,
        /// see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata and user data</a> (Linux) and <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html">Instance metadata and
        /// user data</a> (Windows). If you are using a command line tool, base64-encoding
        /// is performed for you, and you can load the text from a file. Otherwise, you must provide
        /// base64-encoded text. User data is limited to 16 KB.</p>
        pub fn user_data(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_data(input);
            self
        }
        pub fn set_user_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_user_data(input);
            self
        }
        /// <p>The ID of the instance to use to create the launch configuration. The new launch
        /// configuration derives attributes from the instance, except for the block device
        /// mapping.</p>
        /// <p>To create a launch configuration with a block device mapping or override any other
        /// instance attributes, specify them as part of the same request.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-lc-with-instanceID.html">Creating a launch
        /// configuration using an EC2 instance</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>If you do not specify <code>InstanceId</code>, you must specify both
        /// <code>ImageId</code> and <code>InstanceType</code>.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Specifies the instance type of the EC2 instance.</p>
        /// <p>For information about available instance types, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#AvailableInstanceTypes">Available
        /// Instance Types</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        /// <p>If you do not specify <code>InstanceId</code>, you must specify
        /// <code>InstanceType</code>.</p>
        pub fn instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_type(input);
            self
        }
        pub fn set_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_type(input);
            self
        }
        /// <p>The ID of the kernel associated with the AMI.</p>
        pub fn kernel_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kernel_id(input);
            self
        }
        pub fn set_kernel_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kernel_id(input);
            self
        }
        /// <p>The ID of the RAM disk to select.</p>
        pub fn ramdisk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ramdisk_id(input);
            self
        }
        pub fn set_ramdisk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ramdisk_id(input);
            self
        }
        /// <p>A block device mapping, which specifies the block devices for the instance. You can
        /// specify virtual devices and EBS volumes. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html">Block Device
        /// Mapping</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn block_device_mappings(
            mut self,
            inp: impl Into<crate::model::BlockDeviceMapping>,
        ) -> Self {
            self.inner = self.inner.block_device_mappings(inp);
            self
        }
        pub fn set_block_device_mappings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::BlockDeviceMapping>>,
        ) -> Self {
            self.inner = self.inner.set_block_device_mappings(input);
            self
        }
        /// <p>Controls whether instances in this group are launched with detailed
        /// (<code>true</code>) or basic (<code>false</code>) monitoring.</p>
        /// <p>The default value is <code>true</code> (enabled).</p>
        /// <important>
        /// <p>When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and
        /// your account is charged a fee. When you disable detailed monitoring, CloudWatch generates
        /// metrics every 5 minutes. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/latest/userguide/enable-as-instance-metrics.html">Configure
        /// Monitoring for Auto Scaling Instances</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// </important>
        pub fn instance_monitoring(mut self, input: crate::model::InstanceMonitoring) -> Self {
            self.inner = self.inner.instance_monitoring(input);
            self
        }
        pub fn set_instance_monitoring(
            mut self,
            input: std::option::Option<crate::model::InstanceMonitoring>,
        ) -> Self {
            self.inner = self.inner.set_instance_monitoring(input);
            self
        }
        /// <p>The maximum hourly price to be paid for any Spot Instance launched to fulfill the
        /// request. Spot Instances are launched when the price you specify exceeds the current Spot
        /// price. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-launch-spot-instances.html">Requesting Spot
        /// Instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <note>
        /// <p>When you change your maximum price by creating a new launch configuration, running
        /// instances will continue to run as long as the maximum price for those running
        /// instances is higher than the current Spot price.</p>
        /// </note>
        pub fn spot_price(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.spot_price(input);
            self
        }
        pub fn set_spot_price(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_spot_price(input);
            self
        }
        /// <p>The name or the Amazon Resource Name (ARN) of the instance profile associated with the
        /// IAM role for the instance. The instance profile contains the IAM role.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/us-iam-role.html">IAM role for applications that run
        /// on Amazon EC2 instances</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn iam_instance_profile(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_instance_profile(input);
            self
        }
        pub fn set_iam_instance_profile(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_iam_instance_profile(input);
            self
        }
        /// <p>Specifies whether the launch configuration is optimized for EBS I/O
        /// (<code>true</code>) or not (<code>false</code>). The optimization provides dedicated
        /// throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O
        /// performance. This optimization is not available with all instance types. Additional fees
        /// are incurred when you enable EBS optimization for an instance type that is not
        /// EBS-optimized by default. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html">Amazon EBS-Optimized
        /// Instances</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        /// <p>The default value is <code>false</code>.</p>
        pub fn ebs_optimized(mut self, input: bool) -> Self {
            self.inner = self.inner.ebs_optimized(input);
            self
        }
        pub fn set_ebs_optimized(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_ebs_optimized(input);
            self
        }
        /// <p>For Auto Scaling groups that are running in a virtual private cloud (VPC), specifies whether
        /// to assign a public IP address to the group's instances. If you specify
        /// <code>true</code>, each instance in the Auto Scaling group receives a unique public IP address.
        /// For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-in-vpc.html">Launching Auto Scaling instances in a
        /// VPC</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>If you specify this parameter, you must specify at least one subnet for
        /// <code>VPCZoneIdentifier</code> when you create your group.</p>
        /// <note>
        /// <p>If the instance is launched into a default subnet, the default is to assign a
        /// public IP address, unless you disabled the option to assign a public IP address on
        /// the subnet. If the instance is launched into a nondefault subnet, the default is not
        /// to assign a public IP address, unless you enabled the option to assign a public IP
        /// address on the subnet.</p>
        /// </note>
        pub fn associate_public_ip_address(mut self, input: bool) -> Self {
            self.inner = self.inner.associate_public_ip_address(input);
            self
        }
        pub fn set_associate_public_ip_address(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_associate_public_ip_address(input);
            self
        }
        /// <p>The tenancy of the instance. An instance with <code>dedicated</code> tenancy runs on
        /// isolated, single-tenant hardware and can only be launched into a VPC.</p>
        /// <p>To launch dedicated instances into a shared tenancy VPC (a VPC with the instance
        /// placement tenancy attribute set to <code>default</code>), you must set the value of this
        /// parameter to <code>dedicated</code>.</p>
        /// <p>If you specify <code>PlacementTenancy</code>, you must specify at least one subnet for
        /// <code>VPCZoneIdentifier</code> when you create your group.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-dedicated-instances.html">Configuring
        /// instance tenancy with Amazon EC2 Auto Scaling</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>Valid Values: <code>default</code> | <code>dedicated</code>
        /// </p>
        pub fn placement_tenancy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.placement_tenancy(input);
            self
        }
        pub fn set_placement_tenancy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_placement_tenancy(input);
            self
        }
        /// <p>The metadata options for the instances. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-launch-config.html#launch-configurations-imds">Configuring the Instance Metadata Options</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn metadata_options(mut self, input: crate::model::InstanceMetadataOptions) -> Self {
            self.inner = self.inner.metadata_options(input);
            self
        }
        pub fn set_metadata_options(
            mut self,
            input: std::option::Option<crate::model::InstanceMetadataOptions>,
        ) -> Self {
            self.inner = self.inner.set_metadata_options(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateOrUpdateTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_or_update_tags_input::Builder,
    }
    impl<C> CreateOrUpdateTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateOrUpdateTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateOrUpdateTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAutoScalingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_auto_scaling_group_input::Builder,
    }
    impl<C> DeleteAutoScalingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAutoScalingGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteAutoScalingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Specifies that the group is to be deleted along with all instances associated with the
        /// group, without waiting for all instances to be terminated. This parameter also deletes
        /// any outstanding lifecycle actions associated with the group.</p>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete(input);
            self
        }
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_launch_configuration_input::Builder,
    }
    impl<C> DeleteLaunchConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the launch configuration.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_configuration_name(input);
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_configuration_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLifecycleHook<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_lifecycle_hook_input::Builder,
    }
    impl<C> DeleteLifecycleHook<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLifecycleHookOutput,
            smithy_http::result::SdkError<crate::error::DeleteLifecycleHookError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the lifecycle hook.</p>
        pub fn lifecycle_hook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_hook_name(input);
            self
        }
        pub fn set_lifecycle_hook_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_hook_name(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNotificationConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_notification_configuration_input::Builder,
    }
    impl<C> DeleteNotificationConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNotificationConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteNotificationConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (Amazon SNS)
        /// topic.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_policy_input::Builder,
    }
    impl<C> DeletePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeletePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteScheduledAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_scheduled_action_input::Builder,
    }
    impl<C> DeleteScheduledAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteScheduledActionOutput,
            smithy_http::result::SdkError<crate::error::DeleteScheduledActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name of the action to delete.</p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_name(input);
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tags_input::Builder,
    }
    impl<C> DeleteTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTagsOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more tags.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteWarmPool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_warm_pool_input::Builder,
    }
    impl<C> DeleteWarmPool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteWarmPoolOutput,
            smithy_http::result::SdkError<crate::error::DeleteWarmPoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Specifies that the warm pool is to be deleted along with all of its associated
        /// instances, without waiting for all instances to be terminated. This parameter also
        /// deletes any outstanding lifecycle actions associated with the warm pool
        /// instances.</p>
        pub fn force_delete(mut self, input: bool) -> Self {
            self.inner = self.inner.force_delete(input);
            self
        }
        pub fn set_force_delete(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountLimits<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_account_limits_input::Builder,
    }
    impl<C> DescribeAccountLimits<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountLimitsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountLimitsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAdjustmentTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_adjustment_types_input::Builder,
    }
    impl<C> DescribeAdjustmentTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAdjustmentTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAdjustmentTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAutoScalingGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_auto_scaling_groups_input::Builder,
    }
    impl<C> DescribeAutoScalingGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAutoScalingGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAutoScalingGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the Auto Scaling groups. By default, you can only specify up to 50 names. You can
        /// optionally increase this limit using the <code>MaxRecords</code> parameter.</p>
        /// <p>If you omit this parameter, all Auto Scaling groups are described.</p>
        pub fn auto_scaling_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_names(inp);
            self
        }
        pub fn set_auto_scaling_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_names(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAutoScalingInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_auto_scaling_instances_input::Builder,
    }
    impl<C> DescribeAutoScalingInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAutoScalingInstancesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAutoScalingInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances. If you omit this parameter, all Auto Scaling instances are
        /// described. If you specify an ID that does not exist, it is ignored with no error.</p>
        /// <p>Array Members: Maximum number of 50 items.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>50</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAutoScalingNotificationTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_auto_scaling_notification_types_input::Builder,
    }
    impl<C> DescribeAutoScalingNotificationTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAutoScalingNotificationTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAutoScalingNotificationTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeInstanceRefreshes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_instance_refreshes_input::Builder,
    }
    impl<C> DescribeInstanceRefreshes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeInstanceRefreshesOutput,
            smithy_http::result::SdkError<crate::error::DescribeInstanceRefreshesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>One or more instance refresh IDs.</p>
        pub fn instance_refresh_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_refresh_ids(inp);
            self
        }
        pub fn set_instance_refresh_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_refresh_ids(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLaunchConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_launch_configurations_input::Builder,
    }
    impl<C> DescribeLaunchConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLaunchConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLaunchConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch configuration names. If you omit this parameter, all launch configurations
        /// are described.</p>
        /// <p>Array Members: Maximum number of 50 items.</p>
        pub fn launch_configuration_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_configuration_names(inp);
            self
        }
        pub fn set_launch_configuration_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_configuration_names(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLifecycleHooks<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_lifecycle_hooks_input::Builder,
    }
    impl<C> DescribeLifecycleHooks<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLifecycleHooksOutput,
            smithy_http::result::SdkError<crate::error::DescribeLifecycleHooksError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The names of one or more lifecycle hooks. If you omit this parameter, all lifecycle
        /// hooks are described.</p>
        pub fn lifecycle_hook_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_hook_names(inp);
            self
        }
        pub fn set_lifecycle_hook_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_hook_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLifecycleHookTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_lifecycle_hook_types_input::Builder,
    }
    impl<C> DescribeLifecycleHookTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLifecycleHookTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeLifecycleHookTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_load_balancers_input::Builder,
    }
    impl<C> DescribeLoadBalancers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>100</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLoadBalancerTargetGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_load_balancer_target_groups_input::Builder,
    }
    impl<C> DescribeLoadBalancerTargetGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLoadBalancerTargetGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeLoadBalancerTargetGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>100</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMetricCollectionTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_metric_collection_types_input::Builder,
    }
    impl<C> DescribeMetricCollectionTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMetricCollectionTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeMetricCollectionTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNotificationConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_notification_configurations_input::Builder,
    }
    impl<C> DescribeNotificationConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNotificationConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::DescribeNotificationConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_names(inp);
            self
        }
        pub fn set_auto_scaling_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_names(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePolicies<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_policies_input::Builder,
    }
    impl<C> DescribePolicies<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePoliciesOutput,
            smithy_http::result::SdkError<crate::error::DescribePoliciesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The names of one or more policies. If you omit this parameter, all policies are
        /// described. If a group name is provided, the results are limited to that group. If you
        /// specify an unknown policy name, it is ignored with no error.</p>
        /// <p>Array Members: Maximum number of 50 items.</p>
        pub fn policy_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_names(inp);
            self
        }
        pub fn set_policy_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_names(input);
            self
        }
        /// <p>One or more policy types. The valid values are <code>SimpleScaling</code>,
        /// <code>StepScaling</code>, <code>TargetTrackingScaling</code>, and
        /// <code>PredictiveScaling</code>.</p>
        pub fn policy_types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_types(inp);
            self
        }
        pub fn set_policy_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_policy_types(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to be returned with each call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScalingActivities<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scaling_activities_input::Builder,
    }
    impl<C> DescribeScalingActivities<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScalingActivitiesOutput,
            smithy_http::result::SdkError<crate::error::DescribeScalingActivitiesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The activity IDs of the desired scaling activities. If you omit this parameter, all
        /// activities for the past six weeks are described. If unknown activities are requested,
        /// they are ignored with no error. If you specify an Auto Scaling group, the results are limited to
        /// that group.</p>
        /// <p>Array Members: Maximum number of 50 IDs.</p>
        pub fn activity_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.activity_ids(inp);
            self
        }
        pub fn set_activity_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_activity_ids(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Indicates whether to include scaling activity from deleted Auto Scaling groups.</p>
        pub fn include_deleted_groups(mut self, input: bool) -> Self {
            self.inner = self.inner.include_deleted_groups(input);
            self
        }
        pub fn set_include_deleted_groups(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_deleted_groups(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>100</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScalingProcessTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scaling_process_types_input::Builder,
    }
    impl<C> DescribeScalingProcessTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScalingProcessTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeScalingProcessTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeScheduledActions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_scheduled_actions_input::Builder,
    }
    impl<C> DescribeScheduledActions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeScheduledActionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeScheduledActionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The names of one or more scheduled actions. If you omit this parameter, all scheduled
        /// actions are described. If you specify an unknown scheduled action, it is ignored with no
        /// error.</p>
        /// <p>Array Members: Maximum number of 50 actions.</p>
        pub fn scheduled_action_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_names(inp);
            self
        }
        pub fn set_scheduled_action_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_names(input);
            self
        }
        /// <p>The earliest scheduled start time to return. If scheduled action names are provided,
        /// this parameter is ignored.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The latest scheduled start time to return. If scheduled action names are provided,
        /// this parameter is ignored.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tags_input::Builder,
    }
    impl<C> DescribeTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTagsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more filters to scope the tags to return. The maximum number of filters per
        /// filter type (for example, <code>auto-scaling-group</code>) is 1000.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>The token for the next set of items to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of items to return with this call. The default value is
        /// <code>50</code> and the maximum value is <code>100</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTerminationPolicyTypes<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_termination_policy_types_input::Builder,
    }
    impl<C> DescribeTerminationPolicyTypes<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTerminationPolicyTypesOutput,
            smithy_http::result::SdkError<crate::error::DescribeTerminationPolicyTypesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeWarmPool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_warm_pool_input::Builder,
    }
    impl<C> DescribeWarmPool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeWarmPoolOutput,
            smithy_http::result::SdkError<crate::error::DescribeWarmPoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The maximum number of instances to return with this call. The maximum value is
        /// <code>50</code>.</p>
        pub fn max_records(mut self, input: i32) -> Self {
            self.inner = self.inner.max_records(input);
            self
        }
        pub fn set_max_records(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_records(input);
            self
        }
        /// <p>The token for the next set of instances to return. (You received this token from a
        /// previous call.)</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_instances_input::Builder,
    }
    impl<C> DetachInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachInstancesOutput,
            smithy_http::result::SdkError<crate::error::DetachInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances. You can specify up to 20 instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Indicates whether the Auto Scaling group decrements the desired capacity value by the number
        /// of instances detached.</p>
        pub fn should_decrement_desired_capacity(mut self, input: bool) -> Self {
            self.inner = self.inner.should_decrement_desired_capacity(input);
            self
        }
        pub fn set_should_decrement_desired_capacity(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_should_decrement_desired_capacity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachLoadBalancers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_load_balancers_input::Builder,
    }
    impl<C> DetachLoadBalancers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachLoadBalancersOutput,
            smithy_http::result::SdkError<crate::error::DetachLoadBalancersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The names of the load balancers. You can specify up to 10 load balancers.</p>
        pub fn load_balancer_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.load_balancer_names(inp);
            self
        }
        pub fn set_load_balancer_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DetachLoadBalancerTargetGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::detach_load_balancer_target_groups_input::Builder,
    }
    impl<C> DetachLoadBalancerTargetGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DetachLoadBalancerTargetGroupsOutput,
            smithy_http::result::SdkError<crate::error::DetachLoadBalancerTargetGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The Amazon Resource Names (ARN) of the target groups. You can specify up to 10 target
        /// groups.</p>
        pub fn target_group_ar_ns(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_group_ar_ns(inp);
            self
        }
        pub fn set_target_group_ar_ns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_group_ar_ns(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisableMetricsCollection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disable_metrics_collection_input::Builder,
    }
    impl<C> DisableMetricsCollection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisableMetricsCollectionOutput,
            smithy_http::result::SdkError<crate::error::DisableMetricsCollectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Specifies one or more of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>GroupMinSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupMaxSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolWarmedCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you omit this parameter, all metrics are disabled. </p>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnableMetricsCollection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enable_metrics_collection_input::Builder,
    }
    impl<C> EnableMetricsCollection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnableMetricsCollectionOutput,
            smithy_http::result::SdkError<crate::error::EnableMetricsCollectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Specifies which group-level metrics to start collecting. You can specify one or more
        /// of the following metrics:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>GroupMinSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupMaxSize</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupInServiceInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingInstances</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalInstances</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>The instance weighting feature supports the following additional metrics: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>GroupInServiceCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupStandbyCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupTotalCapacity</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>The warm pools feature supports the following additional metrics: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>WarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolWarmedCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolPendingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTerminatingCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>WarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolDesiredCapacity</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>GroupAndWarmPoolTotalCapacity</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you omit this parameter, all metrics are enabled. </p>
        pub fn metrics(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metrics(inp);
            self
        }
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_metrics(input);
            self
        }
        /// <p>The granularity to associate with the metrics to collect. The only valid value is
        /// <code>1Minute</code>.</p>
        pub fn granularity(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.granularity(input);
            self
        }
        pub fn set_granularity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_granularity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EnterStandby<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::enter_standby_input::Builder,
    }
    impl<C> EnterStandby<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EnterStandbyOutput,
            smithy_http::result::SdkError<crate::error::EnterStandbyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances. You can specify up to 20 instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Indicates whether to decrement the desired capacity of the Auto Scaling group by the number of
        /// instances moved to <code>Standby</code> mode.</p>
        pub fn should_decrement_desired_capacity(mut self, input: bool) -> Self {
            self.inner = self.inner.should_decrement_desired_capacity(input);
            self
        }
        pub fn set_should_decrement_desired_capacity(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_should_decrement_desired_capacity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExecutePolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::execute_policy_input::Builder,
    }
    impl<C> ExecutePolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExecutePolicyOutput,
            smithy_http::result::SdkError<crate::error::ExecutePolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name or ARN of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>Indicates whether Amazon EC2 Auto Scaling waits for the cooldown period to complete before executing
        /// the policy.</p>
        /// <p>Valid only if the policy type is <code>SimpleScaling</code>. For more information, see
        /// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/Cooldown.html">Scaling
        /// cooldowns for Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn honor_cooldown(mut self, input: bool) -> Self {
            self.inner = self.inner.honor_cooldown(input);
            self
        }
        pub fn set_honor_cooldown(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_honor_cooldown(input);
            self
        }
        /// <p>The metric value to compare to <code>BreachThreshold</code>. This enables you to
        /// execute a policy of type <code>StepScaling</code> and determine which step adjustment to
        /// use. For example, if the breach threshold is 50 and you want to use a step adjustment
        /// with a lower bound of 0 and an upper bound of 10, you can set the metric value to
        /// 59.</p>
        /// <p>If you specify a metric value that doesn't correspond to a step adjustment for the
        /// policy, the call returns an error.</p>
        /// <p>Required if the policy type is <code>StepScaling</code> and not supported
        /// otherwise.</p>
        pub fn metric_value(mut self, input: f64) -> Self {
            self.inner = self.inner.metric_value(input);
            self
        }
        pub fn set_metric_value(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_metric_value(input);
            self
        }
        /// <p>The breach threshold for the alarm.</p>
        /// <p>Required if the policy type is <code>StepScaling</code> and not supported
        /// otherwise.</p>
        pub fn breach_threshold(mut self, input: f64) -> Self {
            self.inner = self.inner.breach_threshold(input);
            self
        }
        pub fn set_breach_threshold(mut self, input: std::option::Option<f64>) -> Self {
            self.inner = self.inner.set_breach_threshold(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ExitStandby<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::exit_standby_input::Builder,
    }
    impl<C> ExitStandby<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ExitStandbyOutput,
            smithy_http::result::SdkError<crate::error::ExitStandbyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IDs of the instances. You can specify up to 20 instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPredictiveScalingForecast<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_predictive_scaling_forecast_input::Builder,
    }
    impl<C> GetPredictiveScalingForecast<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPredictiveScalingForecastOutput,
            smithy_http::result::SdkError<crate::error::GetPredictiveScalingForecastError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>The inclusive start time of the time range for the forecast data to get. At most, the
        /// date and time can be one year before the current date and time.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The exclusive end time of the time range for the forecast data to get. The maximum
        /// time duration between the start and end time is 30 days. </p>
        /// <p>Although this parameter can accept a date and time that is more than two days in the
        /// future, the availability of forecast data has limits. Amazon EC2 Auto Scaling only issues forecasts for
        /// periods of two days in advance.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLifecycleHook<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_lifecycle_hook_input::Builder,
    }
    impl<C> PutLifecycleHook<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLifecycleHookOutput,
            smithy_http::result::SdkError<crate::error::PutLifecycleHookError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the lifecycle hook.</p>
        pub fn lifecycle_hook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_hook_name(input);
            self
        }
        pub fn set_lifecycle_hook_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_hook_name(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The instance state to which you want to attach the lifecycle hook. The valid values
        /// are:</p>
        /// <ul>
        /// <li>
        /// <p>autoscaling:EC2_INSTANCE_LAUNCHING</p>
        /// </li>
        /// <li>
        /// <p>autoscaling:EC2_INSTANCE_TERMINATING</p>
        /// </li>
        /// </ul>
        /// <p>Required for new lifecycle hooks, but optional when updating existing hooks.</p>
        pub fn lifecycle_transition(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_transition(input);
            self
        }
        pub fn set_lifecycle_transition(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_transition(input);
            self
        }
        /// <p>The ARN of the IAM role that allows the Auto Scaling group to publish to the specified
        /// notification target, for example, an Amazon SNS topic or an Amazon SQS queue.</p>
        /// <p>Required for new lifecycle hooks, but optional when updating existing hooks.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The ARN of the notification target that Amazon EC2 Auto Scaling uses to notify you when an instance
        /// is in the transition state for the lifecycle hook. This target can be either an SQS
        /// queue or an SNS topic.</p>
        /// <p>If you specify an empty string, this overrides the current ARN.</p>
        /// <p>This operation uses the JSON format when sending notifications to an Amazon SQS queue,
        /// and an email key-value pair format when sending notifications to an Amazon SNS
        /// topic.</p>
        /// <p>When you specify a notification target, Amazon EC2 Auto Scaling sends it a test message. Test
        /// messages contain the following additional key-value pair: <code>"Event":
        /// "autoscaling:TEST_NOTIFICATION"</code>.</p>
        pub fn notification_target_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_target_arn(input);
            self
        }
        pub fn set_notification_target_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_target_arn(input);
            self
        }
        /// <p>Additional information that you want to include any time Amazon EC2 Auto Scaling sends a message to
        /// the notification target.</p>
        pub fn notification_metadata(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_metadata(input);
            self
        }
        pub fn set_notification_metadata(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_notification_metadata(input);
            self
        }
        /// <p>The maximum time, in seconds, that can elapse before the lifecycle hook times out. The
        /// range is from <code>30</code> to <code>7200</code> seconds. The default value is
        /// <code>3600</code> seconds (1 hour).</p>
        /// <p>If the lifecycle hook times out, Amazon EC2 Auto Scaling performs the action that you specified in
        /// the <code>DefaultResult</code> parameter. You can prevent the lifecycle hook from timing
        /// out by calling the <a>RecordLifecycleActionHeartbeat</a> API.</p>
        pub fn heartbeat_timeout(mut self, input: i32) -> Self {
            self.inner = self.inner.heartbeat_timeout(input);
            self
        }
        pub fn set_heartbeat_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_heartbeat_timeout(input);
            self
        }
        /// <p>Defines the action the Auto Scaling group should take when the lifecycle hook timeout elapses
        /// or if an unexpected failure occurs. This parameter can be either <code>CONTINUE</code>
        /// or <code>ABANDON</code>. The default value is <code>ABANDON</code>.</p>
        pub fn default_result(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_result(input);
            self
        }
        pub fn set_default_result(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_result(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutNotificationConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_notification_configuration_input::Builder,
    }
    impl<C> PutNotificationConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutNotificationConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutNotificationConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (Amazon SNS)
        /// topic.</p>
        pub fn topic_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.topic_arn(input);
            self
        }
        pub fn set_topic_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_topic_arn(input);
            self
        }
        /// <p>The type of event that causes the notification to be sent. To query the notification
        /// types supported by Amazon EC2 Auto Scaling, call the <a>DescribeAutoScalingNotificationTypes</a> API.</p>
        pub fn notification_types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.notification_types(inp);
            self
        }
        pub fn set_notification_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_notification_types(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutScalingPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_scaling_policy_input::Builder,
    }
    impl<C> PutScalingPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutScalingPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutScalingPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name of the policy.</p>
        pub fn policy_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_name(input);
            self
        }
        pub fn set_policy_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_name(input);
            self
        }
        /// <p>One of the following policy types: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TargetTrackingScaling</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>StepScaling</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>SimpleScaling</code> (default)</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>PredictiveScaling</code>
        /// </p>
        /// </li>
        /// </ul>
        pub fn policy_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy_type(input);
            self
        }
        pub fn set_policy_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy_type(input);
            self
        }
        /// <p>Specifies how the scaling adjustment is interpreted (for example, an absolute number
        /// or a percentage). The valid values are <code>ChangeInCapacity</code>,
        /// <code>ExactCapacity</code>, and <code>PercentChangeInCapacity</code>.</p>
        /// <p>Required if the policy type is <code>StepScaling</code> or <code>SimpleScaling</code>.
        /// For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-adjustment">Scaling adjustment types</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn adjustment_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.adjustment_type(input);
            self
        }
        pub fn set_adjustment_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_adjustment_type(input);
            self
        }
        /// <p>Available for backward compatibility. Use <code>MinAdjustmentMagnitude</code>
        /// instead.</p>
        pub fn min_adjustment_step(mut self, input: i32) -> Self {
            self.inner = self.inner.min_adjustment_step(input);
            self
        }
        pub fn set_min_adjustment_step(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_adjustment_step(input);
            self
        }
        /// <p>The minimum value to scale by when the adjustment type is
        /// <code>PercentChangeInCapacity</code>. For example, suppose that you create a step
        /// scaling policy to scale out an Auto Scaling group by 25 percent and you specify a
        /// <code>MinAdjustmentMagnitude</code> of 2. If the group has 4 instances and the
        /// scaling policy is performed, 25 percent of 4 is 1. However, because you specified a
        /// <code>MinAdjustmentMagnitude</code> of 2, Amazon EC2 Auto Scaling scales out the group by 2
        /// instances.</p>
        /// <p>Valid only if the policy type is <code>StepScaling</code> or
        /// <code>SimpleScaling</code>. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html#as-scaling-adjustment">Scaling adjustment types</a> in the <i>Amazon EC2 Auto Scaling User
        /// Guide</i>.</p>
        /// <note>
        /// <p>Some Auto Scaling groups use instance weights. In this case, set the
        /// <code>MinAdjustmentMagnitude</code> to a value that is at least as large as your
        /// largest instance weight.</p>
        /// </note>
        pub fn min_adjustment_magnitude(mut self, input: i32) -> Self {
            self.inner = self.inner.min_adjustment_magnitude(input);
            self
        }
        pub fn set_min_adjustment_magnitude(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_adjustment_magnitude(input);
            self
        }
        /// <p>The amount by which to scale, based on the specified adjustment type. A positive value
        /// adds to the current capacity while a negative number removes from the current capacity.
        /// For exact capacity, you must specify a positive value.</p>
        /// <p>Required if the policy type is <code>SimpleScaling</code>. (Not used with any other
        /// policy type.) </p>
        pub fn scaling_adjustment(mut self, input: i32) -> Self {
            self.inner = self.inner.scaling_adjustment(input);
            self
        }
        pub fn set_scaling_adjustment(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_scaling_adjustment(input);
            self
        }
        /// <p>The duration of the policy's cooldown period, in seconds. When a cooldown period is
        /// specified here, it overrides the default cooldown period defined for the Auto Scaling
        /// group.</p>
        /// <p>Valid only if the policy type is <code>SimpleScaling</code>. For more information, see
        /// <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/Cooldown.html">Scaling
        /// cooldowns for Amazon EC2 Auto Scaling</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn cooldown(mut self, input: i32) -> Self {
            self.inner = self.inner.cooldown(input);
            self
        }
        pub fn set_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_cooldown(input);
            self
        }
        /// <p>The aggregation type for the CloudWatch metrics. The valid values are <code>Minimum</code>,
        /// <code>Maximum</code>, and <code>Average</code>. If the aggregation type is null, the
        /// value is treated as <code>Average</code>.</p>
        /// <p>Valid only if the policy type is <code>StepScaling</code>.</p>
        pub fn metric_aggregation_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.metric_aggregation_type(input);
            self
        }
        pub fn set_metric_aggregation_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_metric_aggregation_type(input);
            self
        }
        /// <p>A set of adjustments that enable you to scale based on the size of the alarm
        /// breach.</p>
        /// <p>Required if the policy type is <code>StepScaling</code>. (Not used with any other
        /// policy type.) </p>
        pub fn step_adjustments(mut self, inp: impl Into<crate::model::StepAdjustment>) -> Self {
            self.inner = self.inner.step_adjustments(inp);
            self
        }
        pub fn set_step_adjustments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StepAdjustment>>,
        ) -> Self {
            self.inner = self.inner.set_step_adjustments(input);
            self
        }
        /// <p>The estimated time, in seconds, until a newly launched instance can contribute to the
        /// CloudWatch metrics. If not provided, the default is to use the value from the default cooldown
        /// period for the Auto Scaling group.</p>
        /// <p>Valid only if the policy type is <code>TargetTrackingScaling</code> or
        /// <code>StepScaling</code>.</p>
        pub fn estimated_instance_warmup(mut self, input: i32) -> Self {
            self.inner = self.inner.estimated_instance_warmup(input);
            self
        }
        pub fn set_estimated_instance_warmup(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_estimated_instance_warmup(input);
            self
        }
        /// <p>A target tracking scaling policy. Provides support for predefined or customized
        /// metrics.</p>
        /// <p>The following predefined metrics are available:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ASGAverageCPUUtilization</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ASGAverageNetworkIn</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ASGAverageNetworkOut</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ALBRequestCountPerTarget</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you specify <code>ALBRequestCountPerTarget</code> for the metric, you must specify
        /// the <code>ResourceLabel</code> parameter with the
        /// <code>PredefinedMetricSpecification</code>.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_TargetTrackingConfiguration.html">TargetTrackingConfiguration</a> in the <i>Amazon EC2 Auto Scaling API
        /// Reference</i>.</p>
        /// <p>Required if the policy type is <code>TargetTrackingScaling</code>.</p>
        pub fn target_tracking_configuration(
            mut self,
            input: crate::model::TargetTrackingConfiguration,
        ) -> Self {
            self.inner = self.inner.target_tracking_configuration(input);
            self
        }
        pub fn set_target_tracking_configuration(
            mut self,
            input: std::option::Option<crate::model::TargetTrackingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_target_tracking_configuration(input);
            self
        }
        /// <p>Indicates whether the scaling policy is enabled or disabled. The default is enabled.
        /// For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-enable-disable-scaling-policy.html">Disabling a
        /// scaling policy for an Auto Scaling group</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.enabled(input);
            self
        }
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_enabled(input);
            self
        }
        /// <p>A predictive scaling policy. Provides support for only predefined metrics.</p>
        /// <p>Predictive scaling works with CPU utilization, network in/out, and the Application
        /// Load Balancer request count.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_PredictiveScalingConfiguration.html">PredictiveScalingConfiguration</a> in the <i>Amazon EC2 Auto Scaling API
        /// Reference</i>.</p>
        /// <p>Required if the policy type is <code>PredictiveScaling</code>.</p>
        pub fn predictive_scaling_configuration(
            mut self,
            input: crate::model::PredictiveScalingConfiguration,
        ) -> Self {
            self.inner = self.inner.predictive_scaling_configuration(input);
            self
        }
        pub fn set_predictive_scaling_configuration(
            mut self,
            input: std::option::Option<crate::model::PredictiveScalingConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_predictive_scaling_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutScheduledUpdateGroupAction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_scheduled_update_group_action_input::Builder,
    }
    impl<C> PutScheduledUpdateGroupAction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutScheduledUpdateGroupActionOutput,
            smithy_http::result::SdkError<crate::error::PutScheduledUpdateGroupActionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name of this scaling action.</p>
        pub fn scheduled_action_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scheduled_action_name(input);
            self
        }
        pub fn set_scheduled_action_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_scheduled_action_name(input);
            self
        }
        /// <p>This parameter is no longer used.</p>
        pub fn time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.time(input);
            self
        }
        pub fn set_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_time(input);
            self
        }
        /// <p>The date and time for this action to start, in YYYY-MM-DDThh:mm:ssZ format in UTC/GMT
        /// only and in quotes (for example, <code>"2019-06-01T00:00:00Z"</code>).</p>
        /// <p>If you specify <code>Recurrence</code> and <code>StartTime</code>, Amazon EC2 Auto Scaling performs
        /// the action at this time, and then performs the action based on the specified
        /// recurrence.</p>
        /// <p>If you try to schedule your action in the past, Amazon EC2 Auto Scaling returns an error
        /// message.</p>
        pub fn start_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.start_time(input);
            self
        }
        pub fn set_start_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_start_time(input);
            self
        }
        /// <p>The date and time for the recurring schedule to end, in UTC.</p>
        pub fn end_time(mut self, input: smithy_types::Instant) -> Self {
            self.inner = self.inner.end_time(input);
            self
        }
        pub fn set_end_time(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.inner = self.inner.set_end_time(input);
            self
        }
        /// <p>The recurring schedule for this action. This format consists of five fields separated
        /// by white spaces: [Minute] [Hour] [Day_of_Month] [Month_of_Year] [Day_of_Week]. The value
        /// must be in quotes (for example, <code>"30 0 1 1,6,12 *"</code>). For more information
        /// about this format, see <a href="http://crontab.org">Crontab</a>.</p>
        /// <p>When <code>StartTime</code> and <code>EndTime</code> are specified with
        /// <code>Recurrence</code>, they form the boundaries of when the recurring action
        /// starts and stops.</p>
        /// <p>Cron expressions use Universal Coordinated Time (UTC) by default.</p>
        pub fn recurrence(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.recurrence(input);
            self
        }
        pub fn set_recurrence(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_recurrence(input);
            self
        }
        /// <p>The minimum size of the Auto Scaling group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.inner = self.inner.min_size(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>The maximum size of the Auto Scaling group.</p>
        pub fn max_size(mut self, input: i32) -> Self {
            self.inner = self.inner.max_size(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_size(input);
            self
        }
        /// <p>The desired capacity is the initial capacity of the Auto Scaling group after the scheduled
        /// action runs and the capacity it attempts to maintain. It can scale beyond this capacity
        /// if you add more scaling conditions. </p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.desired_capacity(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_capacity(input);
            self
        }
        /// <p>Specifies the time zone for a cron expression. If a time zone is not provided, UTC is
        /// used by default. </p>
        /// <p>Valid values are the canonical names of the IANA time zones, derived from the IANA
        /// Time Zone Database (such as <code>Etc/GMT+9</code> or <code>Pacific/Tahiti</code>). For
        /// more information, see <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p>
        pub fn time_zone(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.time_zone(input);
            self
        }
        pub fn set_time_zone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_time_zone(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutWarmPool<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_warm_pool_input::Builder,
    }
    impl<C> PutWarmPool<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutWarmPoolOutput,
            smithy_http::result::SdkError<crate::error::PutWarmPoolError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Specifies the maximum number of instances that are allowed to be in the warm pool or
        /// in any state except <code>Terminated</code> for the Auto Scaling group. This is an optional
        /// property. Specify it only if you do not want the warm pool size to be determined by the
        /// difference between the group's maximum capacity and its desired capacity. </p>
        /// <important>
        /// <p>If a value for <code>MaxGroupPreparedCapacity</code> is not specified, Amazon EC2 Auto Scaling
        /// launches and maintains the difference between the group's maximum capacity and its
        /// desired capacity. If you specify a value for <code>MaxGroupPreparedCapacity</code>,
        /// Amazon EC2 Auto Scaling uses the difference between the <code>MaxGroupPreparedCapacity</code> and
        /// the desired capacity instead. </p>
        /// <p>The size of the warm pool is dynamic. Only when
        /// <code>MaxGroupPreparedCapacity</code> and <code>MinSize</code> are set to the
        /// same value does the warm pool have an absolute size.</p>
        /// </important>
        /// <p>If the desired capacity of the Auto Scaling group is higher than the
        /// <code>MaxGroupPreparedCapacity</code>, the capacity of the warm pool is 0, unless
        /// you specify a value for <code>MinSize</code>. To remove a value that you previously set,
        /// include the property but specify -1 for the value. </p>
        pub fn max_group_prepared_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.max_group_prepared_capacity(input);
            self
        }
        pub fn set_max_group_prepared_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_group_prepared_capacity(input);
            self
        }
        /// <p>Specifies the minimum number of instances to maintain in the warm pool. This helps you
        /// to ensure that there is always a certain number of warmed instances available to handle
        /// traffic spikes. Defaults to 0 if not specified.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.inner = self.inner.min_size(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>Sets the instance state to transition to after the lifecycle actions are complete.
        /// Default is <code>Stopped</code>.</p>
        pub fn pool_state(mut self, input: crate::model::WarmPoolState) -> Self {
            self.inner = self.inner.pool_state(input);
            self
        }
        pub fn set_pool_state(
            mut self,
            input: std::option::Option<crate::model::WarmPoolState>,
        ) -> Self {
            self.inner = self.inner.set_pool_state(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RecordLifecycleActionHeartbeat<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::record_lifecycle_action_heartbeat_input::Builder,
    }
    impl<C> RecordLifecycleActionHeartbeat<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RecordLifecycleActionHeartbeatOutput,
            smithy_http::result::SdkError<crate::error::RecordLifecycleActionHeartbeatError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the lifecycle hook.</p>
        pub fn lifecycle_hook_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_hook_name(input);
            self
        }
        pub fn set_lifecycle_hook_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_hook_name(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>A token that uniquely identifies a specific lifecycle action associated with an
        /// instance. Amazon EC2 Auto Scaling sends this token to the notification target that you specified when
        /// you created the lifecycle hook.</p>
        pub fn lifecycle_action_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.lifecycle_action_token(input);
            self
        }
        pub fn set_lifecycle_action_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_action_token(input);
            self
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ResumeProcesses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::resume_processes_input::Builder,
    }
    impl<C> ResumeProcesses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ResumeProcessesOutput,
            smithy_http::result::SdkError<crate::error::ResumeProcessesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>One or more of the following processes:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Launch</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Terminate</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AddToLoadBalancer</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AlarmNotification</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AZRebalance</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HealthCheck</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InstanceRefresh</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReplaceUnhealthy</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ScheduledActions</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you omit this parameter, all processes are specified.</p>
        pub fn scaling_processes(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scaling_processes(inp);
            self
        }
        pub fn set_scaling_processes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_scaling_processes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetDesiredCapacity<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_desired_capacity_input::Builder,
    }
    impl<C> SetDesiredCapacity<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetDesiredCapacityOutput,
            smithy_http::result::SdkError<crate::error::SetDesiredCapacityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The desired capacity is the initial capacity of the Auto Scaling group after this operation
        /// completes and the capacity it attempts to maintain.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.desired_capacity(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_capacity(input);
            self
        }
        /// <p>Indicates whether Amazon EC2 Auto Scaling waits for the cooldown period to complete before initiating
        /// a scaling activity to set your Auto Scaling group to its new capacity. By default, Amazon EC2 Auto Scaling does
        /// not honor the cooldown period during manual scaling activities.</p>
        pub fn honor_cooldown(mut self, input: bool) -> Self {
            self.inner = self.inner.honor_cooldown(input);
            self
        }
        pub fn set_honor_cooldown(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_honor_cooldown(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetInstanceHealth<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_instance_health_input::Builder,
    }
    impl<C> SetInstanceHealth<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetInstanceHealthOutput,
            smithy_http::result::SdkError<crate::error::SetInstanceHealthError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>The health status of the instance. Set to <code>Healthy</code> to have the instance
        /// remain in service. Set to <code>Unhealthy</code> to have the instance be out of service.
        /// Amazon EC2 Auto Scaling terminates and replaces the unhealthy instance.</p>
        pub fn health_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_status(input);
            self
        }
        pub fn set_health_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_status(input);
            self
        }
        /// <p>If the Auto Scaling group of the specified instance has a <code>HealthCheckGracePeriod</code>
        /// specified for the group, by default, this call respects the grace period. Set this to
        /// <code>False</code>, to have the call not respect the grace period associated with
        /// the group.</p>
        /// <p>For more information about the health check grace
        /// period, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_CreateAutoScalingGroup.html">CreateAutoScalingGroup</a> in the <i>Amazon EC2 Auto Scaling API
        /// Reference</i>.</p>
        pub fn should_respect_grace_period(mut self, input: bool) -> Self {
            self.inner = self.inner.should_respect_grace_period(input);
            self
        }
        pub fn set_should_respect_grace_period(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_should_respect_grace_period(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SetInstanceProtection<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::set_instance_protection_input::Builder,
    }
    impl<C> SetInstanceProtection<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SetInstanceProtectionOutput,
            smithy_http::result::SdkError<crate::error::SetInstanceProtectionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>One or more instance IDs. You can specify up to 50 instances.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>Indicates whether the instance is protected from termination by Amazon EC2 Auto Scaling when scaling
        /// in.</p>
        pub fn protected_from_scale_in(mut self, input: bool) -> Self {
            self.inner = self.inner.protected_from_scale_in(input);
            self
        }
        pub fn set_protected_from_scale_in(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_protected_from_scale_in(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartInstanceRefresh<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_instance_refresh_input::Builder,
    }
    impl<C> StartInstanceRefresh<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartInstanceRefreshOutput,
            smithy_http::result::SdkError<crate::error::StartInstanceRefreshError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The strategy to use for the instance refresh. The only valid value is
        /// <code>Rolling</code>.</p>
        /// <p>A rolling update is an update that is applied to all instances in an Auto Scaling group until
        /// all instances have been updated. A rolling update can fail due to failed health checks
        /// or if instances are on standby or are protected from scale in. If the rolling update
        /// process fails, any instances that were already replaced are not rolled back to their
        /// previous configuration. </p>
        pub fn strategy(mut self, input: crate::model::RefreshStrategy) -> Self {
            self.inner = self.inner.strategy(input);
            self
        }
        pub fn set_strategy(
            mut self,
            input: std::option::Option<crate::model::RefreshStrategy>,
        ) -> Self {
            self.inner = self.inner.set_strategy(input);
            self
        }
        /// <p>Set of preferences associated with the instance refresh request.</p>
        /// <p>If not provided, the default values are used. For <code>MinHealthyPercentage</code>,
        /// the default value is <code>90</code>. For <code>InstanceWarmup</code>, the default is to
        /// use the value specified for the health check grace period for the Auto Scaling group.</p>
        /// <p>For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/APIReference/API_RefreshPreferences.html">RefreshPreferences</a> in the <i>Amazon EC2 Auto Scaling API
        /// Reference</i>.</p>
        pub fn preferences(mut self, input: crate::model::RefreshPreferences) -> Self {
            self.inner = self.inner.preferences(input);
            self
        }
        pub fn set_preferences(
            mut self,
            input: std::option::Option<crate::model::RefreshPreferences>,
        ) -> Self {
            self.inner = self.inner.set_preferences(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SuspendProcesses<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::suspend_processes_input::Builder,
    }
    impl<C> SuspendProcesses<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SuspendProcessesOutput,
            smithy_http::result::SdkError<crate::error::SuspendProcessesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>One or more of the following processes:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Launch</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Terminate</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AddToLoadBalancer</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AlarmNotification</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>AZRebalance</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>HealthCheck</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InstanceRefresh</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ReplaceUnhealthy</code>
        /// </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ScheduledActions</code>
        /// </p>
        /// </li>
        /// </ul>
        /// <p>If you omit this parameter, all processes are specified.</p>
        pub fn scaling_processes(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.scaling_processes(inp);
            self
        }
        pub fn set_scaling_processes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_scaling_processes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TerminateInstanceInAutoScalingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::terminate_instance_in_auto_scaling_group_input::Builder,
    }
    impl<C> TerminateInstanceInAutoScalingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TerminateInstanceInAutoScalingGroupOutput,
            smithy_http::result::SdkError<crate::error::TerminateInstanceInAutoScalingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the instance.</p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
        /// <p>Indicates whether terminating the instance also decrements the size of the Auto Scaling
        /// group.</p>
        pub fn should_decrement_desired_capacity(mut self, input: bool) -> Self {
            self.inner = self.inner.should_decrement_desired_capacity(input);
            self
        }
        pub fn set_should_decrement_desired_capacity(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_should_decrement_desired_capacity(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAutoScalingGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_auto_scaling_group_input::Builder,
    }
    impl<C> UpdateAutoScalingGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAutoScalingGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateAutoScalingGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Auto Scaling group.</p>
        pub fn auto_scaling_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_group_name(input);
            self
        }
        pub fn set_auto_scaling_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_group_name(input);
            self
        }
        /// <p>The name of the launch configuration. If you specify
        /// <code>LaunchConfigurationName</code> in your update request, you can't specify
        /// <code>LaunchTemplate</code> or <code>MixedInstancesPolicy</code>.</p>
        pub fn launch_configuration_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_configuration_name(input);
            self
        }
        pub fn set_launch_configuration_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_configuration_name(input);
            self
        }
        /// <p>The launch template and version to use to specify the updates. If you specify
        /// <code>LaunchTemplate</code> in your update request, you can't specify
        /// <code>LaunchConfigurationName</code> or <code>MixedInstancesPolicy</code>.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.inner = self.inner.launch_template(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_template(input);
            self
        }
        /// <p>An embedded object that specifies a mixed instances policy. When you make changes to
        /// an existing policy, all optional properties are left unchanged if not specified. For
        /// more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-purchase-options.html">Auto Scaling groups with multiple
        /// instance types and purchase options</a> in the <i>Amazon EC2 Auto Scaling User
        /// Guide</i>.</p>
        pub fn mixed_instances_policy(mut self, input: crate::model::MixedInstancesPolicy) -> Self {
            self.inner = self.inner.mixed_instances_policy(input);
            self
        }
        pub fn set_mixed_instances_policy(
            mut self,
            input: std::option::Option<crate::model::MixedInstancesPolicy>,
        ) -> Self {
            self.inner = self.inner.set_mixed_instances_policy(input);
            self
        }
        /// <p>The minimum size of the Auto Scaling group.</p>
        pub fn min_size(mut self, input: i32) -> Self {
            self.inner = self.inner.min_size(input);
            self
        }
        pub fn set_min_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_min_size(input);
            self
        }
        /// <p>The maximum size of the Auto Scaling group.</p>
        /// <note>
        /// <p>With a mixed instances policy that uses instance weighting, Amazon EC2 Auto Scaling may need to
        /// go above <code>MaxSize</code> to meet your capacity requirements. In this event,
        /// Amazon EC2 Auto Scaling will never go above <code>MaxSize</code> by more than your largest instance
        /// weight (weights that define how many units each instance contributes to the desired
        /// capacity of the group).</p>
        /// </note>
        pub fn max_size(mut self, input: i32) -> Self {
            self.inner = self.inner.max_size(input);
            self
        }
        pub fn set_max_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_size(input);
            self
        }
        /// <p>The desired capacity is the initial capacity of the Auto Scaling group after this operation
        /// completes and the capacity it attempts to maintain. This number must be greater than or
        /// equal to the minimum size of the group and less than or equal to the maximum size of the
        /// group.</p>
        pub fn desired_capacity(mut self, input: i32) -> Self {
            self.inner = self.inner.desired_capacity(input);
            self
        }
        pub fn set_desired_capacity(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_desired_capacity(input);
            self
        }
        /// <p>The amount of time, in seconds, after a scaling activity completes before another
        /// scaling activity can start. The default value is <code>300</code>. This setting applies
        /// when using simple scaling policies, but not when using other scaling policies or
        /// scheduled scaling. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/Cooldown.html">Scaling cooldowns for Amazon EC2 Auto Scaling</a>
        /// in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn default_cooldown(mut self, input: i32) -> Self {
            self.inner = self.inner.default_cooldown(input);
            self
        }
        pub fn set_default_cooldown(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_default_cooldown(input);
            self
        }
        /// <p>One or more Availability Zones for the group.</p>
        pub fn availability_zones(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zones(inp);
            self
        }
        pub fn set_availability_zones(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_availability_zones(input);
            self
        }
        /// <p>The service to use for the health checks. The valid values are <code>EC2</code> and
        /// <code>ELB</code>. If you configure an Auto Scaling group to use <code>ELB</code> health
        /// checks, it considers the instance unhealthy if it fails either the EC2 status checks or
        /// the load balancer health checks.</p>
        pub fn health_check_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.health_check_type(input);
            self
        }
        pub fn set_health_check_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_health_check_type(input);
            self
        }
        /// <p>The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before checking the health status
        /// of an EC2 instance that has come into service. The default value is <code>0</code>. For
        /// more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/healthcheck.html#health-check-grace-period">Health
        /// check grace period</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        /// <p>Conditional: Required if you are adding an <code>ELB</code> health check.</p>
        pub fn health_check_grace_period(mut self, input: i32) -> Self {
            self.inner = self.inner.health_check_grace_period(input);
            self
        }
        pub fn set_health_check_grace_period(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_health_check_grace_period(input);
            self
        }
        /// <p>The name of an existing placement group into which to launch your instances, if any. A
        /// placement group is a logical grouping of instances within a single Availability Zone.
        /// You cannot specify multiple Availability Zones and a placement group. For more
        /// information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html">Placement Groups</a> in the
        /// <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
        pub fn placement_group(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.placement_group(input);
            self
        }
        pub fn set_placement_group(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_placement_group(input);
            self
        }
        /// <p>A comma-separated list of subnet IDs for a virtual private cloud (VPC). If you specify
        /// <code>VPCZoneIdentifier</code> with <code>AvailabilityZones</code>, the subnets that
        /// you specify for this parameter must reside in those Availability Zones.</p>
        pub fn vpc_zone_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.vpc_zone_identifier(input);
            self
        }
        pub fn set_vpc_zone_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_vpc_zone_identifier(input);
            self
        }
        /// <p>A policy or a list of policies that are used to select the instances to terminate. The
        /// policies are executed in the order that you list them. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html">Controlling which Auto Scaling instances terminate during scale in</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn termination_policies(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.termination_policies(inp);
            self
        }
        pub fn set_termination_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_termination_policies(input);
            self
        }
        /// <p>Indicates whether newly launched instances are protected from termination by Amazon EC2 Auto Scaling
        /// when scaling in. For more information about preventing instances from terminating on
        /// scale in, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html#instance-protection">Instance scale-in protection</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn new_instances_protected_from_scale_in(mut self, input: bool) -> Self {
            self.inner = self.inner.new_instances_protected_from_scale_in(input);
            self
        }
        pub fn set_new_instances_protected_from_scale_in(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_new_instances_protected_from_scale_in(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the service-linked role that the Auto Scaling group uses to
        /// call other Amazon Web Services on your behalf. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/autoscaling-service-linked-role.html">Service-linked
        /// roles</a> in the <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn service_linked_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_linked_role_arn(input);
            self
        }
        pub fn set_service_linked_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_linked_role_arn(input);
            self
        }
        /// <p>The maximum amount of time, in seconds, that an instance can be in service. The
        /// default is null. If specified, the value must be either 0 or a number equal to or
        /// greater than 86,400 seconds (1 day). To clear a previously set value, specify a new
        /// value of 0. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/asg-max-instance-lifetime.html">Replacing Auto Scaling
        /// instances based on maximum instance lifetime</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn max_instance_lifetime(mut self, input: i32) -> Self {
            self.inner = self.inner.max_instance_lifetime(input);
            self
        }
        pub fn set_max_instance_lifetime(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_instance_lifetime(input);
            self
        }
        /// <p>Enables or disables Capacity Rebalancing. For more information, see <a href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/capacity-rebalance.html">Amazon EC2 Auto Scaling Capacity Rebalancing</a> in the
        /// <i>Amazon EC2 Auto Scaling User Guide</i>.</p>
        pub fn capacity_rebalance(mut self, input: bool) -> Self {
            self.inner = self.inner.capacity_rebalance(input);
            self
        }
        pub fn set_capacity_rebalance(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_capacity_rebalance(input);
            self
        }
        /// <p>Reserved.</p>
        pub fn context(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.context(input);
            self
        }
        pub fn set_context(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_context(input);
            self
        }
    }
}
