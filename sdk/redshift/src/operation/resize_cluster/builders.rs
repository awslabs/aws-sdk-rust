// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::resize_cluster::_resize_cluster_output::ResizeClusterOutputBuilder;

pub use crate::operation::resize_cluster::_resize_cluster_input::ResizeClusterInputBuilder;

impl ResizeClusterInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::resize_cluster::ResizeClusterOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::resize_cluster::ResizeClusterError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.resize_cluster();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `ResizeCluster`.
///
/// <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method.</p>
/// <p>Elastic resize operations have the following restrictions:</p>
/// <ul>
/// <li>
/// <p>You can only resize clusters of the following types:</p>
/// <ul>
/// <li>
/// <p>dc1.large (if your cluster is in a VPC)</p></li>
/// <li>
/// <p>dc1.8xlarge (if your cluster is in a VPC)</p></li>
/// <li>
/// <p>dc2.large</p></li>
/// <li>
/// <p>dc2.8xlarge</p></li>
/// <li>
/// <p>ds2.xlarge</p></li>
/// <li>
/// <p>ds2.8xlarge</p></li>
/// <li>
/// <p>ra3.xlplus</p></li>
/// <li>
/// <p>ra3.4xlarge</p></li>
/// <li>
/// <p>ra3.16xlarge</p></li>
/// </ul></li>
/// <li>
/// <p>The type of nodes that you add must match the node type for the cluster.</p></li>
/// </ul>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct ResizeClusterFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::resize_cluster::builders::ResizeClusterInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::resize_cluster::ResizeClusterOutput,
        crate::operation::resize_cluster::ResizeClusterError,
    > for ResizeClusterFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::resize_cluster::ResizeClusterOutput,
            crate::operation::resize_cluster::ResizeClusterError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl ResizeClusterFluentBuilder {
    /// Creates a new `ResizeCluster`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the ResizeCluster as a reference.
    pub fn as_input(&self) -> &crate::operation::resize_cluster::builders::ResizeClusterInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::resize_cluster::ResizeClusterOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::resize_cluster::ResizeClusterError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::resize_cluster::ResizeCluster::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::resize_cluster::ResizeCluster::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::resize_cluster::ResizeClusterOutput,
        crate::operation::resize_cluster::ResizeClusterError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The unique identifier for the cluster to resize.</p>
    pub fn cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.cluster_identifier(input.into());
        self
    }
    /// <p>The unique identifier for the cluster to resize.</p>
    pub fn set_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_cluster_identifier(input);
        self
    }
    /// <p>The unique identifier for the cluster to resize.</p>
    pub fn get_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_cluster_identifier()
    }
    /// <p>The new cluster type for the specified cluster.</p>
    pub fn cluster_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.cluster_type(input.into());
        self
    }
    /// <p>The new cluster type for the specified cluster.</p>
    pub fn set_cluster_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_cluster_type(input);
        self
    }
    /// <p>The new cluster type for the specified cluster.</p>
    pub fn get_cluster_type(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_cluster_type()
    }
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    pub fn node_type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.node_type(input.into());
        self
    }
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    pub fn set_node_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_node_type(input);
        self
    }
    /// <p>The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.</p>
    pub fn get_node_type(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_node_type()
    }
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    pub fn number_of_nodes(mut self, input: i32) -> Self {
        self.inner = self.inner.number_of_nodes(input);
        self
    }
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    pub fn set_number_of_nodes(mut self, input: ::std::option::Option<i32>) -> Self {
        self.inner = self.inner.set_number_of_nodes(input);
        self
    }
    /// <p>The new number of nodes for the cluster. If not specified, the cluster's current number of nodes is used.</p>
    pub fn get_number_of_nodes(&self) -> &::std::option::Option<i32> {
        self.inner.get_number_of_nodes()
    }
    /// <p>A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic.</p>
    pub fn classic(mut self, input: bool) -> Self {
        self.inner = self.inner.classic(input);
        self
    }
    /// <p>A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic.</p>
    pub fn set_classic(mut self, input: ::std::option::Option<bool>) -> Self {
        self.inner = self.inner.set_classic(input);
        self
    }
    /// <p>A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic.</p>
    pub fn get_classic(&self) -> &::std::option::Option<bool> {
        self.inner.get_classic()
    }
    /// <p>The identifier of the reserved node.</p>
    pub fn reserved_node_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.reserved_node_id(input.into());
        self
    }
    /// <p>The identifier of the reserved node.</p>
    pub fn set_reserved_node_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_reserved_node_id(input);
        self
    }
    /// <p>The identifier of the reserved node.</p>
    pub fn get_reserved_node_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_reserved_node_id()
    }
    /// <p>The identifier of the target reserved node offering.</p>
    pub fn target_reserved_node_offering_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.target_reserved_node_offering_id(input.into());
        self
    }
    /// <p>The identifier of the target reserved node offering.</p>
    pub fn set_target_reserved_node_offering_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_target_reserved_node_offering_id(input);
        self
    }
    /// <p>The identifier of the target reserved node offering.</p>
    pub fn get_target_reserved_node_offering_id(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_target_reserved_node_offering_id()
    }
}
